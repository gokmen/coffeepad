/**
 * CoffeeScript Compiler v1.7.1
 * http://coffeescript.org
 *
 * Copyright 2011, Jeremy Ashkenas
 * Released under the MIT License
 */
(function(root){var CoffeeScript=function(){function require(e){return require[e]}return require["./helpers"]=function(){var e={},t={exports:e};return function(){var t,n,i,r,s,o,a;e.starts=function(e,t,n){return t===e.substr(n,t.length)},e.ends=function(e,t,n){var i;return i=t.length,t===e.substr(e.length-i-(n||0),i)},e.repeat=s=function(e,t){var n;for(n="";t>0;)1&t&&(n+=e),t>>>=1,e+=e;return n},e.compact=function(e){var t,n,i,r;for(r=[],n=0,i=e.length;i>n;n++)t=e[n],t&&r.push(t);return r},e.count=function(e,t){var n,i;if(n=i=0,!t.length)return 1/0;for(;i=1+e.indexOf(t,i);)n++;return n},e.merge=function(e,t){return n(n({},e),t)},n=e.extend=function(e,t){var n,i;for(n in t)i=t[n],e[n]=i;return e},e.flatten=i=function(e){var t,n,r,s;for(n=[],r=0,s=e.length;s>r;r++)t=e[r],t instanceof Array?n=n.concat(i(t)):n.push(t);return n},e.del=function(e,t){var n;return n=e[t],delete e[t],n},e.last=r=function(e,t){return e[e.length-(t||0)-1]},e.some=null!=(a=Array.prototype.some)?a:function(e){var t,n,i;for(n=0,i=this.length;i>n;n++)if(t=this[n],e(t))return!0;return!1},e.invertLiterate=function(e){var t,n,i;return i=!0,n=function(){var n,r,s,o;for(s=e.split("\n"),o=[],n=0,r=s.length;r>n;n++)t=s[n],i&&/^([ ]{4}|[ ]{0,3}\t)/.test(t)?o.push(t):(i=/^\s*$/.test(t))?o.push(t):o.push("# "+t);return o}(),n.join("\n")},t=function(e,t){return t?{first_line:e.first_line,first_column:e.first_column,last_line:t.last_line,last_column:t.last_column}:e},e.addLocationDataFn=function(e,n){return function(i){return"object"==typeof i&&i.updateLocationDataIfMissing&&i.updateLocationDataIfMissing(t(e,n)),i}},e.locationDataToString=function(e){var t;return"2"in e&&"first_line"in e[2]?t=e[2]:"first_line"in e&&(t=e),t?""+(t.first_line+1)+":"+(t.first_column+1)+"-"+(""+(t.last_line+1)+":"+(t.last_column+1)):"No location data"},e.baseFileName=function(e,t,n){var i,r;return null==t&&(t=!1),null==n&&(n=!1),r=n?/\\|\//:/\//,i=e.split(r),e=i[i.length-1],t&&e.indexOf(".")>=0?(i=e.split("."),i.pop(),"coffee"===i[i.length-1]&&i.length>1&&i.pop(),i.join(".")):e},e.isCoffee=function(e){return/\.((lit)?coffee|coffee\.md)$/.test(e)},e.isLiterate=function(e){return/\.(litcoffee|coffee\.md)$/.test(e)},e.throwSyntaxError=function(e,t){var n;throw n=new SyntaxError(e),n.location=t,n.toString=o,n.stack=""+n,n},e.updateSyntaxError=function(e,t,n){return e.toString===o&&(e.code||(e.code=t),e.filename||(e.filename=n),e.stack=""+e),e},o=function(){var e,t,n,i,r,o,a,c,h,l,u,p,d;return this.code&&this.location?(p=this.location,a=p.first_line,o=p.first_column,h=p.last_line,c=p.last_column,null==h&&(h=a),null==c&&(c=o),r=this.filename||"[stdin]",e=this.code.split("\n")[a],u=o,i=a===h?c+1:e.length,l=s(" ",u)+s("^",i-u),"undefined"!=typeof process&&null!==process&&(n=process.stdout.isTTY&&!process.env.NODE_DISABLE_COLORS),(null!=(d=this.colorful)?d:n)&&(t=function(e){return"[1;31m"+e+"[0m"},e=e.slice(0,u)+t(e.slice(u,i))+e.slice(i),l=t(l)),""+r+":"+(a+1)+":"+(o+1)+": error: "+this.message+"\n"+e+"\n"+l):Error.prototype.toString.call(this)},e.nameWhitespaceCharacter=function(e){switch(e){case" ":return"space";case"\n":return"newline";case"\r":return"carriage return";case"	":return"tab";default:return e}}}.call(this),t.exports}(),require["./rewriter"]=function(){var e={},t={exports:e};return function(){var t,n,i,r,s,o,a,c,h,l,u,p,d,f,m,b,g,k,y,v=[].indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(t in this&&this[t]===e)return t;return-1},w=[].slice;for(f=function(e,t,n){var i;return i=[e,t],i.generated=!0,n&&(i.origin=n),i},e.Rewriter=function(){function e(){}return e.prototype.rewrite=function(e){return this.tokens=e,this.removeLeadingNewlines(),this.closeOpenCalls(),this.closeOpenIndexes(),this.normalizeLines(),this.tagPostfixConditionals(),this.addImplicitBracesAndParens(),this.addLocationDataToGeneratedTokens(),this.tokens},e.prototype.scanTokens=function(e){var t,n,i;for(i=this.tokens,t=0;n=i[t];)t+=e.call(this,n,t,i);return!0},e.prototype.detectEnd=function(e,t,n){var i,o,a,c,h;for(a=this.tokens,i=0;o=a[e];){if(0===i&&t.call(this,o,e))return n.call(this,o,e);if(!o||0>i)return n.call(this,o,e-1);c=o[0],v.call(s,c)>=0?i+=1:(h=o[0],v.call(r,h)>=0&&(i-=1)),e+=1}return e-1},e.prototype.removeLeadingNewlines=function(){var e,t,n,i,r;for(r=this.tokens,e=n=0,i=r.length;i>n&&(t=r[e][0],"TERMINATOR"===t);e=++n);return e?this.tokens.splice(0,e):void 0},e.prototype.closeOpenCalls=function(){var e,t;return t=function(e,t){var n;return")"===(n=e[0])||"CALL_END"===n||"OUTDENT"===e[0]&&")"===this.tag(t-1)},e=function(e,t){return this.tokens["OUTDENT"===e[0]?t-1:t][0]="CALL_END"},this.scanTokens(function(n,i){return"CALL_START"===n[0]&&this.detectEnd(i+1,t,e),1})},e.prototype.closeOpenIndexes=function(){var e,t;return t=function(e){var t;return"]"===(t=e[0])||"INDEX_END"===t},e=function(e){return e[0]="INDEX_END"},this.scanTokens(function(n,i){return"INDEX_START"===n[0]&&this.detectEnd(i+1,t,e),1})},e.prototype.matchTags=function(){var e,t,n,i,r,s,o;for(t=arguments[0],i=arguments.length>=2?w.call(arguments,1):[],e=0,n=r=0,s=i.length;s>=0?s>r:r>s;n=s>=0?++r:--r){for(;"HERECOMMENT"===this.tag(t+n+e);)e+=2;if(null!=i[n]&&("string"==typeof i[n]&&(i[n]=[i[n]]),o=this.tag(t+n+e),0>v.call(i[n],o)))return!1}return!0},e.prototype.looksObjectish=function(e){return this.matchTags(e,"@",null,":")||this.matchTags(e,null,":")},e.prototype.findTagsBackwards=function(e,t){var n,i,o,a,c,h,l;for(n=[];e>=0&&(n.length||(a=this.tag(e),0>v.call(t,a)&&(c=this.tag(e),0>v.call(s,c)||this.tokens[e].generated)&&(h=this.tag(e),0>v.call(u,h))));)i=this.tag(e),v.call(r,i)>=0&&n.push(this.tag(e)),o=this.tag(e),v.call(s,o)>=0&&n.length&&n.pop(),e-=1;return l=this.tag(e),v.call(t,l)>=0},e.prototype.addImplicitBracesAndParens=function(){var e;return e=[],this.scanTokens(function(t,i,l){var p,d,m,b,g,k,y,w,T,F,L,C,N,E,x,D,S,R,A,I,_,$,O,j,M,B,V,P;if($=t[0],L=(C=i>0?l[i-1]:[])[0],T=(l.length-1>i?l[i+1]:[])[0],S=function(){return e[e.length-1]},R=i,m=function(e){return i-R+e},b=function(){var e,t;return null!=(e=S())?null!=(t=e[2])?t.ours:void 0:void 0},g=function(){var e;return b()&&"("===(null!=(e=S())?e[0]:void 0)},y=function(){var e;return b()&&"{"===(null!=(e=S())?e[0]:void 0)},k=function(){var e;return b&&"CONTROL"===(null!=(e=S())?e[0]:void 0)},A=function(t){var n;return n=null!=t?t:i,e.push(["(",n,{ours:!0}]),l.splice(n,0,f("CALL_START","(")),null==t?i+=1:void 0},p=function(){return e.pop(),l.splice(i,0,f("CALL_END",")")),i+=1},I=function(n,r){var s;return null==r&&(r=!0),s=null!=n?n:i,e.push(["{",s,{sameLine:!0,startsLine:r,ours:!0}]),l.splice(s,0,f("{",f(new String("{")),t)),null==n?i+=1:void 0},d=function(n){return n=null!=n?n:i,e.pop(),l.splice(n,0,f("}","}",t)),i+=1},g()&&("IF"===$||"TRY"===$||"FINALLY"===$||"CATCH"===$||"CLASS"===$||"SWITCH"===$))return e.push(["CONTROL",i,{ours:!0}]),m(1);if("INDENT"===$&&b()){if("=>"!==L&&"->"!==L&&"["!==L&&"("!==L&&","!==L&&"{"!==L&&"TRY"!==L&&"ELSE"!==L&&"="!==L)for(;g();)p();return k()&&e.pop(),e.push([$,i]),m(1)}if(v.call(s,$)>=0)return e.push([$,i]),m(1);if(v.call(r,$)>=0){for(;b();)g()?p():y()?d():e.pop();e.pop()}if((v.call(c,$)>=0&&t.spaced&&!t.stringEnd||"?"===$&&i>0&&!l[i-1].spaced)&&(v.call(o,T)>=0||v.call(h,T)>=0&&!(null!=(O=l[i+1])?O.spaced:void 0)&&!(null!=(j=l[i+1])?j.newLine:void 0)))return"?"===$&&($=t[0]="FUNC_EXIST"),A(i+1),m(2);if(v.call(c,$)>=0&&this.matchTags(i+1,"INDENT",null,":")&&!this.findTagsBackwards(i,["CLASS","EXTENDS","IF","CATCH","SWITCH","LEADING_WHEN","FOR","WHILE","UNTIL"]))return A(i+1),e.push(["INDENT",i+2]),m(3);if(":"===$){for(N="@"===this.tag(i-2)?i-2:i-1;"HERECOMMENT"===this.tag(N-2);)N-=2;return this.insideForDeclaration="FOR"===T,_=0===N||(M=this.tag(N-1),v.call(u,M)>=0)||l[N-1].newLine,S()&&(B=S(),D=B[0],x=B[1],("{"===D||"INDENT"===D&&"{"===this.tag(x-1))&&(_||","===this.tag(N-1)||"{"===this.tag(N-1)))?m(1):(I(N,!!_),m(2))}if(y()&&v.call(u,$)>=0&&(S()[2].sameLine=!1),w="OUTDENT"===L||C.newLine,v.call(a,$)>=0||v.call(n,$)>=0&&w)for(;b();)if(V=S(),D=V[0],x=V[1],P=V[2],E=P.sameLine,_=P.startsLine,g()&&","!==L)p();else if(y()&&!this.insideForDeclaration&&E&&"TERMINATOR"!==$&&":"!==L&&d());else{if(!y()||"TERMINATOR"!==$||","===L||_&&this.looksObjectish(i+1))break;d()}if(!(","!==$||this.looksObjectish(i+1)||!y()||this.insideForDeclaration||"TERMINATOR"===T&&this.looksObjectish(i+2)))for(F="OUTDENT"===T?1:0;y();)d(i+F);return m(1)})},e.prototype.addLocationDataToGeneratedTokens=function(){return this.scanTokens(function(e,t,n){var i,r,s,o,a,c;return e[2]?1:e.generated||e.explicit?("{"===e[0]&&(s=null!=(a=n[t+1])?a[2]:void 0)?(r=s.first_line,i=s.first_column):(o=null!=(c=n[t-1])?c[2]:void 0)?(r=o.last_line,i=o.last_column):r=i=0,e[2]={first_line:r,first_column:i,last_line:r,last_column:i},1):1})},e.prototype.normalizeLines=function(){var e,t,r,s,o;return o=r=s=null,t=function(e,t){var r,s,a,c;return";"!==e[1]&&(r=e[0],v.call(p,r)>=0)&&!("TERMINATOR"===e[0]&&(s=this.tag(t+1),v.call(i,s)>=0))&&!("ELSE"===e[0]&&"THEN"!==o)&&!!("CATCH"!==(a=e[0])&&"FINALLY"!==a||"->"!==o&&"=>"!==o)||(c=e[0],v.call(n,c)>=0&&this.tokens[t-1].newLine)},e=function(e,t){return this.tokens.splice(","===this.tag(t-1)?t-1:t,0,s)},this.scanTokens(function(n,a,c){var h,l,u,p,f,m;if(l=n[0],"TERMINATOR"===l){if("ELSE"===this.tag(a+1)&&"OUTDENT"!==this.tag(a-1))return c.splice.apply(c,[a,1].concat(w.call(this.indentation()))),1;if(p=this.tag(a+1),v.call(i,p)>=0)return c.splice(a,1),0}if("CATCH"===l)for(h=u=1;2>=u;h=++u)if("OUTDENT"===(f=this.tag(a+h))||"TERMINATOR"===f||"FINALLY"===f)return c.splice.apply(c,[a+h,0].concat(w.call(this.indentation()))),2+h;return v.call(d,l)>=0&&"INDENT"!==this.tag(a+1)&&("ELSE"!==l||"IF"!==this.tag(a+1))?(o=l,m=this.indentation(c[a]),r=m[0],s=m[1],"THEN"===o&&(r.fromThen=!0),c.splice(a+1,0,r),this.detectEnd(a+2,t,e),"THEN"===l&&c.splice(a,1),1):1})},e.prototype.tagPostfixConditionals=function(){var e,t,n;return n=null,t=function(e,t){var n,i;return i=e[0],n=this.tokens[t-1][0],"TERMINATOR"===i||"INDENT"===i&&0>v.call(d,n)},e=function(e){return"INDENT"!==e[0]||e.generated&&!e.fromThen?n[0]="POST_"+n[0]:void 0},this.scanTokens(function(i,r){return"IF"!==i[0]?1:(n=i,this.detectEnd(r+1,t,e),1)})},e.prototype.indentation=function(e){var t,n;return t=["INDENT",2],n=["OUTDENT",2],e?(t.generated=n.generated=!0,t.origin=n.origin=e):t.explicit=n.explicit=!0,[t,n]},e.prototype.generate=f,e.prototype.tag=function(e){var t;return null!=(t=this.tokens[e])?t[0]:void 0},e}(),t=[["(",")"],["[","]"],["{","}"],["INDENT","OUTDENT"],["CALL_START","CALL_END"],["PARAM_START","PARAM_END"],["INDEX_START","INDEX_END"]],e.INVERSES=l={},s=[],r=[],g=0,k=t.length;k>g;g++)y=t[g],m=y[0],b=y[1],s.push(l[b]=m),r.push(l[m]=b);i=["CATCH","THEN","ELSE","FINALLY"].concat(r),c=["IDENTIFIER","SUPER",")","CALL_END","]","INDEX_END","@","THIS"],o=["IDENTIFIER","NUMBER","STRING","JS","REGEX","NEW","PARAM_START","CLASS","IF","TRY","SWITCH","THIS","BOOL","NULL","UNDEFINED","UNARY","UNARY_MATH","SUPER","THROW","@","->","=>","[","(","{","--","++"],h=["+","-"],a=["POST_IF","FOR","WHILE","UNTIL","WHEN","BY","LOOP","TERMINATOR"],d=["ELSE","->","=>","TRY","FINALLY","THEN"],p=["TERMINATOR","CATCH","FINALLY","ELSE","OUTDENT","LEADING_WHEN"],u=["TERMINATOR","INDENT","OUTDENT"],n=[".","?.","::","?::"]}.call(this),t.exports}(),require["./lexer"]=function(){var e={},t={exports:e};return function(){var t,n,i,r,s,o,a,c,h,l,u,p,d,f,m,b,g,k,y,v,w,T,F,L,C,N,E,x,D,S,R,A,I,_,$,O,j,M,B,V,P,U,H,q,G,W,X,Y,z,K,J,Z,Q,et,tt,nt=[].indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(t in this&&this[t]===e)return t;return-1};et=require("./rewriter"),j=et.Rewriter,y=et.INVERSES,tt=require("./helpers"),W=tt.count,Z=tt.starts,G=tt.compact,z=tt.last,J=tt.repeat,X=tt.invertLiterate,K=tt.locationDataToString,Q=tt.throwSyntaxError,e.Lexer=N=function(){function e(){}return e.prototype.tokenize=function(e,t){var n,i,r,s;for(null==t&&(t={}),this.literate=t.literate,this.indent=0,this.baseIndent=0,this.indebt=0,this.outdebt=0,this.indents=[],this.ends=[],this.tokens=[],this.chunkLine=t.line||0,this.chunkColumn=t.column||0,e=this.clean(e),i=0;this.chunk=e.slice(i);)n=this.identifierToken()||this.commentToken()||this.whitespaceToken()||this.lineToken()||this.heredocToken()||this.stringToken()||this.numberToken()||this.regexToken()||this.jsToken()||this.literalToken(),s=this.getLineAndColumnFromChunk(n),this.chunkLine=s[0],this.chunkColumn=s[1],i+=n;return this.closeIndentation(),(r=this.ends.pop())&&this.error("missing "+r),t.rewrite===!1?this.tokens:(new j).rewrite(this.tokens)},e.prototype.clean=function(e){return e.charCodeAt(0)===t&&(e=e.slice(1)),e=e.replace(/\r/g,"").replace(P,""),q.test(e)&&(e="\n"+e,this.chunkLine--),this.literate&&(e=X(e)),e},e.prototype.identifierToken=function(){var e,t,n,i,r,c,h,l,u,p,d,f,m,g;return(h=b.exec(this.chunk))?(c=h[0],i=h[1],e=h[2],r=i.length,l=void 0,"own"===i&&"FOR"===this.tag()?(this.token("OWN",i),i.length):(n=e||(u=z(this.tokens))&&("."===(f=u[0])||"?."===f||"::"===f||"?::"===f||!u.spaced&&"@"===u[0]),p="IDENTIFIER",!n&&(nt.call(T,i)>=0||nt.call(a,i)>=0)&&(p=i.toUpperCase(),"WHEN"===p&&(m=this.tag(),nt.call(F,m)>=0)?p="LEADING_WHEN":"FOR"===p?this.seenFor=!0:"UNLESS"===p?p="IF":nt.call(U,p)>=0?p="UNARY":nt.call($,p)>=0&&("INSTANCEOF"!==p&&this.seenFor?(p="FOR"+p,this.seenFor=!1):(p="RELATION","!"===this.value()&&(l=this.tokens.pop(),i="!"+i)))),nt.call(w,i)>=0&&(n?(p="IDENTIFIER",i=new String(i),i.reserved=!0):nt.call(O,i)>=0&&this.error('reserved word "'+i+'"')),n||(nt.call(s,i)>=0&&(i=o[i]),p=function(){switch(i){case"!":return"UNARY";case"==":case"!=":return"COMPARE";case"&&":case"||":return"LOGIC";case"true":case"false":return"BOOL";case"break":case"continue":return"STATEMENT";default:return p}}()),d=this.token(p,i,0,r),l&&(g=[l[2].first_line,l[2].first_column],d[2].first_line=g[0],d[2].first_column=g[1]),e&&(t=c.lastIndexOf(":"),this.token(":",":",t,e.length)),c.length)):0},e.prototype.numberToken=function(){var e,t,n,i,r;return(n=A.exec(this.chunk))?(i=n[0],/^0[BOX]/.test(i)?this.error("radix prefix '"+i+"' must be lowercase"):/E/.test(i)&&!/^0x/.test(i)?this.error("exponential notation '"+i+"' must be indicated with a lowercase 'e'"):/^0\d*[89]/.test(i)?this.error("decimal literal '"+i+"' must not be prefixed with '0'"):/^0\d+/.test(i)&&this.error("octal literal '"+i+"' must be prefixed with '0o'"),t=i.length,(r=/^0o([0-7]+)/.exec(i))&&(i="0x"+parseInt(r[1],8).toString(16)),(e=/^0b([01]+)/.exec(i))&&(i="0x"+parseInt(e[1],2).toString(16)),this.token("NUMBER",i,0,t),t):0},e.prototype.stringToken=function(){var e,t,n,i;switch(t=this.chunk.charAt(0)){case"'":n=B.exec(this.chunk)[0];break;case'"':n=this.balancedString(this.chunk,'"')}return n?(i=this.removeNewlines(n.slice(1,-1)),'"'===t&&n.indexOf("#{",1)>0?this.interpolateString(i,{strOffset:1,lexedLength:n.length}):this.token("STRING",t+this.escapeLines(i)+t,0,n.length),(e=/^(?:\\.|[^\\])*\\(?:0[0-7]|[1-7])/.test(n))&&this.error("octal escape sequences "+n+" are not allowed"),n.length):0},e.prototype.heredocToken=function(){var e,t,n,i;return(n=u.exec(this.chunk))?(t=n[0],i=t.charAt(0),e=this.sanitizeHeredoc(n[2],{quote:i,indent:null}),'"'===i&&e.indexOf("#{")>=0?this.interpolateString(e,{heredoc:!0,strOffset:3,lexedLength:t.length}):this.token("STRING",this.makeString(e,i,!0),0,t.length),t.length):0},e.prototype.commentToken=function(){var e,t,n;return(n=this.chunk.match(c))?(e=n[0],t=n[1],t&&this.token("HERECOMMENT",this.sanitizeHeredoc(t,{herecomment:!0,indent:J(" ",this.indent)}),0,e.length),e.length):0},e.prototype.jsToken=function(){var e,t;return"`"===this.chunk.charAt(0)&&(e=v.exec(this.chunk))?(this.token("JS",(t=e[0]).slice(1,-1),0,t.length),t.length):0},e.prototype.regexToken=function(){var e,t,n,i,r,s,o;return"/"!==this.chunk.charAt(0)?0:(t=this.heregexToken())?t:(i=z(this.tokens),i&&(s=i[0],nt.call(i.spaced?S:R,s)>=0)?0:(n=_.exec(this.chunk))?(o=n,n=o[0],r=o[1],e=o[2],"//"===r?0:("/*"===r.slice(0,2)&&this.error("regular expressions cannot begin with `*`"),this.token("REGEX",""+r+e,0,n.length),n.length)):0)},e.prototype.heregexToken=function(){var e,t,n,i,r,s,o,a,c,h,l,u,p,d,b,g,k;if(!(r=f.exec(this.chunk)))return 0;if(i=r[0],e=r[1],t=r[2],0>e.indexOf("#{"))return a=this.escapeLines(e.replace(m,"$1$2").replace(/\//g,"\\/"),!0),a.match(/^\*/)&&this.error("regular expressions cannot begin with `*`"),this.token("REGEX","/"+(a||"(?:)")+"/"+t,0,i.length),i.length;for(this.token("IDENTIFIER","RegExp",0,0),this.token("CALL_START","(",0,0),l=[],b=this.interpolateString(e,{regex:!0}),p=0,d=b.length;d>p;p++){if(h=b[p],c=h[0],u=h[1],"TOKENS"===c)l.push.apply(l,u);else if("NEOSTRING"===c){if(!(u=u.replace(m,"$1$2")))continue;u=u.replace(/\\/g,"\\\\"),h[0]="STRING",h[1]=this.makeString(u,'"',!0),l.push(h)}else this.error("Unexpected "+c);o=z(this.tokens),s=["+","+"],s[2]=o[2],l.push(s)}return l.pop(),"STRING"!==(null!=(g=l[0])?g[0]:void 0)&&(this.token("STRING",'""',0,0),this.token("+","+",0,0)),(k=this.tokens).push.apply(k,l),t&&(n=i.lastIndexOf(t),this.token(",",",",n,0),this.token("STRING",'"'+t+'"',n,t.length)),this.token(")",")",i.length-1,0),i.length},e.prototype.lineToken=function(){var e,t,n,i,r;if(!(n=D.exec(this.chunk)))return 0;if(t=n[0],this.seenFor=!1,r=t.length-1-t.lastIndexOf("\n"),i=this.unfinished(),r-this.indebt===this.indent)return i?this.suppressNewlines():this.newlineToken(0),t.length;if(r>this.indent){if(i)return this.indebt=r-this.indent,this.suppressNewlines(),t.length;if(!this.tokens.length)return this.baseIndent=this.indent=r,t.length;e=r-this.indent+this.outdebt,this.token("INDENT",e,t.length-r,r),this.indents.push(e),this.ends.push("OUTDENT"),this.outdebt=this.indebt=0,this.indent=r}else this.baseIndent>r?this.error("missing indentation",t.length):(this.indebt=0,this.outdentToken(this.indent-r,i,t.length));return t.length},e.prototype.outdentToken=function(e,t,n){var i,r,s,o;for(i=this.indent-e;e>0;)s=this.indents[this.indents.length-1],s?s===this.outdebt?(e-=this.outdebt,this.outdebt=0):this.outdebt>s?(this.outdebt-=s,e-=s):(r=this.indents.pop()+this.outdebt,n&&(o=this.chunk[n],nt.call(g,o)>=0)&&(i-=r-e,e=r),this.outdebt=0,this.pair("OUTDENT"),this.token("OUTDENT",e,0,n),e-=r):e=0;for(r&&(this.outdebt-=e);";"===this.value();)this.tokens.pop();return"TERMINATOR"===this.tag()||t||this.token("TERMINATOR","\n",n,0),this.indent=i,this},e.prototype.whitespaceToken=function(){var e,t,n;return(e=q.exec(this.chunk))||(t="\n"===this.chunk.charAt(0))?(n=z(this.tokens),n&&(n[e?"spaced":"newLine"]=!0),e?e[0].length:0):0},e.prototype.newlineToken=function(e){for(;";"===this.value();)this.tokens.pop();return"TERMINATOR"!==this.tag()&&this.token("TERMINATOR","\n",e,0),this},e.prototype.suppressNewlines=function(){return"\\"===this.value()&&this.tokens.pop(),this},e.prototype.literalToken=function(){var e,t,n,s,o,a,c,u;if((e=I.exec(this.chunk))?(s=e[0],r.test(s)&&this.tagParameters()):s=this.chunk.charAt(0),n=s,t=z(this.tokens),"="===s&&t&&(!t[1].reserved&&(o=t[1],nt.call(w,o)>=0)&&this.error('reserved word "'+this.value()+"\" can't be assigned"),"||"===(a=t[1])||"&&"===a))return t[0]="COMPOUND_ASSIGN",t[1]+="=",s.length;if(";"===s)this.seenFor=!1,n="TERMINATOR";else if(nt.call(E,s)>=0)n="MATH";else if(nt.call(h,s)>=0)n="COMPARE";else if(nt.call(l,s)>=0)n="COMPOUND_ASSIGN";else if(nt.call(U,s)>=0)n="UNARY";else if(nt.call(H,s)>=0)n="UNARY_MATH";else if(nt.call(M,s)>=0)n="SHIFT";else if(nt.call(C,s)>=0||"?"===s&&(null!=t?t.spaced:void 0))n="LOGIC";else if(t&&!t.spaced)if("("===s&&(c=t[0],nt.call(i,c)>=0))"?"===t[0]&&(t[0]="FUNC_EXIST"),n="CALL_START";else if("["===s&&(u=t[0],nt.call(k,u)>=0))switch(n="INDEX_START",t[0]){case"?":t[0]="INDEX_SOAK"}switch(s){case"(":case"{":case"[":this.ends.push(y[s]);break;case")":case"}":case"]":this.pair(s)}return this.token(n,s),s.length},e.prototype.sanitizeHeredoc=function(e,t){var n,i,r,s,o;if(r=t.indent,i=t.herecomment){if(p.test(e)&&this.error('block comment cannot contain "*/", starting'),0>e.indexOf("\n"))return e}else for(;s=d.exec(e);)n=s[1],(null===r||(o=n.length)>0&&r.length>o)&&(r=n);return r&&(e=e.replace(RegExp("\\n"+r,"g"),"\n")),i||(e=e.replace(/^\n/,"")),e},e.prototype.tagParameters=function(){var e,t,n,i;if(")"!==this.tag())return this;for(t=[],i=this.tokens,e=i.length,i[--e][0]="PARAM_END";n=i[--e];)switch(n[0]){case")":t.push(n);break;case"(":case"CALL_START":if(!t.length)return"("===n[0]?(n[0]="PARAM_START",this):this;t.pop()}return this},e.prototype.closeIndentation=function(){return this.outdentToken(this.indent)},e.prototype.balancedString=function(e,t){var n,i,r,s,o,a,c,h;for(n=0,a=[t],i=c=1,h=e.length;h>=1?h>c:c>h;i=h>=1?++c:--c)if(n)--n;else{switch(r=e.charAt(i)){case"\\":++n;continue;case t:if(a.pop(),!a.length)return e.slice(0,+i+1||9e9);t=a[a.length-1];continue}"}"!==t||'"'!==r&&"'"!==r?"}"===t&&"/"===r&&(s=f.exec(e.slice(i))||_.exec(e.slice(i)))?n+=s[0].length-1:"}"===t&&"{"===r?a.push(t="}"):'"'===t&&"#"===o&&"{"===r&&a.push(t="}"):a.push(t=r),o=r}return this.error("missing "+a.pop()+", starting")},e.prototype.interpolateString=function(t,n){var i,r,s,o,a,c,h,l,u,p,d,f,m,b,g,k,y,v,w,T,F,L,C,N,E,x,D,S,R;for(null==n&&(n={}),o=n.heredoc,v=n.regex,b=n.offsetInChunk,T=n.strOffset,p=n.lexedLength,b||(b=0),T||(T=0),p||(p=t.length),C=[],g=0,a=-1;u=t.charAt(a+=1);)"\\"!==u?"#"===u&&"{"===t.charAt(a+1)&&(s=this.balancedString(t.slice(a+1),"}"))&&(a>g&&C.push(this.makeToken("NEOSTRING",t.slice(g,a),T+g)),r||(r=this.makeToken("","string interpolation",b+a+1,2)),c=s.slice(1,-1),c.length&&(D=this.getLineAndColumnFromChunk(T+a+1),d=D[0],i=D[1],m=(new e).tokenize(c,{line:d,column:i,rewrite:!1}),y=m.pop(),"TERMINATOR"===(null!=(S=m[0])?S[0]:void 0)&&(y=m.shift()),(l=m.length)&&(l>1&&(m.unshift(this.makeToken("(","(",T+a+1,0)),m.push(this.makeToken(")",")",T+a+1+c.length,0))),C.push(["TOKENS",m]))),a+=s.length,g=a+1):a+=1;if(a>g&&t.length>g&&C.push(this.makeToken("NEOSTRING",t.slice(g),T+g)),v)return C;if(!C.length)return this.token("STRING",'""',b,p);for("NEOSTRING"!==C[0][0]&&C.unshift(this.makeToken("NEOSTRING","",b)),(h=C.length>1)&&this.token("(","(",b,0,r),a=E=0,x=C.length;x>E;a=++E)L=C[a],F=L[0],N=L[1],a&&(a&&(k=this.token("+","+")),f="TOKENS"===F?N[0]:L,k[2]={first_line:f[2].first_line,first_column:f[2].first_column,last_line:f[2].first_line,last_column:f[2].first_column}),"TOKENS"===F?(R=this.tokens).push.apply(R,N):"NEOSTRING"===F?(L[0]="STRING",L[1]=this.makeString(N,'"',o),this.tokens.push(L)):this.error("Unexpected "+F);return h&&(w=this.makeToken(")",")",b+p,0),w.stringEnd=!0,this.tokens.push(w)),C},e.prototype.pair=function(e){var t;return e!==(t=z(this.ends))?("OUTDENT"!==t&&this.error("unmatched "+e),this.outdentToken(z(this.indents),!0),this.pair(e)):this.ends.pop()},e.prototype.getLineAndColumnFromChunk=function(e){var t,n,i,r;return 0===e?[this.chunkLine,this.chunkColumn]:(r=e>=this.chunk.length?this.chunk:this.chunk.slice(0,+(e-1)+1||9e9),n=W(r,"\n"),t=this.chunkColumn,n>0?(i=r.split("\n"),t=z(i).length):t+=r.length,[this.chunkLine+n,t])},e.prototype.makeToken=function(e,t,n,i){var r,s,o,a,c;return null==n&&(n=0),null==i&&(i=t.length),s={},a=this.getLineAndColumnFromChunk(n),s.first_line=a[0],s.first_column=a[1],r=Math.max(0,i-1),c=this.getLineAndColumnFromChunk(n+r),s.last_line=c[0],s.last_column=c[1],o=[e,t,s]},e.prototype.token=function(e,t,n,i,r){var s;return s=this.makeToken(e,t,n,i),r&&(s.origin=r),this.tokens.push(s),s},e.prototype.tag=function(e,t){var n;return(n=z(this.tokens,e))&&(t?n[0]=t:n[0])},e.prototype.value=function(e,t){var n;return(n=z(this.tokens,e))&&(t?n[1]=t:n[1])},e.prototype.unfinished=function(){var e;return L.test(this.chunk)||"\\"===(e=this.tag())||"."===e||"?."===e||"?::"===e||"UNARY"===e||"MATH"===e||"UNARY_MATH"===e||"+"===e||"-"===e||"**"===e||"SHIFT"===e||"RELATION"===e||"COMPARE"===e||"LOGIC"===e||"THROW"===e||"EXTENDS"===e},e.prototype.removeNewlines=function(e){return e.replace(/^\s*\n\s*/,"").replace(/([^\\]|\\\\)\s*\n\s*$/,"$1")},e.prototype.escapeLines=function(e,t){return e=e.replace(/\\[^\S\n]*(\n|\\)\s*/g,function(e,t){return"\n"===t?"":e}),t?e.replace(x,"\\n"):e.replace(/\s*\n\s*/g," ")},e.prototype.makeString=function(e,t,n){return e?(e=e.replace(RegExp("\\\\("+t+"|\\\\)","g"),function(e,n){return n===t?n:e}),e=e.replace(RegExp(""+t,"g"),"\\$&"),t+this.escapeLines(e,n)+t):t+t},e.prototype.error=function(e,t){var n,i,r;return null==t&&(t=0),r=this.getLineAndColumnFromChunk(t),i=r[0],n=r[1],Q(e,{first_line:i,first_column:n})},e}(),T=["true","false","null","this","new","delete","typeof","in","instanceof","return","throw","break","continue","debugger","if","else","switch","for","while","do","try","catch","finally","class","extends","super"],a=["undefined","then","unless","until","loop","of","by","when"],o={and:"&&",or:"||",is:"==",isnt:"!=",not:"!",yes:"true",no:"false",on:"true",off:"false"},s=function(){var e;e=[];for(Y in o)e.push(Y);return e}(),a=a.concat(s),O=["case","default","function","var","void","with","const","let","enum","export","import","native","__hasProp","__extends","__slice","__bind","__indexOf","implements","interface","package","private","protected","public","static","yield"],V=["arguments","eval"],w=T.concat(O).concat(V),e.RESERVED=O.concat(T).concat(a).concat(V),e.STRICT_PROSCRIBED=V,t=65279,b=/^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\S]*:(?!:))?/,A=/^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i,u=/^("""|''')((?:\\[\s\S]|[^\\])*?)(?:\n[^\n\S]*)?\1/,I=/^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/,q=/^[^\n\S]+/,c=/^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/,r=/^[-=]>/,D=/^(?:\n[^\n\S]*)+/,B=/^'[^\\']*(?:\\[\s\S][^\\']*)*'/,v=/^`[^\\`]*(?:\\.[^\\`]*)*`/,_=/^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/,f=/^\/{3}((?:\\?[\s\S])+?)\/{3}([imgy]{0,4})(?!\w)/,m=/((?:\\\\)+)|\\(\s|\/)|\s+(?:#.*)?/g,x=/\n/g,d=/\n+([^\n\S]*)/g,p=/\*\//,L=/^\s*(?:,|\??\.(?![.\d])|::)/,P=/\s+$/,l=["-=","+=","/=","*=","%=","||=","&&=","?=","<<=",">>=",">>>=","&=","^=","|=","**=","//=","%%="],U=["NEW","TYPEOF","DELETE","DO"],H=["!","~"],C=["&&","||","&","|","^"],M=["<<",">>",">>>"],h=["==","!=","<",">","<=",">="],E=["*","/","%","//","%%"],$=["IN","OF","INSTANCEOF"],n=["TRUE","FALSE"],S=["NUMBER","REGEX","BOOL","NULL","UNDEFINED","++","--"],R=S.concat(")","}","THIS","IDENTIFIER","STRING","]"),i=["IDENTIFIER","STRING","REGEX",")","]","}","?","::","@","THIS","SUPER"],k=i.concat("NUMBER","BOOL","NULL","UNDEFINED"),F=["INDENT","OUTDENT","TERMINATOR"],g=[")","}","]"]}.call(this),t.exports}(),require["./parser"]=function(){var e={},t={exports:e},n=function(){function e(){this.yy={}}var t={trace:function(){},yy:{},symbols_:{error:2,Root:3,Body:4,Line:5,TERMINATOR:6,Expression:7,Statement:8,Return:9,Comment:10,STATEMENT:11,Value:12,Invocation:13,Code:14,Operation:15,Assign:16,If:17,Try:18,While:19,For:20,Switch:21,Class:22,Throw:23,Block:24,INDENT:25,OUTDENT:26,Identifier:27,IDENTIFIER:28,AlphaNumeric:29,NUMBER:30,STRING:31,Literal:32,JS:33,REGEX:34,DEBUGGER:35,UNDEFINED:36,NULL:37,BOOL:38,Assignable:39,"=":40,AssignObj:41,ObjAssignable:42,":":43,ThisProperty:44,RETURN:45,HERECOMMENT:46,PARAM_START:47,ParamList:48,PARAM_END:49,FuncGlyph:50,"->":51,"=>":52,OptComma:53,",":54,Param:55,ParamVar:56,"...":57,Array:58,Object:59,Splat:60,SimpleAssignable:61,Accessor:62,Parenthetical:63,Range:64,This:65,".":66,"?.":67,"::":68,"?::":69,Index:70,INDEX_START:71,IndexValue:72,INDEX_END:73,INDEX_SOAK:74,Slice:75,"{":76,AssignList:77,"}":78,CLASS:79,EXTENDS:80,OptFuncExist:81,Arguments:82,SUPER:83,FUNC_EXIST:84,CALL_START:85,CALL_END:86,ArgList:87,THIS:88,"@":89,"[":90,"]":91,RangeDots:92,"..":93,Arg:94,SimpleArgs:95,TRY:96,Catch:97,FINALLY:98,CATCH:99,THROW:100,"(":101,")":102,WhileSource:103,WHILE:104,WHEN:105,UNTIL:106,Loop:107,LOOP:108,ForBody:109,FOR:110,ForStart:111,ForSource:112,ForVariables:113,OWN:114,ForValue:115,FORIN:116,FOROF:117,BY:118,SWITCH:119,Whens:120,ELSE:121,When:122,LEADING_WHEN:123,IfBlock:124,IF:125,POST_IF:126,UNARY:127,UNARY_MATH:128,"-":129,"+":130,"--":131,"++":132,"?":133,MATH:134,"**":135,SHIFT:136,COMPARE:137,LOGIC:138,RELATION:139,COMPOUND_ASSIGN:140,$accept:0,$end:1},terminals_:{2:"error",6:"TERMINATOR",11:"STATEMENT",25:"INDENT",26:"OUTDENT",28:"IDENTIFIER",30:"NUMBER",31:"STRING",33:"JS",34:"REGEX",35:"DEBUGGER",36:"UNDEFINED",37:"NULL",38:"BOOL",40:"=",43:":",45:"RETURN",46:"HERECOMMENT",47:"PARAM_START",49:"PARAM_END",51:"->",52:"=>",54:",",57:"...",66:".",67:"?.",68:"::",69:"?::",71:"INDEX_START",73:"INDEX_END",74:"INDEX_SOAK",76:"{",78:"}",79:"CLASS",80:"EXTENDS",83:"SUPER",84:"FUNC_EXIST",85:"CALL_START",86:"CALL_END",88:"THIS",89:"@",90:"[",91:"]",93:"..",96:"TRY",98:"FINALLY",99:"CATCH",100:"THROW",101:"(",102:")",104:"WHILE",105:"WHEN",106:"UNTIL",108:"LOOP",110:"FOR",114:"OWN",116:"FORIN",117:"FOROF",118:"BY",119:"SWITCH",121:"ELSE",123:"LEADING_WHEN",125:"IF",126:"POST_IF",127:"UNARY",128:"UNARY_MATH",129:"-",130:"+",131:"--",132:"++",133:"?",134:"MATH",135:"**",136:"SHIFT",137:"COMPARE",138:"LOGIC",139:"RELATION",140:"COMPOUND_ASSIGN"},productions_:[0,[3,0],[3,1],[4,1],[4,3],[4,2],[5,1],[5,1],[8,1],[8,1],[8,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[24,2],[24,3],[27,1],[29,1],[29,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[16,3],[16,4],[16,5],[41,1],[41,3],[41,5],[41,1],[42,1],[42,1],[42,1],[9,2],[9,1],[10,1],[14,5],[14,2],[50,1],[50,1],[53,0],[53,1],[48,0],[48,1],[48,3],[48,4],[48,6],[55,1],[55,2],[55,3],[55,1],[56,1],[56,1],[56,1],[56,1],[60,2],[61,1],[61,2],[61,2],[61,1],[39,1],[39,1],[39,1],[12,1],[12,1],[12,1],[12,1],[12,1],[62,2],[62,2],[62,2],[62,2],[62,1],[62,1],[70,3],[70,2],[72,1],[72,1],[59,4],[77,0],[77,1],[77,3],[77,4],[77,6],[22,1],[22,2],[22,3],[22,4],[22,2],[22,3],[22,4],[22,5],[13,3],[13,3],[13,1],[13,2],[81,0],[81,1],[82,2],[82,4],[65,1],[65,1],[44,2],[58,2],[58,4],[92,1],[92,1],[64,5],[75,3],[75,2],[75,2],[75,1],[87,1],[87,3],[87,4],[87,4],[87,6],[94,1],[94,1],[94,1],[95,1],[95,3],[18,2],[18,3],[18,4],[18,5],[97,3],[97,3],[97,2],[23,2],[63,3],[63,5],[103,2],[103,4],[103,2],[103,4],[19,2],[19,2],[19,2],[19,1],[107,2],[107,2],[20,2],[20,2],[20,2],[109,2],[109,2],[111,2],[111,3],[115,1],[115,1],[115,1],[115,1],[113,1],[113,3],[112,2],[112,2],[112,4],[112,4],[112,4],[112,6],[112,6],[21,5],[21,7],[21,4],[21,6],[120,1],[120,2],[122,3],[122,4],[124,3],[124,5],[17,1],[17,3],[17,3],[17,3],[15,2],[15,2],[15,2],[15,2],[15,2],[15,2],[15,2],[15,2],[15,2],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,3],[15,5],[15,4],[15,3]],performAction:function(e,t,n,i,r,s,o){var a=s.length-1;switch(r){case 1:return this.$=i.addLocationDataFn(o[a],o[a])(new i.Block);case 2:return this.$=s[a];case 3:this.$=i.addLocationDataFn(o[a],o[a])(i.Block.wrap([s[a]]));break;case 4:this.$=i.addLocationDataFn(o[a-2],o[a])(s[a-2].push(s[a]));break;case 5:this.$=s[a-1];break;case 6:this.$=s[a];break;case 7:this.$=s[a];break;case 8:this.$=s[a];break;case 9:this.$=s[a];break;case 10:this.$=i.addLocationDataFn(o[a],o[a])(new i.Literal(s[a]));break;case 11:this.$=s[a];break;case 12:this.$=s[a];break;case 13:this.$=s[a];break;case 14:this.$=s[a];break;case 15:this.$=s[a];break;case 16:this.$=s[a];break;case 17:this.$=s[a];break;case 18:this.$=s[a];break;case 19:this.$=s[a];break;case 20:this.$=s[a];break;case 21:this.$=s[a];break;case 22:this.$=s[a];break;case 23:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Block);break;case 24:this.$=i.addLocationDataFn(o[a-2],o[a])(s[a-1]);break;case 25:this.$=i.addLocationDataFn(o[a],o[a])(new i.Literal(s[a]));break;case 26:this.$=i.addLocationDataFn(o[a],o[a])(new i.Literal(s[a]));break;case 27:this.$=i.addLocationDataFn(o[a],o[a])(new i.Literal(s[a]));break;case 28:this.$=s[a];break;case 29:this.$=i.addLocationDataFn(o[a],o[a])(new i.Literal(s[a]));break;case 30:this.$=i.addLocationDataFn(o[a],o[a])(new i.Literal(s[a]));break;case 31:this.$=i.addLocationDataFn(o[a],o[a])(new i.Literal(s[a]));break;case 32:this.$=i.addLocationDataFn(o[a],o[a])(new i.Undefined);
break;case 33:this.$=i.addLocationDataFn(o[a],o[a])(new i.Null);break;case 34:this.$=i.addLocationDataFn(o[a],o[a])(new i.Bool(s[a]));break;case 35:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Assign(s[a-2],s[a]));break;case 36:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Assign(s[a-3],s[a]));break;case 37:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Assign(s[a-4],s[a-1]));break;case 38:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 39:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Assign(i.addLocationDataFn(o[a-2])(new i.Value(s[a-2])),s[a],"object"));break;case 40:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Assign(i.addLocationDataFn(o[a-4])(new i.Value(s[a-4])),s[a-1],"object"));break;case 41:this.$=s[a];break;case 42:this.$=s[a];break;case 43:this.$=s[a];break;case 44:this.$=s[a];break;case 45:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Return(s[a]));break;case 46:this.$=i.addLocationDataFn(o[a],o[a])(new i.Return);break;case 47:this.$=i.addLocationDataFn(o[a],o[a])(new i.Comment(s[a]));break;case 48:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Code(s[a-3],s[a],s[a-1]));break;case 49:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Code([],s[a],s[a-1]));break;case 50:this.$=i.addLocationDataFn(o[a],o[a])("func");break;case 51:this.$=i.addLocationDataFn(o[a],o[a])("boundfunc");break;case 52:this.$=s[a];break;case 53:this.$=s[a];break;case 54:this.$=i.addLocationDataFn(o[a],o[a])([]);break;case 55:this.$=i.addLocationDataFn(o[a],o[a])([s[a]]);break;case 56:this.$=i.addLocationDataFn(o[a-2],o[a])(s[a-2].concat(s[a]));break;case 57:this.$=i.addLocationDataFn(o[a-3],o[a])(s[a-3].concat(s[a]));break;case 58:this.$=i.addLocationDataFn(o[a-5],o[a])(s[a-5].concat(s[a-2]));break;case 59:this.$=i.addLocationDataFn(o[a],o[a])(new i.Param(s[a]));break;case 60:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Param(s[a-1],null,!0));break;case 61:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Param(s[a-2],s[a]));break;case 62:this.$=i.addLocationDataFn(o[a],o[a])(new i.Expansion);break;case 63:this.$=s[a];break;case 64:this.$=s[a];break;case 65:this.$=s[a];break;case 66:this.$=s[a];break;case 67:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Splat(s[a-1]));break;case 68:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 69:this.$=i.addLocationDataFn(o[a-1],o[a])(s[a-1].add(s[a]));break;case 70:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Value(s[a-1],[].concat(s[a])));break;case 71:this.$=s[a];break;case 72:this.$=s[a];break;case 73:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 74:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 75:this.$=s[a];break;case 76:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 77:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 78:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 79:this.$=s[a];break;case 80:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Access(s[a]));break;case 81:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Access(s[a],"soak"));break;case 82:this.$=i.addLocationDataFn(o[a-1],o[a])([i.addLocationDataFn(o[a-1])(new i.Access(new i.Literal("prototype"))),i.addLocationDataFn(o[a])(new i.Access(s[a]))]);break;case 83:this.$=i.addLocationDataFn(o[a-1],o[a])([i.addLocationDataFn(o[a-1])(new i.Access(new i.Literal("prototype"),"soak")),i.addLocationDataFn(o[a])(new i.Access(s[a]))]);break;case 84:this.$=i.addLocationDataFn(o[a],o[a])(new i.Access(new i.Literal("prototype")));break;case 85:this.$=s[a];break;case 86:this.$=i.addLocationDataFn(o[a-2],o[a])(s[a-1]);break;case 87:this.$=i.addLocationDataFn(o[a-1],o[a])(i.extend(s[a],{soak:!0}));break;case 88:this.$=i.addLocationDataFn(o[a],o[a])(new i.Index(s[a]));break;case 89:this.$=i.addLocationDataFn(o[a],o[a])(new i.Slice(s[a]));break;case 90:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Obj(s[a-2],s[a-3].generated));break;case 91:this.$=i.addLocationDataFn(o[a],o[a])([]);break;case 92:this.$=i.addLocationDataFn(o[a],o[a])([s[a]]);break;case 93:this.$=i.addLocationDataFn(o[a-2],o[a])(s[a-2].concat(s[a]));break;case 94:this.$=i.addLocationDataFn(o[a-3],o[a])(s[a-3].concat(s[a]));break;case 95:this.$=i.addLocationDataFn(o[a-5],o[a])(s[a-5].concat(s[a-2]));break;case 96:this.$=i.addLocationDataFn(o[a],o[a])(new i.Class);break;case 97:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Class(null,null,s[a]));break;case 98:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Class(null,s[a]));break;case 99:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Class(null,s[a-1],s[a]));break;case 100:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Class(s[a]));break;case 101:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Class(s[a-1],null,s[a]));break;case 102:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Class(s[a-2],s[a]));break;case 103:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Class(s[a-3],s[a-1],s[a]));break;case 104:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Call(s[a-2],s[a],s[a-1]));break;case 105:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Call(s[a-2],s[a],s[a-1]));break;case 106:this.$=i.addLocationDataFn(o[a],o[a])(new i.Call("super",[new i.Splat(new i.Literal("arguments"))]));break;case 107:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Call("super",s[a]));break;case 108:this.$=i.addLocationDataFn(o[a],o[a])(!1);break;case 109:this.$=i.addLocationDataFn(o[a],o[a])(!0);break;case 110:this.$=i.addLocationDataFn(o[a-1],o[a])([]);break;case 111:this.$=i.addLocationDataFn(o[a-3],o[a])(s[a-2]);break;case 112:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(new i.Literal("this")));break;case 113:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(new i.Literal("this")));break;case 114:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Value(i.addLocationDataFn(o[a-1])(new i.Literal("this")),[i.addLocationDataFn(o[a])(new i.Access(s[a]))],"this"));break;case 115:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Arr([]));break;case 116:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Arr(s[a-2]));break;case 117:this.$=i.addLocationDataFn(o[a],o[a])("inclusive");break;case 118:this.$=i.addLocationDataFn(o[a],o[a])("exclusive");break;case 119:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Range(s[a-3],s[a-1],s[a-2]));break;case 120:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Range(s[a-2],s[a],s[a-1]));break;case 121:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Range(s[a-1],null,s[a]));break;case 122:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Range(null,s[a],s[a-1]));break;case 123:this.$=i.addLocationDataFn(o[a],o[a])(new i.Range(null,null,s[a]));break;case 124:this.$=i.addLocationDataFn(o[a],o[a])([s[a]]);break;case 125:this.$=i.addLocationDataFn(o[a-2],o[a])(s[a-2].concat(s[a]));break;case 126:this.$=i.addLocationDataFn(o[a-3],o[a])(s[a-3].concat(s[a]));break;case 127:this.$=i.addLocationDataFn(o[a-3],o[a])(s[a-2]);break;case 128:this.$=i.addLocationDataFn(o[a-5],o[a])(s[a-5].concat(s[a-2]));break;case 129:this.$=s[a];break;case 130:this.$=s[a];break;case 131:this.$=i.addLocationDataFn(o[a],o[a])(new i.Expansion);break;case 132:this.$=s[a];break;case 133:this.$=i.addLocationDataFn(o[a-2],o[a])([].concat(s[a-2],s[a]));break;case 134:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Try(s[a]));break;case 135:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Try(s[a-1],s[a][0],s[a][1]));break;case 136:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Try(s[a-2],null,null,s[a]));break;case 137:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Try(s[a-3],s[a-2][0],s[a-2][1],s[a]));break;case 138:this.$=i.addLocationDataFn(o[a-2],o[a])([s[a-1],s[a]]);break;case 139:this.$=i.addLocationDataFn(o[a-2],o[a])([i.addLocationDataFn(o[a-1])(new i.Value(s[a-1])),s[a]]);break;case 140:this.$=i.addLocationDataFn(o[a-1],o[a])([null,s[a]]);break;case 141:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Throw(s[a]));break;case 142:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Parens(s[a-1]));break;case 143:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Parens(s[a-2]));break;case 144:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.While(s[a]));break;case 145:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.While(s[a-2],{guard:s[a]}));break;case 146:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.While(s[a],{invert:!0}));break;case 147:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.While(s[a-2],{invert:!0,guard:s[a]}));break;case 148:this.$=i.addLocationDataFn(o[a-1],o[a])(s[a-1].addBody(s[a]));break;case 149:this.$=i.addLocationDataFn(o[a-1],o[a])(s[a].addBody(i.addLocationDataFn(o[a-1])(i.Block.wrap([s[a-1]]))));break;case 150:this.$=i.addLocationDataFn(o[a-1],o[a])(s[a].addBody(i.addLocationDataFn(o[a-1])(i.Block.wrap([s[a-1]]))));break;case 151:this.$=i.addLocationDataFn(o[a],o[a])(s[a]);break;case 152:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.While(i.addLocationDataFn(o[a-1])(new i.Literal("true"))).addBody(s[a]));break;case 153:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.While(i.addLocationDataFn(o[a-1])(new i.Literal("true"))).addBody(i.addLocationDataFn(o[a])(i.Block.wrap([s[a]]))));break;case 154:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.For(s[a-1],s[a]));break;case 155:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.For(s[a-1],s[a]));break;case 156:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.For(s[a],s[a-1]));break;case 157:this.$=i.addLocationDataFn(o[a-1],o[a])({source:i.addLocationDataFn(o[a])(new i.Value(s[a]))});break;case 158:this.$=i.addLocationDataFn(o[a-1],o[a])(function(){return s[a].own=s[a-1].own,s[a].name=s[a-1][0],s[a].index=s[a-1][1],s[a]}());break;case 159:this.$=i.addLocationDataFn(o[a-1],o[a])(s[a]);break;case 160:this.$=i.addLocationDataFn(o[a-2],o[a])(function(){return s[a].own=!0,s[a]}());break;case 161:this.$=s[a];break;case 162:this.$=s[a];break;case 163:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 164:this.$=i.addLocationDataFn(o[a],o[a])(new i.Value(s[a]));break;case 165:this.$=i.addLocationDataFn(o[a],o[a])([s[a]]);break;case 166:this.$=i.addLocationDataFn(o[a-2],o[a])([s[a-2],s[a]]);break;case 167:this.$=i.addLocationDataFn(o[a-1],o[a])({source:s[a]});break;case 168:this.$=i.addLocationDataFn(o[a-1],o[a])({source:s[a],object:!0});break;case 169:this.$=i.addLocationDataFn(o[a-3],o[a])({source:s[a-2],guard:s[a]});break;case 170:this.$=i.addLocationDataFn(o[a-3],o[a])({source:s[a-2],guard:s[a],object:!0});break;case 171:this.$=i.addLocationDataFn(o[a-3],o[a])({source:s[a-2],step:s[a]});break;case 172:this.$=i.addLocationDataFn(o[a-5],o[a])({source:s[a-4],guard:s[a-2],step:s[a]});break;case 173:this.$=i.addLocationDataFn(o[a-5],o[a])({source:s[a-4],step:s[a-2],guard:s[a]});break;case 174:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Switch(s[a-3],s[a-1]));break;case 175:this.$=i.addLocationDataFn(o[a-6],o[a])(new i.Switch(s[a-5],s[a-3],s[a-1]));break;case 176:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Switch(null,s[a-1]));break;case 177:this.$=i.addLocationDataFn(o[a-5],o[a])(new i.Switch(null,s[a-3],s[a-1]));break;case 178:this.$=s[a];break;case 179:this.$=i.addLocationDataFn(o[a-1],o[a])(s[a-1].concat(s[a]));break;case 180:this.$=i.addLocationDataFn(o[a-2],o[a])([[s[a-1],s[a]]]);break;case 181:this.$=i.addLocationDataFn(o[a-3],o[a])([[s[a-2],s[a-1]]]);break;case 182:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.If(s[a-1],s[a],{type:s[a-2]}));break;case 183:this.$=i.addLocationDataFn(o[a-4],o[a])(s[a-4].addElse(i.addLocationDataFn(o[a-2],o[a])(new i.If(s[a-1],s[a],{type:s[a-2]}))));break;case 184:this.$=s[a];break;case 185:this.$=i.addLocationDataFn(o[a-2],o[a])(s[a-2].addElse(s[a]));break;case 186:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.If(s[a],i.addLocationDataFn(o[a-2])(i.Block.wrap([s[a-2]])),{type:s[a-1],statement:!0}));break;case 187:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.If(s[a],i.addLocationDataFn(o[a-2])(i.Block.wrap([s[a-2]])),{type:s[a-1],statement:!0}));break;case 188:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op(s[a-1],s[a]));break;case 189:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op(s[a-1],s[a]));break;case 190:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op("-",s[a]));break;case 191:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op("+",s[a]));break;case 192:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op("--",s[a]));break;case 193:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op("++",s[a]));break;case 194:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op("--",s[a-1],null,!0));break;case 195:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Op("++",s[a-1],null,!0));break;case 196:this.$=i.addLocationDataFn(o[a-1],o[a])(new i.Existence(s[a-1]));break;case 197:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Op("+",s[a-2],s[a]));break;case 198:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Op("-",s[a-2],s[a]));break;case 199:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Op(s[a-1],s[a-2],s[a]));break;case 200:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Op(s[a-1],s[a-2],s[a]));break;case 201:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Op(s[a-1],s[a-2],s[a]));break;case 202:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Op(s[a-1],s[a-2],s[a]));break;case 203:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Op(s[a-1],s[a-2],s[a]));break;case 204:this.$=i.addLocationDataFn(o[a-2],o[a])(function(){return"!"===s[a-1].charAt(0)?new i.Op(s[a-1].slice(1),s[a-2],s[a]).invert():new i.Op(s[a-1],s[a-2],s[a])}());break;case 205:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Assign(s[a-2],s[a],s[a-1]));break;case 206:this.$=i.addLocationDataFn(o[a-4],o[a])(new i.Assign(s[a-4],s[a-1],s[a-3]));break;case 207:this.$=i.addLocationDataFn(o[a-3],o[a])(new i.Assign(s[a-3],s[a],s[a-2]));break;case 208:this.$=i.addLocationDataFn(o[a-2],o[a])(new i.Extends(s[a-2],s[a]))}},table:[{1:[2,1],3:1,4:2,5:3,7:4,8:5,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[3]},{1:[2,2],6:[1,73]},{1:[2,3],6:[2,3],26:[2,3],102:[2,3]},{1:[2,6],6:[2,6],26:[2,6],102:[2,6],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,7],6:[2,7],26:[2,7],102:[2,7],103:87,104:[1,64],106:[1,65],109:88,110:[1,67],111:68,126:[1,86]},{1:[2,11],6:[2,11],25:[2,11],26:[2,11],49:[2,11],54:[2,11],57:[2,11],62:90,66:[1,92],67:[1,93],68:[1,94],69:[1,95],70:96,71:[1,97],73:[2,11],74:[1,98],78:[2,11],81:89,84:[1,91],85:[2,108],86:[2,11],91:[2,11],93:[2,11],102:[2,11],104:[2,11],105:[2,11],106:[2,11],110:[2,11],118:[2,11],126:[2,11],129:[2,11],130:[2,11],133:[2,11],134:[2,11],135:[2,11],136:[2,11],137:[2,11],138:[2,11],139:[2,11]},{1:[2,12],6:[2,12],25:[2,12],26:[2,12],49:[2,12],54:[2,12],57:[2,12],62:100,66:[1,92],67:[1,93],68:[1,94],69:[1,95],70:96,71:[1,97],73:[2,12],74:[1,98],78:[2,12],81:99,84:[1,91],85:[2,108],86:[2,12],91:[2,12],93:[2,12],102:[2,12],104:[2,12],105:[2,12],106:[2,12],110:[2,12],118:[2,12],126:[2,12],129:[2,12],130:[2,12],133:[2,12],134:[2,12],135:[2,12],136:[2,12],137:[2,12],138:[2,12],139:[2,12]},{1:[2,13],6:[2,13],25:[2,13],26:[2,13],49:[2,13],54:[2,13],57:[2,13],73:[2,13],78:[2,13],86:[2,13],91:[2,13],93:[2,13],102:[2,13],104:[2,13],105:[2,13],106:[2,13],110:[2,13],118:[2,13],126:[2,13],129:[2,13],130:[2,13],133:[2,13],134:[2,13],135:[2,13],136:[2,13],137:[2,13],138:[2,13],139:[2,13]},{1:[2,14],6:[2,14],25:[2,14],26:[2,14],49:[2,14],54:[2,14],57:[2,14],73:[2,14],78:[2,14],86:[2,14],91:[2,14],93:[2,14],102:[2,14],104:[2,14],105:[2,14],106:[2,14],110:[2,14],118:[2,14],126:[2,14],129:[2,14],130:[2,14],133:[2,14],134:[2,14],135:[2,14],136:[2,14],137:[2,14],138:[2,14],139:[2,14]},{1:[2,15],6:[2,15],25:[2,15],26:[2,15],49:[2,15],54:[2,15],57:[2,15],73:[2,15],78:[2,15],86:[2,15],91:[2,15],93:[2,15],102:[2,15],104:[2,15],105:[2,15],106:[2,15],110:[2,15],118:[2,15],126:[2,15],129:[2,15],130:[2,15],133:[2,15],134:[2,15],135:[2,15],136:[2,15],137:[2,15],138:[2,15],139:[2,15]},{1:[2,16],6:[2,16],25:[2,16],26:[2,16],49:[2,16],54:[2,16],57:[2,16],73:[2,16],78:[2,16],86:[2,16],91:[2,16],93:[2,16],102:[2,16],104:[2,16],105:[2,16],106:[2,16],110:[2,16],118:[2,16],126:[2,16],129:[2,16],130:[2,16],133:[2,16],134:[2,16],135:[2,16],136:[2,16],137:[2,16],138:[2,16],139:[2,16]},{1:[2,17],6:[2,17],25:[2,17],26:[2,17],49:[2,17],54:[2,17],57:[2,17],73:[2,17],78:[2,17],86:[2,17],91:[2,17],93:[2,17],102:[2,17],104:[2,17],105:[2,17],106:[2,17],110:[2,17],118:[2,17],126:[2,17],129:[2,17],130:[2,17],133:[2,17],134:[2,17],135:[2,17],136:[2,17],137:[2,17],138:[2,17],139:[2,17]},{1:[2,18],6:[2,18],25:[2,18],26:[2,18],49:[2,18],54:[2,18],57:[2,18],73:[2,18],78:[2,18],86:[2,18],91:[2,18],93:[2,18],102:[2,18],104:[2,18],105:[2,18],106:[2,18],110:[2,18],118:[2,18],126:[2,18],129:[2,18],130:[2,18],133:[2,18],134:[2,18],135:[2,18],136:[2,18],137:[2,18],138:[2,18],139:[2,18]},{1:[2,19],6:[2,19],25:[2,19],26:[2,19],49:[2,19],54:[2,19],57:[2,19],73:[2,19],78:[2,19],86:[2,19],91:[2,19],93:[2,19],102:[2,19],104:[2,19],105:[2,19],106:[2,19],110:[2,19],118:[2,19],126:[2,19],129:[2,19],130:[2,19],133:[2,19],134:[2,19],135:[2,19],136:[2,19],137:[2,19],138:[2,19],139:[2,19]},{1:[2,20],6:[2,20],25:[2,20],26:[2,20],49:[2,20],54:[2,20],57:[2,20],73:[2,20],78:[2,20],86:[2,20],91:[2,20],93:[2,20],102:[2,20],104:[2,20],105:[2,20],106:[2,20],110:[2,20],118:[2,20],126:[2,20],129:[2,20],130:[2,20],133:[2,20],134:[2,20],135:[2,20],136:[2,20],137:[2,20],138:[2,20],139:[2,20]},{1:[2,21],6:[2,21],25:[2,21],26:[2,21],49:[2,21],54:[2,21],57:[2,21],73:[2,21],78:[2,21],86:[2,21],91:[2,21],93:[2,21],102:[2,21],104:[2,21],105:[2,21],106:[2,21],110:[2,21],118:[2,21],126:[2,21],129:[2,21],130:[2,21],133:[2,21],134:[2,21],135:[2,21],136:[2,21],137:[2,21],138:[2,21],139:[2,21]},{1:[2,22],6:[2,22],25:[2,22],26:[2,22],49:[2,22],54:[2,22],57:[2,22],73:[2,22],78:[2,22],86:[2,22],91:[2,22],93:[2,22],102:[2,22],104:[2,22],105:[2,22],106:[2,22],110:[2,22],118:[2,22],126:[2,22],129:[2,22],130:[2,22],133:[2,22],134:[2,22],135:[2,22],136:[2,22],137:[2,22],138:[2,22],139:[2,22]},{1:[2,8],6:[2,8],26:[2,8],102:[2,8],104:[2,8],106:[2,8],110:[2,8],126:[2,8]},{1:[2,9],6:[2,9],26:[2,9],102:[2,9],104:[2,9],106:[2,9],110:[2,9],126:[2,9]},{1:[2,10],6:[2,10],26:[2,10],102:[2,10],104:[2,10],106:[2,10],110:[2,10],126:[2,10]},{1:[2,75],6:[2,75],25:[2,75],26:[2,75],40:[1,101],49:[2,75],54:[2,75],57:[2,75],66:[2,75],67:[2,75],68:[2,75],69:[2,75],71:[2,75],73:[2,75],74:[2,75],78:[2,75],84:[2,75],85:[2,75],86:[2,75],91:[2,75],93:[2,75],102:[2,75],104:[2,75],105:[2,75],106:[2,75],110:[2,75],118:[2,75],126:[2,75],129:[2,75],130:[2,75],133:[2,75],134:[2,75],135:[2,75],136:[2,75],137:[2,75],138:[2,75],139:[2,75]},{1:[2,76],6:[2,76],25:[2,76],26:[2,76],49:[2,76],54:[2,76],57:[2,76],66:[2,76],67:[2,76],68:[2,76],69:[2,76],71:[2,76],73:[2,76],74:[2,76],78:[2,76],84:[2,76],85:[2,76],86:[2,76],91:[2,76],93:[2,76],102:[2,76],104:[2,76],105:[2,76],106:[2,76],110:[2,76],118:[2,76],126:[2,76],129:[2,76],130:[2,76],133:[2,76],134:[2,76],135:[2,76],136:[2,76],137:[2,76],138:[2,76],139:[2,76]},{1:[2,77],6:[2,77],25:[2,77],26:[2,77],49:[2,77],54:[2,77],57:[2,77],66:[2,77],67:[2,77],68:[2,77],69:[2,77],71:[2,77],73:[2,77],74:[2,77],78:[2,77],84:[2,77],85:[2,77],86:[2,77],91:[2,77],93:[2,77],102:[2,77],104:[2,77],105:[2,77],106:[2,77],110:[2,77],118:[2,77],126:[2,77],129:[2,77],130:[2,77],133:[2,77],134:[2,77],135:[2,77],136:[2,77],137:[2,77],138:[2,77],139:[2,77]},{1:[2,78],6:[2,78],25:[2,78],26:[2,78],49:[2,78],54:[2,78],57:[2,78],66:[2,78],67:[2,78],68:[2,78],69:[2,78],71:[2,78],73:[2,78],74:[2,78],78:[2,78],84:[2,78],85:[2,78],86:[2,78],91:[2,78],93:[2,78],102:[2,78],104:[2,78],105:[2,78],106:[2,78],110:[2,78],118:[2,78],126:[2,78],129:[2,78],130:[2,78],133:[2,78],134:[2,78],135:[2,78],136:[2,78],137:[2,78],138:[2,78],139:[2,78]},{1:[2,79],6:[2,79],25:[2,79],26:[2,79],49:[2,79],54:[2,79],57:[2,79],66:[2,79],67:[2,79],68:[2,79],69:[2,79],71:[2,79],73:[2,79],74:[2,79],78:[2,79],84:[2,79],85:[2,79],86:[2,79],91:[2,79],93:[2,79],102:[2,79],104:[2,79],105:[2,79],106:[2,79],110:[2,79],118:[2,79],126:[2,79],129:[2,79],130:[2,79],133:[2,79],134:[2,79],135:[2,79],136:[2,79],137:[2,79],138:[2,79],139:[2,79]},{1:[2,106],6:[2,106],25:[2,106],26:[2,106],49:[2,106],54:[2,106],57:[2,106],66:[2,106],67:[2,106],68:[2,106],69:[2,106],71:[2,106],73:[2,106],74:[2,106],78:[2,106],82:102,84:[2,106],85:[1,103],86:[2,106],91:[2,106],93:[2,106],102:[2,106],104:[2,106],105:[2,106],106:[2,106],110:[2,106],118:[2,106],126:[2,106],129:[2,106],130:[2,106],133:[2,106],134:[2,106],135:[2,106],136:[2,106],137:[2,106],138:[2,106],139:[2,106]},{6:[2,54],25:[2,54],27:108,28:[1,72],44:109,48:104,49:[2,54],54:[2,54],55:105,56:106,57:[1,107],58:110,59:111,76:[1,69],89:[1,112],90:[1,113]},{24:114,25:[1,115]},{7:116,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:118,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:119,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:120,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{12:122,13:123,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:124,44:62,58:46,59:47,61:121,63:23,64:24,65:25,76:[1,69],83:[1,26],88:[1,57],89:[1,58],90:[1,56],101:[1,55]},{12:122,13:123,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:124,44:62,58:46,59:47,61:125,63:23,64:24,65:25,76:[1,69],83:[1,26],88:[1,57],89:[1,58],90:[1,56],101:[1,55]},{1:[2,72],6:[2,72],25:[2,72],26:[2,72],40:[2,72],49:[2,72],54:[2,72],57:[2,72],66:[2,72],67:[2,72],68:[2,72],69:[2,72],71:[2,72],73:[2,72],74:[2,72],78:[2,72],80:[1,129],84:[2,72],85:[2,72],86:[2,72],91:[2,72],93:[2,72],102:[2,72],104:[2,72],105:[2,72],106:[2,72],110:[2,72],118:[2,72],126:[2,72],129:[2,72],130:[2,72],131:[1,126],132:[1,127],133:[2,72],134:[2,72],135:[2,72],136:[2,72],137:[2,72],138:[2,72],139:[2,72],140:[1,128]},{1:[2,184],6:[2,184],25:[2,184],26:[2,184],49:[2,184],54:[2,184],57:[2,184],73:[2,184],78:[2,184],86:[2,184],91:[2,184],93:[2,184],102:[2,184],104:[2,184],105:[2,184],106:[2,184],110:[2,184],118:[2,184],121:[1,130],126:[2,184],129:[2,184],130:[2,184],133:[2,184],134:[2,184],135:[2,184],136:[2,184],137:[2,184],138:[2,184],139:[2,184]},{24:131,25:[1,115]},{24:132,25:[1,115]},{1:[2,151],6:[2,151],25:[2,151],26:[2,151],49:[2,151],54:[2,151],57:[2,151],73:[2,151],78:[2,151],86:[2,151],91:[2,151],93:[2,151],102:[2,151],104:[2,151],105:[2,151],106:[2,151],110:[2,151],118:[2,151],126:[2,151],129:[2,151],130:[2,151],133:[2,151],134:[2,151],135:[2,151],136:[2,151],137:[2,151],138:[2,151],139:[2,151]},{24:133,25:[1,115]},{7:134,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,135],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,96],6:[2,96],12:122,13:123,24:136,25:[1,115],26:[2,96],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:124,44:62,49:[2,96],54:[2,96],57:[2,96],58:46,59:47,61:138,63:23,64:24,65:25,73:[2,96],76:[1,69],78:[2,96],80:[1,137],83:[1,26],86:[2,96],88:[1,57],89:[1,58],90:[1,56],91:[2,96],93:[2,96],101:[1,55],102:[2,96],104:[2,96],105:[2,96],106:[2,96],110:[2,96],118:[2,96],126:[2,96],129:[2,96],130:[2,96],133:[2,96],134:[2,96],135:[2,96],136:[2,96],137:[2,96],138:[2,96],139:[2,96]},{7:139,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,46],6:[2,46],7:140,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,26:[2,46],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],102:[2,46],103:38,104:[2,46],106:[2,46],107:39,108:[1,66],109:40,110:[2,46],111:68,119:[1,41],124:36,125:[1,63],126:[2,46],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,47],6:[2,47],25:[2,47],26:[2,47],54:[2,47],78:[2,47],102:[2,47],104:[2,47],106:[2,47],110:[2,47],126:[2,47]},{1:[2,73],6:[2,73],25:[2,73],26:[2,73],40:[2,73],49:[2,73],54:[2,73],57:[2,73],66:[2,73],67:[2,73],68:[2,73],69:[2,73],71:[2,73],73:[2,73],74:[2,73],78:[2,73],84:[2,73],85:[2,73],86:[2,73],91:[2,73],93:[2,73],102:[2,73],104:[2,73],105:[2,73],106:[2,73],110:[2,73],118:[2,73],126:[2,73],129:[2,73],130:[2,73],133:[2,73],134:[2,73],135:[2,73],136:[2,73],137:[2,73],138:[2,73],139:[2,73]},{1:[2,74],6:[2,74],25:[2,74],26:[2,74],40:[2,74],49:[2,74],54:[2,74],57:[2,74],66:[2,74],67:[2,74],68:[2,74],69:[2,74],71:[2,74],73:[2,74],74:[2,74],78:[2,74],84:[2,74],85:[2,74],86:[2,74],91:[2,74],93:[2,74],102:[2,74],104:[2,74],105:[2,74],106:[2,74],110:[2,74],118:[2,74],126:[2,74],129:[2,74],130:[2,74],133:[2,74],134:[2,74],135:[2,74],136:[2,74],137:[2,74],138:[2,74],139:[2,74]},{1:[2,28],6:[2,28],25:[2,28],26:[2,28],49:[2,28],54:[2,28],57:[2,28],66:[2,28],67:[2,28],68:[2,28],69:[2,28],71:[2,28],73:[2,28],74:[2,28],78:[2,28],84:[2,28],85:[2,28],86:[2,28],91:[2,28],93:[2,28],102:[2,28],104:[2,28],105:[2,28],106:[2,28],110:[2,28],118:[2,28],126:[2,28],129:[2,28],130:[2,28],133:[2,28],134:[2,28],135:[2,28],136:[2,28],137:[2,28],138:[2,28],139:[2,28]},{1:[2,29],6:[2,29],25:[2,29],26:[2,29],49:[2,29],54:[2,29],57:[2,29],66:[2,29],67:[2,29],68:[2,29],69:[2,29],71:[2,29],73:[2,29],74:[2,29],78:[2,29],84:[2,29],85:[2,29],86:[2,29],91:[2,29],93:[2,29],102:[2,29],104:[2,29],105:[2,29],106:[2,29],110:[2,29],118:[2,29],126:[2,29],129:[2,29],130:[2,29],133:[2,29],134:[2,29],135:[2,29],136:[2,29],137:[2,29],138:[2,29],139:[2,29]},{1:[2,30],6:[2,30],25:[2,30],26:[2,30],49:[2,30],54:[2,30],57:[2,30],66:[2,30],67:[2,30],68:[2,30],69:[2,30],71:[2,30],73:[2,30],74:[2,30],78:[2,30],84:[2,30],85:[2,30],86:[2,30],91:[2,30],93:[2,30],102:[2,30],104:[2,30],105:[2,30],106:[2,30],110:[2,30],118:[2,30],126:[2,30],129:[2,30],130:[2,30],133:[2,30],134:[2,30],135:[2,30],136:[2,30],137:[2,30],138:[2,30],139:[2,30]},{1:[2,31],6:[2,31],25:[2,31],26:[2,31],49:[2,31],54:[2,31],57:[2,31],66:[2,31],67:[2,31],68:[2,31],69:[2,31],71:[2,31],73:[2,31],74:[2,31],78:[2,31],84:[2,31],85:[2,31],86:[2,31],91:[2,31],93:[2,31],102:[2,31],104:[2,31],105:[2,31],106:[2,31],110:[2,31],118:[2,31],126:[2,31],129:[2,31],130:[2,31],133:[2,31],134:[2,31],135:[2,31],136:[2,31],137:[2,31],138:[2,31],139:[2,31]},{1:[2,32],6:[2,32],25:[2,32],26:[2,32],49:[2,32],54:[2,32],57:[2,32],66:[2,32],67:[2,32],68:[2,32],69:[2,32],71:[2,32],73:[2,32],74:[2,32],78:[2,32],84:[2,32],85:[2,32],86:[2,32],91:[2,32],93:[2,32],102:[2,32],104:[2,32],105:[2,32],106:[2,32],110:[2,32],118:[2,32],126:[2,32],129:[2,32],130:[2,32],133:[2,32],134:[2,32],135:[2,32],136:[2,32],137:[2,32],138:[2,32],139:[2,32]},{1:[2,33],6:[2,33],25:[2,33],26:[2,33],49:[2,33],54:[2,33],57:[2,33],66:[2,33],67:[2,33],68:[2,33],69:[2,33],71:[2,33],73:[2,33],74:[2,33],78:[2,33],84:[2,33],85:[2,33],86:[2,33],91:[2,33],93:[2,33],102:[2,33],104:[2,33],105:[2,33],106:[2,33],110:[2,33],118:[2,33],126:[2,33],129:[2,33],130:[2,33],133:[2,33],134:[2,33],135:[2,33],136:[2,33],137:[2,33],138:[2,33],139:[2,33]},{1:[2,34],6:[2,34],25:[2,34],26:[2,34],49:[2,34],54:[2,34],57:[2,34],66:[2,34],67:[2,34],68:[2,34],69:[2,34],71:[2,34],73:[2,34],74:[2,34],78:[2,34],84:[2,34],85:[2,34],86:[2,34],91:[2,34],93:[2,34],102:[2,34],104:[2,34],105:[2,34],106:[2,34],110:[2,34],118:[2,34],126:[2,34],129:[2,34],130:[2,34],133:[2,34],134:[2,34],135:[2,34],136:[2,34],137:[2,34],138:[2,34],139:[2,34]},{4:141,5:3,7:4,8:5,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,142],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:143,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,147],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,149],58:46,59:47,60:148,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],87:145,88:[1,57],89:[1,58],90:[1,56],91:[1,144],94:146,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,112],6:[2,112],25:[2,112],26:[2,112],49:[2,112],54:[2,112],57:[2,112],66:[2,112],67:[2,112],68:[2,112],69:[2,112],71:[2,112],73:[2,112],74:[2,112],78:[2,112],84:[2,112],85:[2,112],86:[2,112],91:[2,112],93:[2,112],102:[2,112],104:[2,112],105:[2,112],106:[2,112],110:[2,112],118:[2,112],126:[2,112],129:[2,112],130:[2,112],133:[2,112],134:[2,112],135:[2,112],136:[2,112],137:[2,112],138:[2,112],139:[2,112]},{1:[2,113],6:[2,113],25:[2,113],26:[2,113],27:150,28:[1,72],49:[2,113],54:[2,113],57:[2,113],66:[2,113],67:[2,113],68:[2,113],69:[2,113],71:[2,113],73:[2,113],74:[2,113],78:[2,113],84:[2,113],85:[2,113],86:[2,113],91:[2,113],93:[2,113],102:[2,113],104:[2,113],105:[2,113],106:[2,113],110:[2,113],118:[2,113],126:[2,113],129:[2,113],130:[2,113],133:[2,113],134:[2,113],135:[2,113],136:[2,113],137:[2,113],138:[2,113],139:[2,113]},{25:[2,50]},{25:[2,51]},{1:[2,68],6:[2,68],25:[2,68],26:[2,68],40:[2,68],49:[2,68],54:[2,68],57:[2,68],66:[2,68],67:[2,68],68:[2,68],69:[2,68],71:[2,68],73:[2,68],74:[2,68],78:[2,68],80:[2,68],84:[2,68],85:[2,68],86:[2,68],91:[2,68],93:[2,68],102:[2,68],104:[2,68],105:[2,68],106:[2,68],110:[2,68],118:[2,68],126:[2,68],129:[2,68],130:[2,68],131:[2,68],132:[2,68],133:[2,68],134:[2,68],135:[2,68],136:[2,68],137:[2,68],138:[2,68],139:[2,68],140:[2,68]},{1:[2,71],6:[2,71],25:[2,71],26:[2,71],40:[2,71],49:[2,71],54:[2,71],57:[2,71],66:[2,71],67:[2,71],68:[2,71],69:[2,71],71:[2,71],73:[2,71],74:[2,71],78:[2,71],80:[2,71],84:[2,71],85:[2,71],86:[2,71],91:[2,71],93:[2,71],102:[2,71],104:[2,71],105:[2,71],106:[2,71],110:[2,71],118:[2,71],126:[2,71],129:[2,71],130:[2,71],131:[2,71],132:[2,71],133:[2,71],134:[2,71],135:[2,71],136:[2,71],137:[2,71],138:[2,71],139:[2,71],140:[2,71]},{7:151,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:152,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:153,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:155,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,24:154,25:[1,115],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{27:160,28:[1,72],44:161,58:162,59:163,64:156,76:[1,69],89:[1,112],90:[1,56],113:157,114:[1,158],115:159},{112:164,116:[1,165],117:[1,166]},{6:[2,91],10:170,25:[2,91],27:171,28:[1,72],29:172,30:[1,70],31:[1,71],41:168,42:169,44:173,46:[1,45],54:[2,91],77:167,78:[2,91],89:[1,112]},{1:[2,26],6:[2,26],25:[2,26],26:[2,26],43:[2,26],49:[2,26],54:[2,26],57:[2,26],66:[2,26],67:[2,26],68:[2,26],69:[2,26],71:[2,26],73:[2,26],74:[2,26],78:[2,26],84:[2,26],85:[2,26],86:[2,26],91:[2,26],93:[2,26],102:[2,26],104:[2,26],105:[2,26],106:[2,26],110:[2,26],118:[2,26],126:[2,26],129:[2,26],130:[2,26],133:[2,26],134:[2,26],135:[2,26],136:[2,26],137:[2,26],138:[2,26],139:[2,26]},{1:[2,27],6:[2,27],25:[2,27],26:[2,27],43:[2,27],49:[2,27],54:[2,27],57:[2,27],66:[2,27],67:[2,27],68:[2,27],69:[2,27],71:[2,27],73:[2,27],74:[2,27],78:[2,27],84:[2,27],85:[2,27],86:[2,27],91:[2,27],93:[2,27],102:[2,27],104:[2,27],105:[2,27],106:[2,27],110:[2,27],118:[2,27],126:[2,27],129:[2,27],130:[2,27],133:[2,27],134:[2,27],135:[2,27],136:[2,27],137:[2,27],138:[2,27],139:[2,27]},{1:[2,25],6:[2,25],25:[2,25],26:[2,25],40:[2,25],43:[2,25],49:[2,25],54:[2,25],57:[2,25],66:[2,25],67:[2,25],68:[2,25],69:[2,25],71:[2,25],73:[2,25],74:[2,25],78:[2,25],80:[2,25],84:[2,25],85:[2,25],86:[2,25],91:[2,25],93:[2,25],102:[2,25],104:[2,25],105:[2,25],106:[2,25],110:[2,25],116:[2,25],117:[2,25],118:[2,25],126:[2,25],129:[2,25],130:[2,25],131:[2,25],132:[2,25],133:[2,25],134:[2,25],135:[2,25],136:[2,25],137:[2,25],138:[2,25],139:[2,25],140:[2,25]},{1:[2,5],5:174,6:[2,5],7:4,8:5,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,26:[2,5],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],102:[2,5],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,196],6:[2,196],25:[2,196],26:[2,196],49:[2,196],54:[2,196],57:[2,196],73:[2,196],78:[2,196],86:[2,196],91:[2,196],93:[2,196],102:[2,196],104:[2,196],105:[2,196],106:[2,196],110:[2,196],118:[2,196],126:[2,196],129:[2,196],130:[2,196],133:[2,196],134:[2,196],135:[2,196],136:[2,196],137:[2,196],138:[2,196],139:[2,196]},{7:175,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:176,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:177,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:178,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:179,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:180,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:181,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:182,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:183,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,150],6:[2,150],25:[2,150],26:[2,150],49:[2,150],54:[2,150],57:[2,150],73:[2,150],78:[2,150],86:[2,150],91:[2,150],93:[2,150],102:[2,150],104:[2,150],105:[2,150],106:[2,150],110:[2,150],118:[2,150],126:[2,150],129:[2,150],130:[2,150],133:[2,150],134:[2,150],135:[2,150],136:[2,150],137:[2,150],138:[2,150],139:[2,150]},{1:[2,155],6:[2,155],25:[2,155],26:[2,155],49:[2,155],54:[2,155],57:[2,155],73:[2,155],78:[2,155],86:[2,155],91:[2,155],93:[2,155],102:[2,155],104:[2,155],105:[2,155],106:[2,155],110:[2,155],118:[2,155],126:[2,155],129:[2,155],130:[2,155],133:[2,155],134:[2,155],135:[2,155],136:[2,155],137:[2,155],138:[2,155],139:[2,155]},{7:184,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,149],6:[2,149],25:[2,149],26:[2,149],49:[2,149],54:[2,149],57:[2,149],73:[2,149],78:[2,149],86:[2,149],91:[2,149],93:[2,149],102:[2,149],104:[2,149],105:[2,149],106:[2,149],110:[2,149],118:[2,149],126:[2,149],129:[2,149],130:[2,149],133:[2,149],134:[2,149],135:[2,149],136:[2,149],137:[2,149],138:[2,149],139:[2,149]},{1:[2,154],6:[2,154],25:[2,154],26:[2,154],49:[2,154],54:[2,154],57:[2,154],73:[2,154],78:[2,154],86:[2,154],91:[2,154],93:[2,154],102:[2,154],104:[2,154],105:[2,154],106:[2,154],110:[2,154],118:[2,154],126:[2,154],129:[2,154],130:[2,154],133:[2,154],134:[2,154],135:[2,154],136:[2,154],137:[2,154],138:[2,154],139:[2,154]},{82:185,85:[1,103]},{1:[2,69],6:[2,69],25:[2,69],26:[2,69],40:[2,69],49:[2,69],54:[2,69],57:[2,69],66:[2,69],67:[2,69],68:[2,69],69:[2,69],71:[2,69],73:[2,69],74:[2,69],78:[2,69],80:[2,69],84:[2,69],85:[2,69],86:[2,69],91:[2,69],93:[2,69],102:[2,69],104:[2,69],105:[2,69],106:[2,69],110:[2,69],118:[2,69],126:[2,69],129:[2,69],130:[2,69],131:[2,69],132:[2,69],133:[2,69],134:[2,69],135:[2,69],136:[2,69],137:[2,69],138:[2,69],139:[2,69],140:[2,69]},{85:[2,109]},{27:186,28:[1,72]},{27:187,28:[1,72]},{1:[2,84],6:[2,84],25:[2,84],26:[2,84],27:188,28:[1,72],40:[2,84],49:[2,84],54:[2,84],57:[2,84],66:[2,84],67:[2,84],68:[2,84],69:[2,84],71:[2,84],73:[2,84],74:[2,84],78:[2,84],80:[2,84],84:[2,84],85:[2,84],86:[2,84],91:[2,84],93:[2,84],102:[2,84],104:[2,84],105:[2,84],106:[2,84],110:[2,84],118:[2,84],126:[2,84],129:[2,84],130:[2,84],131:[2,84],132:[2,84],133:[2,84],134:[2,84],135:[2,84],136:[2,84],137:[2,84],138:[2,84],139:[2,84],140:[2,84]},{27:189,28:[1,72]},{1:[2,85],6:[2,85],25:[2,85],26:[2,85],40:[2,85],49:[2,85],54:[2,85],57:[2,85],66:[2,85],67:[2,85],68:[2,85],69:[2,85],71:[2,85],73:[2,85],74:[2,85],78:[2,85],80:[2,85],84:[2,85],85:[2,85],86:[2,85],91:[2,85],93:[2,85],102:[2,85],104:[2,85],105:[2,85],106:[2,85],110:[2,85],118:[2,85],126:[2,85],129:[2,85],130:[2,85],131:[2,85],132:[2,85],133:[2,85],134:[2,85],135:[2,85],136:[2,85],137:[2,85],138:[2,85],139:[2,85],140:[2,85]},{7:191,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,195],58:46,59:47,61:35,63:23,64:24,65:25,72:190,75:192,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],92:193,93:[1,194],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{70:196,71:[1,97],74:[1,98]},{82:197,85:[1,103]},{1:[2,70],6:[2,70],25:[2,70],26:[2,70],40:[2,70],49:[2,70],54:[2,70],57:[2,70],66:[2,70],67:[2,70],68:[2,70],69:[2,70],71:[2,70],73:[2,70],74:[2,70],78:[2,70],80:[2,70],84:[2,70],85:[2,70],86:[2,70],91:[2,70],93:[2,70],102:[2,70],104:[2,70],105:[2,70],106:[2,70],110:[2,70],118:[2,70],126:[2,70],129:[2,70],130:[2,70],131:[2,70],132:[2,70],133:[2,70],134:[2,70],135:[2,70],136:[2,70],137:[2,70],138:[2,70],139:[2,70],140:[2,70]},{6:[1,199],7:198,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,200],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,107],6:[2,107],25:[2,107],26:[2,107],49:[2,107],54:[2,107],57:[2,107],66:[2,107],67:[2,107],68:[2,107],69:[2,107],71:[2,107],73:[2,107],74:[2,107],78:[2,107],84:[2,107],85:[2,107],86:[2,107],91:[2,107],93:[2,107],102:[2,107],104:[2,107],105:[2,107],106:[2,107],110:[2,107],118:[2,107],126:[2,107],129:[2,107],130:[2,107],133:[2,107],134:[2,107],135:[2,107],136:[2,107],137:[2,107],138:[2,107],139:[2,107]},{7:203,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,147],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,149],58:46,59:47,60:148,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],86:[1,201],87:202,88:[1,57],89:[1,58],90:[1,56],94:146,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[2,52],25:[2,52],49:[1,204],53:206,54:[1,205]},{6:[2,55],25:[2,55],26:[2,55],49:[2,55],54:[2,55]},{6:[2,59],25:[2,59],26:[2,59],40:[1,208],49:[2,59],54:[2,59],57:[1,207]},{6:[2,62],25:[2,62],26:[2,62],49:[2,62],54:[2,62]},{6:[2,63],25:[2,63],26:[2,63],40:[2,63],49:[2,63],54:[2,63],57:[2,63]},{6:[2,64],25:[2,64],26:[2,64],40:[2,64],49:[2,64],54:[2,64],57:[2,64]},{6:[2,65],25:[2,65],26:[2,65],40:[2,65],49:[2,65],54:[2,65],57:[2,65]},{6:[2,66],25:[2,66],26:[2,66],40:[2,66],49:[2,66],54:[2,66],57:[2,66]},{27:150,28:[1,72]},{7:203,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,147],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,149],58:46,59:47,60:148,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],87:145,88:[1,57],89:[1,58],90:[1,56],91:[1,144],94:146,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,49],6:[2,49],25:[2,49],26:[2,49],49:[2,49],54:[2,49],57:[2,49],73:[2,49],78:[2,49],86:[2,49],91:[2,49],93:[2,49],102:[2,49],104:[2,49],105:[2,49],106:[2,49],110:[2,49],118:[2,49],126:[2,49],129:[2,49],130:[2,49],133:[2,49],134:[2,49],135:[2,49],136:[2,49],137:[2,49],138:[2,49],139:[2,49]},{4:210,5:3,7:4,8:5,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,26:[1,209],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,188],6:[2,188],25:[2,188],26:[2,188],49:[2,188],54:[2,188],57:[2,188],73:[2,188],78:[2,188],86:[2,188],91:[2,188],93:[2,188],102:[2,188],103:84,104:[2,188],105:[2,188],106:[2,188],109:85,110:[2,188],111:68,118:[2,188],126:[2,188],129:[2,188],130:[2,188],133:[1,74],134:[2,188],135:[2,188],136:[2,188],137:[2,188],138:[2,188],139:[2,188]},{103:87,104:[1,64],106:[1,65],109:88,110:[1,67],111:68,126:[1,86]},{1:[2,189],6:[2,189],25:[2,189],26:[2,189],49:[2,189],54:[2,189],57:[2,189],73:[2,189],78:[2,189],86:[2,189],91:[2,189],93:[2,189],102:[2,189],103:84,104:[2,189],105:[2,189],106:[2,189],109:85,110:[2,189],111:68,118:[2,189],126:[2,189],129:[2,189],130:[2,189],133:[1,74],134:[2,189],135:[1,78],136:[2,189],137:[2,189],138:[2,189],139:[2,189]},{1:[2,190],6:[2,190],25:[2,190],26:[2,190],49:[2,190],54:[2,190],57:[2,190],73:[2,190],78:[2,190],86:[2,190],91:[2,190],93:[2,190],102:[2,190],103:84,104:[2,190],105:[2,190],106:[2,190],109:85,110:[2,190],111:68,118:[2,190],126:[2,190],129:[2,190],130:[2,190],133:[1,74],134:[2,190],135:[1,78],136:[2,190],137:[2,190],138:[2,190],139:[2,190]},{1:[2,191],6:[2,191],25:[2,191],26:[2,191],49:[2,191],54:[2,191],57:[2,191],73:[2,191],78:[2,191],86:[2,191],91:[2,191],93:[2,191],102:[2,191],103:84,104:[2,191],105:[2,191],106:[2,191],109:85,110:[2,191],111:68,118:[2,191],126:[2,191],129:[2,191],130:[2,191],133:[1,74],134:[2,191],135:[1,78],136:[2,191],137:[2,191],138:[2,191],139:[2,191]},{1:[2,192],6:[2,192],25:[2,192],26:[2,192],49:[2,192],54:[2,192],57:[2,192],66:[2,72],67:[2,72],68:[2,72],69:[2,72],71:[2,72],73:[2,192],74:[2,72],78:[2,192],84:[2,72],85:[2,72],86:[2,192],91:[2,192],93:[2,192],102:[2,192],104:[2,192],105:[2,192],106:[2,192],110:[2,192],118:[2,192],126:[2,192],129:[2,192],130:[2,192],133:[2,192],134:[2,192],135:[2,192],136:[2,192],137:[2,192],138:[2,192],139:[2,192]},{62:90,66:[1,92],67:[1,93],68:[1,94],69:[1,95],70:96,71:[1,97],74:[1,98],81:89,84:[1,91],85:[2,108]},{62:100,66:[1,92],67:[1,93],68:[1,94],69:[1,95],70:96,71:[1,97],74:[1,98],81:99,84:[1,91],85:[2,108]},{66:[2,75],67:[2,75],68:[2,75],69:[2,75],71:[2,75],74:[2,75],84:[2,75],85:[2,75]},{1:[2,193],6:[2,193],25:[2,193],26:[2,193],49:[2,193],54:[2,193],57:[2,193],66:[2,72],67:[2,72],68:[2,72],69:[2,72],71:[2,72],73:[2,193],74:[2,72],78:[2,193],84:[2,72],85:[2,72],86:[2,193],91:[2,193],93:[2,193],102:[2,193],104:[2,193],105:[2,193],106:[2,193],110:[2,193],118:[2,193],126:[2,193],129:[2,193],130:[2,193],133:[2,193],134:[2,193],135:[2,193],136:[2,193],137:[2,193],138:[2,193],139:[2,193]},{1:[2,194],6:[2,194],25:[2,194],26:[2,194],49:[2,194],54:[2,194],57:[2,194],73:[2,194],78:[2,194],86:[2,194],91:[2,194],93:[2,194],102:[2,194],104:[2,194],105:[2,194],106:[2,194],110:[2,194],118:[2,194],126:[2,194],129:[2,194],130:[2,194],133:[2,194],134:[2,194],135:[2,194],136:[2,194],137:[2,194],138:[2,194],139:[2,194]},{1:[2,195],6:[2,195],25:[2,195],26:[2,195],49:[2,195],54:[2,195],57:[2,195],73:[2,195],78:[2,195],86:[2,195],91:[2,195],93:[2,195],102:[2,195],104:[2,195],105:[2,195],106:[2,195],110:[2,195],118:[2,195],126:[2,195],129:[2,195],130:[2,195],133:[2,195],134:[2,195],135:[2,195],136:[2,195],137:[2,195],138:[2,195],139:[2,195]},{6:[1,213],7:211,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,212],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:214,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{24:215,25:[1,115],125:[1,216]},{1:[2,134],6:[2,134],25:[2,134],26:[2,134],49:[2,134],54:[2,134],57:[2,134],73:[2,134],78:[2,134],86:[2,134],91:[2,134],93:[2,134],97:217,98:[1,218],99:[1,219],102:[2,134],104:[2,134],105:[2,134],106:[2,134],110:[2,134],118:[2,134],126:[2,134],129:[2,134],130:[2,134],133:[2,134],134:[2,134],135:[2,134],136:[2,134],137:[2,134],138:[2,134],139:[2,134]},{1:[2,148],6:[2,148],25:[2,148],26:[2,148],49:[2,148],54:[2,148],57:[2,148],73:[2,148],78:[2,148],86:[2,148],91:[2,148],93:[2,148],102:[2,148],104:[2,148],105:[2,148],106:[2,148],110:[2,148],118:[2,148],126:[2,148],129:[2,148],130:[2,148],133:[2,148],134:[2,148],135:[2,148],136:[2,148],137:[2,148],138:[2,148],139:[2,148]},{1:[2,156],6:[2,156],25:[2,156],26:[2,156],49:[2,156],54:[2,156],57:[2,156],73:[2,156],78:[2,156],86:[2,156],91:[2,156],93:[2,156],102:[2,156],104:[2,156],105:[2,156],106:[2,156],110:[2,156],118:[2,156],126:[2,156],129:[2,156],130:[2,156],133:[2,156],134:[2,156],135:[2,156],136:[2,156],137:[2,156],138:[2,156],139:[2,156]},{25:[1,220],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{120:221,122:222,123:[1,223]},{1:[2,97],6:[2,97],25:[2,97],26:[2,97],49:[2,97],54:[2,97],57:[2,97],73:[2,97],78:[2,97],86:[2,97],91:[2,97],93:[2,97],102:[2,97],104:[2,97],105:[2,97],106:[2,97],110:[2,97],118:[2,97],126:[2,97],129:[2,97],130:[2,97],133:[2,97],134:[2,97],135:[2,97],136:[2,97],137:[2,97],138:[2,97],139:[2,97]},{7:224,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,100],6:[2,100],24:225,25:[1,115],26:[2,100],49:[2,100],54:[2,100],57:[2,100],66:[2,72],67:[2,72],68:[2,72],69:[2,72],71:[2,72],73:[2,100],74:[2,72],78:[2,100],80:[1,226],84:[2,72],85:[2,72],86:[2,100],91:[2,100],93:[2,100],102:[2,100],104:[2,100],105:[2,100],106:[2,100],110:[2,100],118:[2,100],126:[2,100],129:[2,100],130:[2,100],133:[2,100],134:[2,100],135:[2,100],136:[2,100],137:[2,100],138:[2,100],139:[2,100]},{1:[2,141],6:[2,141],25:[2,141],26:[2,141],49:[2,141],54:[2,141],57:[2,141],73:[2,141],78:[2,141],86:[2,141],91:[2,141],93:[2,141],102:[2,141],103:84,104:[2,141],105:[2,141],106:[2,141],109:85,110:[2,141],111:68,118:[2,141],126:[2,141],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,45],6:[2,45],26:[2,45],102:[2,45],103:84,104:[2,45],106:[2,45],109:85,110:[2,45],111:68,126:[2,45],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{6:[1,73],102:[1,227]},{4:228,5:3,7:4,8:5,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[2,129],25:[2,129],54:[2,129],57:[1,230],91:[2,129],92:229,93:[1,194],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,115],6:[2,115],25:[2,115],26:[2,115],40:[2,115],49:[2,115],54:[2,115],57:[2,115],66:[2,115],67:[2,115],68:[2,115],69:[2,115],71:[2,115],73:[2,115],74:[2,115],78:[2,115],84:[2,115],85:[2,115],86:[2,115],91:[2,115],93:[2,115],102:[2,115],104:[2,115],105:[2,115],106:[2,115],110:[2,115],116:[2,115],117:[2,115],118:[2,115],126:[2,115],129:[2,115],130:[2,115],133:[2,115],134:[2,115],135:[2,115],136:[2,115],137:[2,115],138:[2,115],139:[2,115]},{6:[2,52],25:[2,52],53:231,54:[1,232],91:[2,52]},{6:[2,124],25:[2,124],26:[2,124],54:[2,124],86:[2,124],91:[2,124]},{7:203,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,147],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,149],58:46,59:47,60:148,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],87:233,88:[1,57],89:[1,58],90:[1,56],94:146,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[2,130],25:[2,130],26:[2,130],54:[2,130],86:[2,130],91:[2,130]},{6:[2,131],25:[2,131],26:[2,131],54:[2,131],86:[2,131],91:[2,131]},{1:[2,114],6:[2,114],25:[2,114],26:[2,114],40:[2,114],43:[2,114],49:[2,114],54:[2,114],57:[2,114],66:[2,114],67:[2,114],68:[2,114],69:[2,114],71:[2,114],73:[2,114],74:[2,114],78:[2,114],80:[2,114],84:[2,114],85:[2,114],86:[2,114],91:[2,114],93:[2,114],102:[2,114],104:[2,114],105:[2,114],106:[2,114],110:[2,114],116:[2,114],117:[2,114],118:[2,114],126:[2,114],129:[2,114],130:[2,114],131:[2,114],132:[2,114],133:[2,114],134:[2,114],135:[2,114],136:[2,114],137:[2,114],138:[2,114],139:[2,114],140:[2,114]},{24:234,25:[1,115],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,144],6:[2,144],25:[2,144],26:[2,144],49:[2,144],54:[2,144],57:[2,144],73:[2,144],78:[2,144],86:[2,144],91:[2,144],93:[2,144],102:[2,144],103:84,104:[1,64],105:[1,235],106:[1,65],109:85,110:[1,67],111:68,118:[2,144],126:[2,144],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,146],6:[2,146],25:[2,146],26:[2,146],49:[2,146],54:[2,146],57:[2,146],73:[2,146],78:[2,146],86:[2,146],91:[2,146],93:[2,146],102:[2,146],103:84,104:[1,64],105:[1,236],106:[1,65],109:85,110:[1,67],111:68,118:[2,146],126:[2,146],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,152],6:[2,152],25:[2,152],26:[2,152],49:[2,152],54:[2,152],57:[2,152],73:[2,152],78:[2,152],86:[2,152],91:[2,152],93:[2,152],102:[2,152],104:[2,152],105:[2,152],106:[2,152],110:[2,152],118:[2,152],126:[2,152],129:[2,152],130:[2,152],133:[2,152],134:[2,152],135:[2,152],136:[2,152],137:[2,152],138:[2,152],139:[2,152]},{1:[2,153],6:[2,153],25:[2,153],26:[2,153],49:[2,153],54:[2,153],57:[2,153],73:[2,153],78:[2,153],86:[2,153],91:[2,153],93:[2,153],102:[2,153],103:84,104:[1,64],105:[2,153],106:[1,65],109:85,110:[1,67],111:68,118:[2,153],126:[2,153],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,157],6:[2,157],25:[2,157],26:[2,157],49:[2,157],54:[2,157],57:[2,157],73:[2,157],78:[2,157],86:[2,157],91:[2,157],93:[2,157],102:[2,157],104:[2,157],105:[2,157],106:[2,157],110:[2,157],118:[2,157],126:[2,157],129:[2,157],130:[2,157],133:[2,157],134:[2,157],135:[2,157],136:[2,157],137:[2,157],138:[2,157],139:[2,157]},{116:[2,159],117:[2,159]},{27:160,28:[1,72],44:161,58:162,59:163,76:[1,69],89:[1,112],90:[1,113],113:237,115:159},{54:[1,238],116:[2,165],117:[2,165]},{54:[2,161],116:[2,161],117:[2,161]},{54:[2,162],116:[2,162],117:[2,162]},{54:[2,163],116:[2,163],117:[2,163]},{54:[2,164],116:[2,164],117:[2,164]},{1:[2,158],6:[2,158],25:[2,158],26:[2,158],49:[2,158],54:[2,158],57:[2,158],73:[2,158],78:[2,158],86:[2,158],91:[2,158],93:[2,158],102:[2,158],104:[2,158],105:[2,158],106:[2,158],110:[2,158],118:[2,158],126:[2,158],129:[2,158],130:[2,158],133:[2,158],134:[2,158],135:[2,158],136:[2,158],137:[2,158],138:[2,158],139:[2,158]},{7:239,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:240,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[2,52],25:[2,52],53:241,54:[1,242],78:[2,52]},{6:[2,92],25:[2,92],26:[2,92],54:[2,92],78:[2,92]},{6:[2,38],25:[2,38],26:[2,38],43:[1,243],54:[2,38],78:[2,38]},{6:[2,41],25:[2,41],26:[2,41],54:[2,41],78:[2,41]},{6:[2,42],25:[2,42],26:[2,42],43:[2,42],54:[2,42],78:[2,42]},{6:[2,43],25:[2,43],26:[2,43],43:[2,43],54:[2,43],78:[2,43]},{6:[2,44],25:[2,44],26:[2,44],43:[2,44],54:[2,44],78:[2,44]},{1:[2,4],6:[2,4],26:[2,4],102:[2,4]},{1:[2,197],6:[2,197],25:[2,197],26:[2,197],49:[2,197],54:[2,197],57:[2,197],73:[2,197],78:[2,197],86:[2,197],91:[2,197],93:[2,197],102:[2,197],103:84,104:[2,197],105:[2,197],106:[2,197],109:85,110:[2,197],111:68,118:[2,197],126:[2,197],129:[2,197],130:[2,197],133:[1,74],134:[1,77],135:[1,78],136:[2,197],137:[2,197],138:[2,197],139:[2,197]},{1:[2,198],6:[2,198],25:[2,198],26:[2,198],49:[2,198],54:[2,198],57:[2,198],73:[2,198],78:[2,198],86:[2,198],91:[2,198],93:[2,198],102:[2,198],103:84,104:[2,198],105:[2,198],106:[2,198],109:85,110:[2,198],111:68,118:[2,198],126:[2,198],129:[2,198],130:[2,198],133:[1,74],134:[1,77],135:[1,78],136:[2,198],137:[2,198],138:[2,198],139:[2,198]},{1:[2,199],6:[2,199],25:[2,199],26:[2,199],49:[2,199],54:[2,199],57:[2,199],73:[2,199],78:[2,199],86:[2,199],91:[2,199],93:[2,199],102:[2,199],103:84,104:[2,199],105:[2,199],106:[2,199],109:85,110:[2,199],111:68,118:[2,199],126:[2,199],129:[2,199],130:[2,199],133:[1,74],134:[2,199],135:[1,78],136:[2,199],137:[2,199],138:[2,199],139:[2,199]},{1:[2,200],6:[2,200],25:[2,200],26:[2,200],49:[2,200],54:[2,200],57:[2,200],73:[2,200],78:[2,200],86:[2,200],91:[2,200],93:[2,200],102:[2,200],103:84,104:[2,200],105:[2,200],106:[2,200],109:85,110:[2,200],111:68,118:[2,200],126:[2,200],129:[2,200],130:[2,200],133:[1,74],134:[2,200],135:[1,78],136:[2,200],137:[2,200],138:[2,200],139:[2,200]},{1:[2,201],6:[2,201],25:[2,201],26:[2,201],49:[2,201],54:[2,201],57:[2,201],73:[2,201],78:[2,201],86:[2,201],91:[2,201],93:[2,201],102:[2,201],103:84,104:[2,201],105:[2,201],106:[2,201],109:85,110:[2,201],111:68,118:[2,201],126:[2,201],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[2,201],137:[2,201],138:[2,201],139:[2,201]},{1:[2,202],6:[2,202],25:[2,202],26:[2,202],49:[2,202],54:[2,202],57:[2,202],73:[2,202],78:[2,202],86:[2,202],91:[2,202],93:[2,202],102:[2,202],103:84,104:[2,202],105:[2,202],106:[2,202],109:85,110:[2,202],111:68,118:[2,202],126:[2,202],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[2,202],138:[2,202],139:[1,82]},{1:[2,203],6:[2,203],25:[2,203],26:[2,203],49:[2,203],54:[2,203],57:[2,203],73:[2,203],78:[2,203],86:[2,203],91:[2,203],93:[2,203],102:[2,203],103:84,104:[2,203],105:[2,203],106:[2,203],109:85,110:[2,203],111:68,118:[2,203],126:[2,203],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[2,203],139:[1,82]},{1:[2,204],6:[2,204],25:[2,204],26:[2,204],49:[2,204],54:[2,204],57:[2,204],73:[2,204],78:[2,204],86:[2,204],91:[2,204],93:[2,204],102:[2,204],103:84,104:[2,204],105:[2,204],106:[2,204],109:85,110:[2,204],111:68,118:[2,204],126:[2,204],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[2,204],138:[2,204],139:[2,204]},{1:[2,187],6:[2,187],25:[2,187],26:[2,187],49:[2,187],54:[2,187],57:[2,187],73:[2,187],78:[2,187],86:[2,187],91:[2,187],93:[2,187],102:[2,187],103:84,104:[1,64],105:[2,187],106:[1,65],109:85,110:[1,67],111:68,118:[2,187],126:[2,187],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,186],6:[2,186],25:[2,186],26:[2,186],49:[2,186],54:[2,186],57:[2,186],73:[2,186],78:[2,186],86:[2,186],91:[2,186],93:[2,186],102:[2,186],103:84,104:[1,64],105:[2,186],106:[1,65],109:85,110:[1,67],111:68,118:[2,186],126:[2,186],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,104],6:[2,104],25:[2,104],26:[2,104],49:[2,104],54:[2,104],57:[2,104],66:[2,104],67:[2,104],68:[2,104],69:[2,104],71:[2,104],73:[2,104],74:[2,104],78:[2,104],84:[2,104],85:[2,104],86:[2,104],91:[2,104],93:[2,104],102:[2,104],104:[2,104],105:[2,104],106:[2,104],110:[2,104],118:[2,104],126:[2,104],129:[2,104],130:[2,104],133:[2,104],134:[2,104],135:[2,104],136:[2,104],137:[2,104],138:[2,104],139:[2,104]},{1:[2,80],6:[2,80],25:[2,80],26:[2,80],40:[2,80],49:[2,80],54:[2,80],57:[2,80],66:[2,80],67:[2,80],68:[2,80],69:[2,80],71:[2,80],73:[2,80],74:[2,80],78:[2,80],80:[2,80],84:[2,80],85:[2,80],86:[2,80],91:[2,80],93:[2,80],102:[2,80],104:[2,80],105:[2,80],106:[2,80],110:[2,80],118:[2,80],126:[2,80],129:[2,80],130:[2,80],131:[2,80],132:[2,80],133:[2,80],134:[2,80],135:[2,80],136:[2,80],137:[2,80],138:[2,80],139:[2,80],140:[2,80]},{1:[2,81],6:[2,81],25:[2,81],26:[2,81],40:[2,81],49:[2,81],54:[2,81],57:[2,81],66:[2,81],67:[2,81],68:[2,81],69:[2,81],71:[2,81],73:[2,81],74:[2,81],78:[2,81],80:[2,81],84:[2,81],85:[2,81],86:[2,81],91:[2,81],93:[2,81],102:[2,81],104:[2,81],105:[2,81],106:[2,81],110:[2,81],118:[2,81],126:[2,81],129:[2,81],130:[2,81],131:[2,81],132:[2,81],133:[2,81],134:[2,81],135:[2,81],136:[2,81],137:[2,81],138:[2,81],139:[2,81],140:[2,81]},{1:[2,82],6:[2,82],25:[2,82],26:[2,82],40:[2,82],49:[2,82],54:[2,82],57:[2,82],66:[2,82],67:[2,82],68:[2,82],69:[2,82],71:[2,82],73:[2,82],74:[2,82],78:[2,82],80:[2,82],84:[2,82],85:[2,82],86:[2,82],91:[2,82],93:[2,82],102:[2,82],104:[2,82],105:[2,82],106:[2,82],110:[2,82],118:[2,82],126:[2,82],129:[2,82],130:[2,82],131:[2,82],132:[2,82],133:[2,82],134:[2,82],135:[2,82],136:[2,82],137:[2,82],138:[2,82],139:[2,82],140:[2,82]},{1:[2,83],6:[2,83],25:[2,83],26:[2,83],40:[2,83],49:[2,83],54:[2,83],57:[2,83],66:[2,83],67:[2,83],68:[2,83],69:[2,83],71:[2,83],73:[2,83],74:[2,83],78:[2,83],80:[2,83],84:[2,83],85:[2,83],86:[2,83],91:[2,83],93:[2,83],102:[2,83],104:[2,83],105:[2,83],106:[2,83],110:[2,83],118:[2,83],126:[2,83],129:[2,83],130:[2,83],131:[2,83],132:[2,83],133:[2,83],134:[2,83],135:[2,83],136:[2,83],137:[2,83],138:[2,83],139:[2,83],140:[2,83]},{73:[1,244]},{57:[1,195],73:[2,88],92:245,93:[1,194],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{73:[2,89]},{7:246,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,73:[2,123],76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{11:[2,117],28:[2,117],30:[2,117],31:[2,117],33:[2,117],34:[2,117],35:[2,117],36:[2,117],37:[2,117],38:[2,117],45:[2,117],46:[2,117],47:[2,117],51:[2,117],52:[2,117],73:[2,117],76:[2,117],79:[2,117],83:[2,117],88:[2,117],89:[2,117],90:[2,117],96:[2,117],100:[2,117],101:[2,117],104:[2,117],106:[2,117],108:[2,117],110:[2,117],119:[2,117],125:[2,117],127:[2,117],128:[2,117],129:[2,117],130:[2,117],131:[2,117],132:[2,117]},{11:[2,118],28:[2,118],30:[2,118],31:[2,118],33:[2,118],34:[2,118],35:[2,118],36:[2,118],37:[2,118],38:[2,118],45:[2,118],46:[2,118],47:[2,118],51:[2,118],52:[2,118],73:[2,118],76:[2,118],79:[2,118],83:[2,118],88:[2,118],89:[2,118],90:[2,118],96:[2,118],100:[2,118],101:[2,118],104:[2,118],106:[2,118],108:[2,118],110:[2,118],119:[2,118],125:[2,118],127:[2,118],128:[2,118],129:[2,118],130:[2,118],131:[2,118],132:[2,118]},{1:[2,87],6:[2,87],25:[2,87],26:[2,87],40:[2,87],49:[2,87],54:[2,87],57:[2,87],66:[2,87],67:[2,87],68:[2,87],69:[2,87],71:[2,87],73:[2,87],74:[2,87],78:[2,87],80:[2,87],84:[2,87],85:[2,87],86:[2,87],91:[2,87],93:[2,87],102:[2,87],104:[2,87],105:[2,87],106:[2,87],110:[2,87],118:[2,87],126:[2,87],129:[2,87],130:[2,87],131:[2,87],132:[2,87],133:[2,87],134:[2,87],135:[2,87],136:[2,87],137:[2,87],138:[2,87],139:[2,87],140:[2,87]},{1:[2,105],6:[2,105],25:[2,105],26:[2,105],49:[2,105],54:[2,105],57:[2,105],66:[2,105],67:[2,105],68:[2,105],69:[2,105],71:[2,105],73:[2,105],74:[2,105],78:[2,105],84:[2,105],85:[2,105],86:[2,105],91:[2,105],93:[2,105],102:[2,105],104:[2,105],105:[2,105],106:[2,105],110:[2,105],118:[2,105],126:[2,105],129:[2,105],130:[2,105],133:[2,105],134:[2,105],135:[2,105],136:[2,105],137:[2,105],138:[2,105],139:[2,105]},{1:[2,35],6:[2,35],25:[2,35],26:[2,35],49:[2,35],54:[2,35],57:[2,35],73:[2,35],78:[2,35],86:[2,35],91:[2,35],93:[2,35],102:[2,35],103:84,104:[2,35],105:[2,35],106:[2,35],109:85,110:[2,35],111:68,118:[2,35],126:[2,35],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{7:247,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:248,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,110],6:[2,110],25:[2,110],26:[2,110],49:[2,110],54:[2,110],57:[2,110],66:[2,110],67:[2,110],68:[2,110],69:[2,110],71:[2,110],73:[2,110],74:[2,110],78:[2,110],84:[2,110],85:[2,110],86:[2,110],91:[2,110],93:[2,110],102:[2,110],104:[2,110],105:[2,110],106:[2,110],110:[2,110],118:[2,110],126:[2,110],129:[2,110],130:[2,110],133:[2,110],134:[2,110],135:[2,110],136:[2,110],137:[2,110],138:[2,110],139:[2,110]},{6:[2,52],25:[2,52],53:249,54:[1,232],86:[2,52]},{6:[2,129],25:[2,129],26:[2,129],54:[2,129],57:[1,250],86:[2,129],91:[2,129],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{50:251,51:[1,59],52:[1,60]},{6:[2,53],25:[2,53],26:[2,53],27:108,28:[1,72],44:109,55:252,56:106,57:[1,107],58:110,59:111,76:[1,69],89:[1,112],90:[1,113]},{6:[1,253],25:[1,254]},{6:[2,60],25:[2,60],26:[2,60],49:[2,60],54:[2,60]},{7:255,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,23],6:[2,23],25:[2,23],26:[2,23],49:[2,23],54:[2,23],57:[2,23],73:[2,23],78:[2,23],86:[2,23],91:[2,23],93:[2,23],98:[2,23],99:[2,23],102:[2,23],104:[2,23],105:[2,23],106:[2,23],110:[2,23],118:[2,23],121:[2,23],123:[2,23],126:[2,23],129:[2,23],130:[2,23],133:[2,23],134:[2,23],135:[2,23],136:[2,23],137:[2,23],138:[2,23],139:[2,23]},{6:[1,73],26:[1,256]},{1:[2,205],6:[2,205],25:[2,205],26:[2,205],49:[2,205],54:[2,205],57:[2,205],73:[2,205],78:[2,205],86:[2,205],91:[2,205],93:[2,205],102:[2,205],103:84,104:[2,205],105:[2,205],106:[2,205],109:85,110:[2,205],111:68,118:[2,205],126:[2,205],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{7:257,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:258,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,208],6:[2,208],25:[2,208],26:[2,208],49:[2,208],54:[2,208],57:[2,208],73:[2,208],78:[2,208],86:[2,208],91:[2,208],93:[2,208],102:[2,208],103:84,104:[2,208],105:[2,208],106:[2,208],109:85,110:[2,208],111:68,118:[2,208],126:[2,208],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,185],6:[2,185],25:[2,185],26:[2,185],49:[2,185],54:[2,185],57:[2,185],73:[2,185],78:[2,185],86:[2,185],91:[2,185],93:[2,185],102:[2,185],104:[2,185],105:[2,185],106:[2,185],110:[2,185],118:[2,185],126:[2,185],129:[2,185],130:[2,185],133:[2,185],134:[2,185],135:[2,185],136:[2,185],137:[2,185],138:[2,185],139:[2,185]},{7:259,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,135],6:[2,135],25:[2,135],26:[2,135],49:[2,135],54:[2,135],57:[2,135],73:[2,135],78:[2,135],86:[2,135],91:[2,135],93:[2,135],98:[1,260],102:[2,135],104:[2,135],105:[2,135],106:[2,135],110:[2,135],118:[2,135],126:[2,135],129:[2,135],130:[2,135],133:[2,135],134:[2,135],135:[2,135],136:[2,135],137:[2,135],138:[2,135],139:[2,135]},{24:261,25:[1,115]},{24:264,25:[1,115],27:262,28:[1,72],59:263,76:[1,69]},{120:265,122:222,123:[1,223]},{26:[1,266],121:[1,267],122:268,123:[1,223]},{26:[2,178],121:[2,178],123:[2,178]},{7:270,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],95:269,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,98],6:[2,98],24:271,25:[1,115],26:[2,98],49:[2,98],54:[2,98],57:[2,98],73:[2,98],78:[2,98],86:[2,98],91:[2,98],93:[2,98],102:[2,98],103:84,104:[1,64],105:[2,98],106:[1,65],109:85,110:[1,67],111:68,118:[2,98],126:[2,98],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,101],6:[2,101],25:[2,101],26:[2,101],49:[2,101],54:[2,101],57:[2,101],73:[2,101],78:[2,101],86:[2,101],91:[2,101],93:[2,101],102:[2,101],104:[2,101],105:[2,101],106:[2,101],110:[2,101],118:[2,101],126:[2,101],129:[2,101],130:[2,101],133:[2,101],134:[2,101],135:[2,101],136:[2,101],137:[2,101],138:[2,101],139:[2,101]},{7:272,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,142],6:[2,142],25:[2,142],26:[2,142],49:[2,142],54:[2,142],57:[2,142],66:[2,142],67:[2,142],68:[2,142],69:[2,142],71:[2,142],73:[2,142],74:[2,142],78:[2,142],84:[2,142],85:[2,142],86:[2,142],91:[2,142],93:[2,142],102:[2,142],104:[2,142],105:[2,142],106:[2,142],110:[2,142],118:[2,142],126:[2,142],129:[2,142],130:[2,142],133:[2,142],134:[2,142],135:[2,142],136:[2,142],137:[2,142],138:[2,142],139:[2,142]},{6:[1,73],26:[1,273]},{7:274,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[2,67],11:[2,118],25:[2,67],28:[2,118],30:[2,118],31:[2,118],33:[2,118],34:[2,118],35:[2,118],36:[2,118],37:[2,118],38:[2,118],45:[2,118],46:[2,118],47:[2,118],51:[2,118],52:[2,118],54:[2,67],76:[2,118],79:[2,118],83:[2,118],88:[2,118],89:[2,118],90:[2,118],91:[2,67],96:[2,118],100:[2,118],101:[2,118],104:[2,118],106:[2,118],108:[2,118],110:[2,118],119:[2,118],125:[2,118],127:[2,118],128:[2,118],129:[2,118],130:[2,118],131:[2,118],132:[2,118]},{6:[1,276],25:[1,277],91:[1,275]},{6:[2,53],7:203,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[2,53],26:[2,53],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,149],58:46,59:47,60:148,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],86:[2,53],88:[1,57],89:[1,58],90:[1,56],91:[2,53],94:278,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[2,52],25:[2,52],26:[2,52],53:279,54:[1,232]},{1:[2,182],6:[2,182],25:[2,182],26:[2,182],49:[2,182],54:[2,182],57:[2,182],73:[2,182],78:[2,182],86:[2,182],91:[2,182],93:[2,182],102:[2,182],104:[2,182],105:[2,182],106:[2,182],110:[2,182],118:[2,182],121:[2,182],126:[2,182],129:[2,182],130:[2,182],133:[2,182],134:[2,182],135:[2,182],136:[2,182],137:[2,182],138:[2,182],139:[2,182]},{7:280,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:281,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{116:[2,160],117:[2,160]},{27:160,28:[1,72],44:161,58:162,59:163,76:[1,69],89:[1,112],90:[1,113],115:282},{1:[2,167],6:[2,167],25:[2,167],26:[2,167],49:[2,167],54:[2,167],57:[2,167],73:[2,167],78:[2,167],86:[2,167],91:[2,167],93:[2,167],102:[2,167],103:84,104:[2,167],105:[1,283],106:[2,167],109:85,110:[2,167],111:68,118:[1,284],126:[2,167],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,168],6:[2,168],25:[2,168],26:[2,168],49:[2,168],54:[2,168],57:[2,168],73:[2,168],78:[2,168],86:[2,168],91:[2,168],93:[2,168],102:[2,168],103:84,104:[2,168],105:[1,285],106:[2,168],109:85,110:[2,168],111:68,118:[2,168],126:[2,168],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{6:[1,287],25:[1,288],78:[1,286]},{6:[2,53],10:170,25:[2,53],26:[2,53],27:171,28:[1,72],29:172,30:[1,70],31:[1,71],41:289,42:169,44:173,46:[1,45],78:[2,53],89:[1,112]},{7:290,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,291],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,86],6:[2,86],25:[2,86],26:[2,86],40:[2,86],49:[2,86],54:[2,86],57:[2,86],66:[2,86],67:[2,86],68:[2,86],69:[2,86],71:[2,86],73:[2,86],74:[2,86],78:[2,86],80:[2,86],84:[2,86],85:[2,86],86:[2,86],91:[2,86],93:[2,86],102:[2,86],104:[2,86],105:[2,86],106:[2,86],110:[2,86],118:[2,86],126:[2,86],129:[2,86],130:[2,86],131:[2,86],132:[2,86],133:[2,86],134:[2,86],135:[2,86],136:[2,86],137:[2,86],138:[2,86],139:[2,86],140:[2,86]},{7:292,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,73:[2,121],76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{73:[2,122],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,36],6:[2,36],25:[2,36],26:[2,36],49:[2,36],54:[2,36],57:[2,36],73:[2,36],78:[2,36],86:[2,36],91:[2,36],93:[2,36],102:[2,36],103:84,104:[2,36],105:[2,36],106:[2,36],109:85,110:[2,36],111:68,118:[2,36],126:[2,36],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{26:[1,293],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{6:[1,276],25:[1,277],86:[1,294]},{6:[2,67],25:[2,67],26:[2,67],54:[2,67],86:[2,67],91:[2,67]},{24:295,25:[1,115]},{6:[2,56],25:[2,56],26:[2,56],49:[2,56],54:[2,56]},{27:108,28:[1,72],44:109,55:296,56:106,57:[1,107],58:110,59:111,76:[1,69],89:[1,112],90:[1,113]},{6:[2,54],25:[2,54],26:[2,54],27:108,28:[1,72],44:109,48:297,54:[2,54],55:105,56:106,57:[1,107],58:110,59:111,76:[1,69],89:[1,112],90:[1,113]},{6:[2,61],25:[2,61],26:[2,61],49:[2,61],54:[2,61],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,24],6:[2,24],25:[2,24],26:[2,24],49:[2,24],54:[2,24],57:[2,24],73:[2,24],78:[2,24],86:[2,24],91:[2,24],93:[2,24],98:[2,24],99:[2,24],102:[2,24],104:[2,24],105:[2,24],106:[2,24],110:[2,24],118:[2,24],121:[2,24],123:[2,24],126:[2,24],129:[2,24],130:[2,24],133:[2,24],134:[2,24],135:[2,24],136:[2,24],137:[2,24],138:[2,24],139:[2,24]},{26:[1,298],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,207],6:[2,207],25:[2,207],26:[2,207],49:[2,207],54:[2,207],57:[2,207],73:[2,207],78:[2,207],86:[2,207],91:[2,207],93:[2,207],102:[2,207],103:84,104:[2,207],105:[2,207],106:[2,207],109:85,110:[2,207],111:68,118:[2,207],126:[2,207],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{24:299,25:[1,115],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{24:300,25:[1,115]},{1:[2,136],6:[2,136],25:[2,136],26:[2,136],49:[2,136],54:[2,136],57:[2,136],73:[2,136],78:[2,136],86:[2,136],91:[2,136],93:[2,136],102:[2,136],104:[2,136],105:[2,136],106:[2,136],110:[2,136],118:[2,136],126:[2,136],129:[2,136],130:[2,136],133:[2,136],134:[2,136],135:[2,136],136:[2,136],137:[2,136],138:[2,136],139:[2,136]},{24:301,25:[1,115]},{24:302,25:[1,115]},{1:[2,140],6:[2,140],25:[2,140],26:[2,140],49:[2,140],54:[2,140],57:[2,140],73:[2,140],78:[2,140],86:[2,140],91:[2,140],93:[2,140],98:[2,140],102:[2,140],104:[2,140],105:[2,140],106:[2,140],110:[2,140],118:[2,140],126:[2,140],129:[2,140],130:[2,140],133:[2,140],134:[2,140],135:[2,140],136:[2,140],137:[2,140],138:[2,140],139:[2,140]},{26:[1,303],121:[1,304],122:268,123:[1,223]},{1:[2,176],6:[2,176],25:[2,176],26:[2,176],49:[2,176],54:[2,176],57:[2,176],73:[2,176],78:[2,176],86:[2,176],91:[2,176],93:[2,176],102:[2,176],104:[2,176],105:[2,176],106:[2,176],110:[2,176],118:[2,176],126:[2,176],129:[2,176],130:[2,176],133:[2,176],134:[2,176],135:[2,176],136:[2,176],137:[2,176],138:[2,176],139:[2,176]},{24:305,25:[1,115]},{26:[2,179],121:[2,179],123:[2,179]},{24:306,25:[1,115],54:[1,307]},{25:[2,132],54:[2,132],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,99],6:[2,99],25:[2,99],26:[2,99],49:[2,99],54:[2,99],57:[2,99],73:[2,99],78:[2,99],86:[2,99],91:[2,99],93:[2,99],102:[2,99],104:[2,99],105:[2,99],106:[2,99],110:[2,99],118:[2,99],126:[2,99],129:[2,99],130:[2,99],133:[2,99],134:[2,99],135:[2,99],136:[2,99],137:[2,99],138:[2,99],139:[2,99]},{1:[2,102],6:[2,102],24:308,25:[1,115],26:[2,102],49:[2,102],54:[2,102],57:[2,102],73:[2,102],78:[2,102],86:[2,102],91:[2,102],93:[2,102],102:[2,102],103:84,104:[1,64],105:[2,102],106:[1,65],109:85,110:[1,67],111:68,118:[2,102],126:[2,102],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{102:[1,309]},{91:[1,310],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,116],6:[2,116],25:[2,116],26:[2,116],40:[2,116],49:[2,116],54:[2,116],57:[2,116],66:[2,116],67:[2,116],68:[2,116],69:[2,116],71:[2,116],73:[2,116],74:[2,116],78:[2,116],84:[2,116],85:[2,116],86:[2,116],91:[2,116],93:[2,116],102:[2,116],104:[2,116],105:[2,116],106:[2,116],110:[2,116],116:[2,116],117:[2,116],118:[2,116],126:[2,116],129:[2,116],130:[2,116],133:[2,116],134:[2,116],135:[2,116],136:[2,116],137:[2,116],138:[2,116],139:[2,116]},{7:203,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,149],58:46,59:47,60:148,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],94:311,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:203,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:[1,147],27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],57:[1,149],58:46,59:47,60:148,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],87:312,88:[1,57],89:[1,58],90:[1,56],94:146,96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[2,125],25:[2,125],26:[2,125],54:[2,125],86:[2,125],91:[2,125]},{6:[1,276],25:[1,277],26:[1,313]},{1:[2,145],6:[2,145],25:[2,145],26:[2,145],49:[2,145],54:[2,145],57:[2,145],73:[2,145],78:[2,145],86:[2,145],91:[2,145],93:[2,145],102:[2,145],103:84,104:[1,64],105:[2,145],106:[1,65],109:85,110:[1,67],111:68,118:[2,145],126:[2,145],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,147],6:[2,147],25:[2,147],26:[2,147],49:[2,147],54:[2,147],57:[2,147],73:[2,147],78:[2,147],86:[2,147],91:[2,147],93:[2,147],102:[2,147],103:84,104:[1,64],105:[2,147],106:[1,65],109:85,110:[1,67],111:68,118:[2,147],126:[2,147],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{116:[2,166],117:[2,166]},{7:314,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:315,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:316,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,90],6:[2,90],25:[2,90],26:[2,90],40:[2,90],49:[2,90],54:[2,90],57:[2,90],66:[2,90],67:[2,90],68:[2,90],69:[2,90],71:[2,90],73:[2,90],74:[2,90],78:[2,90],84:[2,90],85:[2,90],86:[2,90],91:[2,90],93:[2,90],102:[2,90],104:[2,90],105:[2,90],106:[2,90],110:[2,90],116:[2,90],117:[2,90],118:[2,90],126:[2,90],129:[2,90],130:[2,90],133:[2,90],134:[2,90],135:[2,90],136:[2,90],137:[2,90],138:[2,90],139:[2,90]},{10:170,27:171,28:[1,72],29:172,30:[1,70],31:[1,71],41:317,42:169,44:173,46:[1,45],89:[1,112]},{6:[2,91],10:170,25:[2,91],26:[2,91],27:171,28:[1,72],29:172,30:[1,70],31:[1,71],41:168,42:169,44:173,46:[1,45],54:[2,91],77:318,89:[1,112]},{6:[2,93],25:[2,93],26:[2,93],54:[2,93],78:[2,93]},{6:[2,39],25:[2,39],26:[2,39],54:[2,39],78:[2,39],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{7:319,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{73:[2,120],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,37],6:[2,37],25:[2,37],26:[2,37],49:[2,37],54:[2,37],57:[2,37],73:[2,37],78:[2,37],86:[2,37],91:[2,37],93:[2,37],102:[2,37],104:[2,37],105:[2,37],106:[2,37],110:[2,37],118:[2,37],126:[2,37],129:[2,37],130:[2,37],133:[2,37],134:[2,37],135:[2,37],136:[2,37],137:[2,37],138:[2,37],139:[2,37]},{1:[2,111],6:[2,111],25:[2,111],26:[2,111],49:[2,111],54:[2,111],57:[2,111],66:[2,111],67:[2,111],68:[2,111],69:[2,111],71:[2,111],73:[2,111],74:[2,111],78:[2,111],84:[2,111],85:[2,111],86:[2,111],91:[2,111],93:[2,111],102:[2,111],104:[2,111],105:[2,111],106:[2,111],110:[2,111],118:[2,111],126:[2,111],129:[2,111],130:[2,111],133:[2,111],134:[2,111],135:[2,111],136:[2,111],137:[2,111],138:[2,111],139:[2,111]},{1:[2,48],6:[2,48],25:[2,48],26:[2,48],49:[2,48],54:[2,48],57:[2,48],73:[2,48],78:[2,48],86:[2,48],91:[2,48],93:[2,48],102:[2,48],104:[2,48],105:[2,48],106:[2,48],110:[2,48],118:[2,48],126:[2,48],129:[2,48],130:[2,48],133:[2,48],134:[2,48],135:[2,48],136:[2,48],137:[2,48],138:[2,48],139:[2,48]},{6:[2,57],25:[2,57],26:[2,57],49:[2,57],54:[2,57]},{6:[2,52],25:[2,52],26:[2,52],53:320,54:[1,205]},{1:[2,206],6:[2,206],25:[2,206],26:[2,206],49:[2,206],54:[2,206],57:[2,206],73:[2,206],78:[2,206],86:[2,206],91:[2,206],93:[2,206],102:[2,206],104:[2,206],105:[2,206],106:[2,206],110:[2,206],118:[2,206],126:[2,206],129:[2,206],130:[2,206],133:[2,206],134:[2,206],135:[2,206],136:[2,206],137:[2,206],138:[2,206],139:[2,206]},{1:[2,183],6:[2,183],25:[2,183],26:[2,183],49:[2,183],54:[2,183],57:[2,183],73:[2,183],78:[2,183],86:[2,183],91:[2,183],93:[2,183],102:[2,183],104:[2,183],105:[2,183],106:[2,183],110:[2,183],118:[2,183],121:[2,183],126:[2,183],129:[2,183],130:[2,183],133:[2,183],134:[2,183],135:[2,183],136:[2,183],137:[2,183],138:[2,183],139:[2,183]},{1:[2,137],6:[2,137],25:[2,137],26:[2,137],49:[2,137],54:[2,137],57:[2,137],73:[2,137],78:[2,137],86:[2,137],91:[2,137],93:[2,137],102:[2,137],104:[2,137],105:[2,137],106:[2,137],110:[2,137],118:[2,137],126:[2,137],129:[2,137],130:[2,137],133:[2,137],134:[2,137],135:[2,137],136:[2,137],137:[2,137],138:[2,137],139:[2,137]},{1:[2,138],6:[2,138],25:[2,138],26:[2,138],49:[2,138],54:[2,138],57:[2,138],73:[2,138],78:[2,138],86:[2,138],91:[2,138],93:[2,138],98:[2,138],102:[2,138],104:[2,138],105:[2,138],106:[2,138],110:[2,138],118:[2,138],126:[2,138],129:[2,138],130:[2,138],133:[2,138],134:[2,138],135:[2,138],136:[2,138],137:[2,138],138:[2,138],139:[2,138]},{1:[2,139],6:[2,139],25:[2,139],26:[2,139],49:[2,139],54:[2,139],57:[2,139],73:[2,139],78:[2,139],86:[2,139],91:[2,139],93:[2,139],98:[2,139],102:[2,139],104:[2,139],105:[2,139],106:[2,139],110:[2,139],118:[2,139],126:[2,139],129:[2,139],130:[2,139],133:[2,139],134:[2,139],135:[2,139],136:[2,139],137:[2,139],138:[2,139],139:[2,139]},{1:[2,174],6:[2,174],25:[2,174],26:[2,174],49:[2,174],54:[2,174],57:[2,174],73:[2,174],78:[2,174],86:[2,174],91:[2,174],93:[2,174],102:[2,174],104:[2,174],105:[2,174],106:[2,174],110:[2,174],118:[2,174],126:[2,174],129:[2,174],130:[2,174],133:[2,174],134:[2,174],135:[2,174],136:[2,174],137:[2,174],138:[2,174],139:[2,174]},{24:321,25:[1,115]},{26:[1,322]},{6:[1,323],26:[2,180],121:[2,180],123:[2,180]},{7:324,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{1:[2,103],6:[2,103],25:[2,103],26:[2,103],49:[2,103],54:[2,103],57:[2,103],73:[2,103],78:[2,103],86:[2,103],91:[2,103],93:[2,103],102:[2,103],104:[2,103],105:[2,103],106:[2,103],110:[2,103],118:[2,103],126:[2,103],129:[2,103],130:[2,103],133:[2,103],134:[2,103],135:[2,103],136:[2,103],137:[2,103],138:[2,103],139:[2,103]},{1:[2,143],6:[2,143],25:[2,143],26:[2,143],49:[2,143],54:[2,143],57:[2,143],66:[2,143],67:[2,143],68:[2,143],69:[2,143],71:[2,143],73:[2,143],74:[2,143],78:[2,143],84:[2,143],85:[2,143],86:[2,143],91:[2,143],93:[2,143],102:[2,143],104:[2,143],105:[2,143],106:[2,143],110:[2,143],118:[2,143],126:[2,143],129:[2,143],130:[2,143],133:[2,143],134:[2,143],135:[2,143],136:[2,143],137:[2,143],138:[2,143],139:[2,143]},{1:[2,119],6:[2,119],25:[2,119],26:[2,119],49:[2,119],54:[2,119],57:[2,119],66:[2,119],67:[2,119],68:[2,119],69:[2,119],71:[2,119],73:[2,119],74:[2,119],78:[2,119],84:[2,119],85:[2,119],86:[2,119],91:[2,119],93:[2,119],102:[2,119],104:[2,119],105:[2,119],106:[2,119],110:[2,119],118:[2,119],126:[2,119],129:[2,119],130:[2,119],133:[2,119],134:[2,119],135:[2,119],136:[2,119],137:[2,119],138:[2,119],139:[2,119]},{6:[2,126],25:[2,126],26:[2,126],54:[2,126],86:[2,126],91:[2,126]},{6:[2,52],25:[2,52],26:[2,52],53:325,54:[1,232]},{6:[2,127],25:[2,127],26:[2,127],54:[2,127],86:[2,127],91:[2,127]},{1:[2,169],6:[2,169],25:[2,169],26:[2,169],49:[2,169],54:[2,169],57:[2,169],73:[2,169],78:[2,169],86:[2,169],91:[2,169],93:[2,169],102:[2,169],103:84,104:[2,169],105:[2,169],106:[2,169],109:85,110:[2,169],111:68,118:[1,326],126:[2,169],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,171],6:[2,171],25:[2,171],26:[2,171],49:[2,171],54:[2,171],57:[2,171],73:[2,171],78:[2,171],86:[2,171],91:[2,171],93:[2,171],102:[2,171],103:84,104:[2,171],105:[1,327],106:[2,171],109:85,110:[2,171],111:68,118:[2,171],126:[2,171],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,170],6:[2,170],25:[2,170],26:[2,170],49:[2,170],54:[2,170],57:[2,170],73:[2,170],78:[2,170],86:[2,170],91:[2,170],93:[2,170],102:[2,170],103:84,104:[2,170],105:[2,170],106:[2,170],109:85,110:[2,170],111:68,118:[2,170],126:[2,170],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{6:[2,94],25:[2,94],26:[2,94],54:[2,94],78:[2,94]},{6:[2,52],25:[2,52],26:[2,52],53:328,54:[1,242]},{26:[1,329],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{6:[1,253],25:[1,254],26:[1,330]},{26:[1,331]},{1:[2,177],6:[2,177],25:[2,177],26:[2,177],49:[2,177],54:[2,177],57:[2,177],73:[2,177],78:[2,177],86:[2,177],91:[2,177],93:[2,177],102:[2,177],104:[2,177],105:[2,177],106:[2,177],110:[2,177],118:[2,177],126:[2,177],129:[2,177],130:[2,177],133:[2,177],134:[2,177],135:[2,177],136:[2,177],137:[2,177],138:[2,177],139:[2,177]},{26:[2,181],121:[2,181],123:[2,181]},{25:[2,133],54:[2,133],103:84,104:[1,64],106:[1,65],109:85,110:[1,67],111:68,126:[1,83],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{6:[1,276],25:[1,277],26:[1,332]},{7:333,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{7:334,8:117,9:18,10:19,11:[1,20],12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:61,28:[1,72],29:48,30:[1,70],31:[1,71],32:22,33:[1,49],34:[1,50],35:[1,51],36:[1,52],37:[1,53],38:[1,54],39:21,44:62,45:[1,44],46:[1,45],47:[1,27],50:28,51:[1,59],52:[1,60],58:46,59:47,61:35,63:23,64:24,65:25,76:[1,69],79:[1,42],83:[1,26],88:[1,57],89:[1,58],90:[1,56],96:[1,37],100:[1,43],101:[1,55],103:38,104:[1,64],106:[1,65],107:39,108:[1,66],109:40,110:[1,67],111:68,119:[1,41],124:36,125:[1,63],127:[1,29],128:[1,30],129:[1,31],130:[1,32],131:[1,33],132:[1,34]},{6:[1,287],25:[1,288],26:[1,335]},{6:[2,40],25:[2,40],26:[2,40],54:[2,40],78:[2,40]},{6:[2,58],25:[2,58],26:[2,58],49:[2,58],54:[2,58]},{1:[2,175],6:[2,175],25:[2,175],26:[2,175],49:[2,175],54:[2,175],57:[2,175],73:[2,175],78:[2,175],86:[2,175],91:[2,175],93:[2,175],102:[2,175],104:[2,175],105:[2,175],106:[2,175],110:[2,175],118:[2,175],126:[2,175],129:[2,175],130:[2,175],133:[2,175],134:[2,175],135:[2,175],136:[2,175],137:[2,175],138:[2,175],139:[2,175]},{6:[2,128],25:[2,128],26:[2,128],54:[2,128],86:[2,128],91:[2,128]},{1:[2,172],6:[2,172],25:[2,172],26:[2,172],49:[2,172],54:[2,172],57:[2,172],73:[2,172],78:[2,172],86:[2,172],91:[2,172],93:[2,172],102:[2,172],103:84,104:[2,172],105:[2,172],106:[2,172],109:85,110:[2,172],111:68,118:[2,172],126:[2,172],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{1:[2,173],6:[2,173],25:[2,173],26:[2,173],49:[2,173],54:[2,173],57:[2,173],73:[2,173],78:[2,173],86:[2,173],91:[2,173],93:[2,173],102:[2,173],103:84,104:[2,173],105:[2,173],106:[2,173],109:85,110:[2,173],111:68,118:[2,173],126:[2,173],129:[1,76],130:[1,75],133:[1,74],134:[1,77],135:[1,78],136:[1,79],137:[1,80],138:[1,81],139:[1,82]},{6:[2,95],25:[2,95],26:[2,95],54:[2,95],78:[2,95]}],defaultActions:{59:[2,50],60:[2,51],91:[2,109],192:[2,89]},parseError:function(e,t){if(!t.recoverable)throw Error(e);
this.trace(e)},parse:function(e){function t(){var e;return e=n.lexer.lex()||p,"number"!=typeof e&&(e=n.symbols_[e]||e),e}var n=this,i=[0],r=[null],s=[],o=this.table,a="",c=0,h=0,l=0,u=2,p=1,d=s.slice.call(arguments,1);this.lexer.setInput(e),this.lexer.yy=this.yy,this.yy.lexer=this.lexer,this.yy.parser=this,this.lexer.yylloc===void 0&&(this.lexer.yylloc={});var f=this.lexer.yylloc;s.push(f);var m=this.lexer.options&&this.lexer.options.ranges;this.parseError="function"==typeof this.yy.parseError?this.yy.parseError:Object.getPrototypeOf(this).parseError;for(var b,g,k,y,v,w,T,F,L,C={};;){if(k=i[i.length-1],this.defaultActions[k]?y=this.defaultActions[k]:((null===b||b===void 0)&&(b=t()),y=o[k]&&o[k][b]),y===void 0||!y.length||!y[0]){var N="";L=[];for(w in o[k])this.terminals_[w]&&w>u&&L.push("'"+this.terminals_[w]+"'");N=this.lexer.showPosition?"Parse error on line "+(c+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+L.join(", ")+", got '"+(this.terminals_[b]||b)+"'":"Parse error on line "+(c+1)+": Unexpected "+(b==p?"end of input":"'"+(this.terminals_[b]||b)+"'"),this.parseError(N,{text:this.lexer.match,token:this.terminals_[b]||b,line:this.lexer.yylineno,loc:f,expected:L})}if(y[0]instanceof Array&&y.length>1)throw Error("Parse Error: multiple actions possible at state: "+k+", token: "+b);switch(y[0]){case 1:i.push(b),r.push(this.lexer.yytext),s.push(this.lexer.yylloc),i.push(y[1]),b=null,g?(b=g,g=null):(h=this.lexer.yyleng,a=this.lexer.yytext,c=this.lexer.yylineno,f=this.lexer.yylloc,l>0&&l--);break;case 2:if(T=this.productions_[y[1]][1],C.$=r[r.length-T],C._$={first_line:s[s.length-(T||1)].first_line,last_line:s[s.length-1].last_line,first_column:s[s.length-(T||1)].first_column,last_column:s[s.length-1].last_column},m&&(C._$.range=[s[s.length-(T||1)].range[0],s[s.length-1].range[1]]),v=this.performAction.apply(C,[a,h,c,this.yy,y[1],r,s].concat(d)),v!==void 0)return v;T&&(i=i.slice(0,2*-1*T),r=r.slice(0,-1*T),s=s.slice(0,-1*T)),i.push(this.productions_[y[1]][0]),r.push(C.$),s.push(C._$),F=o[i[i.length-2]][i[i.length-1]],i.push(F);break;case 3:return!0}}return!0}};return e.prototype=t,t.Parser=e,new e}();return require!==void 0&&e!==void 0&&(e.parser=n,e.Parser=n.Parser,e.parse=function(){return n.parse.apply(n,arguments)},e.main=function(t){t[1]||(console.log("Usage: "+t[0]+" FILE"),process.exit(1));var n=require("fs").readFileSync(require("path").normalize(t[1]),"utf8");return e.parser.parse(n)},t!==void 0&&require.main===t&&e.main(process.argv.slice(1))),t.exports}(),require["./scope"]=function(){var e={},t={exports:e};return function(){var t,n,i,r;r=require("./helpers"),n=r.extend,i=r.last,e.Scope=t=function(){function e(t,n,i){this.parent=t,this.expressions=n,this.method=i,this.variables=[{name:"arguments",type:"arguments"}],this.positions={},this.parent||(e.root=this)}return e.root=null,e.prototype.add=function(e,t,n){return this.shared&&!n?this.parent.add(e,t,n):Object.prototype.hasOwnProperty.call(this.positions,e)?this.variables[this.positions[e]].type=t:this.positions[e]=this.variables.push({name:e,type:t})-1},e.prototype.namedMethod=function(){var e;return(null!=(e=this.method)?e.name:void 0)||!this.parent?this.method:this.parent.namedMethod()},e.prototype.find=function(e){return this.check(e)?!0:(this.add(e,"var"),!1)},e.prototype.parameter=function(e){return this.shared&&this.parent.check(e,!0)?void 0:this.add(e,"param")},e.prototype.check=function(e){var t;return!!(this.type(e)||(null!=(t=this.parent)?t.check(e):void 0))},e.prototype.temporary=function(e,t){return e.length>1?"_"+e+(t>1?t-1:""):"_"+(t+parseInt(e,36)).toString(36).replace(/\d/g,"a")},e.prototype.type=function(e){var t,n,i,r;for(r=this.variables,n=0,i=r.length;i>n;n++)if(t=r[n],t.name===e)return t.type;return null},e.prototype.freeVariable=function(e,t){var n,i;for(null==t&&(t=!0),n=0;this.check(i=this.temporary(e,n));)n++;return t&&this.add(i,"var",!0),i},e.prototype.assign=function(e,t){return this.add(e,{value:t,assigned:!0},!0),this.hasAssignments=!0},e.prototype.hasDeclarations=function(){return!!this.declaredVariables().length},e.prototype.declaredVariables=function(){var e,t,n,i,r,s;for(e=[],t=[],s=this.variables,i=0,r=s.length;r>i;i++)n=s[i],"var"===n.type&&("_"===n.name.charAt(0)?t:e).push(n.name);return e.sort().concat(t.sort())},e.prototype.assignedVariables=function(){var e,t,n,i,r;for(i=this.variables,r=[],t=0,n=i.length;n>t;t++)e=i[t],e.type.assigned&&r.push(""+e.name+" = "+e.type.value);return r},e}()}.call(this),t.exports}(),require["./nodes"]=function(){var e={},t={exports:e};return function(){var t,n,i,r,s,o,a,c,h,l,u,p,d,f,m,b,g,k,y,v,w,T,F,L,C,N,E,x,D,S,R,A,I,_,$,O,j,M,B,V,P,U,H,q,G,W,X,Y,z,K,J,Z,Q,et,tt,nt,it,rt,st,ot,at,ct,ht,lt,ut,pt,dt,ft,mt,bt,gt,kt,yt,vt,wt,Tt={}.hasOwnProperty,Ft=function(e,t){function n(){this.constructor=e}for(var i in t)Tt.call(t,i)&&(e[i]=t[i]);return n.prototype=t.prototype,e.prototype=new n,e.__super__=t.prototype,e},Lt=[].indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(t in this&&this[t]===e)return t;return-1},Ct=[].slice;Error.stackTraceLimit=1/0,H=require("./scope").Scope,vt=require("./lexer"),M=vt.RESERVED,U=vt.STRICT_PROSCRIBED,wt=require("./helpers"),nt=wt.compact,ot=wt.flatten,st=wt.extend,pt=wt.merge,it=wt.del,bt=wt.starts,rt=wt.ends,lt=wt.last,mt=wt.some,tt=wt.addLocationDataFn,ut=wt.locationDataToString,gt=wt.throwSyntaxError,e.extend=st,e.addLocationDataFn=tt,et=function(){return!0},A=function(){return!1},Y=function(){return this},R=function(){return this.negated=!this.negated,this},e.CodeFragment=h=function(){function e(e,t){var n;this.code=""+t,this.locationData=null!=e?e.locationData:void 0,this.type=(null!=e?null!=(n=e.constructor)?n.name:void 0:void 0)||"unknown"}return e.prototype.toString=function(){return""+this.code+(this.locationData?": "+ut(this.locationData):"")},e}(),at=function(e){var t;return function(){var n,i,r;for(r=[],n=0,i=e.length;i>n;n++)t=e[n],r.push(t.code);return r}().join("")},e.Base=r=function(){function e(){}return e.prototype.compile=function(e,t){return at(this.compileToFragments(e,t))},e.prototype.compileToFragments=function(e,t){var n;return e=st({},e),t&&(e.level=t),n=this.unfoldSoak(e)||this,n.tab=e.indent,e.level!==x&&n.isStatement(e)?n.compileClosure(e):n.compileNode(e)},e.prototype.compileClosure=function(e){var n,i,r,a,h;return(a=this.jumps())&&a.error("cannot use a pure statement in an expression"),e.sharedScope=!0,r=new c([],s.wrap([this])),n=[],((i=this.contains(ct))||this.contains(ht))&&(n=[new D("this")],i?(h="apply",n.push(new D("arguments"))):h="call",r=new Z(r,[new t(new D(h))])),new o(r,n).compileNode(e)},e.prototype.cache=function(e,t,n){var r,s;return this.isComplex()?(r=new D(n||e.scope.freeVariable("ref")),s=new i(r,this),t?[s.compileToFragments(e,t),[this.makeCode(r.value)]]:[s,r]):(r=t?this.compileToFragments(e,t):this,[r,r])},e.prototype.cacheToCodeFragments=function(e){return[at(e[0]),at(e[1])]},e.prototype.makeReturn=function(e){var t;return t=this.unwrapAll(),e?new o(new D(""+e+".push"),[t]):new V(t)},e.prototype.contains=function(e){var t;return t=void 0,this.traverseChildren(!1,function(n){return e(n)?(t=n,!1):void 0}),t},e.prototype.lastNonComment=function(e){var t;for(t=e.length;t--;)if(!(e[t]instanceof l))return e[t];return null},e.prototype.toString=function(e,t){var n;return null==e&&(e=""),null==t&&(t=this.constructor.name),n="\n"+e+t,this.soak&&(n+="?"),this.eachChild(function(t){return n+=t.toString(e+X)}),n},e.prototype.eachChild=function(e){var t,n,i,r,s,o,a,c;if(!this.children)return this;for(a=this.children,i=0,s=a.length;s>i;i++)if(t=a[i],this[t])for(c=ot([this[t]]),r=0,o=c.length;o>r;r++)if(n=c[r],e(n)===!1)return this;return this},e.prototype.traverseChildren=function(e,t){return this.eachChild(function(n){var i;return i=t(n),i!==!1?n.traverseChildren(e,t):void 0})},e.prototype.invert=function(){return new $("!",this)},e.prototype.unwrapAll=function(){var e;for(e=this;e!==(e=e.unwrap()););return e},e.prototype.children=[],e.prototype.isStatement=A,e.prototype.jumps=A,e.prototype.isComplex=et,e.prototype.isChainable=A,e.prototype.isAssignable=A,e.prototype.unwrap=Y,e.prototype.unfoldSoak=A,e.prototype.assigns=A,e.prototype.updateLocationDataIfMissing=function(e){return this.locationData?this:(this.locationData=e,this.eachChild(function(t){return t.updateLocationDataIfMissing(e)}))},e.prototype.error=function(e){return gt(e,this.locationData)},e.prototype.makeCode=function(e){return new h(this,e)},e.prototype.wrapInBraces=function(e){return[].concat(this.makeCode("("),e,this.makeCode(")"))},e.prototype.joinFragmentArrays=function(e,t){var n,i,r,s,o;for(n=[],r=s=0,o=e.length;o>s;r=++s)i=e[r],r&&n.push(this.makeCode(t)),n=n.concat(i);return n},e}(),e.Block=s=function(e){function t(e){this.expressions=nt(ot(e||[]))}return Ft(t,e),t.prototype.children=["expressions"],t.prototype.push=function(e){return this.expressions.push(e),this},t.prototype.pop=function(){return this.expressions.pop()},t.prototype.unshift=function(e){return this.expressions.unshift(e),this},t.prototype.unwrap=function(){return 1===this.expressions.length?this.expressions[0]:this},t.prototype.isEmpty=function(){return!this.expressions.length},t.prototype.isStatement=function(e){var t,n,i,r;for(r=this.expressions,n=0,i=r.length;i>n;n++)if(t=r[n],t.isStatement(e))return!0;return!1},t.prototype.jumps=function(e){var t,n,i,r,s;for(s=this.expressions,i=0,r=s.length;r>i;i++)if(t=s[i],n=t.jumps(e))return n},t.prototype.makeReturn=function(e){var t,n;for(n=this.expressions.length;n--;)if(t=this.expressions[n],!(t instanceof l)){this.expressions[n]=t.makeReturn(e),t instanceof V&&!t.expression&&this.expressions.splice(n,1);break}return this},t.prototype.compileToFragments=function(e,n){return null==e&&(e={}),e.scope?t.__super__.compileToFragments.call(this,e,n):this.compileRoot(e)},t.prototype.compileNode=function(e){var n,i,r,s,o,a,c,h,l;for(this.tab=e.indent,a=e.level===x,i=[],l=this.expressions,s=c=0,h=l.length;h>c;s=++c)o=l[s],o=o.unwrapAll(),o=o.unfoldSoak(e)||o,o instanceof t?i.push(o.compileNode(e)):a?(o.front=!0,r=o.compileToFragments(e),o.isStatement(e)||(r.unshift(this.makeCode(""+this.tab)),r.push(this.makeCode(";"))),i.push(r)):i.push(o.compileToFragments(e,C));return a?this.spaced?[].concat(this.joinFragmentArrays(i,"\n\n"),this.makeCode("\n")):this.joinFragmentArrays(i,"\n"):(n=i.length?this.joinFragmentArrays(i,", "):[this.makeCode("void 0")],i.length>1&&e.level>=C?this.wrapInBraces(n):n)},t.prototype.compileRoot=function(e){var t,n,i,r,s,o,a,c,h,u;for(e.indent=e.bare?"":X,e.level=x,this.spaced=!0,e.scope=new H(null,this,null),u=e.locals||[],c=0,h=u.length;h>c;c++)r=u[c],e.scope.parameter(r);return s=[],e.bare||(o=function(){var e,n,r,s;for(r=this.expressions,s=[],i=e=0,n=r.length;n>e&&(t=r[i],t.unwrap()instanceof l);i=++e)s.push(t);return s}.call(this),a=this.expressions.slice(o.length),this.expressions=o,o.length&&(s=this.compileNode(pt(e,{indent:""})),s.push(this.makeCode("\n"))),this.expressions=a),n=this.compileWithDeclarations(e),e.bare?n:[].concat(s,this.makeCode("(function() {\n"),n,this.makeCode("\n}).call(this);\n"))},t.prototype.compileWithDeclarations=function(e){var t,n,i,r,s,o,a,c,h,u,p,d,f,m;for(r=[],o=[],d=this.expressions,s=u=0,p=d.length;p>u&&(i=d[s],i=i.unwrap(),i instanceof l||i instanceof D);s=++u);return e=pt(e,{level:x}),s&&(a=this.expressions.splice(s,9e9),f=[this.spaced,!1],h=f[0],this.spaced=f[1],m=[this.compileNode(e),h],r=m[0],this.spaced=m[1],this.expressions=a),o=this.compileNode(e),c=e.scope,c.expressions===this&&(n=e.scope.hasDeclarations(),t=c.hasAssignments,n||t?(s&&r.push(this.makeCode("\n")),r.push(this.makeCode(""+this.tab+"var ")),n&&r.push(this.makeCode(c.declaredVariables().join(", "))),t&&(n&&r.push(this.makeCode(",\n"+(this.tab+X))),r.push(this.makeCode(c.assignedVariables().join(",\n"+(this.tab+X))))),r.push(this.makeCode(";\n"+(this.spaced?"\n":"")))):r.length&&o.length&&r.push(this.makeCode("\n"))),r.concat(o)},t.wrap=function(e){return 1===e.length&&e[0]instanceof t?e[0]:new t(e)},t}(r),e.Literal=D=function(e){function t(e){this.value=e}return Ft(t,e),t.prototype.makeReturn=function(){return this.isStatement()?this:t.__super__.makeReturn.apply(this,arguments)},t.prototype.isAssignable=function(){return b.test(this.value)},t.prototype.isStatement=function(){var e;return"break"===(e=this.value)||"continue"===e||"debugger"===e},t.prototype.isComplex=A,t.prototype.assigns=function(e){return e===this.value},t.prototype.jumps=function(e){return"break"!==this.value||(null!=e?e.loop:void 0)||(null!=e?e.block:void 0)?"continue"!==this.value||(null!=e?e.loop:void 0)?void 0:this:this},t.prototype.compileNode=function(e){var t,n,i;return n="this"===this.value?(null!=(i=e.scope.method)?i.bound:void 0)?e.scope.method.context:this.value:this.value.reserved?'"'+this.value+'"':this.value,t=this.isStatement()?""+this.tab+n+";":n,[this.makeCode(t)]},t.prototype.toString=function(){return' "'+this.value+'"'},t}(r),e.Undefined=function(e){function t(){return t.__super__.constructor.apply(this,arguments)}return Ft(t,e),t.prototype.isAssignable=A,t.prototype.isComplex=A,t.prototype.compileNode=function(e){return[this.makeCode(e.level>=F?"(void 0)":"void 0")]},t}(r),e.Null=function(e){function t(){return t.__super__.constructor.apply(this,arguments)}return Ft(t,e),t.prototype.isAssignable=A,t.prototype.isComplex=A,t.prototype.compileNode=function(){return[this.makeCode("null")]},t}(r),e.Bool=function(e){function t(e){this.val=e}return Ft(t,e),t.prototype.isAssignable=A,t.prototype.isComplex=A,t.prototype.compileNode=function(){return[this.makeCode(this.val)]},t}(r),e.Return=V=function(e){function t(e){e&&!e.unwrap().isUndefined&&(this.expression=e)}return Ft(t,e),t.prototype.children=["expression"],t.prototype.isStatement=et,t.prototype.makeReturn=Y,t.prototype.jumps=Y,t.prototype.compileToFragments=function(e,n){var i,r;return i=null!=(r=this.expression)?r.makeReturn():void 0,!i||i instanceof t?t.__super__.compileToFragments.call(this,e,n):i.compileToFragments(e,n)},t.prototype.compileNode=function(e){var t;return t=[],t.push(this.makeCode(this.tab+("return"+(this.expression?" ":"")))),this.expression&&(t=t.concat(this.expression.compileToFragments(e,E))),t.push(this.makeCode(";")),t},t}(r),e.Value=Z=function(e){function t(e,n,i){return!n&&e instanceof t?e:(this.base=e,this.properties=n||[],i&&(this[i]=!0),this)}return Ft(t,e),t.prototype.children=["base","properties"],t.prototype.add=function(e){return this.properties=this.properties.concat(e),this},t.prototype.hasProperties=function(){return!!this.properties.length},t.prototype.bareLiteral=function(e){return!this.properties.length&&this.base instanceof e},t.prototype.isArray=function(){return this.bareLiteral(n)},t.prototype.isRange=function(){return this.bareLiteral(B)},t.prototype.isComplex=function(){return this.hasProperties()||this.base.isComplex()},t.prototype.isAssignable=function(){return this.hasProperties()||this.base.isAssignable()},t.prototype.isSimpleNumber=function(){return this.bareLiteral(D)&&P.test(this.base.value)},t.prototype.isString=function(){return this.bareLiteral(D)&&y.test(this.base.value)},t.prototype.isRegex=function(){return this.bareLiteral(D)&&k.test(this.base.value)},t.prototype.isAtomic=function(){var e,t,n,i;for(i=this.properties.concat(this.base),t=0,n=i.length;n>t;t++)if(e=i[t],e.soak||e instanceof o)return!1;return!0},t.prototype.isNotCallable=function(){return this.isSimpleNumber()||this.isString()||this.isRegex()||this.isArray()||this.isRange()||this.isSplice()||this.isObject()},t.prototype.isStatement=function(e){return!this.properties.length&&this.base.isStatement(e)},t.prototype.assigns=function(e){return!this.properties.length&&this.base.assigns(e)},t.prototype.jumps=function(e){return!this.properties.length&&this.base.jumps(e)},t.prototype.isObject=function(e){return this.properties.length?!1:this.base instanceof _&&(!e||this.base.generated)},t.prototype.isSplice=function(){return lt(this.properties)instanceof q},t.prototype.looksStatic=function(e){var t;return this.base.value===e&&this.properties.length&&"prototype"!==(null!=(t=this.properties[0].name)?t.value:void 0)},t.prototype.unwrap=function(){return this.properties.length?this:this.base},t.prototype.cacheReference=function(e){var n,r,s,o;return s=lt(this.properties),2>this.properties.length&&!this.base.isComplex()&&!(null!=s?s.isComplex():void 0)?[this,this]:(n=new t(this.base,this.properties.slice(0,-1)),n.isComplex()&&(r=new D(e.scope.freeVariable("base")),n=new t(new j(new i(r,n)))),s?(s.isComplex()&&(o=new D(e.scope.freeVariable("name")),s=new T(new i(o,s.index)),o=new T(o)),[n.add(s),new t(r||n.base,[o||s])]):[n,r])},t.prototype.compileNode=function(e){var t,n,i,r,s;for(this.base.front=this.front,i=this.properties,t=this.base.compileToFragments(e,i.length?F:null),(this.base instanceof j||i.length)&&P.test(at(t))&&t.push(this.makeCode(".")),r=0,s=i.length;s>r;r++)n=i[r],t.push.apply(t,n.compileToFragments(e));return t},t.prototype.unfoldSoak=function(e){return null!=this.unfoldedSoak?this.unfoldedSoak:this.unfoldedSoak=function(n){return function(){var r,s,o,a,c,h,l,p,d,f;if(o=n.base.unfoldSoak(e))return(d=o.body.properties).push.apply(d,n.properties),o;for(f=n.properties,s=l=0,p=f.length;p>l;s=++l)if(a=f[s],a.soak)return a.soak=!1,r=new t(n.base,n.properties.slice(0,s)),h=new t(n.base,n.properties.slice(s)),r.isComplex()&&(c=new D(e.scope.freeVariable("ref")),r=new j(new i(c,r)),h.base=c),new v(new u(r),h,{soak:!0});return!1}}(this)()},t}(r),e.Comment=l=function(e){function t(e){this.comment=e}return Ft(t,e),t.prototype.isStatement=et,t.prototype.makeReturn=Y,t.prototype.compileNode=function(e,t){var n,i;return i=this.comment.replace(/^(\s*)#/gm,"$1 *"),n="/*"+dt(i,this.tab)+(Lt.call(i,"\n")>=0?"\n"+this.tab:"")+" */",(t||e.level)===x&&(n=e.indent+n),[this.makeCode("\n"),this.makeCode(n)]},t}(r),e.Call=o=function(e){function n(e,t,n){this.args=null!=t?t:[],this.soak=n,this.isNew=!1,this.isSuper="super"===e,this.variable=this.isSuper?null:e,e instanceof Z&&e.isNotCallable()&&e.error("literal is not a function")}return Ft(n,e),n.prototype.children=["variable","args"],n.prototype.newInstance=function(){var e,t;return e=(null!=(t=this.variable)?t.base:void 0)||this.variable,e instanceof n&&!e.isNew?e.newInstance():this.isNew=!0,this},n.prototype.superReference=function(e){var n,i;return i=e.scope.namedMethod(),(null!=i?i.klass:void 0)?(n=[new t(new D("__super__"))],i["static"]&&n.push(new t(new D("constructor"))),n.push(new t(new D(i.name))),new Z(new D(i.klass),n).compile(e)):(null!=i?i.ctor:void 0)?""+i.name+".__super__.constructor":this.error("cannot call super outside of an instance method.")},n.prototype.superThis=function(e){var t;return t=e.scope.method,t&&!t.klass&&t.context||"this"},n.prototype.unfoldSoak=function(e){var t,i,r,s,o,a,c,h,l;if(this.soak){if(this.variable){if(i=kt(e,this,"variable"))return i;h=new Z(this.variable).cacheReference(e),r=h[0],o=h[1]}else r=new D(this.superReference(e)),o=new Z(r);return o=new n(o,this.args),o.isNew=this.isNew,r=new D("typeof "+r.compile(e)+' === "function"'),new v(r,new Z(o),{soak:!0})}for(t=this,s=[];;)if(t.variable instanceof n)s.push(t),t=t.variable;else{if(!(t.variable instanceof Z))break;if(s.push(t),!((t=t.variable.base)instanceof n))break}for(l=s.reverse(),a=0,c=l.length;c>a;a++)t=l[a],i&&(t.variable instanceof n?t.variable=i:t.variable.base=i),i=kt(e,t,"variable");return i},n.prototype.compileNode=function(e){var t,n,i,r,s,o,a,c,h,l;if(null!=(h=this.variable)&&(h.front=this.front),r=G.compileSplattedArray(e,this.args,!0),r.length)return this.compileSplat(e,r);for(i=[],l=this.args,n=a=0,c=l.length;c>a;n=++a)t=l[n],n&&i.push(this.makeCode(", ")),i.push.apply(i,t.compileToFragments(e,C));return s=[],this.isSuper?(o=this.superReference(e)+(".call("+this.superThis(e)),i.length&&(o+=", "),s.push(this.makeCode(o))):(this.isNew&&s.push(this.makeCode("new ")),s.push.apply(s,this.variable.compileToFragments(e,F)),s.push(this.makeCode("("))),s.push.apply(s,i),s.push(this.makeCode(")")),s},n.prototype.compileSplat=function(e,t){var n,i,r,s,o,a;return this.isSuper?[].concat(this.makeCode(""+this.superReference(e)+".apply("+this.superThis(e)+", "),t,this.makeCode(")")):this.isNew?(s=this.tab+X,[].concat(this.makeCode("(function(func, args, ctor) {\n"+s+"ctor.prototype = func.prototype;\n"+s+"var child = new ctor, result = func.apply(child, args);\n"+s+"return Object(result) === result ? result : child;\n"+this.tab+"})("),this.variable.compileToFragments(e,C),this.makeCode(", "),t,this.makeCode(", function(){})"))):(n=[],i=new Z(this.variable),(o=i.properties.pop())&&i.isComplex()?(a=e.scope.freeVariable("ref"),n=n.concat(this.makeCode("("+a+" = "),i.compileToFragments(e,C),this.makeCode(")"),o.compileToFragments(e))):(r=i.compileToFragments(e,F),P.test(at(r))&&(r=this.wrapInBraces(r)),o?(a=at(r),r.push.apply(r,o.compileToFragments(e))):a="null",n=n.concat(r)),n=n.concat(this.makeCode(".apply("+a+", "),t,this.makeCode(")")))},n}(r),e.Extends=d=function(e){function t(e,t){this.child=e,this.parent=t}return Ft(t,e),t.prototype.children=["child","parent"],t.prototype.compileToFragments=function(e){return new o(new Z(new D(yt("extends"))),[this.child,this.parent]).compileToFragments(e)},t}(r),e.Access=t=function(e){function t(e,t){this.name=e,this.name.asKey=!0,this.soak="soak"===t}return Ft(t,e),t.prototype.children=["name"],t.prototype.compileToFragments=function(e){var t;return t=this.name.compileToFragments(e),b.test(at(t))?t.unshift(this.makeCode(".")):(t.unshift(this.makeCode("[")),t.push(this.makeCode("]"))),t},t.prototype.isComplex=A,t}(r),e.Index=T=function(e){function t(e){this.index=e}return Ft(t,e),t.prototype.children=["index"],t.prototype.compileToFragments=function(e){return[].concat(this.makeCode("["),this.index.compileToFragments(e,E),this.makeCode("]"))},t.prototype.isComplex=function(){return this.index.isComplex()},t}(r),e.Range=B=function(e){function t(e,t,n){this.from=e,this.to=t,this.exclusive="exclusive"===n,this.equals=this.exclusive?"":"="}return Ft(t,e),t.prototype.children=["from","to"],t.prototype.compileVariables=function(e){var t,n,i,r,s;return e=pt(e,{top:!0}),n=this.cacheToCodeFragments(this.from.cache(e,C)),this.fromC=n[0],this.fromVar=n[1],i=this.cacheToCodeFragments(this.to.cache(e,C)),this.toC=i[0],this.toVar=i[1],(t=it(e,"step"))&&(r=this.cacheToCodeFragments(t.cache(e,C)),this.step=r[0],this.stepVar=r[1]),s=[this.fromVar.match(I),this.toVar.match(I)],this.fromNum=s[0],this.toNum=s[1],this.stepVar?this.stepNum=this.stepVar.match(I):void 0},t.prototype.compileNode=function(e){var t,n,i,r,s,o,a,c,h,l,u,p,d,f;return this.fromVar||this.compileVariables(e),e.index?(a=this.fromNum&&this.toNum,s=it(e,"index"),o=it(e,"name"),h=o&&o!==s,p=""+s+" = "+this.fromC,this.toC!==this.toVar&&(p+=", "+this.toC),this.step!==this.stepVar&&(p+=", "+this.step),d=[""+s+" <"+this.equals,""+s+" >"+this.equals],c=d[0],r=d[1],n=this.stepNum?ft(this.stepNum[0])>0?""+c+" "+this.toVar:""+r+" "+this.toVar:a?(f=[ft(this.fromNum[0]),ft(this.toNum[0])],i=f[0],u=f[1],f,u>=i?""+c+" "+u:""+r+" "+u):(t=this.stepVar?""+this.stepVar+" > 0":""+this.fromVar+" <= "+this.toVar,""+t+" ? "+c+" "+this.toVar+" : "+r+" "+this.toVar),l=this.stepVar?""+s+" += "+this.stepVar:a?h?u>=i?"++"+s:"--"+s:u>=i?""+s+"++":""+s+"--":h?""+t+" ? ++"+s+" : --"+s:""+t+" ? "+s+"++ : "+s+"--",h&&(p=""+o+" = "+p),h&&(l=""+o+" = "+l),[this.makeCode(""+p+"; "+n+"; "+l)]):this.compileArray(e)},t.prototype.compileArray=function(e){var t,n,i,r,s,o,a,c,h,l,u,p,d;return this.fromNum&&this.toNum&&20>=Math.abs(this.fromNum-this.toNum)?(h=function(){d=[];for(var e=p=+this.fromNum,t=+this.toNum;t>=p?t>=e:e>=t;t>=p?e++:e--)d.push(e);return d}.apply(this),this.exclusive&&h.pop(),[this.makeCode("["+h.join(", ")+"]")]):(o=this.tab+X,s=e.scope.freeVariable("i"),l=e.scope.freeVariable("results"),c="\n"+o+l+" = [];",this.fromNum&&this.toNum?(e.index=s,n=at(this.compileNode(e))):(u=""+s+" = "+this.fromC+(this.toC!==this.toVar?", "+this.toC:""),i=""+this.fromVar+" <= "+this.toVar,n="var "+u+"; "+i+" ? "+s+" <"+this.equals+" "+this.toVar+" : "+s+" >"+this.equals+" "+this.toVar+"; "+i+" ? "+s+"++ : "+s+"--"),a="{ "+l+".push("+s+"); }\n"+o+"return "+l+";\n"+e.indent,r=function(e){return null!=e?e.contains(ct):void 0},(r(this.from)||r(this.to))&&(t=", arguments"),[this.makeCode("(function() {"+c+"\n"+o+"for ("+n+")"+a+"}).apply(this"+(null!=t?t:"")+")")])},t}(r),e.Slice=q=function(e){function t(e){this.range=e,t.__super__.constructor.call(this)}return Ft(t,e),t.prototype.children=["range"],t.prototype.compileNode=function(e){var t,n,i,r,s,o,a;return a=this.range,s=a.to,i=a.from,r=i&&i.compileToFragments(e,E)||[this.makeCode("0")],s&&(t=s.compileToFragments(e,E),n=at(t),(this.range.exclusive||-1!==+n)&&(o=", "+(this.range.exclusive?n:P.test(n)?""+(+n+1):(t=s.compileToFragments(e,F),"+"+at(t)+" + 1 || 9e9")))),[this.makeCode(".slice("+at(r)+(o||"")+")")]},t}(r),e.Obj=_=function(e){function t(e,t){this.generated=null!=t?t:!1,this.objects=this.properties=e||[]}return Ft(t,e),t.prototype.children=["properties"],t.prototype.compileNode=function(e){var t,n,r,s,o,a,c,h,u,p,d,f,m;if(u=this.properties,!u.length)return[this.makeCode(this.front?"({})":"{}")];if(this.generated)for(p=0,f=u.length;f>p;p++)c=u[p],c instanceof Z&&c.error("cannot have an implicit value in an implicit object");for(r=e.indent+=X,a=this.lastNonComment(this.properties),t=[],n=d=0,m=u.length;m>d;n=++d)h=u[n],o=n===u.length-1?"":h===a||h instanceof l?"\n":",\n",s=h instanceof l?"":r,h instanceof i&&h.variable instanceof Z&&h.variable.hasProperties()&&h.variable.error("Invalid object key"),h instanceof Z&&h["this"]&&(h=new i(h.properties[0].name,h,"object")),h instanceof l||(h instanceof i||(h=new i(h,h,"object")),(h.variable.base||h.variable).asKey=!0),s&&t.push(this.makeCode(s)),t.push.apply(t,h.compileToFragments(e,x)),o&&t.push(this.makeCode(o));return t.unshift(this.makeCode("{"+(u.length&&"\n"))),t.push(this.makeCode(""+(u.length&&"\n"+this.tab)+"}")),this.front?this.wrapInBraces(t):t},t.prototype.assigns=function(e){var t,n,i,r;for(r=this.properties,n=0,i=r.length;i>n;n++)if(t=r[n],t.assigns(e))return!0;return!1},t}(r),e.Arr=n=function(e){function t(e){this.objects=e||[]}return Ft(t,e),t.prototype.children=["objects"],t.prototype.compileNode=function(e){var t,n,i,r,s,o,a;if(!this.objects.length)return[this.makeCode("[]")];if(e.indent+=X,t=G.compileSplattedArray(e,this.objects),t.length)return t;for(t=[],n=function(){var t,n,i,r;for(i=this.objects,r=[],t=0,n=i.length;n>t;t++)s=i[t],r.push(s.compileToFragments(e,C));return r}.call(this),r=o=0,a=n.length;a>o;r=++o)i=n[r],r&&t.push(this.makeCode(", ")),t.push.apply(t,i);return at(t).indexOf("\n")>=0?(t.unshift(this.makeCode("[\n"+e.indent)),t.push(this.makeCode("\n"+this.tab+"]"))):(t.unshift(this.makeCode("[")),t.push(this.makeCode("]"))),t},t.prototype.assigns=function(e){var t,n,i,r;for(r=this.objects,n=0,i=r.length;i>n;n++)if(t=r[n],t.assigns(e))return!0;return!1},t}(r),e.Class=a=function(e){function n(e,t,n){this.variable=e,this.parent=t,this.body=null!=n?n:new s,this.boundFuncs=[],this.body.classBody=!0}return Ft(n,e),n.prototype.children=["variable","parent","body"],n.prototype.determineName=function(){var e,n;return this.variable?(e=(n=lt(this.variable.properties))?n instanceof t&&n.name.value:this.variable.base.value,Lt.call(U,e)>=0&&this.variable.error("class variable name may not be "+e),e&&(e=b.test(e)&&e)):null},n.prototype.setContext=function(e){return this.body.traverseChildren(!1,function(t){return t.classBody?!1:t instanceof D&&"this"===t.value?t.value=e:t instanceof c&&(t.klass=e,t.bound)?t.context=e:void 0})},n.prototype.addBoundFunctions=function(e){var n,i,r,s,o;for(o=this.boundFuncs,r=0,s=o.length;s>r;r++)n=o[r],i=new Z(new D("this"),[new t(n)]).compile(e),this.ctor.body.unshift(new D(""+i+" = "+yt("bind")+"("+i+", this)"))},n.prototype.addProperties=function(e,n,r){var s,o,a,h,l;return l=e.base.properties.slice(0),a=function(){var e;for(e=[];s=l.shift();)s instanceof i&&(o=s.variable.base,delete s.context,h=s.value,"constructor"===o.value?(this.ctor&&s.error("cannot define more than one constructor in a class"),h.bound&&s.error("cannot define a constructor as a bound function"),h instanceof c?s=this.ctor=h:(this.externalCtor=r.classScope.freeVariable("class"),s=new i(new D(this.externalCtor),h))):s.variable["this"]?h["static"]=!0:(s.variable=new Z(new D(n),[new t(new D("prototype")),new t(o)]),h instanceof c&&h.bound&&(this.boundFuncs.push(o),h.bound=!1))),e.push(s);return e}.call(this),nt(a)},n.prototype.walkBody=function(e,t){return this.traverseChildren(!1,function(r){return function(o){var a,c,h,l,u,p,d;if(a=!0,o instanceof n)return!1;if(o instanceof s){for(d=c=o.expressions,h=u=0,p=d.length;p>u;h=++u)l=d[h],l instanceof i&&l.variable.looksStatic(e)?l.value["static"]=!0:l instanceof Z&&l.isObject(!0)&&(a=!1,c[h]=r.addProperties(l,e,t));o.expressions=c=ot(c)}return a&&!(o instanceof n)}}(this))},n.prototype.hoistDirectivePrologue=function(){var e,t,n;for(t=0,e=this.body.expressions;(n=e[t])&&n instanceof l||n instanceof Z&&n.isString();)++t;return this.directives=e.splice(0,t)},n.prototype.ensureConstructor=function(e){return this.ctor||(this.ctor=new c,this.externalCtor?this.ctor.body.push(new D(""+this.externalCtor+".apply(this, arguments)")):this.parent&&this.ctor.body.push(new D(""+e+".__super__.constructor.apply(this, arguments)")),this.ctor.body.makeReturn(),this.body.expressions.unshift(this.ctor)),this.ctor.ctor=this.ctor.name=e,this.ctor.klass=null,this.ctor.noReturn=!0},n.prototype.compileNode=function(e){var t,n,r,a,h,l,u,p,f;return(a=this.body.jumps())&&a.error("Class bodies cannot contain pure statements"),(n=this.body.contains(ct))&&n.error("Class bodies shouldn't reference arguments"),u=this.determineName()||"_Class",u.reserved&&(u="_"+u),l=new D(u),r=new c([],s.wrap([this.body])),t=[],e.classScope=r.makeScope(e.scope),this.hoistDirectivePrologue(),this.setContext(u),this.walkBody(u,e),this.ensureConstructor(u),this.addBoundFunctions(e),this.body.spaced=!0,this.body.expressions.push(l),this.parent&&(p=new D(e.classScope.freeVariable("super",!1)),this.body.expressions.unshift(new d(l,p)),r.params.push(new O(p)),t.push(this.parent)),(f=this.body.expressions).unshift.apply(f,this.directives),h=new j(new o(r,t)),this.variable&&(h=new i(this.variable,h)),h.compileToFragments(e)},n}(r),e.Assign=i=function(e){function n(e,t,n,i){var r,s,o;this.variable=e,this.value=t,this.context=n,this.param=i&&i.param,this.subpattern=i&&i.subpattern,o=s=this.variable.unwrapAll().value,r=Lt.call(U,o)>=0,r&&"object"!==this.context&&this.variable.error('variable name may not be "'+s+'"')}return Ft(n,e),n.prototype.children=["variable","value"],n.prototype.isStatement=function(e){return(null!=e?e.level:void 0)===x&&null!=this.context&&Lt.call(this.context,"?")>=0},n.prototype.assigns=function(e){return this["object"===this.context?"value":"variable"].assigns(e)},n.prototype.unfoldSoak=function(e){return kt(e,this,"variable")},n.prototype.compileNode=function(e){var t,n,i,r,s,o,a,h,l,u,p;if(i=this.variable instanceof Z){if(this.variable.isArray()||this.variable.isObject())return this.compilePatternMatch(e);if(this.variable.isSplice())return this.compileSplice(e);if("||="===(h=this.context)||"&&="===h||"?="===h)return this.compileConditional(e);if("**="===(l=this.context)||"//="===l||"%%="===l)return this.compileSpecialMath(e)}return n=this.variable.compileToFragments(e,C),s=at(n),this.context||(a=this.variable.unwrapAll(),a.isAssignable()||this.variable.error('"'+this.variable.compile(e)+'" cannot be assigned'),("function"==typeof a.hasProperties?a.hasProperties():void 0)||(this.param?e.scope.add(s,"var"):e.scope.find(s))),this.value instanceof c&&(r=S.exec(s))&&(r[2]&&(this.value.klass=r[1]),this.value.name=null!=(u=null!=(p=r[3])?p:r[4])?u:r[5]),o=this.value.compileToFragments(e,C),"object"===this.context?n.concat(this.makeCode(": "),o):(t=n.concat(this.makeCode(" "+(this.context||"=")+" "),o),C>=e.level?t:this.wrapInBraces(t))
},n.prototype.compilePatternMatch=function(e){var i,r,s,o,a,c,h,l,u,d,f,m,g,k,y,v,w,F,L,E,S,R,A,I,_,$,O,B;if(v=e.level===x,F=this.value,m=this.variable.base.objects,!(g=m.length))return s=F.compileToFragments(e),e.level>=N?this.wrapInBraces(s):s;if(l=this.variable.isObject(),v&&1===g&&!((f=m[0])instanceof G))return f instanceof n?(A=f,I=A.variable,h=I.base,f=A.value):h=l?f["this"]?f.properties[0].name:f:new D(0),i=b.test(h.unwrap().value||0),F=new Z(F),F.properties.push(new(i?t:T)(h)),_=f.unwrap().value,Lt.call(M,_)>=0&&f.error("assignment to a reserved word: "+f.compile(e)),new n(f,F,null,{param:this.param}).compileToFragments(e,x);for(L=F.compileToFragments(e,C),E=at(L),r=[],o=!1,(!b.test(E)||this.variable.assigns(E))&&(r.push([this.makeCode(""+(k=e.scope.freeVariable("ref"))+" = ")].concat(Ct.call(L))),L=[this.makeCode(k)],E=k),c=S=0,R=m.length;R>S;c=++S){if(f=m[c],h=c,l&&(f instanceof n?($=f,O=$.variable,h=O.base,f=$.value):f.base instanceof j?(B=new Z(f.unwrapAll()).cacheReference(e),f=B[0],h=B[1]):h=f["this"]?f.properties[0].name:f),!o&&f instanceof G)d=f.name.unwrap().value,f=f.unwrap(),w=""+g+" <= "+E+".length ? "+yt("slice")+".call("+E+", "+c,(y=g-c-1)?(u=e.scope.freeVariable("i"),w+=", "+u+" = "+E+".length - "+y+") : ("+u+" = "+c+", [])"):w+=") : []",w=new D(w),o=""+u+"++";else{if(!o&&f instanceof p){(y=g-c-1)&&(1===y?o=""+E+".length - 1":(u=e.scope.freeVariable("i"),w=new D(""+u+" = "+E+".length - "+y),o=""+u+"++",r.push(w.compileToFragments(e,C))));continue}d=f.unwrap().value,(f instanceof G||f instanceof p)&&f.error("multiple splats/expansions are disallowed in an assignment"),"number"==typeof h?(h=new D(o||h),i=!1):i=l&&b.test(h.unwrap().value||0),w=new Z(new D(E),[new(i?t:T)(h)])}null!=d&&Lt.call(M,d)>=0&&f.error("assignment to a reserved word: "+f.compile(e)),r.push(new n(f,w,null,{param:this.param,subpattern:!0}).compileToFragments(e,C))}return v||this.subpattern||r.push(L),a=this.joinFragmentArrays(r,", "),C>e.level?a:this.wrapInBraces(a)},n.prototype.compileConditional=function(e){var t,i,r,s;return s=this.variable.cacheReference(e),i=s[0],r=s[1],!i.properties.length&&i.base instanceof D&&"this"!==i.base.value&&!e.scope.check(i.base.value)&&this.variable.error('the variable "'+i.base.value+"\" can't be assigned with "+this.context+" because it has not been declared before"),Lt.call(this.context,"?")>=0?(e.isExistentialEquals=!0,new v(new u(i),r,{type:"if"}).addElse(new n(r,this.value,"=")).compileToFragments(e)):(t=new $(this.context.slice(0,-1),i,new n(r,this.value,"=")).compileToFragments(e),C>=e.level?t:this.wrapInBraces(t))},n.prototype.compileSpecialMath=function(e){var t,i,r;return r=this.variable.cacheReference(e),t=r[0],i=r[1],new n(t,new $(this.context.slice(0,-1),i,this.value)).compileToFragments(e)},n.prototype.compileSplice=function(e){var t,n,i,r,s,o,a,c,h,l,u,p;return l=this.variable.properties.pop().range,i=l.from,a=l.to,n=l.exclusive,o=this.variable.compile(e),i?(u=this.cacheToCodeFragments(i.cache(e,N)),r=u[0],s=u[1]):r=s="0",a?i instanceof Z&&i.isSimpleNumber()&&a instanceof Z&&a.isSimpleNumber()?(a=a.compile(e)-s,n||(a+=1)):(a=a.compile(e,F)+" - "+s,n||(a+=" + 1")):a="9e9",p=this.value.cache(e,C),c=p[0],h=p[1],t=[].concat(this.makeCode("[].splice.apply("+o+", ["+r+", "+a+"].concat("),c,this.makeCode(")), "),h),e.level>x?this.wrapInBraces(t):t},n}(r),e.Code=c=function(e){function t(e,t,n){this.params=e||[],this.body=t||new s,this.bound="boundfunc"===n}return Ft(t,e),t.prototype.children=["params","body"],t.prototype.isStatement=function(){return!!this.ctor},t.prototype.jumps=A,t.prototype.makeScope=function(e){return new H(e,this.body,this)},t.prototype.compileNode=function(e){var r,a,c,h,l,u,d,f,m,b,g,k,y,w,T,L,C,N,E,x,S,R,A,I,_,j,M,B,V,P,U,H,q;if(this.bound&&(null!=(B=e.scope.method)?B.bound:void 0)&&(this.context=e.scope.method.context),this.bound&&!this.context)return this.context="_this",T=new t([new O(new D(this.context))],new s([this])),a=new o(T,[new D("this")]),a.updateLocationDataIfMissing(this.locationData),a.compileNode(e);for(e.scope=it(e,"classScope")||this.makeScope(e.scope),e.scope.shared=it(e,"sharedScope"),e.indent+=X,delete e.bare,delete e.isExistentialEquals,m=[],h=[],V=this.params,L=0,x=V.length;x>L;L++)f=V[L],f instanceof p||e.scope.parameter(f.asReference(e));for(P=this.params,C=0,S=P.length;S>C;C++)if(f=P[C],f.splat||f instanceof p){for(U=this.params,N=0,R=U.length;R>N;N++)d=U[N].name,f instanceof p||(d["this"]&&(d=d.properties[0].name),d.value&&e.scope.add(d.value,"var",!0));g=new i(new Z(new n(function(){var t,n,i,r;for(i=this.params,r=[],t=0,n=i.length;n>t;t++)d=i[t],r.push(d.asReference(e));return r}.call(this))),new Z(new D("arguments")));break}for(H=this.params,E=0,A=H.length;A>E;E++)f=H[E],f.isComplex()?(y=b=f.asReference(e),f.value&&(y=new $("?",b,f.value)),h.push(new i(new Z(f.name),y,"=",{param:!0}))):(b=f,f.value&&(u=new D(b.name.value+" == null"),y=new i(new Z(f.name),f.value,"="),h.push(new v(u,y)))),g||m.push(b);for(w=this.body.isEmpty(),g&&h.unshift(g),h.length&&(q=this.body.expressions).unshift.apply(q,h),l=j=0,I=m.length;I>j;l=++j)d=m[l],m[l]=d.compileToFragments(e),e.scope.parameter(at(m[l]));for(k=[],this.eachParamName(function(e,t){return Lt.call(k,e)>=0&&t.error("multiple parameters named '"+e+"'"),k.push(e)}),w||this.noReturn||this.body.makeReturn(),c="function",this.ctor&&(c+=" "+this.name),c+="(",r=[this.makeCode(c)],l=M=0,_=m.length;_>M;l=++M)d=m[l],l&&r.push(this.makeCode(", ")),r.push.apply(r,d);return r.push(this.makeCode(") {")),this.body.isEmpty()||(r=r.concat(this.makeCode("\n"),this.body.compileWithDeclarations(e),this.makeCode("\n"+this.tab))),r.push(this.makeCode("}")),this.ctor?[this.makeCode(this.tab)].concat(Ct.call(r)):this.front||e.level>=F?this.wrapInBraces(r):r},t.prototype.eachParamName=function(e){var t,n,i,r,s;for(r=this.params,s=[],n=0,i=r.length;i>n;n++)t=r[n],s.push(t.eachName(e));return s},t.prototype.traverseChildren=function(e,n){return e?t.__super__.traverseChildren.call(this,e,n):void 0},t}(r),e.Param=O=function(e){function t(e,t,n){var i;this.name=e,this.value=t,this.splat=n,i=e=this.name.unwrapAll().value,Lt.call(U,i)>=0&&this.name.error('parameter name "'+e+'" is not allowed')}return Ft(t,e),t.prototype.children=["name","value"],t.prototype.compileToFragments=function(e){return this.name.compileToFragments(e,C)},t.prototype.asReference=function(e){var t;return this.reference?this.reference:(t=this.name,t["this"]?(t=t.properties[0].name,t.value.reserved&&(t=new D(e.scope.freeVariable(t.value)))):t.isComplex()&&(t=new D(e.scope.freeVariable("arg"))),t=new Z(t),this.splat&&(t=new G(t)),t.updateLocationDataIfMissing(this.locationData),this.reference=t)},t.prototype.isComplex=function(){return this.name.isComplex()},t.prototype.eachName=function(e,t){var n,r,s,o,a,c;if(null==t&&(t=this.name),n=function(t){var n;return n=t.properties[0].name,n.value.reserved?void 0:e(n.value,n)},t instanceof D)return e(t.value,t);if(t instanceof Z)return n(t);for(c=t.objects,o=0,a=c.length;a>o;o++)s=c[o],s instanceof i?this.eachName(e,s.value.unwrap()):s instanceof G?(r=s.name.unwrap(),e(r.value,r)):s instanceof Z?s.isArray()||s.isObject()?this.eachName(e,s.base):s["this"]?n(s):e(s.base.value,s.base):s instanceof p||s.error("illegal parameter "+s.compile())},t}(r),e.Splat=G=function(e){function t(e){this.name=e.compile?e:new D(e)}return Ft(t,e),t.prototype.children=["name"],t.prototype.isAssignable=et,t.prototype.assigns=function(e){return this.name.assigns(e)},t.prototype.compileToFragments=function(e){return this.name.compileToFragments(e)},t.prototype.unwrap=function(){return this.name},t.compileSplattedArray=function(e,n,i){var r,s,o,a,c,h,l,u,p,d;for(l=-1;(u=n[++l])&&!(u instanceof t););if(l>=n.length)return[];if(1===n.length)return u=n[0],c=u.compileToFragments(e,C),i?c:[].concat(u.makeCode(""+yt("slice")+".call("),c,u.makeCode(")"));for(r=n.slice(l),h=p=0,d=r.length;d>p;h=++p)u=r[h],o=u.compileToFragments(e,C),r[h]=u instanceof t?[].concat(u.makeCode(""+yt("slice")+".call("),o,u.makeCode(")")):[].concat(u.makeCode("["),o,u.makeCode("]"));return 0===l?(u=n[0],a=u.joinFragmentArrays(r.slice(1),", "),r[0].concat(u.makeCode(".concat("),a,u.makeCode(")"))):(s=function(){var t,i,r,s;for(r=n.slice(0,l),s=[],t=0,i=r.length;i>t;t++)u=r[t],s.push(u.compileToFragments(e,C));return s}(),s=n[0].joinFragmentArrays(s,", "),a=n[l].joinFragmentArrays(r,", "),[].concat(n[0].makeCode("["),s,n[l].makeCode("].concat("),a,lt(n).makeCode(")")))},t}(r),e.Expansion=p=function(e){function t(){return t.__super__.constructor.apply(this,arguments)}return Ft(t,e),t.prototype.isComplex=A,t.prototype.compileNode=function(){return this.error("Expansion must be used inside a destructuring assignment or parameter list")},t.prototype.asReference=function(){return this},t.prototype.eachName=function(){},t}(r),e.While=Q=function(e){function t(e,t){this.condition=(null!=t?t.invert:void 0)?e.invert():e,this.guard=null!=t?t.guard:void 0}return Ft(t,e),t.prototype.children=["condition","guard","body"],t.prototype.isStatement=et,t.prototype.makeReturn=function(e){return e?t.__super__.makeReturn.apply(this,arguments):(this.returns=!this.jumps({loop:!0}),this)},t.prototype.addBody=function(e){return this.body=e,this},t.prototype.jumps=function(){var e,t,n,i,r;if(e=this.body.expressions,!e.length)return!1;for(i=0,r=e.length;r>i;i++)if(n=e[i],t=n.jumps({loop:!0}))return t;return!1},t.prototype.compileNode=function(e){var t,n,i,r;return e.indent+=X,r="",n=this.body,n.isEmpty()?n=this.makeCode(""):(this.returns&&(n.makeReturn(i=e.scope.freeVariable("results")),r=""+this.tab+i+" = [];\n"),this.guard&&(n.expressions.length>1?n.expressions.unshift(new v(new j(this.guard).invert(),new D("continue"))):this.guard&&(n=s.wrap([new v(this.guard,n)]))),n=[].concat(this.makeCode("\n"),n.compileToFragments(e,x),this.makeCode("\n"+this.tab))),t=[].concat(this.makeCode(r+this.tab+"while ("),this.condition.compileToFragments(e,E),this.makeCode(") {"),n,this.makeCode("}")),this.returns&&t.push(this.makeCode("\n"+this.tab+"return "+i+";")),t},t}(r),e.Op=$=function(e){function n(e,t,n,i){if("in"===e)return new w(t,n);if("do"===e)return this.generateDo(t);if("new"===e){if(t instanceof o&&!t["do"]&&!t.isNew)return t.newInstance();(t instanceof c&&t.bound||t["do"])&&(t=new j(t))}return this.operator=r[e]||e,this.first=t,this.second=n,this.flip=!!i,this}var r,s;return Ft(n,e),r={"==":"===","!=":"!==",of:"in"},s={"!==":"===","===":"!=="},n.prototype.children=["first","second"],n.prototype.isSimpleNumber=A,n.prototype.isUnary=function(){return!this.second},n.prototype.isComplex=function(){var e;return!(this.isUnary()&&("+"===(e=this.operator)||"-"===e))||this.first.isComplex()},n.prototype.isChainable=function(){var e;return"<"===(e=this.operator)||">"===e||">="===e||"<="===e||"==="===e||"!=="===e},n.prototype.invert=function(){var e,t,i,r,o;if(this.isChainable()&&this.first.isChainable()){for(e=!0,t=this;t&&t.operator;)e&&(e=t.operator in s),t=t.first;if(!e)return new j(this).invert();for(t=this;t&&t.operator;)t.invert=!t.invert,t.operator=s[t.operator],t=t.first;return this}return(r=s[this.operator])?(this.operator=r,this.first.unwrap()instanceof n&&this.first.invert(),this):this.second?new j(this).invert():"!"===this.operator&&(i=this.first.unwrap())instanceof n&&("!"===(o=i.operator)||"in"===o||"instanceof"===o)?i:new n("!",this)},n.prototype.unfoldSoak=function(e){var t;return("++"===(t=this.operator)||"--"===t||"delete"===t)&&kt(e,this,"first")},n.prototype.generateDo=function(e){var t,n,r,s,a,h,l,u;for(s=[],n=e instanceof i&&(a=e.value.unwrap())instanceof c?a:e,u=n.params||[],h=0,l=u.length;l>h;h++)r=u[h],r.value?(s.push(r.value),delete r.value):s.push(r);return t=new o(e,s),t["do"]=!0,t},n.prototype.compileNode=function(e){var t,n,i,r,s,o;if(n=this.isChainable()&&this.first.isChainable(),n||(this.first.front=this.front),"delete"===this.operator&&e.scope.check(this.first.unwrapAll().value)&&this.error("delete operand may not be argument or var"),("--"===(s=this.operator)||"++"===s)&&(o=this.first.unwrapAll().value,Lt.call(U,o)>=0)&&this.error('cannot increment/decrement "'+this.first.unwrapAll().value+'"'),this.isUnary())return this.compileUnary(e);if(n)return this.compileChain(e);switch(this.operator){case"?":return this.compileExistence(e);case"**":return this.compilePower(e);case"//":return this.compileFloorDivision(e);case"%%":return this.compileModulo(e);default:return i=this.first.compileToFragments(e,N),r=this.second.compileToFragments(e,N),t=[].concat(i,this.makeCode(" "+this.operator+" "),r),N>=e.level?t:this.wrapInBraces(t)}},n.prototype.compileChain=function(e){var t,n,i,r;return r=this.first.second.cache(e),this.first.second=r[0],i=r[1],n=this.first.compileToFragments(e,N),t=n.concat(this.makeCode(" "+(this.invert?"&&":"||")+" "),i.compileToFragments(e),this.makeCode(" "+this.operator+" "),this.second.compileToFragments(e,N)),this.wrapInBraces(t)},n.prototype.compileExistence=function(e){var t,n;return this.first.isComplex()?(n=new D(e.scope.freeVariable("ref")),t=new j(new i(n,this.first))):(t=this.first,n=t),new v(new u(t),n,{type:"if"}).addElse(this.second).compileToFragments(e)},n.prototype.compileUnary=function(e){var t,i,r;return i=[],t=this.operator,i.push([this.makeCode(t)]),"!"===t&&this.first instanceof u?(this.first.negated=!this.first.negated,this.first.compileToFragments(e)):e.level>=F?new j(this).compileToFragments(e):(r="+"===t||"-"===t,("new"===t||"typeof"===t||"delete"===t||r&&this.first instanceof n&&this.first.operator===t)&&i.push([this.makeCode(" ")]),(r&&this.first instanceof n||"new"===t&&this.first.isStatement(e))&&(this.first=new j(this.first)),i.push(this.first.compileToFragments(e,N)),this.flip&&i.reverse(),this.joinFragmentArrays(i,""))},n.prototype.compilePower=function(e){var n;return n=new Z(new D("Math"),[new t(new D("pow"))]),new o(n,[this.first,this.second]).compileToFragments(e)},n.prototype.compileFloorDivision=function(e){var i,r;return r=new Z(new D("Math"),[new t(new D("floor"))]),i=new n("/",this.first,this.second),new o(r,[i]).compileToFragments(e)},n.prototype.compileModulo=function(e){var t;return t=new Z(new D(yt("modulo"))),new o(t,[this.first,this.second]).compileToFragments(e)},n.prototype.toString=function(e){return n.__super__.toString.call(this,e,this.constructor.name+" "+this.operator)},n}(r),e.In=w=function(e){function t(e,t){this.object=e,this.array=t}return Ft(t,e),t.prototype.children=["object","array"],t.prototype.invert=R,t.prototype.compileNode=function(e){var t,n,i,r,s;if(this.array instanceof Z&&this.array.isArray()&&this.array.base.objects.length){for(s=this.array.base.objects,i=0,r=s.length;r>i;i++)if(n=s[i],n instanceof G){t=!0;break}if(!t)return this.compileOrTest(e)}return this.compileLoopTest(e)},t.prototype.compileOrTest=function(e){var t,n,i,r,s,o,a,c,h,l,u,p;for(l=this.object.cache(e,N),o=l[0],s=l[1],u=this.negated?[" !== "," && "]:[" === "," || "],t=u[0],n=u[1],a=[],p=this.array.base.objects,i=c=0,h=p.length;h>c;i=++c)r=p[i],i&&a.push(this.makeCode(n)),a=a.concat(i?s:o,this.makeCode(t),r.compileToFragments(e,F));return N>e.level?a:this.wrapInBraces(a)},t.prototype.compileLoopTest=function(e){var t,n,i,r;return r=this.object.cache(e,C),i=r[0],n=r[1],t=[].concat(this.makeCode(yt("indexOf")+".call("),this.array.compileToFragments(e,C),this.makeCode(", "),n,this.makeCode(") "+(this.negated?"< 0":">= 0"))),at(i)===at(n)?t:(t=i.concat(this.makeCode(", "),t),C>e.level?t:this.wrapInBraces(t))},t.prototype.toString=function(e){return t.__super__.toString.call(this,e,this.constructor.name+(this.negated?"!":""))},t}(r),e.Try=K=function(e){function t(e,t,n,i){this.attempt=e,this.errorVariable=t,this.recovery=n,this.ensure=i}return Ft(t,e),t.prototype.children=["attempt","recovery","ensure"],t.prototype.isStatement=et,t.prototype.jumps=function(e){var t;return this.attempt.jumps(e)||(null!=(t=this.recovery)?t.jumps(e):void 0)},t.prototype.makeReturn=function(e){return this.attempt&&(this.attempt=this.attempt.makeReturn(e)),this.recovery&&(this.recovery=this.recovery.makeReturn(e)),this},t.prototype.compileNode=function(e){var t,n,r,s;return e.indent+=X,s=this.attempt.compileToFragments(e,x),t=this.recovery?(r=new D("_error"),this.errorVariable?this.recovery.unshift(new i(this.errorVariable,r)):void 0,[].concat(this.makeCode(" catch ("),r.compileToFragments(e),this.makeCode(") {\n"),this.recovery.compileToFragments(e,x),this.makeCode("\n"+this.tab+"}"))):this.ensure||this.recovery?[]:[this.makeCode(" catch (_error) {}")],n=this.ensure?[].concat(this.makeCode(" finally {\n"),this.ensure.compileToFragments(e,x),this.makeCode("\n"+this.tab+"}")):[],[].concat(this.makeCode(""+this.tab+"try {\n"),s,this.makeCode("\n"+this.tab+"}"),t,n)},t}(r),e.Throw=z=function(e){function t(e){this.expression=e}return Ft(t,e),t.prototype.children=["expression"],t.prototype.isStatement=et,t.prototype.jumps=A,t.prototype.makeReturn=Y,t.prototype.compileNode=function(e){return[].concat(this.makeCode(this.tab+"throw "),this.expression.compileToFragments(e),this.makeCode(";"))},t}(r),e.Existence=u=function(e){function t(e){this.expression=e}return Ft(t,e),t.prototype.children=["expression"],t.prototype.invert=R,t.prototype.compileNode=function(e){var t,n,i,r;return this.expression.front=this.front,i=this.expression.compile(e,N),b.test(i)&&!e.scope.check(i)?(r=this.negated?["===","||"]:["!==","&&"],t=r[0],n=r[1],i="typeof "+i+" "+t+' "undefined" '+n+" "+i+" "+t+" null"):i=""+i+" "+(this.negated?"==":"!=")+" null",[this.makeCode(L>=e.level?i:"("+i+")")]},t}(r),e.Parens=j=function(e){function t(e){this.body=e}return Ft(t,e),t.prototype.children=["body"],t.prototype.unwrap=function(){return this.body},t.prototype.isComplex=function(){return this.body.isComplex()},t.prototype.compileNode=function(e){var t,n,i;return n=this.body.unwrap(),n instanceof Z&&n.isAtomic()?(n.front=this.front,n.compileToFragments(e)):(i=n.compileToFragments(e,E),t=N>e.level&&(n instanceof $||n instanceof o||n instanceof f&&n.returns),t?i:this.wrapInBraces(i))},t}(r),e.For=f=function(e){function t(e,t){var n;this.source=t.source,this.guard=t.guard,this.step=t.step,this.name=t.name,this.index=t.index,this.body=s.wrap([e]),this.own=!!t.own,this.object=!!t.object,this.object&&(n=[this.index,this.name],this.name=n[0],this.index=n[1]),this.index instanceof Z&&this.index.error("index cannot be a pattern matching expression"),this.range=this.source instanceof Z&&this.source.base instanceof B&&!this.source.properties.length,this.pattern=this.name instanceof Z,this.range&&this.index&&this.index.error("indexes do not apply to range loops"),this.range&&this.pattern&&this.name.error("cannot pattern match over range loops"),this.own&&!this.object&&this.name.error("cannot use own with for-in"),this.returns=!1}return Ft(t,e),t.prototype.children=["body","source","guard","step"],t.prototype.compileNode=function(e){var t,n,r,o,a,c,h,l,u,p,d,f,m,g,k,y,w,T,F,L,N,E,S,R,A,_,$,O,M,B,P,U,H,q;return t=s.wrap([this.body]),T=null!=(H=lt(t.expressions))?H.jumps():void 0,T&&T instanceof V&&(this.returns=!1),$=this.range?this.source.base:this.source,_=e.scope,this.pattern||(L=this.name&&this.name.compile(e,C)),g=this.index&&this.index.compile(e,C),L&&!this.pattern&&_.find(L),g&&_.find(g),this.returns&&(A=_.freeVariable("results")),k=this.object&&g||_.freeVariable("i"),y=this.range&&L||g||k,w=y!==k?""+y+" = ":"",this.step&&!this.range&&(q=this.cacheToCodeFragments(this.step.cache(e,C)),O=q[0],B=q[1],M=B.match(I)),this.pattern&&(L=k),U="",d="",h="",f=this.tab+X,this.range?p=$.compileToFragments(pt(e,{index:k,name:L,step:this.step})):(P=this.source.compile(e,C),!L&&!this.own||b.test(P)||(h+=""+this.tab+(E=_.freeVariable("ref"))+" = "+P+";\n",P=E),L&&!this.pattern&&(N=""+L+" = "+P+"["+y+"]"),this.object||(O!==B&&(h+=""+this.tab+O+";\n"),this.step&&M&&(u=0>ft(M[0]))||(F=_.freeVariable("len")),a=""+w+k+" = 0, "+F+" = "+P+".length",c=""+w+k+" = "+P+".length - 1",r=""+k+" < "+F,o=""+k+" >= 0",this.step?(M?u&&(r=o,a=c):(r=""+B+" > 0 ? "+r+" : "+o,a="("+B+" > 0 ? ("+a+") : "+c+")"),m=""+k+" += "+B):m=""+(y!==k?"++"+k:""+k+"++"),p=[this.makeCode(""+a+"; "+r+"; "+w+m)])),this.returns&&(S=""+this.tab+A+" = [];\n",R="\n"+this.tab+"return "+A+";",t.makeReturn(A)),this.guard&&(t.expressions.length>1?t.expressions.unshift(new v(new j(this.guard).invert(),new D("continue"))):this.guard&&(t=s.wrap([new v(this.guard,t)]))),this.pattern&&t.expressions.unshift(new i(this.name,new D(""+P+"["+y+"]"))),l=[].concat(this.makeCode(h),this.pluckDirectCall(e,t)),N&&(U="\n"+f+N+";"),this.object&&(p=[this.makeCode(""+y+" in "+P)],this.own&&(d="\n"+f+"if (!"+yt("hasProp")+".call("+P+", "+y+")) continue;")),n=t.compileToFragments(pt(e,{indent:f}),x),n&&n.length>0&&(n=[].concat(this.makeCode("\n"),n,this.makeCode("\n"))),[].concat(l,this.makeCode(""+(S||"")+this.tab+"for ("),p,this.makeCode(") {"+d+U),n,this.makeCode(""+this.tab+"}"+(R||"")))},t.prototype.pluckDirectCall=function(e,t){var n,r,s,a,h,l,u,p,d,f,m,b,g,k,y,v;for(r=[],f=t.expressions,h=p=0,d=f.length;d>p;h=++p)s=f[h],s=s.unwrapAll(),s instanceof o&&(u=null!=(m=s.variable)?m.unwrapAll():void 0,(u instanceof c||u instanceof Z&&(null!=(b=u.base)?b.unwrapAll():void 0)instanceof c&&1===u.properties.length&&("call"===(g=null!=(k=u.properties[0].name)?k.value:void 0)||"apply"===g))&&(a=(null!=(y=u.base)?y.unwrapAll():void 0)||u,l=new D(e.scope.freeVariable("fn")),n=new Z(l),u.base&&(v=[n,u],u.base=v[0],n=v[1]),t.expressions[h]=new o(n,s.args),r=r.concat(this.makeCode(this.tab),new i(l,a).compileToFragments(e,x),this.makeCode(";\n"))));return r},t}(Q),e.Switch=W=function(e){function t(e,t,n){this.subject=e,this.cases=t,this.otherwise=n}return Ft(t,e),t.prototype.children=["subject","cases","otherwise"],t.prototype.isStatement=et,t.prototype.jumps=function(e){var t,n,i,r,s,o,a,c;for(null==e&&(e={block:!0}),o=this.cases,r=0,s=o.length;s>r;r++)if(a=o[r],n=a[0],t=a[1],i=t.jumps(e))return i;return null!=(c=this.otherwise)?c.jumps(e):void 0},t.prototype.makeReturn=function(e){var t,n,i,r,o;for(r=this.cases,n=0,i=r.length;i>n;n++)t=r[n],t[1].makeReturn(e);return e&&(this.otherwise||(this.otherwise=new s([new D("void 0")]))),null!=(o=this.otherwise)&&o.makeReturn(e),this},t.prototype.compileNode=function(e){var t,n,i,r,s,o,a,c,h,l,u,p,d,f,m,b;for(c=e.indent+X,h=e.indent=c+X,o=[].concat(this.makeCode(this.tab+"switch ("),this.subject?this.subject.compileToFragments(e,E):this.makeCode("false"),this.makeCode(") {\n")),f=this.cases,a=l=0,p=f.length;p>l;a=++l){for(m=f[a],r=m[0],t=m[1],b=ot([r]),u=0,d=b.length;d>u;u++)i=b[u],this.subject||(i=i.invert()),o=o.concat(this.makeCode(c+"case "),i.compileToFragments(e,E),this.makeCode(":\n"));if((n=t.compileToFragments(e,x)).length>0&&(o=o.concat(n,this.makeCode("\n"))),a===this.cases.length-1&&!this.otherwise)break;s=this.lastNonComment(t.expressions),s instanceof V||s instanceof D&&s.jumps()&&"debugger"!==s.value||o.push(i.makeCode(h+"break;\n"))}return this.otherwise&&this.otherwise.expressions.length&&o.push.apply(o,[this.makeCode(c+"default:\n")].concat(Ct.call(this.otherwise.compileToFragments(e,x)),[this.makeCode("\n")])),o.push(this.makeCode(this.tab+"}")),o},t}(r),e.If=v=function(e){function t(e,t,n){this.body=t,null==n&&(n={}),this.condition="unless"===n.type?e.invert():e,this.elseBody=null,this.isChain=!1,this.soak=n.soak}return Ft(t,e),t.prototype.children=["condition","body","elseBody"],t.prototype.bodyNode=function(){var e;return null!=(e=this.body)?e.unwrap():void 0},t.prototype.elseBodyNode=function(){var e;return null!=(e=this.elseBody)?e.unwrap():void 0},t.prototype.addElse=function(e){return this.isChain?this.elseBodyNode().addElse(e):(this.isChain=e instanceof t,this.elseBody=this.ensureBlock(e),this.elseBody.updateLocationDataIfMissing(e.locationData)),this},t.prototype.isStatement=function(e){var t;return(null!=e?e.level:void 0)===x||this.bodyNode().isStatement(e)||(null!=(t=this.elseBodyNode())?t.isStatement(e):void 0)},t.prototype.jumps=function(e){var t;return this.body.jumps(e)||(null!=(t=this.elseBody)?t.jumps(e):void 0)},t.prototype.compileNode=function(e){return this.isStatement(e)?this.compileStatement(e):this.compileExpression(e)},t.prototype.makeReturn=function(e){return e&&(this.elseBody||(this.elseBody=new s([new D("void 0")]))),this.body&&(this.body=new s([this.body.makeReturn(e)])),this.elseBody&&(this.elseBody=new s([this.elseBody.makeReturn(e)])),this},t.prototype.ensureBlock=function(e){return e instanceof s?e:new s([e])},t.prototype.compileStatement=function(e){var n,i,r,s,o,a,c;return r=it(e,"chainChild"),(o=it(e,"isExistentialEquals"))?new t(this.condition.invert(),this.elseBodyNode(),{type:"if"}).compileToFragments(e):(c=e.indent+X,s=this.condition.compileToFragments(e,E),i=this.ensureBlock(this.body).compileToFragments(pt(e,{indent:c})),a=[].concat(this.makeCode("if ("),s,this.makeCode(") {\n"),i,this.makeCode("\n"+this.tab+"}")),r||a.unshift(this.makeCode(this.tab)),this.elseBody?(n=a.concat(this.makeCode(" else ")),this.isChain?(e.chainChild=!0,n=n.concat(this.elseBody.unwrap().compileToFragments(e,x))):n=n.concat(this.makeCode("{\n"),this.elseBody.compileToFragments(pt(e,{indent:c}),x),this.makeCode("\n"+this.tab+"}")),n):a)},t.prototype.compileExpression=function(e){var t,n,i,r;return i=this.condition.compileToFragments(e,L),n=this.bodyNode().compileToFragments(e,C),t=this.elseBodyNode()?this.elseBodyNode().compileToFragments(e,C):[this.makeCode("void 0")],r=i.concat(this.makeCode(" ? "),n,this.makeCode(" : "),t),e.level>=L?this.wrapInBraces(r):r},t.prototype.unfoldSoak=function(){return this.soak&&this},t}(r),J={"extends":function(){return"function(child, parent) { for (var key in parent) { if ("+yt("hasProp")+".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }"},bind:function(){return"function(fn, me){ return function(){ return fn.apply(me, arguments); }; }"},indexOf:function(){return"[].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }"},modulo:function(){return"function(a, b) { return (a % b + +b) % b; }"},hasProp:function(){return"{}.hasOwnProperty"},slice:function(){return"[].slice"}},x=1,E=2,C=3,L=4,N=5,F=6,X="  ",g="[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*",b=RegExp("^"+g+"$"),P=/^[+-]?\d+$/,m=/^[+-]?0x[\da-f]+/i,I=/^[+-]?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)$/i,S=RegExp("^("+g+")(\\.prototype)?(?:\\.("+g+")|\\[(\"(?:[^\\\\\"\\r\\n]|\\\\.)*\"|'(?:[^\\\\'\\r\\n]|\\\\.)*')\\]|\\[(0x[\\da-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\])$"),y=/^['"]/,k=/^\//,yt=function(e){var t;return t="__"+e,H.root.assign(t,J[e]()),t},dt=function(e,t){return e=e.replace(/\n/g,"$&"+t),e.replace(/\s+$/,"")},ft=function(e){return null==e?0:e.match(m)?parseInt(e,16):parseFloat(e)},ct=function(e){return e instanceof D&&"arguments"===e.value&&!e.asKey},ht=function(e){return e instanceof D&&"this"===e.value&&!e.asKey||e instanceof c&&e.bound||e instanceof o&&e.isSuper},kt=function(e,t,n){var i;if(i=t[n].unfoldSoak(e))return t[n]=i.body,i.body=new Z(t),i}}.call(this),t.exports}(),require["./sourcemap"]=function(){var e={},t={exports:e};return function(){var e,n;e=function(){function e(e){this.line=e,this.columns=[]}return e.prototype.add=function(e,t,n){var i,r;return r=t[0],i=t[1],null==n&&(n={}),this.columns[e]&&n.noReplace?void 0:this.columns[e]={line:this.line,column:e,sourceLine:r,sourceColumn:i}},e.prototype.sourceLocation=function(e){for(var t;!((t=this.columns[e])||0>=e);)e--;return t&&[t.sourceLine,t.sourceColumn]},e}(),n=function(){function t(){this.lines=[]}var n,i,r,s;return t.prototype.add=function(t,n,i){var r,s,o,a;return null==i&&(i={}),s=n[0],r=n[1],o=(a=this.lines)[s]||(a[s]=new e(s)),o.add(r,t,i)},t.prototype.sourceLocation=function(e){var t,n,i;for(n=e[0],t=e[1];!((i=this.lines[n])||0>=n);)n--;return i&&i.sourceLocation(t)},t.prototype.generate=function(e,t){var n,i,r,s,o,a,c,h,l,u,p,d,f,m,b,g;for(null==e&&(e={}),null==t&&(t=null),u=0,i=0,s=0,r=0,h=!1,n="",b=this.lines,a=p=0,f=b.length;f>p;a=++p)if(o=b[a])for(g=o.columns,d=0,m=g.length;m>d;d++)if(c=g[d]){for(;c.line>u;)i=0,h=!1,n+=";",u++;h&&(n+=",",h=!1),n+=this.encodeVlq(c.column-i),i=c.column,n+=this.encodeVlq(0),n+=this.encodeVlq(c.sourceLine-s),s=c.sourceLine,n+=this.encodeVlq(c.sourceColumn-r),r=c.sourceColumn,h=!0}return l={version:3,file:e.generatedFile||"",sourceRoot:e.sourceRoot||"",sources:e.sourceFiles||[""],names:[],mappings:n},e.inline&&(l.sourcesContent=[t]),JSON.stringify(l,null,2)},r=5,i=1<<r,s=i-1,t.prototype.encodeVlq=function(e){var t,n,o,a;for(t="",o=0>e?1:0,a=(Math.abs(e)<<1)+o;a||!t;)n=a&s,a>>=r,a&&(n|=i),t+=this.encodeBase64(n);return t},n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t.prototype.encodeBase64=function(e){return n[e]||function(){throw Error("Cannot Base64 encode value: "+e)}()},t}(),t.exports=n}.call(this),t.exports}(),require["./coffee-script"]=function(){var e={},t={exports:e};return function(){var t,n,i,r,s,o,a,c,h,l,u,p,d,f={}.hasOwnProperty,m=[].indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(t in this&&this[t]===e)return t;return-1};s=require("fs"),p=require("vm"),l=require("path"),t=require("./lexer").Lexer,h=require("./parser").parser,a=require("./helpers"),n=require("./sourcemap"),e.VERSION="1.7.1",e.FILE_EXTENSIONS=[".coffee",".litcoffee",".coffee.md"],e.helpers=a,d=function(e){return function(t,n){var i;null==n&&(n={});try{return e.call(this,t,n)}catch(r){throw i=r,a.updateSyntaxError(i,t,n.filename)}}},e.compile=i=d(function(e,t){var i,r,s,o,l,u,p,d,f,m,b,g,k;for(m=a.merge,o=a.extend,t=o({},t),t.sourceMap&&(f=new n),u=h.parse(c.tokenize(e,t)).compileToFragments(t),s=0,t.header&&(s+=1),t.shiftLine&&(s+=1),r=0,d="",g=0,k=u.length;k>g;g++)l=u[g],t.sourceMap&&(l.locationData&&f.add([l.locationData.first_line,l.locationData.first_column],[s,r],{noReplace:!0}),b=a.count(l.code,"\n"),s+=b,b?r=l.code.length-(l.code.lastIndexOf("\n")+1):r+=l.code.length),d+=l.code;return t.header&&(p="Generated by CoffeeScript "+this.VERSION,d="// "+p+"\n"+d),t.sourceMap?(i={js:d},i.sourceMap=f,i.v3SourceMap=f.generate(t,e),i):d}),e.tokens=d(function(e,t){return c.tokenize(e,t)}),e.nodes=d(function(e,t){return"string"==typeof e?h.parse(c.tokenize(e,t)):h.parse(e)}),e.run=function(e,t){var n,r,o,c;return null==t&&(t={}),o=require.main,o.filename=process.argv[1]=t.filename?s.realpathSync(t.filename):".",o.moduleCache&&(o.moduleCache={}),r=t.filename?l.dirname(s.realpathSync(t.filename)):s.realpathSync("."),o.paths=require("module")._nodeModulePaths(r),(!a.isCoffee(o.filename)||require.extensions)&&(n=i(e,t),e=null!=(c=n.js)?c:n),o._compile(e,o.filename)},e.eval=function(e,t){var n,r,s,o,a,c,h,u,d,m,b,g,k,y;if(null==t&&(t={}),e=e.trim()){if(r=p.Script){if(null!=t.sandbox){if(t.sandbox instanceof r.createContext().constructor)h=t.sandbox;else{h=r.createContext(),g=t.sandbox;for(o in g)f.call(g,o)&&(u=g[o],h[o]=u)}h.global=h.root=h.GLOBAL=h}else h=global;if(h.__filename=t.filename||"eval",h.__dirname=l.dirname(h.__filename),h===global&&!h.module&&!h.require){for(n=require("module"),h.module=b=new n(t.modulename||"eval"),h.require=y=function(e){return n._load(e,b,!0)},b.filename=h.__filename,k=Object.getOwnPropertyNames(require),d=0,m=k.length;m>d;d++)c=k[d],"paths"!==c&&(y[c]=require[c]);y.paths=b.paths=n._nodeModulePaths(process.cwd()),y.resolve=function(e){return n._resolveFilename(e,b)}}}a={};for(o in t)f.call(t,o)&&(u=t[o],a[o]=u);return a.bare=!0,s=i(e,a),h===global?p.runInThisContext(s):p.runInContext(s,h)}},e.register=function(){return require("./register")},e._compileFile=function(e,t){var n,r,o,c;null==t&&(t=!1),o=s.readFileSync(e,"utf8"),c=65279===o.charCodeAt(0)?o.substring(1):o;try{n=i(c,{filename:e,sourceMap:t,literate:a.isLiterate(e)})}catch(h){throw r=h,a.updateSyntaxError(r,c,e)}return n},c=new t,h.lexer={lex:function(){var e,t;
return t=this.tokens[this.pos++],t?(e=t[0],this.yytext=t[1],this.yylloc=t[2],this.errorToken=t.origin||t,this.yylineno=this.yylloc.first_line):e="",e},setInput:function(e){return this.tokens=e,this.pos=0},upcomingInput:function(){return""}},h.yy=require("./nodes"),h.yy.parseError=function(e,t){var n,i,r,s,o,c,l;return o=t.token,l=h.lexer,s=l.errorToken,c=l.tokens,i=s[0],r=s[1],n=s[2],r=s===c[c.length-1]?"end of input":"INDENT"===i||"OUTDENT"===i?"indentation":a.nameWhitespaceCharacter(r),a.throwSyntaxError("unexpected "+r,n)},r=function(e,t){var n,i,r,s,o,a,c,h,l,u,p,d;return s=void 0,r="",e.isNative()?r="native":(e.isEval()?(s=e.getScriptNameOrSourceURL(),s||(r=""+e.getEvalOrigin()+", ")):s=e.getFileName(),s||(s="<anonymous>"),h=e.getLineNumber(),i=e.getColumnNumber(),u=t(s,h,i),r=u?""+s+":"+u[0]+":"+u[1]:""+s+":"+h+":"+i),o=e.getFunctionName(),a=e.isConstructor(),c=!(e.isToplevel()||a),c?(l=e.getMethodName(),d=e.getTypeName(),o?(p=n="",d&&o.indexOf(d)&&(p=""+d+"."),l&&o.indexOf("."+l)!==o.length-l.length-1&&(n=" [as "+l+"]"),""+p+o+n+" ("+r+")"):""+d+"."+(l||"<anonymous>")+" ("+r+")"):a?"new "+(o||"<anonymous>")+" ("+r+")":o?""+o+" ("+r+")":r},u={},o=function(t){var n,i;if(u[t])return u[t];if(i=null!=l?l.extname(t):void 0,!(0>m.call(e.FILE_EXTENSIONS,i)))return n=e._compileFile(t,!0),u[t]=n.sourceMap},Error.prepareStackTrace=function(t,n){var i,s,a,c;return a=function(e,t,n){var i,r;return r=o(e),r&&(i=r.sourceLocation([t-1,n-1])),i?[i[0]+1,i[1]+1]:null},s=function(){var t,s,o;for(o=[],t=0,s=n.length;s>t&&(i=n[t],i.getFunction()!==e.run);t++)o.push("  at "+r(i,a));return o}(),""+t.name+": "+(null!=(c=t.message)?c:"")+"\n"+s.join("\n")+"\n"}}.call(this),t.exports}(),require["./browser"]=function(){var exports={},module={exports:exports};return function(){var CoffeeScript,compile,runScripts,__indexOf=[].indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(t in this&&this[t]===e)return t;return-1};CoffeeScript=require("./coffee-script"),CoffeeScript.require=require,compile=CoffeeScript.compile,CoffeeScript.eval=function(code,options){return null==options&&(options={}),null==options.bare&&(options.bare=!0),eval(compile(code,options))},CoffeeScript.run=function(e,t){return null==t&&(t={}),t.bare=!0,t.shiftLine=!0,Function(compile(e,t))()},"undefined"!=typeof window&&null!==window&&("undefined"!=typeof btoa&&null!==btoa&&"undefined"!=typeof JSON&&null!==JSON&&"undefined"!=typeof unescape&&null!==unescape&&"undefined"!=typeof encodeURIComponent&&null!==encodeURIComponent&&(compile=function(e,t){var n,i,r;return null==t&&(t={}),t.sourceMap=!0,t.inline=!0,r=CoffeeScript.compile(e,t),n=r.js,i=r.v3SourceMap,""+n+"\n//# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(i)))+"\n//# sourceURL=coffeescript"}),CoffeeScript.load=function(e,t,n,i){var r;return null==n&&(n={}),null==i&&(i=!1),n.sourceFiles=[e],r=window.ActiveXObject?new window.ActiveXObject("Microsoft.XMLHTTP"):new window.XMLHttpRequest,r.open("GET",e,!0),"overrideMimeType"in r&&r.overrideMimeType("text/plain"),r.onreadystatechange=function(){var s,o;if(4===r.readyState){if(0!==(o=r.status)&&200!==o)throw Error("Could not load "+e);if(s=[r.responseText,n],i||CoffeeScript.run.apply(CoffeeScript,s),t)return t(s)}},r.send(null)},runScripts=function(){var e,t,n,i,r,s,o,a,c,h,l;for(a=window.document.getElementsByTagName("script"),t=["text/coffeescript","text/literate-coffeescript"],e=function(){var e,n,i,r;for(r=[],e=0,n=a.length;n>e;e++)s=a[e],i=s.type,__indexOf.call(t,i)>=0&&r.push(s);return r}(),r=0,n=function(){var t;return t=e[r],t instanceof Array?(CoffeeScript.run.apply(CoffeeScript,t),r++,n()):void 0},c=function(i,r){var s;return s={literate:i.type===t[1]},i.src?CoffeeScript.load(i.src,function(t){return e[r]=t,n()},s,!0):(s.sourceFiles=["embedded"],e[r]=[i.innerHTML,s])},i=h=0,l=e.length;l>h;i=++h)o=e[i],c(o,i);return n()},window.addEventListener?window.addEventListener("DOMContentLoaded",runScripts,!1):window.attachEvent("onload",runScripts))}.call(this),module.exports}(),require["./coffee-script"]}();"function"==typeof define&&define.amd?define(function(){return CoffeeScript}):root.CoffeeScript=CoffeeScript})(this);
// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    module.exports = mod();
  else if (typeof define == "function" && define.amd) // AMD
    return define([], mod);
  else // Plain browser env
    this.CodeMirror = mod();
})(function() {
  "use strict";

  // BROWSER SNIFFING

  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.

  var gecko = /gecko\/\d/i.test(navigator.userAgent);
  // ie_uptoN means Internet Explorer version N or lower
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_upto7 = ie_upto10 && (document.documentMode == null || document.documentMode < 8);
  var ie_upto8 = ie_upto10 && (document.documentMode == null || document.documentMode < 9);
  var ie_upto9 = ie_upto10 && (document.documentMode == null || document.documentMode < 10);
  var ie_11up = /Trident\/([7-9]|\d{2,})\./.test(navigator.userAgent);
  var ie = ie_upto10 || ie_11up;
  var webkit = /WebKit\//.test(navigator.userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
  var chrome = /Chrome\//.test(navigator.userAgent);
  var presto = /Opera\//.test(navigator.userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var khtml = /KHTML\//.test(navigator.userAgent);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
  var phantom = /PhantomJS/.test(navigator.userAgent);

  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
  var mac = ios || /Mac/.test(navigator.platform);
  var windows = /win/i.test(navigator.platform);

  var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) presto_version = Number(presto_version[1]);
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && !ie_upto8);

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  // EDITOR CONSTRUCTOR

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);

    this.options = options = options || {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);
    setGuttersForLineNumbers(options);

    var doc = options.value;
    if (typeof doc == "string") doc = new Doc(doc, options.mode);
    this.doc = doc;

    var display = this.display = new Display(place, doc);
    display.wrapper.CodeMirror = this;
    updateGutters(this);
    themeChanged(this);
    if (options.lineWrapping)
      this.display.wrapper.className += " CodeMirror-wrap";
    if (options.autofocus && !mobile) focusInput(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false, focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput
      draggingText: false,
      highlight: new Delayed() // stores highlight worker timeout
    };

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie_upto10) setTimeout(bind(resetInput, this, true), 20);

    registerEventHandlers(this);

    var cm = this;
    runInOp(this, function() {
      cm.curOp.forceUpdate = true;
      attachDoc(cm, doc);

      if ((options.autofocus && !mobile) || activeElt() == display.input)
        setTimeout(bind(onFocus, cm), 20);
      else
        onBlur(cm);

      for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))
        optionHandlers[opt](cm, options[opt], Init);
      for (var i = 0; i < initHooks.length; ++i) initHooks[i](cm);
    });
  }

  // DISPLAY CONSTRUCTOR

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc) {
    var d = this;

    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) input.style.width = "1000px";
    else input.setAttribute("wrap", "off");
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) input.style.border = "1px solid black";
    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");

    // Wraps and hides input textarea
    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The fake scrollbar elements.
    d.scrollbarH = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    d.scrollbarV = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = elt("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,
                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie_upto7) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    // Needed to hide big blue blinking cursor on Mobile Safari
    if (ios) input.style.width = "0px";
    if (!webkit) d.scroller.draggable = true;
    // Needed to handle Tab key in KHTML
    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie_upto7) d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = "18px";

    if (place.appendChild) place.appendChild(d.wrapper);
    else place(d.wrapper);

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastSizeC = 0;
    d.updateLineNumbers = null;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // See readInput and resetInput
    d.prevInput = "";
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;
    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    d.pollingFast = false;
    // Self-resetting timeout for the poller
    d.poll = new Delayed();

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks when resetInput has punted to just putting a short
    // string into the textarea instead of the full selection.
    d.inaccurateSelection = false;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;
  }

  // STATE UPDATES

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function(line) {
      if (line.stateAfter) line.stateAfter = null;
      if (line.styles) line.styles = null;
    });
    cm.doc.frontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) regChange(cm);
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function(){updateScrollbars(cm);}, 100);
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function(line) {
      if (lineIsHidden(cm.doc, line)) return 0;

      var widgetsHeight = 0;
      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;
      }

      if (wrapping)
        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
      else
        return widgetsHeight + th;
    };
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function(line) {
      var estHeight = est(line);
      if (estHeight != line.height) updateLineHeight(line, estHeight);
    });
  }

  function keyMapChanged(cm) {
    var map = keyMap[cm.options.keyMap], style = map.style;
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-keymap-\S+/g, "") +
      (style ? " cm-keymap-" + style : "");
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  function guttersChanged(cm) {
    updateGutters(cm);
    regChange(cm);
    setTimeout(function(){alignHorizontally(cm);}, 20);
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function updateGutters(cm) {
    var gutters = cm.display.gutters, specs = cm.options.gutters;
    removeChildren(gutters);
    for (var i = 0; i < specs.length; ++i) {
      var gutterClass = specs[i];
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
      if (gutterClass == "CodeMirror-linenumbers") {
        cm.display.lineGutter = gElt;
        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = i ? "" : "none";
    updateGutterSpace(cm);
  }

  function updateGutterSpace(cm) {
    var width = cm.display.gutters.offsetWidth;
    cm.display.sizer.style.marginLeft = width + "px";
    cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + "px" : 0;
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) return 0;
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found = merged.find(0, true);
      len -= cur.text.length - found.from.ch;
      cur = found.to.line;
      len += cur.text.length - found.to.ch;
    }
    return len;
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function(line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // Make sure the gutters options contains the element
  // "CodeMirror-linenumbers" when the lineNumbers option is true.
  function setGuttersForLineNumbers(options) {
    var found = indexOf(options.gutters, "CodeMirror-linenumbers");
    if (found == -1 && options.lineNumbers) {
      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);
    } else if (found > -1 && !options.lineNumbers) {
      options.gutters = options.gutters.slice(0);
      options.gutters.splice(found, 1);
    }
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var scroll = cm.display.scroller;
    return {
      clientHeight: scroll.clientHeight,
      barHeight: cm.display.scrollbarV.clientHeight,
      scrollWidth: scroll.scrollWidth, clientWidth: scroll.clientWidth,
      barWidth: cm.display.scrollbarH.clientWidth,
      docHeight: Math.round(cm.doc.height + paddingVert(cm.display))
    };
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbars(cm, measure) {
    if (!measure) measure = measureForScrollbars(cm);
    var d = cm.display;
    var scrollHeight = measure.docHeight + scrollerCutOff;
    var needsH = measure.scrollWidth > measure.clientWidth;
    var needsV = scrollHeight > measure.clientHeight;
    if (needsV) {
      d.scrollbarV.style.display = "block";
      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";
      // A bug in IE8 can cause this value to be negative, so guard it.
      d.scrollbarV.firstChild.style.height =
        Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + "px";
    } else {
      d.scrollbarV.style.display = "";
      d.scrollbarV.firstChild.style.height = "0";
    }
    if (needsH) {
      d.scrollbarH.style.display = "block";
      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";
      d.scrollbarH.firstChild.style.width =
        (measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth)) + "px";
    } else {
      d.scrollbarH.style.display = "";
      d.scrollbarH.firstChild.style.width = "0";
    }
    if (needsH && needsV) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";
    } else d.scrollbarFiller.style.display = "";
    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";
      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";
    } else d.gutterFiller.style.display = "";

    if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {
      if (scrollbarWidth(d.measure) === 0) {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;
        var barMouseDown = function(e) {
          if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)
            operation(cm, onMouseDown)(e);
        };
        on(d.scrollbarV, "mousedown", barMouseDown);
        on(d.scrollbarH, "mousedown", barMouseDown);
      }
      cm.state.checkedOverlayScrollbar = true;
    }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewPort may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewPort) {
    var top = viewPort && viewPort.top != null ? viewPort.top : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewPort && viewPort.bottom != null ? viewPort.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewPort && viewPort.ensure) {
      var ensureFrom = viewPort.ensure.from.line, ensureTo = viewPort.ensure.to.line;
      if (ensureFrom < from)
        return {from: ensureFrom,
                to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)};
      if (Math.min(ensureTo, doc.lastLine()) >= to)
        return {from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),
                to: ensureTo};
    }
    return {from: from, to: to};
  }

  // LINE NUMBERS

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {
      if (cm.options.fixedGutter && view[i].gutter)
        view[i].gutter.style.left = left;
      var align = view[i].alignable;
      if (align) for (var j = 0; j < align.length; j++)
        align[j].style.left = left;
    }
    if (cm.options.fixedGutter)
      display.gutters.style.left = (comp + gutterW) + "px";
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) return false;
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm);
      return true;
    }
    return false;
  }

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber));
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
  }

  // DISPLAY DRAWING

  // Updates the display, selection, and scrollbars, using the
  // information in display.view to find out which nodes are no longer
  // up-to-date. Tries to bail out early when no changes are needed,
  // unless forced is true.
  // Returns true if an actual update happened, false otherwise.
  function updateDisplay(cm, viewPort, forced) {
    var oldFrom = cm.display.viewFrom, oldTo = cm.display.viewTo, updated;
    var visible = visibleLines(cm.display, cm.doc, viewPort);
    for (var first = true;; first = false) {
      var oldWidth = cm.display.scroller.clientWidth;
      if (!updateDisplayInner(cm, visible, forced)) break;
      updated = true;

      // If the max line changed since it was last measured, measure it,
      // and ensure the document's width matches it.
      if (cm.display.maxLineChanged && !cm.options.lineWrapping)
        adjustContentWidth(cm);

      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      setDocumentHeight(cm, barMeasure);
      updateScrollbars(cm, barMeasure);
      if (webkit && cm.options.lineWrapping)
        checkForWebkitWidthBug(cm, barMeasure); // (Issue #2420)
      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {
        forced = true;
        continue;
      }
      forced = false;

      // Clip forced viewport to actual scrollable area.
      if (viewPort && viewPort.top != null)
        viewPort = {top: Math.min(barMeasure.docHeight - scrollerCutOff - barMeasure.clientHeight, viewPort.top)};
      // Updated line heights might result in the drawn area not
      // actually covering the viewport. Keep looping until it does.
      visible = visibleLines(cm.display, cm.doc, viewPort);
      if (visible.from >= cm.display.viewFrom && visible.to <= cm.display.viewTo)
        break;
    }

    cm.display.updateLineNumbers = null;
    if (updated) {
      signalLater(cm, "update", cm);
      if (cm.display.viewFrom != oldFrom || cm.display.viewTo != oldTo)
        signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
    }
    return updated;
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayInner(cm, visible, forced) {
    var display = cm.display, doc = cm.doc;
    if (!display.wrapper.offsetWidth) {
      resetView(cm);
      return;
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!forced && visible.from >= display.viewFrom && visible.to <= display.viewTo &&
        countDirtyView(cm) == 0)
      return;

    if (maybeUpdateLineNumberWidth(cm))
      resetView(cm);
    var dims = getDimensions(cm);

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);
    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastSizeC != display.wrapper.clientHeight;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !forced) return;

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var focused = activeElt();
    if (toUpdate > 4) display.lineDiv.style.display = "none";
    patchDisplay(cm, display.updateLineNumbers, dims);
    if (toUpdate > 4) display.lineDiv.style.display = "";
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();

    // Prevent selection and cursors from interfering with the scroll
    // width.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);

    if (different) {
      display.lastSizeC = display.wrapper.clientHeight;
      startWorker(cm, 400);
    }

    updateHeightsInViewport(cm);

    return true;
  }

  function adjustContentWidth(cm) {
    var display = cm.display;
    var width = measureChar(cm, display.maxLine, display.maxLine.text.length).left;
    display.maxLineChanged = false;
    var minWidth = Math.max(0, width + 3);
    var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + minWidth + scrollerCutOff - display.scroller.clientWidth);
    display.sizer.style.minWidth = minWidth + "px";
    if (maxScrollLeft < cm.doc.scrollLeft)
      setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + "px";
  }


  function checkForWebkitWidthBug(cm, measure) {
    // Work around Webkit bug where it sometimes reserves space for a
    // non-existing phantom scrollbar in the scroller (Issue #2420)
    if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {
      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = "0px";
      cm.display.gutters.style.height = measure.docHeight + "px";
    }
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], height;
      if (cur.hidden) continue;
      if (ie_upto7) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
      }
      var diff = cur.line.height - height;
      if (height < 2) height = textHeight(display);
      if (diff > .001 || diff < -.001) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)
          updateWidgetHeight(cur.rest[j]);
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)
      line.widgets[i].height = line.widgets[i].node.offsetHeight;
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      left[cm.options.gutters[i]] = n.offsetLeft;
      width[cm.options.gutters[i]] = n.offsetWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth};
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        node.style.display = "none";
      else
        node.parentNode.removeChild(node);
      return next;
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) {
      } else if (!lineView.node) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) cur = rm(cur);
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) cur = rm(cur);
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") updateLineText(cm, lineView);
      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);
      else if (type == "class") updateLineClasses(lineView);
      else if (type == "widget") updateLineWidgets(lineView, dims);
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
      lineView.node.appendChild(lineView.text);
      if (ie_upto7) lineView.node.style.zIndex = 2;
    }
    return lineView.node;
  }

  function updateLineBackground(lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) cls += " CodeMirror-linebackground";
    if (lineView.background) {
      if (cls) lineView.background.className = cls;
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built;
    }
    return buildLineContent(cm, lineView);
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) lineView.node = built.pre;
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(lineView) {
    updateLineBackground(lineView);
    if (lineView.line.wrapClass)
      ensureLineWrapped(lineView).className = lineView.line.wrapClass;
    else if (lineView.node != lineView.text)
      lineView.node.className = "";
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter =
        wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +
                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),
                          lineView.text);
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "
              + cm.display.lineNumInnerWidth + "px"));
      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {
        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +
                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
      }
    }
  }

  function updateLineWidgets(lineView, dims) {
    if (lineView.alignable) lineView.alignable = null;
    for (var node = lineView.node.firstChild, next; node; node = next) {
      var next = node.nextSibling;
      if (node.className == "CodeMirror-linewidget")
        lineView.node.removeChild(node);
    }
    insertLineWidgets(lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) lineView.bgClass = built.bgClass;
    if (built.textClass) lineView.textClass = built.textClass;

    updateLineClasses(lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(lineView, dims);
    return lineView.node;
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(lineView, dims) {
    insertLineWidgetsFor(lineView.line, lineView, dims, true);
    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);
  }

  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {
    if (!line.widgets) return;
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");
      if (!widget.handleMouseEvents) node.ignoreEvents = true;
      positionLineWidget(widget, node, lineView, dims);
      if (allowAbove && widget.above)
        wrap.insertBefore(node, lineView.gutter || lineView.text);
      else
        wrap.appendChild(node);
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
      (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";
    }
  }

  // POSITION OBJECT

  // A Pos instance represents a position within the text.
  var Pos = CodeMirror.Pos = function(line, ch) {
    if (!(this instanceof Pos)) return new Pos(line, ch);
    this.line = line; this.ch = ch;
  };

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };

  function copyPos(x) {return Pos(x.line, x.ch);}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }

  // SELECTION / CURSOR

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  function Selection(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  }

  Selection.prototype = {
    primary: function() { return this.ranges[this.primIndex]; },
    equals: function(other) {
      if (other == this) return true;
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;
      for (var i = 0; i < this.ranges.length; i++) {
        var here = this.ranges[i], there = other.ranges[i];
        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;
      }
      return true;
    },
    deepCopy: function() {
      for (var out = [], i = 0; i < this.ranges.length; i++)
        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
      return new Selection(out, this.primIndex);
    },
    somethingSelected: function() {
      for (var i = 0; i < this.ranges.length; i++)
        if (!this.ranges[i].empty()) return true;
      return false;
    },
    contains: function(pos, end) {
      if (!end) end = pos;
      for (var i = 0; i < this.ranges.length; i++) {
        var range = this.ranges[i];
        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
          return i;
      }
      return -1;
    }
  };

  function Range(anchor, head) {
    this.anchor = anchor; this.head = head;
  }

  Range.prototype = {
    from: function() { return minPos(this.anchor, this.head); },
    to: function() { return maxPos(this.anchor, this.head); },
    empty: function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    }
  };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(ranges, primIndex) {
    var prim = ranges[primIndex];
    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      if (cmp(prev.to(), cur.from()) >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) --primIndex;
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex);
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0);
  }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) return Pos(doc.first, 0);
    var last = doc.first + doc.size - 1;
    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);
    return clipToLen(pos, getLine(doc, pos.line).text.length);
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) return Pos(pos.line, linelen);
    else if (ch < 0) return Pos(pos.line, 0);
    else return pos;
  }
  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}
  function clipPosArray(doc, array) {
    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);
    return out;
  }

  // SELECTION UPDATES

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(doc, range, head, other) {
    if (doc.cm && doc.cm.display.shift || doc.extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head);
    } else {
      return new Range(other || head, head);
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options) {
    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
    var newSel = normalizeSelection(out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head));
      }
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);
    else return sel;
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      sel = filterSelectionChange(doc, sel);

    var bias = cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1;
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm)
      ensureCursorVisible(doc.cm);
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) return;

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) out = sel.ranges.slice(0, i);
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(out, sel.primIndex) : sel;
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, bias, mayClear) {
    var flipped = false, curPos = pos;
    var dir = bias || 1;
    doc.cantEdit = false;
    search: for (;;) {
      var line = getLine(doc, curPos.line);
      if (line.markedSpans) {
        for (var i = 0; i < line.markedSpans.length; ++i) {
          var sp = line.markedSpans[i], m = sp.marker;
          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&
              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
            if (mayClear) {
              signal(m, "beforeCursorEnter");
              if (m.explicitlyCleared) {
                if (!line.markedSpans) break;
                else {--i; continue;}
              }
            }
            if (!m.atomic) continue;
            var newPos = m.find(dir < 0 ? -1 : 1);
            if (cmp(newPos, curPos) == 0) {
              newPos.ch += dir;
              if (newPos.ch < 0) {
                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));
                else newPos = null;
              } else if (newPos.ch > line.text.length) {
                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);
                else newPos = null;
              }
              if (!newPos) {
                if (flipped) {
                  // Driven in a corner -- no valid cursor position found at all
                  // -- try again *with* clearing, if we didn't already
                  if (!mayClear) return skipAtomic(doc, pos, bias, true);
                  // Otherwise, turn off editing until further notice, and return the start of the doc
                  doc.cantEdit = true;
                  return Pos(doc.first, 0);
                }
                flipped = true; newPos = pos; dir = -dir;
              }
            }
            curPos = newPos;
            continue search;
          }
        }
      }
      return curPos;
    }
  }

  // SELECTION DRAWING

  // Redraw the selection and/or cursor
  function updateSelection(cm) {
    var display = cm.display, doc = cm.doc;
    var curFragment = document.createDocumentFragment();
    var selFragment = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        drawSelectionCursor(cm, range, curFragment);
      if (!collapsed)
        drawSelectionRange(cm, range, selFragment);
    }

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      var top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                     headPos.top + lineOff.top - wrapOff.top));
      var left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                      headPos.left + lineOff.left - wrapOff.left));
      display.inputDiv.style.top = top + "px";
      display.inputDiv.style.left = left + "px";
    }

    removeChildrenAndAdd(display.cursorDiv, curFragment);
    removeChildrenAndAdd(display.selectionDiv, selFragment);
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, range, output) {
    var pos = cursorCoords(cm, range.head, "div");

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;

    function add(left, top, width, bottom) {
      if (top < 0) top = 0;
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +
                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +
                               "px; height: " + (bottom - top) + "px"));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
      }

      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {
        var leftPos = coords(from, "left"), rightPos, left, right;
        if (from == to) {
          rightPos = leftPos;
          left = right = leftPos.left;
        } else {
          rightPos = coords(to - 1, "right");
          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }
          left = leftPos.left;
          right = rightPos.right;
        }
        if (fromArg == null && from == 0) left = leftSide;
        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part
          add(left, leftPos.top, null, leftPos.bottom);
          left = leftSide;
          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);
        }
        if (toArg == null && to == lineLen) right = rightSide;
        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
          start = leftPos;
        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
          end = rightPos;
        if (left < leftSide + 1) left = leftSide;
        add(left, rightPos.top, right - left, rightPos.bottom);
      });
      return {start: start, end: end};
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        add(leftSide, leftEnd.bottom, null, rightStart.top);
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) return;
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      display.blinker = setInterval(function() {
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate);
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
      cm.state.highlight.set(time, bind(highlightWorker, cm));
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.frontier < doc.first) doc.frontier = doc.first;
    if (doc.frontier >= cm.display.viewTo) return;
    var end = +new Date + cm.options.workTime;
    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));

    runInOp(cm, function() {
    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
      if (doc.frontier >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var highlighted = highlightLine(cm, line, state, true);
        line.styles = highlighted.styles;
        if (highlighted.classes) line.styleClasses = highlighted.classes;
        else if (line.styleClasses) line.styleClasses = null;
        var ischange = !oldStyles || oldStyles.length != line.styles.length;
        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
        if (ischange) regLineChange(cm, doc.frontier, "text");
        line.stateAfter = copyState(doc.mode, state);
      } else {
        processLine(cm, line.text, state);
        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
      }
      ++doc.frontier;
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true;
      }
    });
    });
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) return doc.first;
      var line = getLine(doc, search - 1);
      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline;
  }

  function getStateBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) return true;
    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;
    if (!state) state = startState(doc.mode);
    else state = copyState(doc.mode, state);
    doc.iter(pos, n, function(line) {
      processLine(cm, line.text, state);
      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
      line.stateAfter = save ? copyState(doc.mode, state) : null;
      ++pos;
    });
    if (precise) doc.frontier = pos;
    return state;
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop;}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}
  function paddingH(display) {
    if (display.cachedPaddingH) return display.cachedPaddingH;
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;
    return data;
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && cm.display.scroller.clientWidth;
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            heights.push((cur.bottom + next.top) / 2 - rect.top);
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      return {map: lineView.measure.map, cache: lineView.measure.cache};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineView.rest[i] == line)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};
    for (var i = 0; i < lineView.rest.length; i++)
      if (lineNo(lineView.rest[i]) > lineN)
        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view;
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      return cm.display.view[findViewIndex(cm, lineN)];
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      return ext;
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text)
      view = null;
    else if (view && view.changes)
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
    if (!view)
      view = updateExternalMeasurement(cm, line);

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    };
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias) {
    if (prepared.before) ch = -1;
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        prepared.rect = prepared.view.text.getBoundingClientRect();
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) prepared.cache[key] = found;
    }
    return {left: found.left, right: found.right, top: found.top, bottom: found.bottom};
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function measureCharInner(cm, prepared, ch, bias) {
    var map = prepared.map;

    var node, start, end, collapse;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      var mStart = map[i], mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) collapse = "right";
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          collapse = bias;
        if (bias == "left" && start == 0)
          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          }
        if (bias == "right" && start == mEnd - mStart)
          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          }
        break;
      }
    }

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;
      while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;
      if (ie_upto8 && start == 0 && end == mEnd - mStart) {
        rect = node.parentNode.getBoundingClientRect();
      } else if (ie && cm.options.lineWrapping) {
        var rects = range(node, start, end).getClientRects();
        if (rects.length)
          rect = rects[bias == "right" ? rects.length - 1 : 0];
        else
          rect = nullRect;
      } else {
        rect = range(node, start, end).getBoundingClientRect();
      }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) collapse = bias = "right";
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        rect = rects[bias == "right" ? rects.length - 1 : 0];
      else
        rect = node.getBoundingClientRect();
    }
    if (ie_upto8 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};
      else
        rect = nullRect;
    }

    var top, bot = (rect.bottom + rect.top) / 2 - prepared.rect.top;
    var heights = prepared.view.measure.heights;
    for (var i = 0; i < heights.length - 1; i++)
      if (bot < heights[i]) break;
    top = i ? heights[i - 1] : 0; bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) result.bogus = true;
    return result;
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)
        lineView.measure.caches[i] = {};
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      clearLineMeasurementCacheFor(cm.display.view[i]);
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;
    cm.display.lineNumChars = null;
  }

  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }
  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"/null (editor), or "page".
  function intoCoordSystem(cm, lineObj, rect, context) {
    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {
      var size = widgetHeight(lineObj.widgets[i]);
      rect.top += size; rect.bottom += size;
    }
    if (context == "line") return rect;
    if (!context) context = "local";
    var yOff = heightAtLine(lineObj);
    if (context == "local") yOff += paddingTop(cm.display);
    else yOff -= cm.display.viewOffset;
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect;
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"/null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") return coords;
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) lineObj = getLine(cm.doc, pos.line);
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left");
      if (right) m.left = m.right; else m.right = m.left;
      return intoCoordSystem(cm, lineObj, m, context);
    }
    function getBidi(ch, partPos) {
      var part = order[partPos], right = part.level % 2;
      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
        part = order[--partPos];
        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
        right = true;
      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
        part = order[++partPos];
        ch = bidiLeft(part) - part.level % 2;
        right = false;
      }
      if (right && ch == part.to && ch > part.from) return get(ch - 1);
      return get(ch, right);
    }
    var order = getOrder(lineObj), ch = pos.ch;
    if (!order) return get(ch);
    var partPos = getBidiPartAt(order, ch);
    var val = getBidi(ch, partPos);
    if (bidiOther != null) val.other = getBidi(ch, bidiOther);
    return val;
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0, pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height};
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, outside, xRel) {
    var pos = Pos(line, ch);
    pos.xRel = xRel;
    if (outside) pos.outside = true;
    return pos;
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
    if (x < 0) x = 0;

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var merged = collapsedSpanAtEnd(lineObj);
      var mergedPos = merged && merged.find(0, true);
      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
        lineN = lineNo(lineObj = mergedPos.to.line);
      else
        return found;
    }
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    var innerOff = y - heightAtLine(lineObj);
    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);

    function getX(ch) {
      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);
      wrongLine = true;
      if (innerOff > sp.bottom) return sp.left - adjust;
      else if (innerOff < sp.top) return sp.left + adjust;
      else wrongLine = false;
      return sp.left;
    }

    var bidi = getOrder(lineObj), dist = lineObj.text.length;
    var from = lineLeft(lineObj), to = lineRight(lineObj);
    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;

    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);
    // Do a binary search between these bounds.
    for (;;) {
      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
        var ch = x < fromX || x - fromX <= toX - x ? from : to;
        var xDiff = x - (ch == from ? fromX : toX);
        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;
        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,
                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
        return pos;
      }
      var step = Math.ceil(dist / 2), middle = from + step;
      if (bidi) {
        middle = from;
        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);
      }
      var middleX = getX(middle);
      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}
      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}
    }
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) return display.cachedTextHeight;
    if (measureText == null) {
      measureText = elt("pre");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) display.cachedTextHeight = height;
    removeChildren(display.measure);
    return height || 1;
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) return display.cachedCharWidth;
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor]);
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) display.cachedCharWidth = width;
    return width || 10;
  }

  // OPERATIONS

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: null,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      id: ++nextOpId           // Unique ID
    };
    if (!delayedCallbackDepth++) delayedCallbacks = [];
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp, doc = cm.doc, display = cm.display;
    cm.curOp = null;

    if (op.updateMaxLine) findMaxLine(cm);

    // If it looks like an update might be needed, call updateDisplay
    if (op.viewChanged || op.forceUpdate || op.scrollTop != null ||
        op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                           op.scrollToPos.to.line >= display.viewTo) ||
        display.maxLineChanged && cm.options.lineWrapping) {
      var updated = updateDisplay(cm, {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;
    }
    // If no update was run, but the selection changed, redraw that.
    if (!updated && op.selectionChanged) updateSelection(cm);
    if (!updated && op.startHeight != cm.doc.height) updateScrollbars(cm);

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null && display.scroller.scrollTop != op.scrollTop) {
      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;
    }
    if (op.scrollLeft != null && display.scroller.scrollLeft != op.scrollLeft) {
      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));
      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;
      alignHorizontally(cm);
    }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var coords = scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),
                                     clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);
      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);
    }

    if (op.selectionChanged) restartBlink(cm);

    if (cm.state.focused && op.updateInput)
      resetInput(cm, op.typing);

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) for (var i = 0; i < hidden.length; ++i)
      if (!hidden[i].lines.length) signal(hidden[i], "hide");
    if (unhidden) for (var i = 0; i < unhidden.length; ++i)
      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");

    var delayed;
    if (!--delayedCallbackDepth) {
      delayed = delayedCallbacks;
      delayedCallbacks = null;
    }
    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      signal(cm, "changes", cm, op.changeObjs);
    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();
    if (op.cursorActivityHandlers)
      for (var i = 0; i < op.cursorActivityHandlers.length; i++)
        op.cursorActivityHandlers[i](cm);
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) return f();
    startOperation(cm);
    try { return f(); }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) return f.apply(cm, arguments);
      startOperation(cm);
      try { return f.apply(cm, arguments); }
      finally { endOperation(cm); }
    };
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) return f.apply(this, arguments);
      startOperation(this);
      try { return f.apply(this, arguments); }
      finally { endOperation(this); }
    };
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) return f.apply(this, arguments);
      startOperation(cm);
      try { return f.apply(this, arguments); }
      finally { endOperation(cm); }
    };
  }

  // VIEW TRACKING

  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array;
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) from = cm.doc.first;
    if (to == null) to = cm.doc.first + cm.doc.size;
    if (!lendiff) lendiff = 0;

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      display.updateLineNumbers = from;

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        resetView(cm);
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut = viewCuttingPoint(cm, from, from, -1);
      if (cut) {
        display.view = display.view.slice(0, cut.index);
        display.viewTo = cut.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        ext.lineN += lendiff;
      else if (from < ext.lineN + ext.size)
        display.externalMeasured = null;
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      display.externalMeasured = null;

    if (line < display.viewFrom || line >= display.viewTo) return;
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) return;
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) arr.push(type);
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) return null;
    n -= cm.display.viewFrom;
    if (n < 0) return null;
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) return i;
    }
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans) return {index: index, lineN: newN};
    for (var i = 0, n = cm.display.viewFrom; i < index; i++)
      n += view[i].size;
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) return null;
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) return null;
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN};
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
      else if (display.viewFrom < from)
        display.view = display.view.slice(findViewIndex(cm, from));
      display.viewFrom = from;
      if (display.viewTo < to)
        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
      else if (display.viewTo > to)
        display.view = display.view.slice(0, findViewIndex(cm, to));
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;
    }
    return dirty;
  }

  // INPUT HANDLING

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  function slowPoll(cm) {
    if (cm.display.pollingFast) return;
    cm.display.poll.set(cm.options.pollInterval, function() {
      readInput(cm);
      if (cm.state.focused) slowPoll(cm);
    });
  }

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  function fastPoll(cm) {
    var missed = false;
    cm.display.pollingFast = true;
    function p() {
      var changed = readInput(cm);
      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}
      else {cm.display.pollingFast = false; slowPoll(cm);}
    }
    cm.display.poll.set(20, p);
  }

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  function readInput(cm) {
    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput)
      return false;
    // See paste handler for more on the fakedLastChar kludge
    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
      input.value = input.value.substring(0, input.value.length - 1);
      cm.state.fakedLastChar = false;
    }
    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) return false;
    // Work around nonsensical selection resetting in IE9/10
    if (ie && !ie_upto8 && cm.display.inputHasSelection === text) {
      resetInput(cm);
      return false;
    }

    var withOp = !cm.curOp;
    if (withOp) startOperation(cm);
    cm.display.shift = false;

    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;
    var inserted = text.slice(same), textLines = splitLines(inserted);

    // When pasing N lines into N selections, insert one line per selection
    var multiPaste = cm.state.pasteIncoming && textLines.length > 1 && doc.sel.ranges.length == textLines.length;

    // Normal behavior is to insert the new text into every selection
    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {
      var range = doc.sel.ranges[i];
      var from = range.from(), to = range.to();
      // Handle deletion
      if (same < prevInput.length)
        from = Pos(from.line, from.ch - (prevInput.length - same));
      // Handle overwrite
      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)
        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
      var updateInput = cm.curOp.updateInput;
      var changeEvent = {from: from, to: to, text: multiPaste ? [textLines[i]] : textLines,
                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
      // When an 'electric' character is inserted, immediately trigger a reindent
      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&
          cm.options.smartIndent && range.head.ch < 100 &&
          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {
        var mode = cm.getModeAt(range.head);
        if (mode.electricChars) {
          for (var j = 0; j < mode.electricChars.length; j++)
            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
              indentLine(cm, range.head.line, "smart");
              break;
            }
        } else if (mode.electricInput) {
          var end = changeEnd(changeEvent);
          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
            indentLine(cm, range.head.line, "smart");
        }
      }
    }
    ensureCursorVisible(cm);
    cm.curOp.updateInput = updateInput;
    cm.curOp.typing = true;

    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf("\n") > -1) input.value = cm.display.prevInput = "";
    else cm.display.prevInput = text;
    if (withOp) endOperation(cm);
    cm.state.pasteIncoming = cm.state.cutIncoming = false;
    return true;
  }

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  function resetInput(cm, typing) {
    var minimal, selected, doc = cm.doc;
    if (cm.somethingSelected()) {
      cm.display.prevInput = "";
      var range = doc.sel.primary();
      minimal = hasCopyEvent &&
        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
      var content = minimal ? "-" : selected || cm.getSelection();
      cm.display.input.value = content;
      if (cm.state.focused) selectInput(cm.display.input);
      if (ie && !ie_upto8) cm.display.inputHasSelection = content;
    } else if (!typing) {
      cm.display.prevInput = cm.display.input.value = "";
      if (ie && !ie_upto8) cm.display.inputHasSelection = null;
    }
    cm.display.inaccurateSelection = minimal;
  }

  function focusInput(cm) {
    if (cm.options.readOnly != "nocursor" && (!mobile || activeElt() != cm.display.input))
      cm.display.input.focus();
  }

  function ensureFocus(cm) {
    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }
  }

  function isReadOnly(cm) {
    return cm.options.readOnly || cm.doc.cantEdit;
  }

  // EVENT HANDLERS

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie_upto10)
      on(d.scroller, "dblclick", operation(cm, function(e) {
        if (signalDOMEvent(cm, e)) return;
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;
        e_preventDefault(e);
        var word = findWordAt(cm.doc, pos);
        extendSelection(cm.doc, word.anchor, word.head);
      }));
    else
      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });
    // Prevent normal selection in the editor (we handle our own)
    on(d.lineSpace, "selectstart", function(e) {
      if (!eventInWidget(d, e)) e_preventDefault(e);
    });
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function() {
      if (d.scroller.clientHeight) {
        setScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });
    on(d.scrollbarV, "scroll", function() {
      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);
    });
    on(d.scrollbarH, "scroll", function() {
      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});
    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});

    // Prevent clicks in the scrollbars from killing focus
    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }
    on(d.scrollbarH, "mousedown", reFocus);
    on(d.scrollbarV, "mousedown", reFocus);
    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    function onResize() {
      if (resizeTimer == null) resizeTimer = setTimeout(function() {
        resizeTimer = null;
        // Might be a text scaling operation, clear size caches.
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = knownScrollbarWidth = null;
        cm.setSize();
      }, 100);
    }
    on(window, "resize", onResize);
    // The above handler holds on to the editor and its data
    // structures. Here we poll to unregister it when the editor is no
    // longer in the document, so that it can be garbage-collected.
    function unregister() {
      if (contains(document.body, d.wrapper)) setTimeout(unregister, 5000);
      else off(window, "resize", onResize);
    }
    setTimeout(unregister, 5000);

    on(d.input, "keyup", operation(cm, onKeyUp));
    on(d.input, "input", function() {
      if (ie && !ie_upto8 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;
      fastPoll(cm);
    });
    on(d.input, "keydown", operation(cm, onKeyDown));
    on(d.input, "keypress", operation(cm, onKeyPress));
    on(d.input, "focus", bind(onFocus, cm));
    on(d.input, "blur", bind(onBlur, cm));

    function drag_(e) {
      if (!signalDOMEvent(cm, e)) e_stop(e);
    }
    if (cm.options.dragDrop) {
      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});
      on(d.scroller, "dragenter", drag_);
      on(d.scroller, "dragover", drag_);
      on(d.scroller, "drop", operation(cm, onDrop));
    }
    on(d.scroller, "paste", function(e) {
      if (eventInWidget(d, e)) return;
      cm.state.pasteIncoming = true;
      focusInput(cm);
      fastPoll(cm);
    });
    on(d.input, "paste", function() {
      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206
      // Add a char to the end of textarea before paste occur so that
      // selection doesn't span to the end of textarea.
      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {
        var start = d.input.selectionStart, end = d.input.selectionEnd;
        d.input.value += "$";
        d.input.selectionStart = start;
        d.input.selectionEnd = end;
        cm.state.fakedLastChar = true;
      }
      cm.state.pasteIncoming = true;
      fastPoll(cm);
    });

    function prepareCopyCut(e) {
      if (cm.somethingSelected()) {
        if (d.inaccurateSelection) {
          d.prevInput = "";
          d.inaccurateSelection = false;
          d.input.value = cm.getSelection();
          selectInput(d.input);
        }
      } else {
        var text = "", ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
          var line = cm.doc.sel.ranges[i].head.line;
          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
          ranges.push(lineRange);
          text += cm.getRange(lineRange.anchor, lineRange.head);
        }
        if (e.type == "cut") {
          cm.setSelections(ranges, null, sel_dontScroll);
        } else {
          d.prevInput = "";
          d.input.value = text;
          selectInput(d.input);
        }
      }
      if (e.type == "cut") cm.state.cutIncoming = true;
    }
    on(d.input, "cut", prepareCopyCut);
    on(d.input, "copy", prepareCopyCut);

    // Needed to handle Tab key in KHTML
    if (khtml) on(d.sizer, "mouseup", function() {
      if (activeElt() == d.input) d.input.blur();
      focusInput(cm);
    });
  }

  // MOUSE EVENTS

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;
    }
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal) {
      var target = e_target(e);
      if (target == display.scrollbarH || target == display.scrollbarV ||
          target == display.scrollbarFiller || target == display.gutterFiller) return null;
    }
    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e) { return null; }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords;
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    if (signalDOMEvent(this, e)) return;
    var cm = this, display = cm.display;
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function(){display.scroller.draggable = true;}, 100);
      }
      return;
    }
    if (clickInGutter(cm, e)) return;
    var start = posFromMouse(cm, e);
    window.focus();

    switch (e_button(e)) {
    case 1:
      if (start)
        leftButtonDown(cm, e, start);
      else if (e_target(e) == display.scroller)
        e_preventDefault(e);
      break;
    case 2:
      if (webkit) cm.state.lastMiddleDown = +new Date;
      if (start) extendSelection(cm.doc, start);
      setTimeout(bind(focusInput, cm), 20);
      e_preventDefault(e);
      break;
    case 3:
      if (captureRightClick) onContextMenu(cm, e);
      break;
    }
  }

  var lastClick, lastDoubleClick;
  function leftButtonDown(cm, e, start) {
    setTimeout(bind(ensureFocus, cm), 0);

    var now = +new Date, type;
    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
      type = "triple";
    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
      type = "double";
      lastDoubleClick = {time: now, pos: start};
    } else {
      type = "single";
      lastClick = {time: now, pos: start};
    }

    var sel = cm.doc.sel, addNew = mac ? e.metaKey : e.ctrlKey;
    if (cm.options.dragDrop && dragAndDrop && !addNew && !isReadOnly(cm) &&
        type == "single" && sel.contains(start) > -1 && sel.somethingSelected())
      leftButtonStartDrag(cm, e, start);
    else
      leftButtonSelect(cm, e, start, type, addNew);
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, e, start) {
    var display = cm.display;
    var dragEnd = operation(cm, function(e2) {
      if (webkit) display.scroller.draggable = false;
      cm.state.draggingText = false;
      off(document, "mouseup", dragEnd);
      off(display.scroller, "drop", dragEnd);
      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
        e_preventDefault(e2);
        extendSelection(cm.doc, start);
        focusInput(cm);
        // Work around unexplainable focus problem in IE9 (#2127)
        if (ie_upto10 && !ie_upto8)
          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);
      }
    });
    // Let the drag handler handle this.
    if (webkit) display.scroller.draggable = true;
    cm.state.draggingText = dragEnd;
    // IE's approach to draggable
    if (display.scroller.dragDrop) display.scroller.dragDrop();
    on(document, "mouseup", dragEnd);
    on(display.scroller, "drop", dragEnd);
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, e, start, type, addNew) {
    var display = cm.display, doc = cm.doc;
    e_preventDefault(e);

    var ourRange, ourIndex, startSel = doc.sel;
    if (addNew && !e.shiftKey) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        ourRange = doc.sel.ranges[ourIndex];
      else
        ourRange = new Range(start, start);
    } else {
      ourRange = doc.sel.primary();
    }

    if (e.altKey) {
      type = "rect";
      if (!addNew) ourRange = new Range(start, start);
      start = posFromMouse(cm, e, true, true);
      ourIndex = -1;
    } else if (type == "double") {
      var word = findWordAt(doc, start);
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, word.anchor, word.head);
      else
        ourRange = word;
    } else if (type == "triple") {
      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
      if (cm.display.shift || doc.extend)
        ourRange = extendRange(doc, ourRange, line.anchor, line.head);
      else
        ourRange = line;
    } else {
      ourRange = extendRange(doc, ourRange, start);
    }

    if (!addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex > -1) {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    } else {
      ourIndex = doc.sel.ranges.length;
      setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) return;
      lastPos = pos;

      if (type == "rect") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
          else if (text.length > leftPos)
            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
        }
        if (!ranges.length) ranges.push(new Range(start, start));
        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), sel_mouse);
      } else {
        var oldRange = ourRange;
        var anchor = oldRange.anchor, head = pos;
        if (type != "single") {
          if (type == "double")
            var range = findWordAt(doc, pos);
          else
            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
          if (cmp(range.anchor, anchor) > 0) {
            head = range.head;
            anchor = minPos(oldRange.from(), range.anchor);
          } else {
            head = range.anchor;
            anchor = maxPos(oldRange.to(), range.head);
          }
        }
        var ranges = startSel.ranges.slice(0);
        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, type == "rect");
      if (!cur) return;
      if (cmp(cur, lastPos) != 0) {
        ensureFocus(cm);
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) setTimeout(operation(cm, function() {
          if (counter != curCount) return;
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50);
      }
    }

    function done(e) {
      counter = Infinity;
      e_preventDefault(e);
      focusInput(cm);
      off(document, "mousemove", move);
      off(document, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function(e) {
      if ((ie && !ie_upto9) ?  !e.buttons : !e_button(e)) done(e);
      else extend(e);
    });
    var up = operation(cm, done);
    on(document, "mousemove", move);
    on(document, "mouseup", up);
  }

  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent, signalfn) {
    try { var mX = e.clientX, mY = e.clientY; }
    catch(e) { return false; }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;
    if (prevent) e_preventDefault(e);

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.options.gutters.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.options.gutters[i];
        signalfn(cm, type, cm, line, gutter, e);
        return e_defaultPrevented(e);
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true, signalLater);
  }

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      return;
    e_preventDefault(e);
    if (ie) lastDrop = +new Date;
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || isReadOnly(cm)) return;
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var loadFile = function(file, i) {
        var reader = new FileReader;
        reader.onload = operation(cm, function() {
          text[i] = reader.result;
          if (++read == n) {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos, text: splitLines(text.join("\n")), origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
          }
        });
        reader.readAsText(file);
      };
      for (var i = 0; i < n; ++i) loadFile(files[i], i);
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(bind(focusInput, cm), 20);
        return;
      }
      try {
        var text = e.dataTransfer.getData("Text");
        if (text) {
          var selected = cm.state.draggingText && cm.listSelections();
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) for (var i = 0; i < selected.length; ++i)
            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");
          cm.replaceSelection(text, "around", "paste");
          focusInput(cm);
        }
      }
      catch(e){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;

    e.dataTransfer.setData("Text", cm.getSelection());

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) img.parentNode.removeChild(img);
    }
  }

  // SCROLL EVENTS

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function setScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) return;
    cm.doc.scrollTop = val;
    if (!gecko) updateDisplay(cm, {top: val});
    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;
    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;
    if (gecko) updateDisplay(cm);
    startWorker(cm, 100);
  }
  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller) {
    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;
    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;
    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) wheelPixelsPerUnit = -.53;
  else if (gecko) wheelPixelsPerUnit = 15;
  else if (chrome) wheelPixelsPerUnit = -.7;
  else if (safari) wheelPixelsPerUnit = -1/3;

  function onScrollWheel(cm, e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;
    else if (dy == null) dy = e.wheelDelta;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||
          dy && scroll.scrollHeight > scroll.clientHeight)) return;

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer;
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy)
        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
      e_preventDefault(e);
      display.wheelStartX = null; // Abort measurement, if in progress
      return;
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) top = Math.max(0, top + pixels - 50);
      else bot = Math.min(cm.doc.height, bot + pixels + 50);
      updateDisplay(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function() {
          if (display.wheelStartX == null) return;
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) return;
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // KEY EVENTS

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) return false;
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;
    var prevShift = cm.display.shift, done = false;
    try {
      if (isReadOnly(cm)) cm.state.suppressEdits = true;
      if (dropShift) cm.display.shift = false;
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done;
  }

  // Collect the currently active keymaps.
  function allKeyMaps(cm) {
    var maps = cm.state.keyMaps.slice(0);
    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);
    maps.push(cm.options.keyMap);
    return maps;
  }

  var maybeTransition;
  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    // Handle automatic keymap transitions
    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;
    clearTimeout(maybeTransition);
    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {
      if (getKeyMap(cm.options.keyMap) == startMap) {
        cm.options.keyMap = (next.call ? next.call(null, cm) : next);
        keyMapChanged(cm);
      }
    }, 50);

    var name = keyName(e, true), handled = false;
    if (!name) return false;
    var keymaps = allKeyMaps(cm);

    if (e.shiftKey) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})
             || lookupKey(name, keymaps, function(b) {
                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
                });
    } else {
      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });
    }

    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, name, e);
    }
    return handled;
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),
                            function(b) { return doHandleBinding(cm, b, true); });
    if (handled) {
      e_preventDefault(e);
      restartBlink(cm);
      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);
    }
    return handled;
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    ensureFocus(cm);
    if (signalDOMEvent(cm, e)) return;
    // IE does strange things with escape.
    if (ie_upto10 && e.keyCode == 27) e.returnValue = false;
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        cm.replaceSelection("", null, "cut");
    }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      showCrossHair(cm);
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (signalDOMEvent(this, e)) return;
    if (e.keyCode == 16) this.doc.sel.shift = false;
  }

  function onKeyPress(e) {
    var cm = this;
    if (signalDOMEvent(cm, e)) return;
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}
    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    if (handleCharBinding(cm, e, ch)) return;
    if (ie && !ie_upto8) cm.display.inputHasSelection = null;
    fastPoll(cm);
  }

  // FOCUS/BLUR EVENTS

  function onFocus(cm) {
    if (cm.options.readOnly == "nocursor") return;
    if (!cm.state.focused) {
      signal(cm, "focus", cm);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // The prevInput test prevents this from firing when a context
      // menu is closed (since the resetInput would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu == cm.doc.sel) {
        resetInput(cm);
        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730
      }
    }
    slowPoll(cm);
    restartBlink(cm);
  }
  function onBlur(cm) {
    if (cm.state.focused) {
      signal(cm, "blur", cm);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);
  }

  // CONTEXT MENU HANDLING

  var detectingSelectAll;
  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (signalDOMEvent(cm, e, "contextmenu")) return;
    var display = cm.display;
    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;

    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) return; // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);

    var oldCSS = display.input.style.cssText;
    display.inputDiv.style.position = "absolute";
    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +
      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +
      (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
      "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    focusInput(cm);
    resetInput(cm);
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) display.input.value = display.prevInput = " ";
    display.selForContextMenu = cm.doc.sel;

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (display.input.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = display.input.value = "\u200b" + (selected ? display.input.value : "");
        display.prevInput = selected ? "" : "\u200b";
        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;
      }
    }
    function rehide() {
      display.inputDiv.style.position = "relative";
      display.input.style.cssText = oldCSS;
      if (ie_upto8) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;
      slowPoll(cm);

      // Try to detect the user choosing select-all
      if (display.input.selectionStart != null) {
        if (!ie || ie_upto8) prepareSelectAllHack();
        clearTimeout(detectingSelectAll);
        var i = 0, poll = function() {
          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)
            operation(cm, commands.selectAll)(cm);
          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);
          else resetInput(cm);
        };
        detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && !ie_upto8) prepareSelectAllHack();
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function() {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) return false;
    return gutterEvent(cm, e, "gutterContextMenu", false, signal);
  }

  // UPDATING

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  var changeEnd = CodeMirror.changeEnd = function(change) {
    if (!change.text) return change.to;
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
  };

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) return pos;
    if (cmp(pos, change.to) <= 0) return changeEnd(change);

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;
    return Pos(line, ch);
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(out, doc.sel.primIndex);
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      return Pos(nw.line, pos.ch - old.ch + nw.ch);
    else
      return Pos(nw.line + (pos.line - old.line), pos.ch);
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex);
  }

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function() { this.canceled = true; }
    };
    if (update) obj.update = function(from, to, text, origin) {
      if (from) this.from = clipPos(doc, from);
      if (to) this.to = clipPos(doc, to);
      if (text) this.text = text;
      if (origin !== undefined) this.origin = origin;
    };
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);

    if (obj.canceled) return null;
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
      if (doc.cm.state.suppressEdits) return;
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) return;
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function(doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    if (doc.cm && doc.cm.state.suppressEdits) return;

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    for (var i = 0; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        break;
    }
    if (i == source.length) return;
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return;
        }
        selAfter = event;
      }
      else break;
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    for (var i = event.changes.length - 1; i >= 0; --i) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return;
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change, null) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (doc.cm) ensureCursorVisible(doc.cm);
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function(doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function(range) {
      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),
                       Pos(range.head.line + distance, range.head.ch));
    }), doc.sel.primIndex);
    if (doc.cm) regChange(doc.cm, doc.first, doc.first - distance, distance);
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return;
    }
    if (change.from.line > doc.lastLine()) return;

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);
    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);
    else updateDoc(doc, change, spans);
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function(line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true;
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      signalCursorActivity(cm);

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;
    }

    // Adjust frontier, schedule worker
    doc.frontier = Math.min(doc.frontier, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      regLineChange(cm, from.line, "text");
    else
      regChange(cm, from.line, to.line + 1, lendiff);

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) signalLater(cm, "change", cm, obj);
      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
    }
  }

  function replaceRange(doc, code, from, to, origin) {
    if (!to) to = from;
    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }
    if (typeof code == "string") code = splitLines(code);
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, coords) {
    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (coords.top + box.top < 0) doScroll = true;
    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, "position: absolute; top: " +
                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +
                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +
                           coords.left + "px; width: 2px;");
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) margin = 0;
    for (;;) {
      var changed = false, coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),
                                         Math.min(coords.top, endCoords.top) - margin,
                                         Math.max(coords.left, endCoords.left),
                                         Math.max(coords.bottom, endCoords.bottom) + margin);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        setScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;
      }
      if (!changed) return coords;
    }
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, x1, y1, x2, y2) {
    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);
    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, x1, y1, x2, y2) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (y1 < 0) y1 = 0;
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = display.scroller.clientHeight - scrollerCutOff, result = {};
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
    if (y1 < screentop) {
      result.scrollTop = atTop ? 0 : y1;
    } else if (y2 > screentop + screen) {
      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
      if (newTop != screentop) result.scrollTop = newTop;
    }

    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
    var screenw = display.scroller.clientWidth - scrollerCutOff;
    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;
    var gutterw = display.gutters.offsetWidth;
    var atLeft = x1 < gutterw + 10;
    if (x1 < screenleft + gutterw || atLeft) {
      if (atLeft) x1 = 0;
      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);
    } else if (x2 > screenw + screenleft - 3) {
      result.scrollLeft = x2 + 10 - screenw;
    }
    return result;
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollPos(cm, left, top) {
    if (left != null || top != null) resolveScrollToPos(cm);
    if (left != null)
      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
    if (top != null)
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor(), from = cur, to = cur;
    if (!cm.options.lineWrapping) {
      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
      to = Pos(cur.line, cur.ch + 1);
    }
    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),
                                    Math.min(from.top, to.top) - range.margin,
                                    Math.max(from.right, to.right),
                                    Math.max(from.bottom, to.bottom) + range.margin);
      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
    }
  }

  // API UTILITIES

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) how = "add";
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!cm.doc.mode.indent) how = "prev";
      else state = getStateBefore(cm, n);
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) line.stateAfter = null;
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass) {
        if (!aggressive) return;
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);
      else indentation = 0;
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";}
    if (pos < indentation) indentString += spaceStr(indentation - pos);

    if (indentString != curSpaceString) {
      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i = 0; i < doc.sel.ranges.length; i++) {
        var range = doc.sel.ranges[i];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i, new Range(pos, pos));
          break;
        }
      }
    }
    line.stateAfter = null;
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(cm, handle, changeType, op) {
    var no = handle, line = handle, doc = cm.doc;
    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));
    else no = lineNo(handle);
    if (no == null) return null;
    if (op(line, no)) regLineChange(cm, no, changeType);
    return line;
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break;
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function() {
      for (var i = kill.length - 1; i >= 0; i--)
        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
      ensureCursorVisible(cm);
    });
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "char", "column" (like char, but doesn't
  // cross line boundaries), "word" (across next word), or "group" (to
  // the start of next group of word or non-word-non-whitespace
  // chars). The visually param controls whether, in right-to-left
  // text, direction 1 means to move towards the next index in the
  // string, or towards the character to the right of the current
  // position. The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var line = pos.line, ch = pos.ch, origDir = dir;
    var lineObj = getLine(doc, line);
    var possible = true;
    function findNextLine() {
      var l = line + dir;
      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);
      line = l;
      return lineObj = getLine(doc, l);
    }
    function moveOnce(boundToLine) {
      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
      if (next == null) {
        if (!boundToLine && findNextLine()) {
          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
          else ch = dir < 0 ? lineObj.text.length : 0;
        } else return (possible = false);
      } else ch = next;
      return true;
    }

    if (unit == "char") moveOnce();
    else if (unit == "column") moveOnce(true);
    else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) break;
        var cur = lineObj.text.charAt(ch) || "\n";
        var type = isWordChar(cur) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) type = "s";
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce();}
          break;
        }

        if (type) sawType = type;
        if (dir > 0 && !moveOnce(!first)) break;
      }
    }
    var result = skipAtomic(doc, Pos(line, ch), origDir, true);
    if (!possible) result.hitSide = true;
    return result;
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));
    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    for (;;) {
      var target = coordsChar(cm, x, y);
      if (!target.outside) break;
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }
      y += dir * 5;
    }
    return target;
  }

  // Find the word at the given position (as returned by coordsChar).
  function findWordAt(doc, pos) {
    var line = getLine(doc, pos.line).text;
    var start = pos.ch, end = pos.ch;
    if (line) {
      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;
      var startChar = line.charAt(start);
      var check = isWordChar(startChar) ? isWordChar
        : /\s/.test(startChar) ? function(ch) {return /\s/.test(ch);}
        : function(ch) {return !/\s/.test(ch) && !isWordChar(ch);};
      while (start > 0 && check(line.charAt(start - 1))) --start;
      while (end < line.length && check(line.charAt(end))) ++end;
    }
    return new Range(Pos(pos.line, start), Pos(pos.line, end));
  }

  // EDITOR METHODS

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); focusInput(this); fastPoll(this);},

    setOption: function(option, value) {
      var options = this.options, old = options[option];
      if (options[option] == value && option != "mode") return;
      options[option] = value;
      if (optionHandlers.hasOwnProperty(option))
        operation(this, optionHandlers[option])(this, value, old);
    },

    getOption: function(option) {return this.options[option];},
    getDoc: function() {return this.doc;},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](map);
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps;
      for (var i = 0; i < maps.length; ++i)
        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {
          maps.splice(i, 1);
          return true;
        }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
      if (mode.startState) throw new Error("Overlays may not be stateful.");
      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});
      this.state.modeGen++;
      regChange(this);
    }),
    removeOverlay: methodOp(function(spec) {
      var overlays = this.state.overlays;
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec;
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1);
          this.state.modeGen++;
          regChange(this);
          return;
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";
        else dir = dir ? "add" : "subtract";
      }
      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);
    }),
    indentSelection: methodOp(function(how) {
      var ranges = this.doc.sel.ranges, end = -1;
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (!range.empty()) {
          var start = Math.max(end, range.from().line);
          var to = range.to();
          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
          for (var j = start; j < end; ++j)
            indentLine(this, j, how);
        } else if (range.head.line > end) {
          indentLine(this, range.head.line, how, true);
          end = range.head.line;
          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      var doc = this.doc;
      pos = clipPos(doc, pos);
      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;
      var line = getLine(doc, pos.line);
      var stream = new StringStream(line.text, this.options.tabSize);
      while (stream.pos < pos.ch && !stream.eol()) {
        stream.start = stream.pos;
        var style = readToken(mode, stream, state);
      }
      return {start: stream.start,
              end: stream.pos,
              string: stream.current(),
              type: style || null,
              state: state};
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos);
      var styles = getLineStyles(this, getLine(this.doc, pos.line));
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
      var type;
      if (ch == 0) type = styles[2];
      else for (;;) {
        var mid = (before + after) >> 1;
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;
        else if (styles[mid * 2 + 1] < ch) before = mid + 1;
        else { type = styles[mid * 2 + 2]; break; }
      }
      var cut = type ? type.indexOf("cm-overlay ") : -1;
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode;
      if (!mode.innerMode) return mode;
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0];
    },

    getHelpers: function(pos, type) {
      var found = [];
      if (!helpers.hasOwnProperty(type)) return helpers;
      var help = helpers[type], mode = this.getModeAt(pos);
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) found.push(help[mode[type]]);
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]];
          if (val) found.push(val);
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType]);
      } else if (help[mode.name]) {
        found.push(help[mode.name]);
      }
      for (var i = 0; i < help._global.length; i++) {
        var cur = help._global[i];
        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
          found.push(cur.val);
      }
      return found;
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc;
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
      return getStateBefore(this, line + 1, precise);
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary();
      if (start == null) pos = range.head;
      else if (typeof start == "object") pos = clipPos(this.doc, start);
      else pos = start ? range.from() : range.to();
      return cursorCoords(this, pos, mode || "page");
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page");
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page");
      return coordsChar(this, coords.left, coords.top);
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
      return lineAtHeight(this.doc, height + this.display.viewOffset);
    },
    heightAtLine: function(line, mode) {
      var end = false, last = this.doc.first + this.doc.size - 1;
      if (line < this.doc.first) line = this.doc.first;
      else if (line > last) { line = last; end = true; }
      var lineObj = getLine(this.doc, line);
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0);
    },

    defaultTextHeight: function() { return textHeight(this.display); },
    defaultCharWidth: function() { return charWidth(this.display); },

    setGutterMarker: methodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function(line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) line.gutterMarkers = null;
        return true;
      });
    }),

    clearGutter: methodOp(function(gutterID) {
      var cm = this, doc = cm.doc, i = doc.first;
      doc.iter(function(line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          line.gutterMarkers[gutterID] = null;
          regLineChange(cm, i, "gutter");
          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;
        }
        ++i;
      });
    }),

    addLineClass: methodOp(function(handle, where, cls) {
      return changeLine(this, handle, "class", function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        if (!line[prop]) line[prop] = cls;
        else if (new RegExp("(?:^|\\s)" + cls + "(?:$|\\s)").test(line[prop])) return false;
        else line[prop] += " " + cls;
        return true;
      });
    }),

    removeLineClass: methodOp(function(handle, where, cls) {
      return changeLine(this, handle, "class", function(line) {
        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) return false;
        else if (cls == null) line[prop] = null;
        else {
          var found = cur.match(new RegExp("(?:^|\\s+)" + cls + "(?:$|\\s+)"));
          if (!found) return false;
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true;
      });
    }),

    addLineWidget: methodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options);
    }),

    removeLineWidget: function(widget) { widget.clear(); },

    lineInfo: function(line) {
      if (typeof line == "number") {
        if (!isLine(this.doc, line)) return null;
        var n = line;
        line = getLine(this.doc, line);
        if (!line) return null;
      } else {
        var n = lineNo(line);
        if (n == null) return null;
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets};
    },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display;
      pos = cursorCoords(this, clipPos(this.doc, pos));
      var top = pos.bottom, left = pos.left;
      node.style.position = "absolute";
      display.sizer.appendChild(node);
      if (vert == "over") {
        top = pos.top;
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          top = pos.top - node.offsetHeight;
        else if (pos.bottom + node.offsetHeight <= vspace)
          top = pos.bottom;
        if (left + node.offsetWidth > hspace)
          left = hspace - node.offsetWidth;
      }
      node.style.top = top + "px";
      node.style.left = node.style.right = "";
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth;
        node.style.right = "0px";
      } else {
        if (horiz == "left") left = 0;
        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;
        node.style.left = left + "px";
      }
      if (scroll)
        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: methodOp(onKeyUp),

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        return commands[cmd](this);
    },

    findPosH: function(from, amount, unit, visually) {
      var dir = 1;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        cur = findPosH(this.doc, cur, dir, unit, visually);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveH: methodOp(function(dir, unit) {
      var cm = this;
      cm.extendSelectionsBy(function(range) {
        if (cm.display.shift || cm.doc.extend || range.empty())
          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
        else
          return dir < 0 ? range.from() : range.to();
      }, sel_move);
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc;
      if (sel.somethingSelected())
        doc.replaceSelection("", null, "+delete");
      else
        deleteNearSelection(this, function(range) {
          var other = findPosH(doc, range.head, dir, unit, false);
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};
        });
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var dir = 1, x = goalColumn;
      if (amount < 0) { dir = -1; amount = -amount; }
      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
        var coords = cursorCoords(this, cur, "div");
        if (x == null) x = coords.left;
        else coords.left = x;
        cur = findPosV(this, coords, dir, unit);
        if (cur.hitSide) break;
      }
      return cur;
    },

    moveV: methodOp(function(dir, unit) {
      var cm = this, doc = this.doc, goals = [];
      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
      doc.extendSelectionsBy(function(range) {
        if (collapse)
          return dir < 0 ? range.from() : range.to();
        var headPos = cursorCoords(cm, range.head, "div");
        if (range.goalColumn != null) headPos.left = range.goalColumn;
        goals.push(headPos.left);
        var pos = findPosV(cm, headPos, dir, unit);
        if (unit == "page" && range == doc.sel.primary())
          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);
        return pos;
      }, sel_move);
      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)
        doc.sel.ranges[i].goalColumn = goals[i];
    }),

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) return;
      if (this.state.overwrite = !this.state.overwrite)
        addClass(this.display.cursorDiv, "CodeMirror-overwrite");
      else
        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");

      signal(this, "overwriteToggle", this, this.state.overwrite);
    },
    hasFocus: function() { return activeElt() == this.display.input; },

    scrollTo: methodOp(function(x, y) {
      if (x != null || y != null) resolveScrollToPos(this);
      if (x != null) this.curOp.scrollLeft = x;
      if (y != null) this.curOp.scrollTop = y;
    }),
    getScrollInfo: function() {
      var scroller = this.display.scroller, co = scrollerCutOff;
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,
              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null};
        if (margin == null) margin = this.options.cursorScrollMargin;
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null};
      } else if (range.from == null) {
        range = {from: range, to: null};
      }
      if (!range.to) range.to = range.from;
      range.margin = margin || 0;

      if (range.from.line != null) {
        resolveScrollToPos(this);
        this.curOp.scrollToPos = range;
      } else {
        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),
                                      Math.min(range.from.top, range.to.top) - range.margin,
                                      Math.max(range.from.right, range.to.right),
                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);
        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
      }
    }),

    setSize: methodOp(function(width, height) {
      function interpret(val) {
        return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
      }
      if (width != null) this.display.wrapper.style.width = interpret(width);
      if (height != null) this.display.wrapper.style.height = interpret(height);
      if (this.options.lineWrapping) clearLineMeasurementCache(this);
      this.curOp.forceUpdate = true;
      signal(this, "refresh", this);
    }),

    operation: function(f){return runInOp(this, f);},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight;
      regChange(this);
      this.curOp.forceUpdate = true;
      clearCaches(this);
      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
      updateGutterSpace(this);
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        estimateLineHeights(this);
      signal(this, "refresh", this);
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc;
      old.cm = null;
      attachDoc(this, doc);
      clearCaches(this);
      resetInput(this);
      this.scrollTo(doc.scrollLeft, doc.scrollTop);
      signalLater(this, "swapDoc", this, old);
      return old;
    }),

    getInputField: function(){return this.display.input;},
    getWrapperElement: function(){return this.display.wrapper;},
    getScrollerElement: function(){return this.display.scroller;},
    getGutterElement: function(){return this.display.gutters;}
  };
  eventMixin(CodeMirror);

  // OPTION DEFAULTS

  // The default configuration options.
  var defaults = CodeMirror.defaults = {};
  // Functions to run when options are changed.
  var optionHandlers = CodeMirror.optionHandlers = {};

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt;
    if (handle) optionHandlers[name] =
      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;
  }

  // Passed to option handlers when there is no old value.
  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function(cm, val) {
    cm.setValue(val);
  }, true);
  option("mode", null, function(cm, val) {
    cm.doc.modeOption = val;
    loadMode(cm);
  }, true);

  option("indentUnit", 2, loadMode, true);
  option("indentWithTabs", false);
  option("smartIndent", true);
  option("tabSize", 4, function(cm) {
    resetModeState(cm);
    clearCaches(cm);
    regChange(cm);
  }, true);
  option("specialChars", /[\t\u0000-\u0019\u00ad\u200b\u2028\u2029\ufeff]/g, function(cm, val) {
    cm.options.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
    cm.refresh();
  }, true);
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);
  option("electricChars", true);
  option("rtlMoveVisually", !windows);
  option("wholeLineUpdateBefore", true);

  option("theme", "default", function(cm) {
    themeChanged(cm);
    guttersChanged(cm);
  }, true);
  option("keyMap", "default", keyMapChanged);
  option("extraKeys", null);

  option("lineWrapping", false, wrappingChanged, true);
  option("gutters", [], function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("fixedGutter", true, function(cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
    cm.refresh();
  }, true);
  option("coverGutterNextToScrollbar", false, updateScrollbars, true);
  option("lineNumbers", false, function(cm) {
    setGuttersForLineNumbers(cm.options);
    guttersChanged(cm);
  }, true);
  option("firstLineNumber", 1, guttersChanged, true);
  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);
  option("showCursorWhenSelecting", false, updateSelection, true);

  option("resetSelectionOnContextMenu", true);

  option("readOnly", false, function(cm, val) {
    if (val == "nocursor") {
      onBlur(cm);
      cm.display.input.blur();
      cm.display.disabled = true;
    } else {
      cm.display.disabled = false;
      if (!val) resetInput(cm);
    }
  });
  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm);}, true);
  option("dragDrop", true);

  option("cursorBlinkRate", 530);
  option("cursorScrollMargin", 0);
  option("cursorHeight", 1);
  option("workTime", 100);
  option("workDelay", 100);
  option("flattenSpans", true, resetModeState, true);
  option("addModeClass", false, resetModeState, true);
  option("pollInterval", 100);
  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});
  option("historyEventDelay", 1250);
  option("viewportMargin", 10, function(cm){cm.refresh();}, true);
  option("maxHighlightLength", 10000, resetModeState, true);
  option("moveInputWithCursor", true, function(cm, val) {
    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;
  });

  option("tabindex", null, function(cm, val) {
    cm.display.input.tabIndex = val || "";
  });
  option("autofocus", null);

  // MODE DEFINITION AND QUERYING

  // Known modes, by name and by MIME
  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name, mode) {
    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;
    if (arguments.length > 2) {
      mode.dependencies = [];
      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);
    }
    modes[name] = mode;
  };

  CodeMirror.defineMIME = function(mime, spec) {
    mimeModes[mime] = spec;
  };

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  CodeMirror.resolveMode = function(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") found = {name: found};
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return CodeMirror.resolveMode("application/xml");
    }
    if (typeof spec == "string") return {name: spec};
    else return spec || {name: "null"};
  };

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  CodeMirror.getMode = function(options, spec) {
    var spec = CodeMirror.resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) return CodeMirror.getMode(options, "text/plain");
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) continue;
        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) modeObj.helperType = spec.helperType;
    if (spec.modeProps) for (var prop in spec.modeProps)
      modeObj[prop] = spec.modeProps[prop];

    return modeObj;
  };

  // Minimal default mode.
  CodeMirror.defineMode("null", function() {
    return {token: function(stream) {stream.skipToEnd();}};
  });
  CodeMirror.defineMIME("text/plain", "null");

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = CodeMirror.modeExtensions = {};
  CodeMirror.extendMode = function(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  };

  // EXTENSIONS

  CodeMirror.defineExtension = function(name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function(name, func) {
    Doc.prototype[name] = func;
  };
  CodeMirror.defineOption = option;

  var initHooks = [];
  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};

  var helpers = CodeMirror.helpers = {};
  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};
    helpers[type][name] = value;
  };
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value);
    helpers[type]._global.push({pred: predicate, val: value});
  };

  // MODE STATE HANDLING

  // Utility functions for working with state. Exported because nested
  // modes need to do this for their inner modes.

  var copyState = CodeMirror.copyState = function(mode, state) {
    if (state === true) return state;
    if (mode.copyState) return mode.copyState(state);
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) val = val.concat([]);
      nstate[n] = val;
    }
    return nstate;
  };

  var startState = CodeMirror.startState = function(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true;
  };

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  CodeMirror.innerMode = function(mode, state) {
    while (mode.innerMode) {
      var info = mode.innerMode(state);
      if (!info || info.mode == mode) break;
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state};
  };

  // STANDARD COMMANDS

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = CodeMirror.commands = {
    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},
    singleSelection: function(cm) {
      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
    },
    killLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        if (range.empty()) {
          var len = getLine(cm.doc, range.head.line).text.length;
          if (range.head.ch == len && range.head.line < cm.lastLine())
            return {from: range.head, to: Pos(range.head.line + 1, 0)};
          else
            return {from: range.head, to: Pos(range.head.line, len)};
        } else {
          return {from: range.from(), to: range.to()};
        }
      });
    },
    deleteLine: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0),
                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};
      });
    },
    delLineLeft: function(cm) {
      deleteNearSelection(cm, function(range) {
        return {from: Pos(range.from().line, 0), to: range.from()};
      });
    },
    undo: function(cm) {cm.undo();},
    redo: function(cm) {cm.redo();},
    undoSelection: function(cm) {cm.undoSelection();},
    redoSelection: function(cm) {cm.redoSelection();},
    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},
    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},
    goLineStart: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); }, sel_move);
    },
    goLineStartSmart: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var start = lineStart(cm, range.head.line);
        var line = cm.getLineHandle(start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(0, line.text.search(/\S/));
          var inWS = range.head.line == start.line && range.head.ch <= firstNonWS && range.head.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
      }, sel_move);
    },
    goLineEnd: function(cm) {
      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); }, sel_move);
    },
    goLineRight: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      }, sel_move);
    },
    goLineLeft: function(cm) {
      cm.extendSelectionsBy(function(range) {
        var top = cm.charCoords(range.head, "div").top + 5;
        return cm.coordsChar({left: 0, top: top}, "div");
      }, sel_move);
    },
    goLineUp: function(cm) {cm.moveV(-1, "line");},
    goLineDown: function(cm) {cm.moveV(1, "line");},
    goPageUp: function(cm) {cm.moveV(-1, "page");},
    goPageDown: function(cm) {cm.moveV(1, "page");},
    goCharLeft: function(cm) {cm.moveH(-1, "char");},
    goCharRight: function(cm) {cm.moveH(1, "char");},
    goColumnLeft: function(cm) {cm.moveH(-1, "column");},
    goColumnRight: function(cm) {cm.moveH(1, "column");},
    goWordLeft: function(cm) {cm.moveH(-1, "word");},
    goGroupRight: function(cm) {cm.moveH(1, "group");},
    goGroupLeft: function(cm) {cm.moveH(-1, "group");},
    goWordRight: function(cm) {cm.moveH(1, "word");},
    delCharBefore: function(cm) {cm.deleteH(-1, "char");},
    delCharAfter: function(cm) {cm.deleteH(1, "char");},
    delWordBefore: function(cm) {cm.deleteH(-1, "word");},
    delWordAfter: function(cm) {cm.deleteH(1, "word");},
    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},
    delGroupAfter: function(cm) {cm.deleteH(1, "group");},
    indentAuto: function(cm) {cm.indentSelection("smart");},
    indentMore: function(cm) {cm.indentSelection("add");},
    indentLess: function(cm) {cm.indentSelection("subtract");},
    insertTab: function(cm) {cm.replaceSelection("\t");},
    insertSoftTab: function(cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function(cm) {
      if (cm.somethingSelected()) cm.indentSelection("add");
      else cm.execCommand("insertTab");
    },
    transposeChars: function(cm) {
      runInOp(cm, function() {
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
          if (cur.ch > 0 && cur.ch < line.length - 1)
            cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),
                            Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
        }
      });
    },
    newlineAndIndent: function(cm) {
      runInOp(cm, function() {
        var len = cm.listSelections().length;
        for (var i = 0; i < len; i++) {
          var range = cm.listSelections()[i];
          cm.replaceRange("\n", range.anchor, range.head, "+input");
          cm.indentLine(range.from().line + 1, null, true);
          ensureCursorVisible(cm);
        }
      });
    },
    toggleOverwrite: function(cm) {cm.toggleOverwrite();}
  };

  // STANDARD KEYMAPS

  var keyMap = CodeMirror.keyMap = {};
  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    fallthrough: "basic"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection",
    fallthrough: ["basic", "emacsy"]
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function getKeyMap(val) {
    if (typeof val == "string") return keyMap[val];
    else return val;
  }

  // Given an array of keymaps and a key name, call handle on any
  // bindings found, until that returns a truthy value, at which point
  // we consider the key handled. Implements things like binding a key
  // to false stopping further handling and keymap fallthrough.
  var lookupKey = CodeMirror.lookupKey = function(name, maps, handle) {
    function lookup(map) {
      map = getKeyMap(map);
      var found = map[name];
      if (found === false) return "stop";
      if (found != null && handle(found)) return true;
      if (map.nofallthrough) return "stop";

      var fallthrough = map.fallthrough;
      if (fallthrough == null) return false;
      if (Object.prototype.toString.call(fallthrough) != "[object Array]")
        return lookup(fallthrough);
      for (var i = 0; i < fallthrough.length; ++i) {
        var done = lookup(fallthrough[i]);
        if (done) return done;
      }
      return false;
    }

    for (var i = 0; i < maps.length; ++i) {
      var done = lookup(maps[i]);
      if (done) return done != "stop";
    }
  };

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  var isModifierKey = CodeMirror.isModifierKey = function(event) {
    var name = keyNames[event.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";
  };

  // Look up the name of a key as indicated by an event object.
  var keyName = CodeMirror.keyName = function(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) return false;
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) return false;
    if (event.altKey) name = "Alt-" + name;
    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;
    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;
    if (!noShift && event.shiftKey) name = "Shift-" + name;
    return name;
  };

  // FROMTEXTAREA

  CodeMirror.fromTextArea = function(textarea, options) {
    if (!options) options = {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabindex)
      options.tabindex = textarea.tabindex;
    if (!options.placeholder && textarea.placeholder)
      options.placeholder = textarea.placeholder;
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form, realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function() {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    textarea.style.display = "none";
    var cm = CodeMirror(function(node) {
      textarea.parentNode.insertBefore(node, textarea.nextSibling);
    }, options);
    cm.save = save;
    cm.getTextArea = function() { return textarea; };
    cm.toTextArea = function() {
      save();
      textarea.parentNode.removeChild(cm.getWrapperElement());
      textarea.style.display = "";
      if (textarea.form) {
        off(textarea.form, "submit", save);
        if (typeof textarea.form.submit == "function")
          textarea.form.submit = realSubmit;
      }
    };
    return cm;
  };

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  var TextMarker = CodeMirror.TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
  };
  eventMixin(TextMarker);

  // Clear the marker.
  TextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) startOperation(cm);
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) signalLater(this, "clear", found.from, found.to);
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");
      else if (cm) {
        if (span.to != null) max = lineNo(line);
        if (span.from != null) min = lineNo(line);
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        updateLineHeight(line, textHeight(cm.display));
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {
      var visual = visualLine(this.lines[i]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    }

    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) reCheckSelection(cm.doc);
    }
    if (cm) signalLater(cm, "markerCleared", cm, this);
    if (withOp) endOperation(cm);
    if (this.parent) this.parent.clear();
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function(side, lineObj) {
    if (side == null && this.type == "bookmark") side = 1;
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) return from;
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) return to;
      }
    }
    return from && {from: from, to: to};
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function() {
    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) return;
    runInOp(cm, function() {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          updateLineHeight(line, line.height + dHeight);
      }
    });
  };

  TextMarker.prototype.attachLine = function(line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
    }
    this.lines.push(line);
  };
  TextMarker.prototype.detachLine = function(line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) return markTextShared(doc, from, to, options, type);
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) copyObj(options, marker, false);
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      return marker;
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) marker.widgetNode.ignoreEvents = true;
      if (options.insertLeft) marker.widgetNode.insertLeft = true;
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        throw new Error("Inserting collapsed marker partially overlapping an existing one");
      sawCollapsedSpans = true;
    }

    if (marker.addToHistory)
      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function(line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        updateMaxLine = true;
      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {
      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);
    });

    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });

    if (marker.readOnly) {
      sawReadOnlySpans = true;
      if (doc.history.done.length || doc.history.undone.length)
        doc.clearHistory();
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) cm.curOp.updateMaxLine = true;
      if (marker.collapsed)
        regChange(cm, from.line, to.line + 1);
      else if (marker.className || marker.title || marker.startStyle || marker.endStyle)
        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
      if (marker.atomic) reCheckSelection(cm.doc);
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker;
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      markers[i].parent = this;
  };
  eventMixin(SharedTextMarker);

  SharedTextMarker.prototype.clear = function() {
    if (this.explicitlyCleared) return;
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      this.markers[i].clear();
    signalLater(this, "clear");
  };
  SharedTextMarker.prototype.find = function(side, lineObj) {
    return this.primary.find(side, lineObj);
  };

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function(doc) {
      if (widget) options.widgetNode = widget.cloneNode(true);
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        if (doc.linked[i].isParent) return;
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary);
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),
                         function(m) { return m.parent; });
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], linked = [marker.primary.doc];;
      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    }
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) return span;
    }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    for (var r, i = 0; i < spans.length; ++i)
      if (spans[i] != span) (r || (r = [])).push(spans[i]);
    return r;
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    }
    return nw;
  }
  function markedSpansAfter(old, endCh, isInsert) {
    if (old) for (var i = 0, nw; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    }
    return nw;
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) return null;

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) span.to = startCh;
          else if (sameLine) span.to = found.to == null ? null : found.to + offset;
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i = 0; i < last.length; ++i) {
        var span = last[i];
        if (span.to != null) span.to += offset;
        if (span.from == null) {
          var found = getMarkedSpanFor(first, span.marker);
          if (!found) {
            span.from = offset;
            if (sameLine) (first || (first = [])).push(span);
          }
        } else {
          span.from += offset;
          if (sameLine) (first || (first = [])).push(span);
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) first = clearEmptySpans(first);
    if (last && last != first) last = clearEmptySpans(last);

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        for (var i = 0; i < first.length; ++i)
          if (first[i].to == null)
            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
      for (var i = 0; i < gap; ++i)
        newMarkers.push(gapMarkers);
      newMarkers.push(last);
    }
    return newMarkers;
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        spans.splice(i--, 1);
    }
    if (!spans.length) return null;
    return spans;
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) return stretched;
    if (!stretched) return old;

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            if (oldCur[k].marker == span.marker) continue spans;
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old;
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function(line) {
      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          (markers || (markers = [])).push(mark);
      }
    });
    if (!markers) return null;
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          newParts.push({from: p.from, to: m.from});
        if (dto > 0 || !mk.inclusiveRight && !dto)
          newParts.push({from: m.to, to: p.to});
        parts.splice.apply(parts, newParts);
        j += newParts.length - 1;
      }
    }
    return parts;
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.detachLine(line);
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) return;
    for (var i = 0; i < spans.length; ++i)
      spans[i].marker.attachLine(line);
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) return lenDiff;
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) return -fromCmp;
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) return toCmp;
    return b.id - a.id;
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        found = sp.marker;
    }
    return found;
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) continue;
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;
      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||
          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)
        return true;
    }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      line = merged.find(-1, true).line;
    return line;
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      (lines || (lines = [])).push(line);
    }
    return lines;
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) return lineN;
    return lineNo(vis);
  }
  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) return lineN;
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) return lineN;
    while (merged = collapsedSpanAtEnd(line))
      line = merged.find(1, true).line;
    return lineNo(line) + 1;
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) for (var sp, i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) continue;
      if (sp.from == null) return true;
      if (sp.marker.widgetNode) continue;
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        return true;
    }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      return true;
    for (var sp, i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) return true;
    }
  }

  // LINE WIDGETS

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {
    if (options) for (var opt in options) if (options.hasOwnProperty(opt))
      this[opt] = options[opt];
    this.cm = cm;
    this.node = node;
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      addToScrollPos(cm, null, diff);
  }

  LineWidget.prototype.clear = function() {
    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) return;
    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);
    if (!ws.length) line.widgets = null;
    var height = widgetHeight(this);
    runInOp(cm, function() {
      adjustScrollWhenAboveVisible(cm, line, -height);
      regLineChange(cm, no, "widget");
      updateLineHeight(line, Math.max(0, line.height - height));
    });
  };
  LineWidget.prototype.changed = function() {
    var oldH = this.height, cm = this.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) return;
    runInOp(cm, function() {
      cm.curOp.forceUpdate = true;
      adjustScrollWhenAboveVisible(cm, line, diff);
      updateLineHeight(line, line.height + diff);
    });
  };

  function widgetHeight(widget) {
    if (widget.height != null) return widget.height;
    if (!contains(document.body, widget.node))
      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));
    return widget.height = widget.node.offsetHeight;
  }

  function addLineWidget(cm, handle, node, options) {
    var widget = new LineWidget(cm, node, options);
    if (widget.noHScroll) cm.display.alignWidgets = true;
    changeLine(cm, handle, "widget", function(line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) widgets.push(widget);
      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
      widget.line = line;
      if (!lineIsHidden(cm.doc, line)) {
        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) addToScrollPos(cm, null, widget.height);
        cm.curOp.forceUpdate = true;
      }
      return true;
    });
    return widget;
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };
  eventMixin(Line);
  Line.prototype.lineNo = function() { return lineNo(this); };

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) line.stateAfter = null;
    if (line.styles) line.styles = null;
    if (line.order != null) line.order = null;
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) updateLineHeight(line, estHeight);
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  function extractLineClasses(type, output) {
    if (type) for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) break;
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        output[prop] = lineClass[2];
      else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
        output[prop] += " " + lineClass[2];
    }
    return type;
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) return mode.blankLine(state);
    if (!mode.innerMode) return;
    var inner = CodeMirror.innerMode(mode, state);
    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);
  }

  function readToken(mode, stream, state) {
    var style = mode.token(stream, state);
    if (stream.pos <= stream.start)
      throw new Error("Mode " + mode.name + " failed to advance stream.");
    return style;
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize), style;
    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) processLine(cm, text, state, stream.pos);
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, state), lineClasses);
      }
      if (cm.options.addModeClass) {
        var mName = CodeMirror.innerMode(mode, state).mode.name;
        if (mName) style = "m-" + (style ? mName + " " + style : mName);
      }
      if (!flattenSpans || curStyle != style) {
        if (curStart < stream.start) f(stream.start, curStyle);
        curStart = stream.start; curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444 characters
      var pos = Math.min(stream.pos, curStart + 50000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, state, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {
      st.push(end, style);
    }, lineClasses, forceToEnd);

    // Run overlays, adjust style array.
    for (var o = 0; o < cm.state.overlays.length; ++o) {
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      runMode(cm, line.text, overlay.mode, true, function(end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            st.splice(i, 1, end, st[i+1], i_end);
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) return;
        if (overlay.opaque) {
          st.splice(start, i - start, end, "cm-overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;
          }
        }
      }, lineClasses);
    }

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};
  }

  function getLineStyles(cm, line) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
      line.styles = result.styles;
      if (result.classes) line.styleClasses = result.classes;
      else if (line.styleClasses) line.styleClasses = null;
    }
    return line.styles;
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, state, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize);
    stream.start = stream.pos = startAt || 0;
    if (text == "") callBlankLine(mode, state);
    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
      readToken(mode, stream, state);
      stream.start = stream.pos;
    }
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) return null;
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"));
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order;
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if ((ie || webkit) && cm.getOption("lineWrapping"))
        builder.addToken = buildTokenSplitSpaces(builder.addToken);
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
        builder.addToken = buildTokenBadBidi(builder.addToken, order);
      builder.map = [];
      insertLineContent(line, builder, getLineStyles(cm, line));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
        if (line.styleClasses.textClass)
          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
        (lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    return builder;
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    return token;
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, title) {
    if (!text) return;
    var special = builder.cm.options.specialChars, mustWrap = false;
    if (!special.test(text)) {
      builder.col += text.length;
      var content = document.createTextNode(text);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie_upto8) mustWrap = true;
      builder.pos += text.length;
    } else {
      var content = document.createDocumentFragment(), pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(text.slice(pos, pos + skipped));
          if (ie_upto8) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) break;
        pos += skipped + 1;
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          builder.col += tabWidth;
        } else {
          var txt = builder.cm.options.specialCharPlaceholder(m[0]);
          if (ie_upto8) content.appendChild(elt("span", [txt]));
          else content.appendChild(txt);
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt);
        builder.pos++;
      }
    }
    if (style || startStyle || endStyle || mustWrap) {
      var fullStyle = style || "";
      if (startStyle) fullStyle += startStyle;
      if (endStyle) fullStyle += endStyle;
      var token = elt("span", [content], fullStyle);
      if (title) token.title = title;
      return builder.content.appendChild(token);
    }
    builder.content.appendChild(content);
  }

  function buildTokenSplitSpaces(inner) {
    function split(old) {
      var out = " ";
      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\u00a0";
      out += " ";
      return out;
    }
    return function(builder, text, style, startStyle, endStyle, title) {
      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);
    };
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function(builder, text, style, startStyle, endStyle, title) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        for (var i = 0; i < order.length; i++) {
          var part = order[i];
          if (part.to > start && part.from <= start) break;
        }
        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    };
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) {
      builder.map.push(builder.pos, builder.pos + size, widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i = 1; i < styles.length; i+=2)
        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));
      return;
    }

    var len = allText.length, pos = 0, i = 1, text = "", style;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = title = "";
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [];
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {
            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }
            if (m.className) spanStyle += " " + m.className;
            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;
            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;
            if (m.title && !title) title = m.title;
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              collapsed = sp;
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);
        }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) return;
        }
        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)
          buildCollapsedSpan(builder, 0, foundBookmarks[j]);
      }
      if (pos >= len) break;

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      for (var i = 0, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) doc.remove(from.line, nlines);
      if (added.length) doc.insert(from.line, added);
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        for (var added = [], i = 1; i < text.length - 1; ++i)
          added.push(new Line(text[i], spansFor(i), estimateHeight));
        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      for (var i = 1, added = []; i < text.length - 1; ++i)
        added.push(new Line(text[i], spansFor(i), estimateHeight));
      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);
      doc.insert(from.line + 1, added);
    }

    signalLater(doc, "change", doc, change);
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    for (var i = 0, height = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length; },
    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },
    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },
    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;
    },
    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        if (op(this.lines[at])) return true;
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size; },
    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) break;
          at = 0;
        } else at -= sz;
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },
    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);
    },
    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            while (child.lines.length > 50) {
              var spilled = child.lines.splice(child.lines.length - 25, 25);
              var newleaf = new LeafChunk(spilled);
              child.height -= newleaf.height;
              this.children.splice(i + 1, 0, newleaf);
              newleaf.parent = this;
            }
            this.maybeSpill();
          }
          break;
        }
        at -= sz;
      }
    },
    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) return;
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
        } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10);
      me.parent.maybeSpill();
    },
    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) return true;
          if ((n -= used) == 0) break;
          at = 0;
        } else at -= sz;
      }
    }
  };

  var nextDocId = 0;
  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {
    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);
    if (firstLine == null) firstLine = 0;

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.frontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;

    if (typeof text == "string") text = splitLines(text);
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) this.iterN(from - this.first, to - from, op);
      else this.iterN(this.first, this.first + this.size, from);
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) height += lines[i].height;
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: splitLines(code), origin: "setValue"}, true);
      setSelection(this, simpleSelection(top));
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) return lines;
      return lines.join(lineSep || "\n");
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},

    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},
    getLineNumber: function(line) {return lineNo(line);},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") line = getLine(this, line);
      return visualLine(line);
    },

    lineCount: function() {return this.size;},
    firstLine: function() {return this.first;},
    lastLine: function() {return this.first + this.size - 1;},

    clipPos: function(pos) {return clipPos(this, pos);},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") pos = range.head;
      else if (start == "anchor") pos = range.anchor;
      else if (start == "end" || start == "to" || start === false) pos = range.to();
      else pos = range.from();
      return pos;
    },
    listSelections: function() { return this.sel.ranges; },
    somethingSelected: function() {return this.sel.somethingSelected();},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads, options));
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      extendSelections(this, map(this.sel.ranges, f), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) return;
      for (var i = 0, out = []; i < ranges.length; i++)
        out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head));
      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);
      setSelection(this, normalizeSelection(out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) return lines;
      else return lines.join(lineSep || "\n");
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) sel = sel.join(lineSep || "\n");
        parts[i] = sel;
      }
      return parts;
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        dup[i] = code;
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i = changes.length - 1; i >= 0; i--)
        makeChange(this, changes[i]);
      if (newSel) setSelectionReplaceHistory(this, newSel);
      else if (this.cm) ensureCursorVisible(this.cm);
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend;},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;
      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;
      return {undo: done, redo: undone};
    },
    clearHistory: function() {this.history = new History(this.history.maxGeneration);},

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        this.history.lastOp = this.history.lastOrigin = null;
      return this.history.generation;
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration);
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)};
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark");
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          markers.push(span.marker.parent || span.marker);
      }
      return markers;
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function(line) {
        var spans = line.markedSpans;
        if (spans) for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(lineNo == from.line && from.ch > span.to ||
                span.from == null && lineNo != from.line||
                lineNo == to.line && span.from > to.ch) &&
              (!filter || filter(span.marker)))
            found.push(span.marker.parent || span.marker);
        }
        ++lineNo;
      });
      return found;
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function(line) {
        var sps = line.markedSpans;
        if (sps) for (var i = 0; i < sps.length; ++i)
          if (sps[i].from != null) markers.push(sps[i].marker);
      });
      return markers;
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first;
      this.iter(function(line) {
        var sz = line.text.length + 1;
        if (sz > off) { ch = off; return true; }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch));
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) return 0;
      this.iter(this.first, coords.line, function (line) {
        index += line.text.length + 1;
      });
      return index;
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc;
    },

    linkedDoc: function(options) {
      if (!options) options = {};
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) from = options.from;
      if (options.to != null && options.to < to) to = options.to;
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
      if (options.sharedHist) copy.history = this.history;
      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy;
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) other = other.doc;
      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) continue;
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break;
      }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode;},
    getEditor: function() {return this.cm;}
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor".split(" ");
  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments);};
    })(Doc.prototype[prop]);

  eventMixin(Doc);

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) continue;
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) continue;
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) throw new Error("This document is already in use.");
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    if (!cm.options.lineWrapping) findMaxLine(cm);
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  // LINE UTILITIES

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
    for (var chunk = doc; !chunk.lines;) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break; }
        n -= sz;
      }
    }
    return chunk.lines[n];
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function(line) {
      var text = line.text;
      if (n == end.line) text = text.slice(0, end.ch);
      if (n == start.line) text = text.slice(start.ch);
      out.push(text);
      ++n;
    });
    return out;
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function(line) { out.push(line.text); });
    return out;
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) for (var n = line; n; n = n.parent) n.height += diff;
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) return null;
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) break;
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first;
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i = 0; i < chunk.children.length; ++i) {
        var child = chunk.children[i], ch = child.height;
        if (h < ch) { chunk = child; continue outer; }
        h -= ch;
        n += child.chunkSize();
      }
      return n;
    } while (!chunk.lines);
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) break;
      h -= lh;
    }
    return n + i;
  }


  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) break;
      else h += line.height;
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i = 0; i < p.children.length; ++i) {
        var cur = p.children[i];
        if (cur == chunk) break;
        else h += cur.height;
      }
    }
    return h;
  }

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line) {
    var order = line.order;
    if (order == null) order = line.order = bidiOrdering(line.text);
    return order;
  }

  // HISTORY

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);
    return histChange;
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) array.pop();
      else break;
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done);
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done);
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done);
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, ore are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      var last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        pushSelectionToHistory(doc.sel, hist.done);
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) hist.done.shift();
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) signal(doc, "historyAdded");
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      hist.done[hist.done.length - 1] = sel;
    else
      pushSelectionToHistory(sel, hist.done);

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastOp = opId;
    if (options && options.clearRedo !== false)
      clearSelectionEvents(hist.undone);
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      dest.push(sel);
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
      if (line.markedSpans)
        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) return null;
    for (var i = 0, out; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }
      else if (out) out.push(spans[i]);
    }
    return !out ? spans : out.length ? out : null;
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) return null;
    for (var i = 0, nw = []; i < change.text.length; ++i)
      nw.push(removeClearedSpans(found[i]));
    return nw;
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    for (var i = 0, copy = []; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue;
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m;
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        }
      }
    }
    return copy;
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue;
      }
      for (var j = 0; j < sub.changes.length; ++j) {
        var cur = sub.changes[j];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break;
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // EVENT UTILITIES

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {
    if (e.preventDefault) e.preventDefault();
    else e.returnValue = false;
  };
  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {
    if (e.stopPropagation) e.stopPropagation();
    else e.cancelBubble = true;
  };
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
  }
  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};

  function e_target(e) {return e.target || e.srcElement;}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) b = 1;
      else if (e.button & 2) b = 3;
      else if (e.button & 4) b = 2;
    }
    if (mac && e.ctrlKey && b == 1) b = 3;
    return b;
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var on = CodeMirror.on = function(emitter, type, f) {
    if (emitter.addEventListener)
      emitter.addEventListener(type, f, false);
    else if (emitter.attachEvent)
      emitter.attachEvent("on" + type, f);
    else {
      var map = emitter._handlers || (emitter._handlers = {});
      var arr = map[type] || (map[type] = []);
      arr.push(f);
    }
  };

  var off = CodeMirror.off = function(emitter, type, f) {
    if (emitter.removeEventListener)
      emitter.removeEventListener(type, f, false);
    else if (emitter.detachEvent)
      emitter.detachEvent("on" + type, f);
    else {
      var arr = emitter._handlers && emitter._handlers[type];
      if (!arr) return;
      for (var i = 0; i < arr.length; ++i)
        if (arr[i] == f) { arr.splice(i, 1); break; }
    }
  };

  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);
  };

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  var delayedCallbacks, delayedCallbackDepth = 0;
  function signalLater(emitter, type /*, values...*/) {
    var arr = emitter._handlers && emitter._handlers[type];
    if (!arr) return;
    var args = Array.prototype.slice.call(arguments, 2);
    if (!delayedCallbacks) {
      ++delayedCallbackDepth;
      delayedCallbacks = [];
      setTimeout(fireDelayed, 0);
    }
    function bnd(f) {return function(){f.apply(null, args);};};
    for (var i = 0; i < arr.length; ++i)
      delayedCallbacks.push(bnd(arr[i]));
  }

  function fireDelayed() {
    --delayedCallbackDepth;
    var delayed = delayedCallbacks;
    delayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) delayed[i]();
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore;
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) return;
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)
      set.push(arr[i]);
  }

  function hasHandler(emitter, type) {
    var arr = emitter._handlers && emitter._handlers[type];
    return arr && arr.length > 0;
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // MISC UTILITIES

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerCutOff = 30;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  function Delayed() {this.id = null;}
  Delayed.prototype.set = function(ms, f) {
    clearTimeout(this.id);
    this.id = setTimeout(f, ms);
  };

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) end = string.length;
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        return n + (end - i);
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  };

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) nextTab = string.length;
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        return pos + Math.min(skipped, goal - col);
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) return pos;
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      spaceStrs.push(lst(spaceStrs) + " ");
    return spaceStrs[n];
  }

  function lst(arr) { return arr[arr.length-1]; }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };
  else if (ie) // Suppress mysterious IE10 errors
    selectInput = function(node) { try { node.select(); } catch(_e) {} };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      if (array[i] == elt) return i;
    return -1;
  }
  if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };
  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);
    return out;
  }
  if ([].map) map = function(array, f) { return array.map(f); };

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      var ctor = function() {};
      ctor.prototype = base;
      inst = new ctor();
    }
    if (props) copyObj(props, inst);
    return inst;
  };

  function copyObj(obj, target, overwrite) {
    if (!target) target = {};
    for (var prop in obj)
      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        target[prop] = obj[prop];
    return target;
  }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args);};
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  var isWordChar = CodeMirror.isWordChar = function(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
  };

  function isEmpty(obj) {
    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;
    return true;
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }

  // DOM UTILITIES

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) e.className = className;
    if (style) e.style.cssText = style;
    if (typeof content == "string") e.appendChild(document.createTextNode(content));
    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
    return e;
  }

  var range;
  if (document.createRange) range = function(node, start, end) {
    var r = document.createRange();
    r.setEnd(node, end);
    r.setStart(node, start);
    return r;
  };
  else range = function(node, start, end) {
    var r = document.body.createTextRange();
    r.moveToElementText(node.parentNode);
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r;
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      e.removeChild(e.firstChild);
    return e;
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e);
  }

  function contains(parent, child) {
    if (parent.contains)
      return parent.contains(child);
    while (child = child.parentNode)
      if (child == parent) return true;
  }

  function activeElt() { return document.activeElement; }
  // Older versions of IE throws unspecified error when touching
  // document.activeElement in some cases (during loading, in iframe)
  if (ie_upto10) activeElt = function() {
    try { return document.activeElement; }
    catch(e) { return document.body; }
  };

  function classTest(cls) { return new RegExp("\\b" + cls + "\\b\\s*"); }
  function rmClass(node, cls) {
    var test = classTest(cls);
    if (test.test(node.className)) node.className = node.className.replace(test, "");
  }
  function addClass(node, cls) {
    if (!classTest(cls).test(node.className)) node.className += " " + cls;
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];
    return b;
  }

  // FEATURE DETECTION

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie_upto8) return false;
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div;
  }();

  var knownScrollbarWidth;
  function scrollbarWidth(measure) {
    if (knownScrollbarWidth != null) return knownScrollbarWidth;
    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");
    removeChildrenAndAdd(measure, test);
    if (test.offsetWidth)
      knownScrollbarWidth = test.offsetHeight - test.clientHeight;
    return knownScrollbarWidth || 0;
  }

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_upto7;
    }
    if (zwspSupported) return elt("span", "\u200b");
    else return elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) return badBidiRects;
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    if (r0.left == r0.right) return false;
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    return badBidiRects = (r1.right - r0.right < 3);
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLines = CodeMirror.splitLines = "\n\nb".split(/\n/).length != 3 ? function(string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) nl = string.length;
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result;
  } : function(string){return string.split(/\r\n?|\n/);};

  var hasSelection = window.getSelection ? function(te) {
    try { return te.selectionStart != te.selectionEnd; }
    catch(e) { return false; }
  } : function(te) {
    try {var range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) return false;
    return range.compareEndPoints("StartToEnd", range) != 0;
  };

  var hasCopyEvent = (function() {
    var e = elt("div");
    if ("oncopy" in e) return true;
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function";
  })();

  // KEY NAMES

  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",
                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};
  CodeMirror.keyNames = keyNames;
  (function() {
    // Number keys
    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
    // Alphabetic keys
    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);
    // Function keys
    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;
  })();

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) return f(from, to, "ltr");
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");
        found = true;
      }
    }
    if (!found) f(from, to, "ltr");
  }

  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }
  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }

  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }
  function lineRight(line) {
    var order = getOrder(line);
    if (!order) return line.text.length;
    return bidiRight(lst(order));
  }

  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) lineN = lineNo(visual);
    var order = getOrder(visual);
    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
    return Pos(lineN, ch);
  }
  function lineEnd(cm, lineN) {
    var merged, line = getLine(cm.doc, lineN);
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line;
      lineN = null;
    }
    var order = getOrder(line);
    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
    return Pos(lineN == null ? lineNo(line) : lineN, ch);
  }

  function compareBidiLevel(order, a, b) {
    var linedir = order[0].level;
    if (a == linedir) return true;
    if (b == linedir) return false;
    return a < b;
  }
  var bidiOther;
  function getBidiPartAt(order, pos) {
    bidiOther = null;
    for (var i = 0, found; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < pos && cur.to > pos) return i;
      if ((cur.from == pos || cur.to == pos)) {
        if (found == null) {
          found = i;
        } else if (compareBidiLevel(order, cur.level, order[found].level)) {
          if (cur.from != cur.to) bidiOther = found;
          return i;
        } else {
          if (cur.from != cur.to) bidiOther = i;
          return found;
        }
      }
    }
    return found;
  }

  function moveInLine(line, pos, dir, byUnit) {
    if (!byUnit) return pos + dir;
    do pos += dir;
    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
    return pos;
  }

  // This is needed in order to move 'visually' through bi-directional
  // text -- i.e., pressing left should make the cursor go left, even
  // when in RTL text. The tricky part is the 'jumps', where RTL and
  // LTR text touch each other. This often requires the cursor offset
  // to move more than one unit, in order to visually move one unit.
  function moveVisually(line, start, dir, byUnit) {
    var bidi = getOrder(line);
    if (!bidi) return moveLogically(line, start, dir, byUnit);
    var pos = getBidiPartAt(bidi, start), part = bidi[pos];
    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);

    for (;;) {
      if (target > part.from && target < part.to) return target;
      if (target == part.from || target == part.to) {
        if (getBidiPartAt(bidi, target) == pos) return target;
        part = bidi[pos += dir];
        return (dir > 0) == part.level % 2 ? part.to : part.from;
      } else {
        part = bidi[pos += dir];
        if (!part) return null;
        if ((dir > 0) == part.level % 2)
          target = moveInLine(line, part.to, -1, byUnit);
        else
          target = moveInLine(line, part.from, 1, byUnit);
      }
    }
  }

  function moveLogically(line, start, dir, byUnit) {
    var target = start + dir;
    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;
    return target < 0 || target > line.text.length ? null : target;
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6ff
    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";
    function charType(code) {
      if (code <= 0xf7) return lowTypes.charAt(code);
      else if (0x590 <= code && code <= 0x5f4) return "R";
      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);
      else if (0x6ee <= code && code <= 0x8ac) return "r";
      else if (0x2000 <= code && code <= 0x200b) return "w";
      else if (code == 0x200c) return "b";
      else return "L";
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
    // Browsers seem to always treat the boundaries of block elements as being L.
    var outerType = "L";

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str) {
      if (!bidiRE.test(str)) return false;
      var len = str.length, types = [];
      for (var i = 0, type; i < len; ++i)
        types.push(type = charType(str.charCodeAt(i)));

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i = 0, prev = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "m") types[i] = prev;
        else prev = type;
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (type == "1" && cur == "r") types[i] = "n";
        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i = 1, prev = types[0]; i < len - 1; ++i) {
        var type = types[i];
        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";
        else if (type == "," && prev == types[i+1] &&
                 (prev == "1" || prev == "n")) types[i] = prev;
        prev = type;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i = 0; i < len; ++i) {
        var type = types[i];
        if (type == ",") types[i] = "N";
        else if (type == "%") {
          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i = 0, cur = outerType; i < len; ++i) {
        var type = types[i];
        if (cur == "L" && type == "1") types[i] = "L";
        else if (isStrong.test(type)) cur = type;
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i = 0; i < len; ++i) {
        if (isNeutral.test(types[i])) {
          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}
          var before = (i ? types[i-1] : outerType) == "L";
          var after = (end < len ? types[end] : outerType) == "L";
          var replace = before || after ? "L" : "R";
          for (var j = i; j < end; ++j) types[j] = replace;
          i = end - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i = 0; i < len;) {
        if (countsAsLeft.test(types[i])) {
          var start = i;
          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}
          order.push(new BidiSpan(0, start, i));
        } else {
          var pos = i, at = order.length;
          for (++i; i < len && types[i] != "L"; ++i) {}
          for (var j = pos; j < i;) {
            if (countsAsNum.test(types[j])) {
              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));
              var nstart = j;
              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j));
              pos = j;
            } else ++j;
          }
          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));
        }
      }
      if (order[0].level == 1 && (m = str.match(/^\s+/))) {
        order[0].from = m[0].length;
        order.unshift(new BidiSpan(0, 0, m[0].length));
      }
      if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
        lst(order).to -= m[0].length;
        order.push(new BidiSpan(0, len - m[0].length, len));
      }
      if (order[0].level != lst(order).level)
        order.push(new BidiSpan(order[0].level, len, len));

      return order;
    };
  })();

  // THE END

  CodeMirror.version = "4.1.0";

  return CodeMirror;
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  CodeMirror.showHint = function(cm, getHints, options) {
    // We want a single cursor position.
    if (cm.listSelections().length > 1 || cm.somethingSelected()) return;
    if (getHints == null) {
      if (options && options.async) return;
      else getHints = CodeMirror.hint.auto;
    }

    if (cm.state.completionActive) cm.state.completionActive.close();

    var completion = cm.state.completionActive = new Completion(cm, getHints, options || {});
    CodeMirror.signal(cm, "startCompletion", cm);
    if (completion.options.async)
      getHints(cm, function(hints) { completion.showHints(hints); }, completion.options);
    else
      return completion.showHints(getHints(cm, completion.options));
  };

  function Completion(cm, getHints, options) {
    this.cm = cm;
    this.getHints = getHints;
    this.options = options;
    this.widget = this.onClose = null;
  }

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;

      if (this.widget) this.widget.close();
      if (this.onClose) this.onClose();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else this.cm.replaceRange(getText(completion), completion.from || data.from,
                                completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    showHints: function(data) {
      if (!data || !data.list.length || !this.active()) return this.close();

      if (this.options.completeSingle != false && data.list.length == 1)
        this.pick(data, 0);
      else
        this.showWidget(data);
    },

    showWidget: function(data) {
      this.widget = new Widget(this, data);
      CodeMirror.signal(data, "shown");

      var debounce = 0, completion = this, finished;
      var closeOn = this.options.closeCharacters || /[\s()\[\]{};:>,]/;
      var startPos = this.cm.getCursor(), startLen = this.cm.getLine(startPos.line).length;

      var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
        return setTimeout(fn, 1000/60);
      };
      var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

      function done() {
        if (finished) return;
        finished = true;
        completion.close();
        completion.cm.off("cursorActivity", activity);
        if (data) CodeMirror.signal(data, "close");
      }

      function update() {
        if (finished) return;
        CodeMirror.signal(data, "update");
        if (completion.options.async)
          completion.getHints(completion.cm, finishUpdate, completion.options);
        else
          finishUpdate(completion.getHints(completion.cm, completion.options));
      }
      function finishUpdate(data_) {
        data = data_;
        if (finished) return;
        if (!data || !data.list.length) return done();
        if (completion.widget) completion.widget.close();
        completion.widget = new Widget(completion, data);
      }

      function clearDebounce() {
        if (debounce) {
          cancelAnimationFrame(debounce);
          debounce = 0;
        }
      }

      function activity() {
        clearDebounce();
        var pos = completion.cm.getCursor(), line = completion.cm.getLine(pos.line);
        if (pos.line != startPos.line || line.length - pos.ch != startLen - startPos.ch ||
            pos.ch < startPos.ch || completion.cm.somethingSelected() ||
            (pos.ch && closeOn.test(line.charAt(pos.ch - 1)))) {
          completion.close();
        } else {
          debounce = requestAnimationFrame(update);
          if (completion.widget) completion.widget.close();
        }
      }
      this.cm.on("cursorActivity", activity);
      this.onClose = done;
    }
  };

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(options, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var ourMap = options.customKeys ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (options.customKeys)
      for (var key in options.customKeys) if (options.customKeys.hasOwnProperty(key))
        addBinding(key, options.customKeys[key]);
    if (options.extraKeys)
      for (var key in options.extraKeys) if (options.extraKeys.hasOwnProperty(key))
        addBinding(key, options.extraKeys[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    var widget = this, cm = completion.cm, options = completion.options;

    var hints = this.hints = document.createElement("ul");
    hints.className = "CodeMirror-hints";
    this.selectedHint = options.getDefaultSelection ? options.getDefaultSelection(cm,options,data) : 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var pos = cm.cursorCoords(options.alignWithWord !== false ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    (options.container || document.body).appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = box.top - (pos.bottom - pos.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = curTop - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.left - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + "px";
    }

    cm.addKeyMap(this.keyMap = buildKeyMap(options, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (options.closeOnUnfocus !== false) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    var startScroll = cm.getScrollInfo();
    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[0], hints.firstChild);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus !== false) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  CodeMirror.registerHelper("hint", "auto", function(cm, options) {
    var helpers = cm.getHelpers(cm.getCursor(), "hint"), words;
    if (helpers.length) {
      for (var i = 0; i < helpers.length; i++) {
        var cur = helpers[i](cm, options);
        if (cur && cur.list.length) return cur;
      }
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      if (words) return CodeMirror.hint.fromList(cm, {words: words});
    } else if (CodeMirror.hint.anyword) {
      return CodeMirror.hint.anyword(cm, options);
    }
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, token.string.length) == token.string)
        found.push(word);
    }

    if (found.length) return {
      list: found,
      from: CodeMirror.Pos(cur.line, token.start),
            to: CodeMirror.Pos(cur.line, token.end)
    };
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var Pos = CodeMirror.Pos;

  function forEach(arr, f) {
    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);
  }

  function arrayContains(arr, item) {
    if (!Array.prototype.indexOf) {
      var i = arr.length;
      while (i--) {
        if (arr[i] === item) {
          return true;
        }
      }
      return false;
    }
    return arr.indexOf(item) != -1;
  }

  function scriptHint(editor, keywords, getToken, options) {
    // Find the token at the cursor
    var cur = editor.getCursor(), token = getToken(editor, cur), tprop = token;
    if (/\b(?:string|comment)\b/.test(token.type)) return;
    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;

    // If it's not a 'word-style' token, ignore the token.
    if (!/^[\w$_]*$/.test(token.string)) {
      token = tprop = {start: cur.ch, end: cur.ch, string: "", state: token.state,
                       type: token.string == "." ? "property" : null};
    }
    // If it is a property, find out what it is a property of.
    while (tprop.type == "property") {
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (tprop.string != ".") return;
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if (!context) var context = [];
      context.push(tprop);
    }
    return {list: getCompletions(token, context, keywords, options),
            from: Pos(cur.line, token.start),
            to: Pos(cur.line, token.end)};
  }

  function javascriptHint(editor, options) {
    return scriptHint(editor, javascriptKeywords,
                      function (e, cur) {return e.getTokenAt(cur);},
                      options);
  };
  CodeMirror.registerHelper("hint", "javascript", javascriptHint);

  function getCoffeeScriptToken(editor, cur) {
  // This getToken, it is for coffeescript, imitates the behavior of
  // getTokenAt method in javascript.js, that is, returning "property"
  // type and treat "." as indepenent token.
    var token = editor.getTokenAt(cur);
    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {
      token.end = token.start;
      token.string = '.';
      token.type = "property";
    }
    else if (/^\.[\w$_]*$/.test(token.string)) {
      token.type = "property";
      token.start++;
      token.string = token.string.replace(/\./, '');
    }
    return token;
  }

  function coffeescriptHint(editor, options) {
    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);
  }
  CodeMirror.registerHelper("hint", "coffeescript", coffeescriptHint);

  var stringProps = ("charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight " +
                     "toUpperCase toLowerCase split concat match replace search").split(" ");
  var arrayProps = ("length concat join splice push pop shift unshift slice reverse sort indexOf " +
                    "lastIndexOf every some filter forEach map reduce reduceRight ").split(" ");
  var funcProps = "prototype apply call bind".split(" ");
  var javascriptKeywords = ("break case catch continue debugger default delete do else false finally for function " +
                  "if in instanceof new null return switch throw true try typeof var void while with").split(" ");
  var coffeescriptKeywords = ("and break catch class continue delete do else extends false finally for " +
                  "if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes").split(" ");

  function getCompletions(token, context, keywords, options) {
    var found = [], start = token.string;
    function maybeAdd(str) {
      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);
    }
    function gatherCompletions(obj) {
      if (typeof obj == "string") forEach(stringProps, maybeAdd);
      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);
      else if (obj instanceof Function) forEach(funcProps, maybeAdd);
      for (var name in obj) maybeAdd(name);
    }

    if (context && context.length) {
      // If this is a property, see if it belongs to some object we can
      // find in the current environment.
      var obj = context.pop(), base;
      if (obj.type && obj.type.indexOf("variable") === 0) {
        if (options && options.additionalContext)
          base = options.additionalContext[obj.string];
        base = base || window[obj.string];
      } else if (obj.type == "string") {
        base = "";
      } else if (obj.type == "atom") {
        base = 1;
      } else if (obj.type == "function") {
        if (window.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&
            (typeof window.jQuery == 'function'))
          base = window.jQuery();
        else if (window._ != null && (obj.string == '_') && (typeof window._ == 'function'))
          base = window._();
      }
      while (base != null && context.length)
        base = base[context.pop().string];
      if (base != null) gatherCompletions(base);
    } else {
      // If not, just look in the window object and any local scope
      // (reading into JS mode internals to get at the local and global variables)
      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);
      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);
      gatherCompletions(window);
      forEach(keywords, maybeAdd);
    }
    return found;
  }
});

// TODO actually recognize syntax of TypeScript constructs

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "variable-3"};
      var tsKeywords = {
        // object-like things
        "interface": kw("interface"),
        "extends": kw("extends"),
        "constructor": kw("constructor"),

        // scope modifiers
        "public": kw("public"),
        "private": kw("private"),
        "protected": kw("protected"),
        "static": kw("static"),

        // types
        "string": type, "number": type, "bool": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||
               state.lastType == "sof" || /^[\[{}\(,;:]$/.test(state.lastType)) {
        readRegexp(stream);
        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else {
      stream.eatWhile(/[\w\$_]/);
      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :
                     ret("variable", "variable", word);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) break;
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (/[$\w]/.test(ch)) {
        sawSomething = true;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    if (state.context) {
      cx.marked = "def";
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), expression, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") return cont(pushlex("stat"), maybelabel);
    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);
    if (type == "class") return cont(pushlex("form"), className, objlit, poplex);
    if (type == "export") return cont(pushlex("form"), afterExport, poplex);
    if (type == "import") return cont(pushlex("form"), afterImport, poplex);
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") { return pass(quasi, maybeop); }
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value)) return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    if (type == "{") return pass(statement);
    return pass(expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    if (type == "{") return pass(statement);
    return pass(expressionNoComma);
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "variable") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (type + " property");
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    }
    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end) {
    function proceed(type) {
      if (type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(what, proceed);
      }
      if (type == end) return cont();
      return cont(expect(end));
    }
    return function(type) {
      if (type == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type) {
    if (isTS && type == ":") return cont(typedef);
  }
  function typedef(type) {
    if (type == "variable"){cx.marked = "variable-3"; return cont();}
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "variable") { register(value); return cont(); }
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);
  }
  function funarg(type) {
    if (type == "spread") return cont(funarg);
    return pass(pattern, maybetype);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(_type, value) {
    if (value == "extends") return cont(expression);
  }
  function objlit(type) {
    if (type == "{") return contCommasep(objprop, "}");
  }
  function afterModule(type, value) {
    if (type == "string") return cont(statement);
    if (type == "variable") { register(value); return cont(maybeFrom); }
  }
  function afterExport(_type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    return pass(statement);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    return cont();
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(expressionNoComma, maybeArrayComprehension);
  }
  function maybeArrayComprehension(type) {
    if (type == "for") return pass(comprehension, expect("]"));
    if (type == ",") return cont(commasep(expressionNoComma, "]"));
    return pass(commasep(expressionNoComma, "]"));
  }
  function comprehension(type) {
    if (type == "for") return cont(forspec, comprehension);
    if (type == "if") return cont(expression, comprehension);
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricChars: ":{}",
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode
  };
});

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

/**
 * Link to the project's GitHub page:
 * https://github.com/pickhardt/coffeescript-codemirror-mode
 */
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("coffeescript", function(conf) {
  var ERRORCLASS = "error";

  function wordRegexp(words) {
    return new RegExp("^((" + words.join(")|(") + "))\\b");
  }

  var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?)/;
  var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
  var properties = /^(@|this\.)[_A-Za-z$][_A-Za-z$0-9]*/;

  var wordOperators = wordRegexp(["and", "or", "not",
                                  "is", "isnt", "in",
                                  "instanceof", "typeof"]);
  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
                        "switch", "try", "catch", "finally", "class"];
  var commonKeywords = ["break", "by", "continue", "debugger", "delete",
                        "do", "in", "of", "new", "return", "then",
                        "this", "throw", "when", "until"];

  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

  indentKeywords = wordRegexp(indentKeywords);


  var stringPrefixes = /^('{3}|\"{3}|['\"])/;
  var regexPrefixes = /^(\/{3}|\/)/;
  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
  var constants = wordRegexp(commonConstants);

  // Tokenizers
  function tokenBase(stream, state) {
    // Handle scope changes
    if (stream.sol()) {
      if (state.scope.align === null) state.scope.align = false;
      var scopeOffset = state.scope.offset;
      if (stream.eatSpace()) {
        var lineOffset = stream.indentation();
        if (lineOffset > scopeOffset && state.scope.type == "coffee") {
          return "indent";
        } else if (lineOffset < scopeOffset) {
          return "dedent";
        }
        return null;
      } else {
        if (scopeOffset > 0) {
          dedent(stream, state);
        }
      }
    }
    if (stream.eatSpace()) {
      return null;
    }

    var ch = stream.peek();

    // Handle docco title comment (single line)
    if (stream.match("####")) {
      stream.skipToEnd();
      return "comment";
    }

    // Handle multi line comments
    if (stream.match("###")) {
      state.tokenize = longComment;
      return state.tokenize(stream, state);
    }

    // Single line comment
    if (ch === "#") {
      stream.skipToEnd();
      return "comment";
    }

    // Handle number literals
    if (stream.match(/^-?[0-9\.]/, false)) {
      var floatLiteral = false;
      // Floats
      if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
        floatLiteral = true;
      }
      if (stream.match(/^-?\d+\.\d*/)) {
        floatLiteral = true;
      }
      if (stream.match(/^-?\.\d+/)) {
        floatLiteral = true;
      }

      if (floatLiteral) {
        // prevent from getting extra . on 1..
        if (stream.peek() == "."){
          stream.backUp(1);
        }
        return "number";
      }
      // Integers
      var intLiteral = false;
      // Hex
      if (stream.match(/^-?0x[0-9a-f]+/i)) {
        intLiteral = true;
      }
      // Decimal
      if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
        intLiteral = true;
      }
      // Zero by itself with no other piece of number.
      if (stream.match(/^-?0(?![\dx])/i)) {
        intLiteral = true;
      }
      if (intLiteral) {
        return "number";
      }
    }

    // Handle strings
    if (stream.match(stringPrefixes)) {
      state.tokenize = tokenFactory(stream.current(), false, "string");
      return state.tokenize(stream, state);
    }
    // Handle regex literals
    if (stream.match(regexPrefixes)) {
      if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
        state.tokenize = tokenFactory(stream.current(), true, "string-2");
        return state.tokenize(stream, state);
      } else {
        stream.backUp(1);
      }
    }

    // Handle operators and delimiters
    if (stream.match(operators) || stream.match(wordOperators)) {
      return "operator";
    }
    if (stream.match(delimiters)) {
      return "punctuation";
    }

    if (stream.match(constants)) {
      return "atom";
    }

    if (stream.match(keywords)) {
      return "keyword";
    }

    if (stream.match(identifiers)) {
      return "variable";
    }

    if (stream.match(properties)) {
      return "property";
    }

    // Handle non-detected items
    stream.next();
    return ERRORCLASS;
  }

  function tokenFactory(delimiter, singleline, outclass) {
    return function(stream, state) {
      while (!stream.eol()) {
        stream.eatWhile(/[^'"\/\\]/);
        if (stream.eat("\\")) {
          stream.next();
          if (singleline && stream.eol()) {
            return outclass;
          }
        } else if (stream.match(delimiter)) {
          state.tokenize = tokenBase;
          return outclass;
        } else {
          stream.eat(/['"\/]/);
        }
      }
      if (singleline) {
        if (conf.mode.singleLineStringErrors) {
          outclass = ERRORCLASS;
        } else {
          state.tokenize = tokenBase;
        }
      }
      return outclass;
    };
  }

  function longComment(stream, state) {
    while (!stream.eol()) {
      stream.eatWhile(/[^#]/);
      if (stream.match("###")) {
        state.tokenize = tokenBase;
        break;
      }
      stream.eatWhile("#");
    }
    return "comment";
  }

  function indent(stream, state, type) {
    type = type || "coffee";
    var offset = 0, align = false, alignOffset = null;
    for (var scope = state.scope; scope; scope = scope.prev) {
      if (scope.type === "coffee") {
        offset = scope.offset + conf.indentUnit;
        break;
      }
    }
    if (type !== "coffee") {
      align = null;
      alignOffset = stream.column() + stream.current().length;
    } else if (state.scope.align) {
      state.scope.align = false;
    }
    state.scope = {
      offset: offset,
      type: type,
      prev: state.scope,
      align: align,
      alignOffset: alignOffset
    };
  }

  function dedent(stream, state) {
    if (!state.scope.prev) return;
    if (state.scope.type === "coffee") {
      var _indent = stream.indentation();
      var matched = false;
      for (var scope = state.scope; scope; scope = scope.prev) {
        if (_indent === scope.offset) {
          matched = true;
          break;
        }
      }
      if (!matched) {
        return true;
      }
      while (state.scope.prev && state.scope.offset !== _indent) {
        state.scope = state.scope.prev;
      }
      return false;
    } else {
      state.scope = state.scope.prev;
      return false;
    }
  }

  function tokenLexer(stream, state) {
    var style = state.tokenize(stream, state);
    var current = stream.current();

    // Handle "." connected identifiers
    if (current === ".") {
      style = state.tokenize(stream, state);
      current = stream.current();
      if (/^\.[\w$]+$/.test(current)) {
        return "variable";
      } else {
        return ERRORCLASS;
      }
    }

    // Handle scope changes.
    if (current === "return") {
      state.dedent += 1;
    }
    if (((current === "->" || current === "=>") &&
         !state.lambda &&
         !stream.peek())
        || style === "indent") {
      indent(stream, state);
    }
    var delimiter_index = "[({".indexOf(current);
    if (delimiter_index !== -1) {
      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
    }
    if (indentKeywords.exec(current)){
      indent(stream, state);
    }
    if (current == "then"){
      dedent(stream, state);
    }


    if (style === "dedent") {
      if (dedent(stream, state)) {
        return ERRORCLASS;
      }
    }
    delimiter_index = "])}".indexOf(current);
    if (delimiter_index !== -1) {
      while (state.scope.type == "coffee" && state.scope.prev)
        state.scope = state.scope.prev;
      if (state.scope.type == current)
        state.scope = state.scope.prev;
    }
    if (state.dedent > 0 && stream.eol() && state.scope.type == "coffee") {
      if (state.scope.prev) state.scope = state.scope.prev;
      state.dedent -= 1;
    }

    return style;
  }

  var external = {
    startState: function(basecolumn) {
      return {
        tokenize: tokenBase,
        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},
        lastToken: null,
        lambda: false,
        dedent: 0
      };
    },

    token: function(stream, state) {
      var fillAlign = state.scope.align === null && state.scope;
      if (fillAlign && stream.sol()) fillAlign.align = false;

      var style = tokenLexer(stream, state);
      if (fillAlign && style && style != "comment") fillAlign.align = true;

      state.lastToken = {style:style, content: stream.current()};

      if (stream.eol() && stream.lambda) {
        state.lambda = false;
      }

      return style;
    },

    indent: function(state, text) {
      if (state.tokenize != tokenBase) return 0;
      var scope = state.scope;
      var closer = text && "])}".indexOf(text.charAt(0)) > -1;
      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
      var closes = closer && scope.type === text.charAt(0);
      if (scope.align)
        return scope.alignOffset - (closes ? 1 : 0);
      else
        return (closes ? scope.prev : scope).offset;
    },

    lineComment: "#",
    fold: "indent"
  };
  return external;
});

CodeMirror.defineMIME("text/x-coffeescript", "coffeescript");

});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("css", function(config, parserConfig) {
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      allowNested = parserConfig.allowNested;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^[^-]+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (ch == "u" && stream.match("rl(")) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "word");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type) {
    state.context = new Context(type, stream.indentation() + indentUnit, state.context);
    return type;
  }

  function popContext(state) {
    state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (type == "@media") {
      return pushContext(state, stream, "media");
    } else if (type == "@font-face") {
      return "font_face_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "params");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.media = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "media_parens");
    if (type == "}") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.media_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.media(type, stream, state);
  };

  states.font_face_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "font_face");
    return pass(type, stream, state);
  };

  states.font_face = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") {
      if (!fontProperties.hasOwnProperty(stream.current().toLowerCase()))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "font_face";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type != "variable") override = "error";
    return "interpolation";
  };

  states.params = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") wordAsValue(stream);
    return "params";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: "top",
              context: new Context("top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && ch == "}") cx = cx.prev;
      if (cx.prev &&
          (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "font_face") ||
           ch == ")" && (cx.type == "parens" || cx.type == "params" || cx.type == "media_parens") ||
           ch == "{" && (cx.type == "at" || cx.type == "media"))) {
        indent = cx.indent - indentUnit;
        cx = cx.prev;
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i]] = true;
    }
    return keys;
  }

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid"
  ], mediaFeatures = keySet(mediaFeatures_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end",
    "grid-column-start", "grid-row", "grid-row-end", "grid-row-start",
    "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marker-offset", "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size",
    "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",
    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",
    "content-box", "context-menu", "continuous", "copy", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari",
    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",
    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",
    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",
    "landscape", "lao", "large", "larger", "left", "level", "lighter",
    "line-through", "linear", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "malayalam", "match",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",
    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",
    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",
    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "single", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke",
    "sub", "subpixel-antialiased", "super", "sw-resize", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_)
    .concat(nonStandardPropertyKeywords).concat(colorKeywords_).concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  function tokenSGMLComment(stream, state) {
    if (stream.skipTo("-->")) {
      stream.match("-->");
      state.tokenize = null;
    } else {
      stream.skipToEnd();
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    tokenHooks: {
      "<": function(stream, state) {
        if (!stream.match("!--")) return false;
        state.tokenize = tokenSGMLComment;
        return tokenSGMLComment(stream, state);
      },
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*{/))
          return [null, "{"];
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

});

/*!
 * JSHint, by JSHint Community.
 *
 * Licensed under the same slightly modified MIT license that JSLint is.
 * It stops evil-doers everywhere.
 *
 * JSHint is a derivative work of JSLint:
 *
 *   Copyright (c) 2002 Douglas Crockford  (www.JSLint.com)
 *
 *   Permission is hereby granted, free of charge, to any person obtaining
 *   a copy of this software and associated documentation files (the "Software"),
 *   to deal in the Software without restriction, including without limitation
 *   the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *   and/or sell copies of the Software, and to permit persons to whom
 *   the Software is furnished to do so, subject to the following conditions:
 *
 *   The above copyright notice and this permission notice shall be included
 *   in all copies or substantial portions of the Software.
 *
 *   The Software shall be used for Good, not Evil.
 *
 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *   DEALINGS IN THE SOFTWARE.
 *
 * JSHint was forked from 2010-12-16 edition of JSLint.
 *
 */

/*
 JSHINT is a global function. It takes two parameters.

     var myResult = JSHINT(source, option);

 The first parameter is either a string or an array of strings. If it is a
 string, it will be split on '\n' or '\r'. If it is an array of strings, it
 is assumed that each string represents one line. The source can be a
 JavaScript text or a JSON text.

 The second parameter is an optional object of options which control the
 operation of JSHINT. Most of the options are booleans: They are all
 optional and have a default value of false. One of the options, predef,
 can be an array of names, which will be used to declare global variables,
 or an object whose keys are used as global names, with a boolean value
 that determines if they are assignable.

 If it checks out, JSHINT returns true. Otherwise, it returns false.

 If false, you can inspect JSHINT.errors to find out the problems.
 JSHINT.errors is an array of objects containing these members:

 {
     line      : The line (relative to 0) at which the lint was found
     character : The character (relative to 0) at which the lint was found
     reason    : The problem
     evidence  : The text line in which the problem occurred
     raw       : The raw message before the details were inserted
     a         : The first detail
     b         : The second detail
     c         : The third detail
     d         : The fourth detail
 }

 If a fatal error was found, a null will be the last element of the
 JSHINT.errors array.

 You can request a Function Report, which shows all of the functions
 and the parameters and vars that they use. This can be used to find
 implied global variables and other problems. The report is in HTML and
 can be inserted in an HTML <body>.

     var myReport = JSHINT.report(limited);

 If limited is true, then the report will be limited to only errors.

 You can request a data structure which contains JSHint's results.

     var myData = JSHINT.data();

 It returns a structure with this form:

 {
     errors: [
         {
             line: NUMBER,
             character: NUMBER,
             reason: STRING,
             evidence: STRING
         }
     ],
     functions: [
         name: STRING,
         line: NUMBER,
         last: NUMBER,
         param: [
             STRING
         ],
         closure: [
             STRING
         ],
         var: [
             STRING
         ],
         exception: [
             STRING
         ],
         outer: [
             STRING
         ],
         unused: [
             STRING
         ],
         global: [
             STRING
         ],
         label: [
             STRING
         ]
     ],
     globals: [
         STRING
     ],
     member: {
         STRING: NUMBER
     },
     unused: [
         {
             name: STRING,
             line: NUMBER
         }
     ],
     implieds: [
         {
             name: STRING,
             line: NUMBER
         }
     ],
     urls: [
         STRING
     ],
     json: BOOLEAN
 }

 Empty arrays will not be included.

*/

/*jshint
 evil: true, nomen: false, onevar: false, regexp: false, strict: true, boss: true,
 undef: true, maxlen: 100, indent:4
*/

/*members "\b", "\t", "\n", "\f", "\r", "!=", "!==", "\"", "%", "(begin)",
 "(breakage)", "(context)", "(error)", "(global)", "(identifier)", "(last)",
 "(line)", "(loopage)", "(name)", "(onevar)", "(params)", "(scope)",
 "(statement)", "(verb)", "*", "+", "++", "-", "--", "\/", "<", "<=", "==",
 "===", ">", ">=", $, $$, $A, $F, $H, $R, $break, $continue, $w, Abstract, Ajax,
 __filename, __dirname, ActiveXObject, Array, ArrayBuffer, ArrayBufferView, Audio,
 Autocompleter, Assets, Boolean, Builder, Buffer, Browser, COM, CScript, Canvas,
 CustomAnimation, Class, Control, Chain, Color, Cookie, Core, DataView, Date,
 Debug, Draggable, Draggables, Droppables, Document, DomReady, DOMReady, DOMParser, Drag,
 E, Enumerator, Enumerable, Element, Elements, Error, Effect, EvalError, Event,
 Events, FadeAnimation, Field, Flash, Float32Array, Float64Array, Form,
 FormField, Frame, FormData, Function, Fx, GetObject, Group, Hash, HotKey,
 HTMLElement, HTMLAnchorElement, HTMLBaseElement, HTMLBlockquoteElement,
 HTMLBodyElement, HTMLBRElement, HTMLButtonElement, HTMLCanvasElement, HTMLDirectoryElement,
 HTMLDivElement, HTMLDListElement, HTMLFieldSetElement,
 HTMLFontElement, HTMLFormElement, HTMLFrameElement, HTMLFrameSetElement,
 HTMLHeadElement, HTMLHeadingElement, HTMLHRElement, HTMLHtmlElement,
 HTMLIFrameElement, HTMLImageElement, HTMLInputElement, HTMLIsIndexElement,
 HTMLLabelElement, HTMLLayerElement, HTMLLegendElement, HTMLLIElement,
 HTMLLinkElement, HTMLMapElement, HTMLMenuElement, HTMLMetaElement,
 HTMLModElement, HTMLObjectElement, HTMLOListElement, HTMLOptGroupElement,
 HTMLOptionElement, HTMLParagraphElement, HTMLParamElement, HTMLPreElement,
 HTMLQuoteElement, HTMLScriptElement, HTMLSelectElement, HTMLStyleElement,
 HtmlTable, HTMLTableCaptionElement, HTMLTableCellElement, HTMLTableColElement,
 HTMLTableElement, HTMLTableRowElement, HTMLTableSectionElement,
 HTMLTextAreaElement, HTMLTitleElement, HTMLUListElement, HTMLVideoElement,
 Iframe, IframeShim, Image, Int16Array, Int32Array, Int8Array,
 Insertion, InputValidator, JSON, Keyboard, Locale, LN10, LN2, LOG10E, LOG2E,
 MAX_VALUE, MIN_VALUE, Mask, Math, MenuItem, MessageChannel, MessageEvent, MessagePort,
 MoveAnimation, MooTools, Native, NEGATIVE_INFINITY, Number, Object, ObjectRange, Option,
 Options, OverText, PI, POSITIVE_INFINITY, PeriodicalExecuter, Point, Position, Prototype,
 RangeError, Rectangle, ReferenceError, RegExp, ResizeAnimation, Request, RotateAnimation,
 SQRT1_2, SQRT2, ScrollBar, ScriptEngine, ScriptEngineBuildVersion,
 ScriptEngineMajorVersion, ScriptEngineMinorVersion, Scriptaculous, Scroller,
 Slick, Slider, Selector, SharedWorker, String, Style, SyntaxError, Sortable, Sortables,
 SortableObserver, Sound, Spinner, System, Swiff, Text, TextArea, Template,
 Timer, Tips, Type, TypeError, Toggle, Try, "use strict", unescape, URI, URIError, URL,
 VBArray, WSH, WScript, XDomainRequest, Web, Window, XMLDOM, XMLHttpRequest, XMLSerializer,
 XPathEvaluator, XPathException, XPathExpression, XPathNamespace, XPathNSResolver, XPathResult,
 "\\", a, addEventListener, address, alert, apply, applicationCache, arguments, arity, asi, atob,
 b, basic, basicToken, bitwise, block, blur, boolOptions, boss, browser, btoa, c, call, callee,
 caller, cases, charAt, charCodeAt, character, clearInterval, clearTimeout,
 close, closed, closure, comment, condition, confirm, console, constructor,
 content, couch, create, css, curly, d, data, datalist, dd, debug, decodeURI,
 decodeURIComponent, defaultStatus, defineClass, deserialize, devel, document,
 dojo, dijit, dojox, define, else, emit, encodeURI, encodeURIComponent,
 entityify, eqeq, eqeqeq, eqnull, errors, es5, escape, esnext, eval, event, evidence, evil,
 ex, exception, exec, exps, expr, exports, FileReader, first, floor, focus,
 forin, fragment, frames, from, fromCharCode, fud, funcscope, funct, function, functions,
 g, gc, getComputedStyle, getRow, getter, getterToken, GLOBAL, global, globals, globalstrict,
 hasOwnProperty, help, history, i, id, identifier, immed, implieds, importPackage, include,
 indent, indexOf, init, ins, instanceOf, isAlpha, isApplicationRunning, isArray,
 isDigit, isFinite, isNaN, iterator, java, join, jshint,
 JSHINT, json, jquery, jQuery, keys, label, labelled, last, lastsemic, laxbreak, laxcomma,
 latedef, lbp, led, left, length, line, load, loadClass, localStorage, location,
 log, loopfunc, m, match, maxerr, maxlen, member,message, meta, module, moveBy,
 moveTo, mootools, multistr, name, navigator, new, newcap, noarg, node, noempty, nomen,
 nonew, nonstandard, nud, onbeforeunload, onblur, onerror, onevar, onecase, onfocus,
 onload, onresize, onunload, open, openDatabase, openURL, opener, opera, options, outer, param,
 parent, parseFloat, parseInt, passfail, plusplus, predef, print, process, prompt,
 proto, prototype, prototypejs, provides, push, quit, range, raw, reach, reason, regexp,
 readFile, readUrl, regexdash, removeEventListener, replace, report, require,
 reserved, resizeBy, resizeTo, resolvePath, resumeUpdates, respond, rhino, right,
 runCommand, scroll, screen, scripturl, scrollBy, scrollTo, scrollbar, search, seal,
 send, serialize, sessionStorage, setInterval, setTimeout, setter, setterToken, shift, slice,
 smarttabs, sort, spawn, split, stack, status, start, strict, sub, substr, supernew, shadow,
 supplant, sum, sync, test, toLowerCase, toString, toUpperCase, toint32, token, top, trailing,
 type, typeOf, Uint16Array, Uint32Array, Uint8Array, undef, undefs, unused, urls, validthis,
 value, valueOf, var, vars, version, WebSocket, withstmt, white, window, windows, Worker, wsh*/

/*global exports: false */

// We build the application inside a function so that we produce only a single
// global variable. That function will be invoked immediately, and its return
// value is the JSHINT function itself.

var JSHINT = (function () {
    "use strict";

    var anonname,       // The guessed name for anonymous functions.

// These are operators that should not be used with the ! operator.

        bang = {
            '<'  : true,
            '<=' : true,
            '==' : true,
            '===': true,
            '!==': true,
            '!=' : true,
            '>'  : true,
            '>=' : true,
            '+'  : true,
            '-'  : true,
            '*'  : true,
            '/'  : true,
            '%'  : true
        },

        // These are the JSHint boolean options.
        boolOptions = {
            asi         : true, // if automatic semicolon insertion should be tolerated
            bitwise     : true, // if bitwise operators should not be allowed
            boss        : true, // if advanced usage of assignments should be allowed
            browser     : true, // if the standard browser globals should be predefined
            couch       : true, // if CouchDB globals should be predefined
            curly       : true, // if curly braces around all blocks should be required
            debug       : true, // if debugger statements should be allowed
            devel       : true, // if logging globals should be predefined (console,
                                // alert, etc.)
            dojo        : true, // if Dojo Toolkit globals should be predefined
            eqeqeq      : true, // if === should be required
            eqnull      : true, // if == null comparisons should be tolerated
            es5         : true, // if ES5 syntax should be allowed
            esnext      : true, // if es.next specific syntax should be allowed
            evil        : true, // if eval should be allowed
            expr        : true, // if ExpressionStatement should be allowed as Programs
            forin       : true, // if for in statements must filter
            funcscope   : true, // if only function scope should be used for scope tests
            globalstrict: true, // if global "use strict"; should be allowed (also
                                // enables 'strict')
            immed       : true, // if immediate invocations must be wrapped in parens
            iterator    : true, // if the `__iterator__` property should be allowed
            jquery      : true, // if jQuery globals should be predefined
            lastsemic   : true, // if semicolons may be ommitted for the trailing
                                // statements inside of a one-line blocks.
            latedef     : true, // if the use before definition should not be tolerated
            laxbreak    : true, // if line breaks should not be checked
            laxcomma    : true, // if line breaks should not be checked around commas
            loopfunc    : true, // if functions should be allowed to be defined within
                                // loops
            mootools    : true, // if MooTools globals should be predefined
            multistr    : true, // allow multiline strings
            newcap      : true, // if constructor names must be capitalized
            noarg       : true, // if arguments.caller and arguments.callee should be
                                // disallowed
            node        : true, // if the Node.js environment globals should be
                                // predefined
            noempty     : true, // if empty blocks should be disallowed
            nonew       : true, // if using `new` for side-effects should be disallowed
            nonstandard : true, // if non-standard (but widely adopted) globals should
                                // be predefined
            nomen       : true, // if names should be checked
            onevar      : true, // if only one var statement per function should be
                                // allowed
            onecase     : true, // if one case switch statements should be allowed
            passfail    : true, // if the scan should stop on first error
            plusplus    : true, // if increment/decrement should not be allowed
            proto       : true, // if the `__proto__` property should be allowed
            prototypejs : true, // if Prototype and Scriptaculous globals should be
                                // predefined
            regexdash   : true, // if unescaped first/last dash (-) inside brackets
                                // should be tolerated
            regexp      : true, // if the . should not be allowed in regexp literals
            rhino       : true, // if the Rhino environment globals should be predefined
            undef       : true, // if variables should be declared before used
            scripturl   : true, // if script-targeted URLs should be tolerated
            shadow      : true, // if variable shadowing should be tolerated
            smarttabs   : true, // if smarttabs should be tolerated
                                // (http://www.emacswiki.org/emacs/SmartTabs)
            strict      : true, // require the "use strict"; pragma
            sub         : true, // if all forms of subscript notation are tolerated
            supernew    : true, // if `new function () { ... };` and `new Object;`
                                // should be tolerated
            trailing    : true, // if trailing whitespace rules apply
            validthis   : true, // if 'this' inside a non-constructor function is valid.
                                // This is a function scoped option only.
            withstmt    : true, // if with statements should be allowed
            white       : true, // if strict whitespace rules apply
            wsh         : true  // if the Windows Scripting Host environment globals
                                // should be predefined
        },

        // These are the JSHint options that can take any value
        // (we use this object to detect invalid options)
        valOptions = {
            maxlen: false,
            indent: false,
            maxerr: false,
            predef: false
        },

        // These are JSHint boolean options which are shared with JSLint
        // where the definition in JSHint is opposite JSLint
        invertedOptions = {
            bitwise     : true,
            forin       : true,
            newcap      : true,
            nomen       : true,
            plusplus    : true,
            regexp      : true,
            undef       : true,
            white       : true,

            // Inverted and renamed, use JSHint name here
            eqeqeq      : true,
            onevar      : true
        },

        // These are JSHint boolean options which are shared with JSLint
        // where the name has been changed but the effect is unchanged
        renamedOptions = {
            eqeq        : "eqeqeq",
            vars        : "onevar",
            windows     : "wsh"
        },


        // browser contains a set of global names which are commonly provided by a
        // web browser environment.
        browser = {
            ArrayBuffer              :  false,
            ArrayBufferView          :  false,
            Audio                    :  false,
            addEventListener         :  false,
            applicationCache         :  false,
            atob                     :  false,
            blur                     :  false,
            btoa                     :  false,
            clearInterval            :  false,
            clearTimeout             :  false,
            close                    :  false,
            closed                   :  false,
            DataView                 :  false,
            DOMParser                :  false,
            defaultStatus            :  false,
            document                 :  false,
            event                    :  false,
            FileReader               :  false,
            Float32Array             :  false,
            Float64Array             :  false,
            FormData                 :  false,
            focus                    :  false,
            frames                   :  false,
            getComputedStyle         :  false,
            HTMLElement              :  false,
            HTMLAnchorElement        :  false,
            HTMLBaseElement          :  false,
            HTMLBlockquoteElement    :  false,
            HTMLBodyElement          :  false,
            HTMLBRElement            :  false,
            HTMLButtonElement        :  false,
            HTMLCanvasElement        :  false,
            HTMLDirectoryElement     :  false,
            HTMLDivElement           :  false,
            HTMLDListElement         :  false,
            HTMLFieldSetElement      :  false,
            HTMLFontElement          :  false,
            HTMLFormElement          :  false,
            HTMLFrameElement         :  false,
            HTMLFrameSetElement      :  false,
            HTMLHeadElement          :  false,
            HTMLHeadingElement       :  false,
            HTMLHRElement            :  false,
            HTMLHtmlElement          :  false,
            HTMLIFrameElement        :  false,
            HTMLImageElement         :  false,
            HTMLInputElement         :  false,
            HTMLIsIndexElement       :  false,
            HTMLLabelElement         :  false,
            HTMLLayerElement         :  false,
            HTMLLegendElement        :  false,
            HTMLLIElement            :  false,
            HTMLLinkElement          :  false,
            HTMLMapElement           :  false,
            HTMLMenuElement          :  false,
            HTMLMetaElement          :  false,
            HTMLModElement           :  false,
            HTMLObjectElement        :  false,
            HTMLOListElement         :  false,
            HTMLOptGroupElement      :  false,
            HTMLOptionElement        :  false,
            HTMLParagraphElement     :  false,
            HTMLParamElement         :  false,
            HTMLPreElement           :  false,
            HTMLQuoteElement         :  false,
            HTMLScriptElement        :  false,
            HTMLSelectElement        :  false,
            HTMLStyleElement         :  false,
            HTMLTableCaptionElement  :  false,
            HTMLTableCellElement     :  false,
            HTMLTableColElement      :  false,
            HTMLTableElement         :  false,
            HTMLTableRowElement      :  false,
            HTMLTableSectionElement  :  false,
            HTMLTextAreaElement      :  false,
            HTMLTitleElement         :  false,
            HTMLUListElement         :  false,
            HTMLVideoElement         :  false,
            history                  :  false,
            Int16Array               :  false,
            Int32Array               :  false,
            Int8Array                :  false,
            Image                    :  false,
            length                   :  false,
            localStorage             :  false,
            location                 :  false,
            MessageChannel           :  false,
            MessageEvent             :  false,
            MessagePort              :  false,
            moveBy                   :  false,
            moveTo                   :  false,
            name                     :  false,
            navigator                :  false,
            onbeforeunload           :  true,
            onblur                   :  true,
            onerror                  :  true,
            onfocus                  :  true,
            onload                   :  true,
            onresize                 :  true,
            onunload                 :  true,
            open                     :  false,
            openDatabase             :  false,
            opener                   :  false,
            Option                   :  false,
            parent                   :  false,
            print                    :  false,
            removeEventListener      :  false,
            resizeBy                 :  false,
            resizeTo                 :  false,
            screen                   :  false,
            scroll                   :  false,
            scrollBy                 :  false,
            scrollTo                 :  false,
            sessionStorage           :  false,
            setInterval              :  false,
            setTimeout               :  false,
            SharedWorker             :  false,
            status                   :  false,
            top                      :  false,
            Uint16Array              :  false,
            Uint32Array              :  false,
            Uint8Array               :  false,
            WebSocket                :  false,
            window                   :  false,
            Worker                   :  false,
            XMLHttpRequest           :  false,
            XMLSerializer            :  false,
            XPathEvaluator           :  false,
            XPathException           :  false,
            XPathExpression          :  false,
            XPathNamespace           :  false,
            XPathNSResolver          :  false,
            XPathResult              :  false
        },

        couch = {
            "require" : false,
            respond   : false,
            getRow    : false,
            emit      : false,
            send      : false,
            start     : false,
            sum       : false,
            log       : false,
            exports   : false,
            module    : false,
            provides  : false
        },

        devel = {
            alert   : false,
            confirm : false,
            console : false,
            Debug   : false,
            opera   : false,
            prompt  : false
        },

        dojo = {
            dojo      : false,
            dijit     : false,
            dojox     : false,
            define    : false,
            "require" : false
        },

        escapes = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '/' : '\\/',
            '\\': '\\\\'
        },

        funct,          // The current function

        functionicity = [
            'closure', 'exception', 'global', 'label',
            'outer', 'unused', 'var'
        ],

        functions,      // All of the functions

        global,         // The global scope
        implied,        // Implied globals
        inblock,
        indent,
        jsonmode,

        jquery = {
            '$'    : false,
            jQuery : false
        },

        lines,
        lookahead,
        member,
        membersOnly,

        mootools = {
            '$'             : false,
            '$$'            : false,
            Assets          : false,
            Browser         : false,
            Chain           : false,
            Class           : false,
            Color           : false,
            Cookie          : false,
            Core            : false,
            Document        : false,
            DomReady        : false,
            DOMReady        : false,
            Drag            : false,
            Element         : false,
            Elements        : false,
            Event           : false,
            Events          : false,
            Fx              : false,
            Group           : false,
            Hash            : false,
            HtmlTable       : false,
            Iframe          : false,
            IframeShim      : false,
            InputValidator  : false,
            instanceOf      : false,
            Keyboard        : false,
            Locale          : false,
            Mask            : false,
            MooTools        : false,
            Native          : false,
            Options         : false,
            OverText        : false,
            Request         : false,
            Scroller        : false,
            Slick           : false,
            Slider          : false,
            Sortables       : false,
            Spinner         : false,
            Swiff           : false,
            Tips            : false,
            Type            : false,
            typeOf          : false,
            URI             : false,
            Window          : false
        },

        nexttoken,

        node = {
            __filename    : false,
            __dirname     : false,
            Buffer        : false,
            console       : false,
            exports       : false,
            GLOBAL        : false,
            global        : false,
            module        : false,
            process       : false,
            require       : false,
            setTimeout    : false,
            clearTimeout  : false,
            setInterval   : false,
            clearInterval : false
        },

        noreach,
        option,
        predefined,     // Global variables defined by option
        prereg,
        prevtoken,

        prototypejs = {
            '$'               : false,
            '$$'              : false,
            '$A'              : false,
            '$F'              : false,
            '$H'              : false,
            '$R'              : false,
            '$break'          : false,
            '$continue'       : false,
            '$w'              : false,
            Abstract          : false,
            Ajax              : false,
            Class             : false,
            Enumerable        : false,
            Element           : false,
            Event             : false,
            Field             : false,
            Form              : false,
            Hash              : false,
            Insertion         : false,
            ObjectRange       : false,
            PeriodicalExecuter: false,
            Position          : false,
            Prototype         : false,
            Selector          : false,
            Template          : false,
            Toggle            : false,
            Try               : false,
            Autocompleter     : false,
            Builder           : false,
            Control           : false,
            Draggable         : false,
            Draggables        : false,
            Droppables        : false,
            Effect            : false,
            Sortable          : false,
            SortableObserver  : false,
            Sound             : false,
            Scriptaculous     : false
        },

        rhino = {
            defineClass  : false,
            deserialize  : false,
            gc           : false,
            help         : false,
            importPackage: false,
            "java"       : false,
            load         : false,
            loadClass    : false,
            print        : false,
            quit         : false,
            readFile     : false,
            readUrl      : false,
            runCommand   : false,
            seal         : false,
            serialize    : false,
            spawn        : false,
            sync         : false,
            toint32      : false,
            version      : false
        },

        scope,      // The current scope
        stack,

        // standard contains the global names that are provided by the
        // ECMAScript standard.
        standard = {
            Array               : false,
            Boolean             : false,
            Date                : false,
            decodeURI           : false,
            decodeURIComponent  : false,
            encodeURI           : false,
            encodeURIComponent  : false,
            Error               : false,
            'eval'              : false,
            EvalError           : false,
            Function            : false,
            hasOwnProperty      : false,
            isFinite            : false,
            isNaN               : false,
            JSON                : false,
            Math                : false,
            Number              : false,
            Object              : false,
            parseInt            : false,
            parseFloat          : false,
            RangeError          : false,
            ReferenceError      : false,
            RegExp              : false,
            String              : false,
            SyntaxError         : false,
            TypeError           : false,
            URIError            : false
        },

        // widely adopted global names that are not part of ECMAScript standard
        nonstandard = {
            escape              : false,
            unescape            : false
        },

        standard_member = {
            E                   : true,
            LN2                 : true,
            LN10                : true,
            LOG2E               : true,
            LOG10E              : true,
            MAX_VALUE           : true,
            MIN_VALUE           : true,
            NEGATIVE_INFINITY   : true,
            PI                  : true,
            POSITIVE_INFINITY   : true,
            SQRT1_2             : true,
            SQRT2               : true
        },

        directive,
        syntax = {},
        tab,
        token,
        urls,
        useESNextSyntax,
        warnings,

        wsh = {
            ActiveXObject             : true,
            Enumerator                : true,
            GetObject                 : true,
            ScriptEngine              : true,
            ScriptEngineBuildVersion  : true,
            ScriptEngineMajorVersion  : true,
            ScriptEngineMinorVersion  : true,
            VBArray                   : true,
            WSH                       : true,
            WScript                   : true,
            XDomainRequest            : true
        };

    // Regular expressions. Some of these are stupidly long.
    var ax, cx, tx, nx, nxg, lx, ix, jx, ft;
    (function () {
        /*jshint maxlen:300 */

        // unsafe comment or string
        ax = /@cc|<\/?|script|\]\s*\]|<\s*!|&lt/i;

        // unsafe characters that are silently deleted by one or more browsers
        cx = /[\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;

        // token
        tx = /^\s*([(){}\[.,:;'"~\?\]#@]|==?=?|\/(\*(jshint|jslint|members?|global)?|=|\/)?|\*[\/=]?|\+(?:=|\++)?|-(?:=|-+)?|%=?|&[&=]?|\|[|=]?|>>?>?=?|<([\/=!]|\!(\[|--)?|<=?)?|\^=?|\!=?=?|[a-zA-Z_$][a-zA-Z0-9_$]*|[0-9]+([xX][0-9a-fA-F]+|\.[0-9]*)?([eE][+\-]?[0-9]+)?)/;

        // characters in strings that need escapement
        nx = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/;
        nxg = /[\u0000-\u001f&<"\/\\\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

        // star slash
        lx = /\*\/|\/\*/;

        // identifier
        ix = /^([a-zA-Z_$][a-zA-Z0-9_$]*)$/;

        // javascript url
        jx = /^(?:javascript|jscript|ecmascript|vbscript|mocha|livescript)\s*:/i;

        // catches /* falls through */ comments
        ft = /^\s*\/\*\s*falls\sthrough\s*\*\/\s*$/;
    }());

    function F() {}     // Used by Object.create

    function is_own(object, name) {

// The object.hasOwnProperty method fails when the property under consideration
// is named 'hasOwnProperty'. So we have to use this more convoluted form.

        return Object.prototype.hasOwnProperty.call(object, name);
    }

    function checkOption(name, t) {
        if (valOptions[name] === undefined && boolOptions[name] === undefined) {
            warning("Bad option: '" + name + "'.", t);
        }
    }

// Provide critical ES5 functions to ES3.

    if (typeof Array.isArray !== 'function') {
        Array.isArray = function (o) {
            return Object.prototype.toString.apply(o) === '[object Array]';
        };
    }

    if (typeof Object.create !== 'function') {
        Object.create = function (o) {
            F.prototype = o;
            return new F();
        };
    }

    if (typeof Object.keys !== 'function') {
        Object.keys = function (o) {
            var a = [], k;
            for (k in o) {
                if (is_own(o, k)) {
                    a.push(k);
                }
            }
            return a;
        };
    }

// Non standard methods

    if (typeof String.prototype.entityify !== 'function') {
        String.prototype.entityify = function () {
            return this
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        };
    }

    if (typeof String.prototype.isAlpha !== 'function') {
        String.prototype.isAlpha = function () {
            return (this >= 'a' && this <= 'z\uffff') ||
                (this >= 'A' && this <= 'Z\uffff');
        };
    }

    if (typeof String.prototype.isDigit !== 'function') {
        String.prototype.isDigit = function () {
            return (this >= '0' && this <= '9');
        };
    }

    if (typeof String.prototype.supplant !== 'function') {
        String.prototype.supplant = function (o) {
            return this.replace(/\{([^{}]*)\}/g, function (a, b) {
                var r = o[b];
                return typeof r === 'string' || typeof r === 'number' ? r : a;
            });
        };
    }

    if (typeof String.prototype.name !== 'function') {
        String.prototype.name = function () {

// If the string looks like an identifier, then we can return it as is.
// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can simply slap some quotes around it.
// Otherwise we must also replace the offending characters with safe
// sequences.

            if (ix.test(this)) {
                return this;
            }
            if (nx.test(this)) {
                return '"' + this.replace(nxg, function (a) {
                    var c = escapes[a];
                    if (c) {
                        return c;
                    }
                    return '\\u' + ('0000' + a.charCodeAt().toString(16)).slice(-4);
                }) + '"';
            }
            return '"' + this + '"';
        };
    }


    function combine(t, o) {
        var n;
        for (n in o) {
            if (is_own(o, n)) {
                t[n] = o[n];
            }
        }
    }

    function assume() {
        if (option.couch) {
            combine(predefined, couch);
        }

        if (option.rhino) {
            combine(predefined, rhino);
        }

        if (option.prototypejs) {
            combine(predefined, prototypejs);
        }

        if (option.node) {
            combine(predefined, node);
            option.globalstrict = true;
        }

        if (option.devel) {
            combine(predefined, devel);
        }

        if (option.dojo) {
            combine(predefined, dojo);
        }

        if (option.browser) {
            combine(predefined, browser);
        }

        if (option.nonstandard) {
            combine(predefined, nonstandard);
        }

        if (option.jquery) {
            combine(predefined, jquery);
        }

        if (option.mootools) {
            combine(predefined, mootools);
        }

        if (option.wsh) {
            combine(predefined, wsh);
        }

        if (option.esnext) {
            useESNextSyntax();
        }

        if (option.globalstrict && option.strict !== false) {
            option.strict = true;
        }
    }


    // Produce an error warning.
    function quit(message, line, chr) {
        var percentage = Math.floor((line / lines.length) * 100);

        throw {
            name: 'JSHintError',
            line: line,
            character: chr,
            message: message + " (" + percentage + "% scanned).",
            raw: message
        };
    }

    function isundef(scope, m, t, a) {
        return JSHINT.undefs.push([scope, m, t, a]);
    }

    function warning(m, t, a, b, c, d) {
        var ch, l, w;
        t = t || nexttoken;
        if (t.id === '(end)') {  // `~
            t = token;
        }
        l = t.line || 0;
        ch = t.from || 0;
        w = {
            id: '(error)',
            raw: m,
            evidence: lines[l - 1] || '',
            line: l,
            character: ch,
            a: a,
            b: b,
            c: c,
            d: d
        };
        w.reason = m.supplant(w);
        JSHINT.errors.push(w);
        if (option.passfail) {
            quit('Stopping. ', l, ch);
        }
        warnings += 1;
        if (warnings >= option.maxerr) {
            quit("Too many errors.", l, ch);
        }
        return w;
    }

    function warningAt(m, l, ch, a, b, c, d) {
        return warning(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }

    function error(m, t, a, b, c, d) {
        var w = warning(m, t, a, b, c, d);
    }

    function errorAt(m, l, ch, a, b, c, d) {
        return error(m, {
            line: l,
            from: ch
        }, a, b, c, d);
    }



// lexical analysis and token construction

    var lex = (function lex() {
        var character, from, line, s;

// Private lex methods

        function nextLine() {
            var at,
                tw; // trailing whitespace check

            if (line >= lines.length)
                return false;

            character = 1;
            s = lines[line];
            line += 1;

            // If smarttabs option is used check for spaces followed by tabs only.
            // Otherwise check for any occurence of mixed tabs and spaces.
            if (option.smarttabs)
                at = s.search(/ \t/);
            else
                at = s.search(/ \t|\t /);

            if (at >= 0)
                warningAt("Mixed spaces and tabs.", line, at + 1);

            s = s.replace(/\t/g, tab);
            at = s.search(cx);

            if (at >= 0)
                warningAt("Unsafe character.", line, at);

            if (option.maxlen && option.maxlen < s.length)
                warningAt("Line too long.", line, s.length);

            // Check for trailing whitespaces
            tw = option.trailing && s.match(/^(.*?)\s+$/);
            if (tw && !/^\s+$/.test(s)) {
                warningAt("Trailing whitespace.", line, tw[1].length + 1);
            }
            return true;
        }

// Produce a token object.  The token inherits from a syntax symbol.

        function it(type, value) {
            var i, t;
            if (type === '(color)' || type === '(range)') {
                t = {type: type};
            } else if (type === '(punctuator)' ||
                    (type === '(identifier)' && is_own(syntax, value))) {
                t = syntax[value] || syntax['(error)'];
            } else {
                t = syntax[type];
            }
            t = Object.create(t);
            if (type === '(string)' || type === '(range)') {
                if (!option.scripturl && jx.test(value)) {
                    warningAt("Script URL.", line, from);
                }
            }
            if (type === '(identifier)') {
                t.identifier = true;
                if (value === '__proto__' && !option.proto) {
                    warningAt("The '{a}' property is deprecated.",
                        line, from, value);
                } else if (value === '__iterator__' && !option.iterator) {
                    warningAt("'{a}' is only available in JavaScript 1.7.",
                        line, from, value);
                } else if (option.nomen && (value.charAt(0) === '_' ||
                         value.charAt(value.length - 1) === '_')) {
                    if (!option.node || token.id === '.' ||
                            (value !== '__dirname' && value !== '__filename')) {
                        warningAt("Unexpected {a} in '{b}'.", line, from, "dangling '_'", value);
                    }
                }
            }
            t.value = value;
            t.line = line;
            t.character = character;
            t.from = from;
            i = t.id;
            if (i !== '(endline)') {
                prereg = i &&
                    (('(,=:[!&|?{};'.indexOf(i.charAt(i.length - 1)) >= 0) ||
                    i === 'return' ||
                    i === 'case');
            }
            return t;
        }

        // Public lex methods
        return {
            init: function (source) {
                if (typeof source === 'string') {
                    lines = source
                        .replace(/\r\n/g, '\n')
                        .replace(/\r/g, '\n')
                        .split('\n');
                } else {
                    lines = source;
                }

                // If the first line is a shebang (#!), make it a blank and move on.
                // Shebangs are used by Node scripts.
                if (lines[0] && lines[0].substr(0, 2) === '#!')
                    lines[0] = '';

                line = 0;
                nextLine();
                from = 1;
            },

            range: function (begin, end) {
                var c, value = '';
                from = character;
                if (s.charAt(0) !== begin) {
                    errorAt("Expected '{a}' and instead saw '{b}'.",
                            line, character, begin, s.charAt(0));
                }
                for (;;) {
                    s = s.slice(1);
                    character += 1;
                    c = s.charAt(0);
                    switch (c) {
                    case '':
                        errorAt("Missing '{a}'.", line, character, c);
                        break;
                    case end:
                        s = s.slice(1);
                        character += 1;
                        return it('(range)', value);
                    case '\\':
                        warningAt("Unexpected '{a}'.", line, character, c);
                    }
                    value += c;
                }

            },


            // token -- this is called by advance to get the next token
            token: function () {
                var b, c, captures, d, depth, high, i, l, low, q, t, isLiteral, isInRange, n;

                function match(x) {
                    var r = x.exec(s), r1;
                    if (r) {
                        l = r[0].length;
                        r1 = r[1];
                        c = r1.charAt(0);
                        s = s.substr(l);
                        from = character + l - r1.length;
                        character += l;
                        return r1;
                    }
                }

                function string(x) {
                    var c, j, r = '', allowNewLine = false;

                    if (jsonmode && x !== '"') {
                        warningAt("Strings must use doublequote.",
                                line, character);
                    }

                    function esc(n) {
                        var i = parseInt(s.substr(j + 1, n), 16);
                        j += n;
                        if (i >= 32 && i <= 126 &&
                                i !== 34 && i !== 92 && i !== 39) {
                            warningAt("Unnecessary escapement.", line, character);
                        }
                        character += n;
                        c = String.fromCharCode(i);
                    }
                    j = 0;
unclosedString:     for (;;) {
                        while (j >= s.length) {
                            j = 0;

                            var cl = line, cf = from;
                            if (!nextLine()) {
                                errorAt("Unclosed string.", cl, cf);
                                break unclosedString;
                            }

                            if (allowNewLine) {
                                allowNewLine = false;
                            } else {
                                warningAt("Unclosed string.", cl, cf);
                            }
                        }
                        c = s.charAt(j);
                        if (c === x) {
                            character += 1;
                            s = s.substr(j + 1);
                            return it('(string)', r, x);
                        }
                        if (c < ' ') {
                            if (c === '\n' || c === '\r') {
                                break;
                            }
                            warningAt("Control character in string: {a}.",
                                    line, character + j, s.slice(0, j));
                        } else if (c === '\\') {
                            j += 1;
                            character += 1;
                            c = s.charAt(j);
                            n = s.charAt(j + 1);
                            switch (c) {
                            case '\\':
                            case '"':
                            case '/':
                                break;
                            case '\'':
                                if (jsonmode) {
                                    warningAt("Avoid \\'.", line, character);
                                }
                                break;
                            case 'b':
                                c = '\b';
                                break;
                            case 'f':
                                c = '\f';
                                break;
                            case 'n':
                                c = '\n';
                                break;
                            case 'r':
                                c = '\r';
                                break;
                            case 't':
                                c = '\t';
                                break;
                            case '0':
                                c = '\0';
                                // Octal literals fail in strict mode
                                // check if the number is between 00 and 07
                                // where 'n' is the token next to 'c'
                                if (n >= 0 && n <= 7 && directive["use strict"]) {
                                    warningAt(
                                    "Octal literals are not allowed in strict mode.",
                                    line, character);
                                }
                                break;
                            case 'u':
                                esc(4);
                                break;
                            case 'v':
                                if (jsonmode) {
                                    warningAt("Avoid \\v.", line, character);
                                }
                                c = '\v';
                                break;
                            case 'x':
                                if (jsonmode) {
                                    warningAt("Avoid \\x-.", line, character);
                                }
                                esc(2);
                                break;
                            case '':
                                // last character is escape character
                                // always allow new line if escaped, but show
                                // warning if option is not set
                                allowNewLine = true;
                                if (option.multistr) {
                                    if (jsonmode) {
                                        warningAt("Avoid EOL escapement.", line, character);
                                    }
                                    c = '';
                                    character -= 1;
                                    break;
                                }
                                warningAt("Bad escapement of EOL. Use option multistr if needed.",
                                    line, character);
                                break;
                            default:
                                warningAt("Bad escapement.", line, character);
                            }
                        }
                        r += c;
                        character += 1;
                        j += 1;
                    }
                }

                for (;;) {
                    if (!s) {
                        return it(nextLine() ? '(endline)' : '(end)', '');
                    }
                    t = match(tx);
                    if (!t) {
                        t = '';
                        c = '';
                        while (s && s < '!') {
                            s = s.substr(1);
                        }
                        if (s) {
                            errorAt("Unexpected '{a}'.", line, character, s.substr(0, 1));
                            s = '';
                        }
                    } else {

    //      identifier

                        if (c.isAlpha() || c === '_' || c === '$') {
                            return it('(identifier)', t);
                        }

    //      number

                        if (c.isDigit()) {
                            if (!isFinite(Number(t))) {
                                warningAt("Bad number '{a}'.",
                                    line, character, t);
                            }
                            if (s.substr(0, 1).isAlpha()) {
                                warningAt("Missing space after '{a}'.",
                                        line, character, t);
                            }
                            if (c === '0') {
                                d = t.substr(1, 1);
                                if (d.isDigit()) {
                                    if (token.id !== '.') {
                                        warningAt("Don't use extra leading zeros '{a}'.",
                                            line, character, t);
                                    }
                                } else if (jsonmode && (d === 'x' || d === 'X')) {
                                    warningAt("Avoid 0x-. '{a}'.",
                                            line, character, t);
                                }
                            }
                            if (t.substr(t.length - 1) === '.') {
                                warningAt(
"A trailing decimal point can be confused with a dot '{a}'.", line, character, t);
                            }
                            return it('(number)', t);
                        }
                        switch (t) {

    //      string

                        case '"':
                        case "'":
                            return string(t);

    //      // comment

                        case '//':
                            s = '';
                            token.comment = true;
                            break;

    //      /* comment

                        case '/*':
                            for (;;) {
                                i = s.search(lx);
                                if (i >= 0) {
                                    break;
                                }
                                if (!nextLine()) {
                                    errorAt("Unclosed comment.", line, character);
                                }
                            }
                            character += i + 2;
                            if (s.substr(i, 1) === '/') {
                                errorAt("Nested comment.", line, character);
                            }
                            s = s.substr(i + 2);
                            token.comment = true;
                            break;

    //      /*members /*jshint /*global

                        case '/*members':
                        case '/*member':
                        case '/*jshint':
                        case '/*jslint':
                        case '/*global':
                        case '*/':
                            return {
                                value: t,
                                type: 'special',
                                line: line,
                                character: character,
                                from: from
                            };

                        case '':
                            break;
    //      /
                        case '/':
                            if (token.id === '/=') {
                                errorAt("A regular expression literal can be confused with '/='.",
                                    line, from);
                            }
                            if (prereg) {
                                depth = 0;
                                captures = 0;
                                l = 0;
                                for (;;) {
                                    b = true;
                                    c = s.charAt(l);
                                    l += 1;
                                    switch (c) {
                                    case '':
                                        errorAt("Unclosed regular expression.", line, from);
                                        return quit('Stopping.', line, from);
                                    case '/':
                                        if (depth > 0) {
                                            warningAt("{a} unterminated regular expression " +
                                                "group(s).", line, from + l, depth);
                                        }
                                        c = s.substr(0, l - 1);
                                        q = {
                                            g: true,
                                            i: true,
                                            m: true
                                        };
                                        while (q[s.charAt(l)] === true) {
                                            q[s.charAt(l)] = false;
                                            l += 1;
                                        }
                                        character += l;
                                        s = s.substr(l);
                                        q = s.charAt(0);
                                        if (q === '/' || q === '*') {
                                            errorAt("Confusing regular expression.",
                                                    line, from);
                                        }
                                        return it('(regexp)', c);
                                    case '\\':
                                        c = s.charAt(l);
                                        if (c < ' ') {
                                            warningAt(
"Unexpected control character in regular expression.", line, from + l);
                                        } else if (c === '<') {
                                            warningAt(
"Unexpected escaped character '{a}' in regular expression.", line, from + l, c);
                                        }
                                        l += 1;
                                        break;
                                    case '(':
                                        depth += 1;
                                        b = false;
                                        if (s.charAt(l) === '?') {
                                            l += 1;
                                            switch (s.charAt(l)) {
                                            case ':':
                                            case '=':
                                            case '!':
                                                l += 1;
                                                break;
                                            default:
                                                warningAt(
"Expected '{a}' and instead saw '{b}'.", line, from + l, ':', s.charAt(l));
                                            }
                                        } else {
                                            captures += 1;
                                        }
                                        break;
                                    case '|':
                                        b = false;
                                        break;
                                    case ')':
                                        if (depth === 0) {
                                            warningAt("Unescaped '{a}'.",
                                                    line, from + l, ')');
                                        } else {
                                            depth -= 1;
                                        }
                                        break;
                                    case ' ':
                                        q = 1;
                                        while (s.charAt(l) === ' ') {
                                            l += 1;
                                            q += 1;
                                        }
                                        if (q > 1) {
                                            warningAt(
"Spaces are hard to count. Use {{a}}.", line, from + l, q);
                                        }
                                        break;
                                    case '[':
                                        c = s.charAt(l);
                                        if (c === '^') {
                                            l += 1;
                                            if (option.regexp) {
                                                warningAt("Insecure '{a}'.",
                                                        line, from + l, c);
                                            } else if (s.charAt(l) === ']') {
                                                errorAt("Unescaped '{a}'.",
                                                    line, from + l, '^');
                                            }
                                        }
                                        if (c === ']') {
                                            warningAt("Empty class.", line,
                                                    from + l - 1);
                                        }
                                        isLiteral = false;
                                        isInRange = false;
klass:                                  do {
                                            c = s.charAt(l);
                                            l += 1;
                                            switch (c) {
                                            case '[':
                                            case '^':
                                                warningAt("Unescaped '{a}'.",
                                                        line, from + l, c);
                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            case '-':
                                                if (isLiteral && !isInRange) {
                                                    isLiteral = false;
                                                    isInRange = true;
                                                } else if (isInRange) {
                                                    isInRange = false;
                                                } else if (s.charAt(l) === ']') {
                                                    isInRange = true;
                                                } else {
                                                    if (option.regexdash !== (l === 2 || (l === 3 &&
                                                        s.charAt(1) === '^'))) {
                                                        warningAt("Unescaped '{a}'.",
                                                            line, from + l - 1, '-');
                                                    }
                                                    isLiteral = true;
                                                }
                                                break;
                                            case ']':
                                                if (isInRange && !option.regexdash) {
                                                    warningAt("Unescaped '{a}'.",
                                                            line, from + l - 1, '-');
                                                }
                                                break klass;
                                            case '\\':
                                                c = s.charAt(l);
                                                if (c < ' ') {
                                                    warningAt(
"Unexpected control character in regular expression.", line, from + l);
                                                } else if (c === '<') {
                                                    warningAt(
"Unexpected escaped character '{a}' in regular expression.", line, from + l, c);
                                                }
                                                l += 1;

                                                // \w, \s and \d are never part of a character range
                                                if (/[wsd]/i.test(c)) {
                                                    if (isInRange) {
                                                        warningAt("Unescaped '{a}'.",
                                                            line, from + l, '-');
                                                        isInRange = false;
                                                    }
                                                    isLiteral = false;
                                                } else if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            case '/':
                                                warningAt("Unescaped '{a}'.",
                                                        line, from + l - 1, '/');

                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            case '<':
                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                                break;
                                            default:
                                                if (isInRange) {
                                                    isInRange = false;
                                                } else {
                                                    isLiteral = true;
                                                }
                                            }
                                        } while (c);
                                        break;
                                    case '.':
                                        if (option.regexp) {
                                            warningAt("Insecure '{a}'.", line,
                                                    from + l, c);
                                        }
                                        break;
                                    case ']':
                                    case '?':
                                    case '{':
                                    case '}':
                                    case '+':
                                    case '*':
                                        warningAt("Unescaped '{a}'.", line,
                                                from + l, c);
                                    }
                                    if (b) {
                                        switch (s.charAt(l)) {
                                        case '?':
                                        case '+':
                                        case '*':
                                            l += 1;
                                            if (s.charAt(l) === '?') {
                                                l += 1;
                                            }
                                            break;
                                        case '{':
                                            l += 1;
                                            c = s.charAt(l);
                                            if (c < '0' || c > '9') {
                                                warningAt(
"Expected a number and instead saw '{a}'.", line, from + l, c);
                                            }
                                            l += 1;
                                            low = +c;
                                            for (;;) {
                                                c = s.charAt(l);
                                                if (c < '0' || c > '9') {
                                                    break;
                                                }
                                                l += 1;
                                                low = +c + (low * 10);
                                            }
                                            high = low;
                                            if (c === ',') {
                                                l += 1;
                                                high = Infinity;
                                                c = s.charAt(l);
                                                if (c >= '0' && c <= '9') {
                                                    l += 1;
                                                    high = +c;
                                                    for (;;) {
                                                        c = s.charAt(l);
                                                        if (c < '0' || c > '9') {
                                                            break;
                                                        }
                                                        l += 1;
                                                        high = +c + (high * 10);
                                                    }
                                                }
                                            }
                                            if (s.charAt(l) !== '}') {
                                                warningAt(
"Expected '{a}' and instead saw '{b}'.", line, from + l, '}', c);
                                            } else {
                                                l += 1;
                                            }
                                            if (s.charAt(l) === '?') {
                                                l += 1;
                                            }
                                            if (low > high) {
                                                warningAt(
"'{a}' should not be greater than '{b}'.", line, from + l, low, high);
                                            }
                                        }
                                    }
                                }
                                c = s.substr(0, l - 1);
                                character += l;
                                s = s.substr(l);
                                return it('(regexp)', c);
                            }
                            return it('(punctuator)', t);

    //      punctuator

                        case '#':
                            return it('(punctuator)', t);
                        default:
                            return it('(punctuator)', t);
                        }
                    }
                }
            }
        };
    }());


    function addlabel(t, type) {

        if (t === 'hasOwnProperty') {
            warning("'hasOwnProperty' is a really bad name.");
        }

// Define t in the current function in the current scope.
        if (is_own(funct, t) && !funct['(global)']) {
            if (funct[t] === true) {
                if (option.latedef)
                    warning("'{a}' was used before it was defined.", nexttoken, t);
            } else {
                if (!option.shadow && type !== "exception")
                    warning("'{a}' is already defined.", nexttoken, t);
            }
        }

        funct[t] = type;
        if (funct['(global)']) {
            global[t] = funct;
            if (is_own(implied, t)) {
                if (option.latedef)
                    warning("'{a}' was used before it was defined.", nexttoken, t);
                delete implied[t];
            }
        } else {
            scope[t] = funct;
        }
    }


    function doOption() {
        var b, obj, filter, o = nexttoken.value, t, tn, v;

        switch (o) {
        case '*/':
            error("Unbegun comment.");
            break;
        case '/*members':
        case '/*member':
            o = '/*members';
            if (!membersOnly) {
                membersOnly = {};
            }
            obj = membersOnly;
            break;
        case '/*jshint':
        case '/*jslint':
            obj = option;
            filter = boolOptions;
            break;
        case '/*global':
            obj = predefined;
            break;
        default:
            error("What?");
        }

        t = lex.token();
loop:   for (;;) {
            for (;;) {
                if (t.type === 'special' && t.value === '*/') {
                    break loop;
                }
                if (t.id !== '(endline)' && t.id !== ',') {
                    break;
                }
                t = lex.token();
            }
            if (t.type !== '(string)' && t.type !== '(identifier)' &&
                    o !== '/*members') {
                error("Bad option.", t);
            }

            v = lex.token();
            if (v.id === ':') {
                v = lex.token();

                if (obj === membersOnly) {
                    error("Expected '{a}' and instead saw '{b}'.",
                            t, '*/', ':');
                }

                if (o === '/*jshint') {
                    checkOption(t.value, t);
                }

                if (t.value === 'indent' && (o === '/*jshint' || o === '/*jslint')) {
                    b = +v.value;
                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.white = true;
                    obj.indent = b;
                } else if (t.value === 'maxerr' && (o === '/*jshint' || o === '/*jslint')) {
                    b = +v.value;
                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.maxerr = b;
                } else if (t.value === 'maxlen' && (o === '/*jshint' || o === '/*jslint')) {
                    b = +v.value;
                    if (typeof b !== 'number' || !isFinite(b) || b <= 0 ||
                            Math.floor(b) !== b) {
                        error("Expected a small integer and instead saw '{a}'.",
                                v, v.value);
                    }
                    obj.maxlen = b;
                } else if (t.value === 'validthis') {
                    if (funct['(global)']) {
                        error("Option 'validthis' can't be used in a global scope.");
                    } else {
                        if (v.value === 'true' || v.value === 'false')
                            obj[t.value] = v.value === 'true';
                        else
                            error("Bad option value.", v);
                    }
                } else if (v.value === 'true' || v.value === 'false') {
                    if (o === '/*jslint') {
                        tn = renamedOptions[t.value] || t.value;
                        obj[tn] = v.value === 'true';
                        if (invertedOptions[tn] !== undefined) {
                            obj[tn] = !obj[tn];
                        }
                    } else {
                        obj[t.value] = v.value === 'true';
                    }
                } else {
                    error("Bad option value.", v);
                }
                t = lex.token();
            } else {
                if (o === '/*jshint' || o === '/*jslint') {
                    error("Missing option value.", t);
                }
                obj[t.value] = false;
                t = v;
            }
        }
        if (filter) {
            assume();
        }
    }


// We need a peek function. If it has an argument, it peeks that much farther
// ahead. It is used to distinguish
//     for ( var i in ...
// from
//     for ( var i = ...

    function peek(p) {
        var i = p || 0, j = 0, t;

        while (j <= i) {
            t = lookahead[j];
            if (!t) {
                t = lookahead[j] = lex.token();
            }
            j += 1;
        }
        return t;
    }



// Produce the next token. It looks for programming errors.

    function advance(id, t) {
        switch (token.id) {
        case '(number)':
            if (nexttoken.id === '.') {
                warning("A dot following a number can be confused with a decimal point.", token);
            }
            break;
        case '-':
            if (nexttoken.id === '-' || nexttoken.id === '--') {
                warning("Confusing minusses.");
            }
            break;
        case '+':
            if (nexttoken.id === '+' || nexttoken.id === '++') {
                warning("Confusing plusses.");
            }
            break;
        }

        if (token.type === '(string)' || token.identifier) {
            anonname = token.value;
        }

        if (id && nexttoken.id !== id) {
            if (t) {
                if (nexttoken.id === '(end)') {
                    warning("Unmatched '{a}'.", t, t.id);
                } else {
                    warning("Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.",
                            nexttoken, id, t.id, t.line, nexttoken.value);
                }
            } else if (nexttoken.type !== '(identifier)' ||
                            nexttoken.value !== id) {
                warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, id, nexttoken.value);
            }
        }

        prevtoken = token;
        token = nexttoken;
        for (;;) {
            nexttoken = lookahead.shift() || lex.token();
            if (nexttoken.id === '(end)' || nexttoken.id === '(error)') {
                return;
            }
            if (nexttoken.type === 'special') {
                doOption();
            } else {
                if (nexttoken.id !== '(endline)') {
                    break;
                }
            }
        }
    }


// This is the heart of JSHINT, the Pratt parser. In addition to parsing, it
// is looking for ad hoc lint patterns. We add .fud to Pratt's model, which is
// like .nud except that it is only used on the first token of a statement.
// Having .fud makes it much easier to define statement-oriented languages like
// JavaScript. I retained Pratt's nomenclature.

// .nud     Null denotation
// .fud     First null denotation
// .led     Left denotation
//  lbp     Left binding power
//  rbp     Right binding power

// They are elements of the parsing method called Top Down Operator Precedence.

    function expression(rbp, initial) {
        var left, isArray = false, isObject = false;

        if (nexttoken.id === '(end)')
            error("Unexpected early end of program.", token);

        advance();
        if (initial) {
            anonname = 'anonymous';
            funct['(verb)'] = token.value;
        }
        if (initial === true && token.fud) {
            left = token.fud();
        } else {
            if (token.nud) {
                left = token.nud();
            } else {
                if (nexttoken.type === '(number)' && token.id === '.') {
                    warning("A leading decimal point can be confused with a dot: '.{a}'.",
                            token, nexttoken.value);
                    advance();
                    return token;
                } else {
                    error("Expected an identifier and instead saw '{a}'.",
                            token, token.id);
                }
            }
            while (rbp < nexttoken.lbp) {
                isArray = token.value === 'Array';
                isObject = token.value === 'Object';

                // #527, new Foo.Array(), Foo.Array(), new Foo.Object(), Foo.Object()
                // Line breaks in IfStatement heads exist to satisfy the checkJSHint
                // "Line too long." error.
                if (left && (left.value || (left.first && left.first.value))) {
                    // If the left.value is not "new", or the left.first.value is a "."
                    // then safely assume that this is not "new Array()" and possibly
                    // not "new Object()"...
                    if (left.value !== 'new' ||
                      (left.first && left.first.value && left.first.value === '.')) {
                        isArray = false;
                        // ...In the case of Object, if the left.value and token.value
                        // are not equal, then safely assume that this not "new Object()"
                        if (left.value !== token.value) {
                            isObject = false;
                        }
                    }
                }

                advance();
                if (isArray && token.id === '(' && nexttoken.id === ')')
                    warning("Use the array literal notation [].", token);
                if (isObject && token.id === '(' && nexttoken.id === ')')
                    warning("Use the object literal notation {}.", token);
                if (token.led) {
                    left = token.led(left);
                } else {
                    error("Expected an operator and instead saw '{a}'.",
                        token, token.id);
                }
            }
        }
        return left;
    }


// Functions for conformance of style.

    function adjacent(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white) {
            if (left.character !== right.from && left.line === right.line) {
                left.from += (left.character - left.from);
                warning("Unexpected space after '{a}'.", left, left.value);
            }
        }
    }

    function nobreak(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white && (left.character !== right.from || left.line !== right.line)) {
            warning("Unexpected space before '{a}'.", right, right.value);
        }
    }

    function nospace(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (option.white && !left.comment) {
            if (left.line === right.line) {
                adjacent(left, right);
            }
        }
    }

    function nonadjacent(left, right) {
        if (option.white) {
            left = left || token;
            right = right || nexttoken;
            if (left.line === right.line && left.character === right.from) {
                left.from += (left.character - left.from);
                warning("Missing space after '{a}'.",
                        left, left.value);
            }
        }
    }

    function nobreaknonadjacent(left, right) {
        left = left || token;
        right = right || nexttoken;
        if (!option.laxbreak && left.line !== right.line) {
            warning("Bad line breaking before '{a}'.", right, right.id);
        } else if (option.white) {
            left = left || token;
            right = right || nexttoken;
            if (left.character === right.from) {
                left.from += (left.character - left.from);
                warning("Missing space after '{a}'.",
                        left, left.value);
            }
        }
    }

    function indentation(bias) {
        var i;
        if (option.white && nexttoken.id !== '(end)') {
            i = indent + (bias || 0);
            if (nexttoken.from !== i) {
                warning(
"Expected '{a}' to have an indentation at {b} instead at {c}.",
                        nexttoken, nexttoken.value, i, nexttoken.from);
            }
        }
    }

    function nolinebreak(t) {
        t = t || token;
        if (t.line !== nexttoken.line) {
            warning("Line breaking error '{a}'.", t, t.value);
        }
    }


    function comma() {
        if (token.line !== nexttoken.line) {
            if (!option.laxcomma) {
                if (comma.first) {
                    warning("Comma warnings can be turned off with 'laxcomma'");
                    comma.first = false;
                }
                warning("Bad line breaking before '{a}'.", token, nexttoken.id);
            }
        } else if (!token.comment && token.character !== nexttoken.from && option.white) {
            token.from += (token.character - token.from);
            warning("Unexpected space after '{a}'.", token, token.value);
        }
        advance(',');
        nonadjacent(token, nexttoken);
    }


// Functional constructors for making the symbols that will be inherited by
// tokens.

    function symbol(s, p) {
        var x = syntax[s];
        if (!x || typeof x !== 'object') {
            syntax[s] = x = {
                id: s,
                lbp: p,
                value: s
            };
        }
        return x;
    }


    function delim(s) {
        return symbol(s, 0);
    }


    function stmt(s, f) {
        var x = delim(s);
        x.identifier = x.reserved = true;
        x.fud = f;
        return x;
    }


    function blockstmt(s, f) {
        var x = stmt(s, f);
        x.block = true;
        return x;
    }


    function reserveName(x) {
        var c = x.id.charAt(0);
        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            x.identifier = x.reserved = true;
        }
        return x;
    }


    function prefix(s, f) {
        var x = symbol(s, 150);
        reserveName(x);
        x.nud = (typeof f === 'function') ? f : function () {
            this.right = expression(150);
            this.arity = 'unary';
            if (this.id === '++' || this.id === '--') {
                if (option.plusplus) {
                    warning("Unexpected use of '{a}'.", this, this.id);
                } else if ((!this.right.identifier || this.right.reserved) &&
                        this.right.id !== '.' && this.right.id !== '[') {
                    warning("Bad operand.", this);
                }
            }
            return this;
        };
        return x;
    }


    function type(s, f) {
        var x = delim(s);
        x.type = s;
        x.nud = f;
        return x;
    }


    function reserve(s, f) {
        var x = type(s, f);
        x.identifier = x.reserved = true;
        return x;
    }


    function reservevar(s, v) {
        return reserve(s, function () {
            if (typeof v === 'function') {
                v(this);
            }
            return this;
        });
    }


    function infix(s, f, p, w) {
        var x = symbol(s, p);
        reserveName(x);
        x.led = function (left) {
            if (!w) {
                nobreaknonadjacent(prevtoken, token);
                nonadjacent(token, nexttoken);
            }
            if (s === "in" && left.id === "!") {
                warning("Confusing use of '{a}'.", left, '!');
            }
            if (typeof f === 'function') {
                return f(left, this);
            } else {
                this.left = left;
                this.right = expression(p);
                return this;
            }
        };
        return x;
    }


    function relation(s, f) {
        var x = symbol(s, 100);
        x.led = function (left) {
            nobreaknonadjacent(prevtoken, token);
            nonadjacent(token, nexttoken);
            var right = expression(100);
            if ((left && left.id === 'NaN') || (right && right.id === 'NaN')) {
                warning("Use the isNaN function to compare with NaN.", this);
            } else if (f) {
                f.apply(this, [left, right]);
            }
            if (left.id === '!') {
                warning("Confusing use of '{a}'.", left, '!');
            }
            if (right.id === '!') {
                warning("Confusing use of '{a}'.", right, '!');
            }
            this.left = left;
            this.right = right;
            return this;
        };
        return x;
    }


    function isPoorRelation(node) {
        return node &&
              ((node.type === '(number)' && +node.value === 0) ||
               (node.type === '(string)' && node.value === '') ||
               (node.type === 'null' && !option.eqnull) ||
                node.type === 'true' ||
                node.type === 'false' ||
                node.type === 'undefined');
    }


    function assignop(s, f) {
        symbol(s, 20).exps = true;
        return infix(s, function (left, that) {
            var l;
            that.left = left;
            if (predefined[left.value] === false &&
                    scope[left.value]['(global)'] === true) {
                warning("Read only.", left);
            } else if (left['function']) {
                warning("'{a}' is a function.", left, left.value);
            }
            if (left) {
                if (option.esnext && funct[left.value] === 'const') {
                    warning("Attempting to override '{a}' which is a constant", left, left.value);
                }
                if (left.id === '.' || left.id === '[') {
                    if (!left.left || left.left.value === 'arguments') {
                        warning('Bad assignment.', that);
                    }
                    that.right = expression(19);
                    return that;
                } else if (left.identifier && !left.reserved) {
                    if (funct[left.value] === 'exception') {
                        warning("Do not assign to the exception parameter.", left);
                    }
                    that.right = expression(19);
                    return that;
                }
                if (left === syntax['function']) {
                    warning(
"Expected an identifier in an assignment and instead saw a function invocation.",
                                token);
                }
            }
            error("Bad assignment.", that);
        }, 20);
    }


    function bitwise(s, f, p) {
        var x = symbol(s, p);
        reserveName(x);
        x.led = (typeof f === 'function') ? f : function (left) {
            if (option.bitwise) {
                warning("Unexpected use of '{a}'.", this, this.id);
            }
            this.left = left;
            this.right = expression(p);
            return this;
        };
        return x;
    }


    function bitwiseassignop(s) {
        symbol(s, 20).exps = true;
        return infix(s, function (left, that) {
            if (option.bitwise) {
                warning("Unexpected use of '{a}'.", that, that.id);
            }
            nonadjacent(prevtoken, token);
            nonadjacent(token, nexttoken);
            if (left) {
                if (left.id === '.' || left.id === '[' ||
                        (left.identifier && !left.reserved)) {
                    expression(19);
                    return that;
                }
                if (left === syntax['function']) {
                    warning(
"Expected an identifier in an assignment, and instead saw a function invocation.",
                                token);
                }
                return that;
            }
            error("Bad assignment.", that);
        }, 20);
    }


    function suffix(s, f) {
        var x = symbol(s, 150);
        x.led = function (left) {
            if (option.plusplus) {
                warning("Unexpected use of '{a}'.", this, this.id);
            } else if ((!left.identifier || left.reserved) &&
                    left.id !== '.' && left.id !== '[') {
                warning("Bad operand.", this);
            }
            this.left = left;
            return this;
        };
        return x;
    }


    // fnparam means that this identifier is being defined as a function
    // argument (see identifier())
    function optionalidentifier(fnparam) {
        if (nexttoken.identifier) {
            advance();
            if (token.reserved && !option.es5) {
                // `undefined` as a function param is a common pattern to protect
                // against the case when somebody does `undefined = true` and
                // help with minification. More info: https://gist.github.com/315916
                if (!fnparam || token.value !== 'undefined') {
                    warning("Expected an identifier and instead saw '{a}' (a reserved word).",
                            token, token.id);
                }
            }
            return token.value;
        }
    }

    // fnparam means that this identifier is being defined as a function
    // argument
    function identifier(fnparam) {
        var i = optionalidentifier(fnparam);
        if (i) {
            return i;
        }
        if (token.id === 'function' && nexttoken.id === '(') {
            warning("Missing name in function declaration.");
        } else {
            error("Expected an identifier and instead saw '{a}'.",
                    nexttoken, nexttoken.value);
        }
    }


    function reachable(s) {
        var i = 0, t;
        if (nexttoken.id !== ';' || noreach) {
            return;
        }
        for (;;) {
            t = peek(i);
            if (t.reach) {
                return;
            }
            if (t.id !== '(endline)') {
                if (t.id === 'function') {
                    if (!option.latedef) {
                        break;
                    }
                    warning(
"Inner functions should be listed at the top of the outer function.", t);
                    break;
                }
                warning("Unreachable '{a}' after '{b}'.", t, t.value, s);
                break;
            }
            i += 1;
        }
    }


    function statement(noindent) {
        var i = indent, r, s = scope, t = nexttoken;

        if (t.id === ";") {
            advance(";");
            return;
        }

// Is this a labelled statement?

        if (t.identifier && !t.reserved && peek().id === ':') {
            advance();
            advance(':');
            scope = Object.create(s);
            addlabel(t.value, 'label');
            if (!nexttoken.labelled) {
                warning("Label '{a}' on {b} statement.",
                        nexttoken, t.value, nexttoken.value);
            }
            if (jx.test(t.value + ':')) {
                warning("Label '{a}' looks like a javascript url.",
                        t, t.value);
            }
            nexttoken.label = t.value;
            t = nexttoken;
        }

// Parse the statement.

        if (!noindent) {
            indentation();
        }
        r = expression(0, true);

        // Look for the final semicolon.
        if (!t.block) {
            if (!option.expr && (!r || !r.exps)) {
                warning("Expected an assignment or function call and instead saw an expression.",
                    token);
            } else if (option.nonew && r.id === '(' && r.left.id === 'new') {
                warning("Do not use 'new' for side effects.");
            }

            if (nexttoken.id === ',') {
                return comma();
            }

            if (nexttoken.id !== ';') {
                if (!option.asi) {
                    // If this is the last statement in a block that ends on
                    // the same line *and* option lastsemic is on, ignore the warning.
                    // Otherwise, complain about missing semicolon.
                    if (!option.lastsemic || nexttoken.id !== '}' ||
                            nexttoken.line !== token.line) {
                        warningAt("Missing semicolon.", token.line, token.character);
                    }
                }
            } else {
                adjacent(token, nexttoken);
                advance(';');
                nonadjacent(token, nexttoken);
            }
        }

// Restore the indentation.

        indent = i;
        scope = s;
        return r;
    }


    function statements(startLine) {
        var a = [], f, p;

        while (!nexttoken.reach && nexttoken.id !== '(end)') {
            if (nexttoken.id === ';') {
                p = peek();
                if (!p || p.id !== "(") {
                    warning("Unnecessary semicolon.");
                }
                advance(';');
            } else {
                a.push(statement(startLine === nexttoken.line));
            }
        }
        return a;
    }


    /*
     * read all directives
     * recognizes a simple form of asi, but always
     * warns, if it is used
     */
    function directives() {
        var i, p, pn;

        for (;;) {
            if (nexttoken.id === "(string)") {
                p = peek(0);
                if (p.id === "(endline)") {
                    i = 1;
                    do {
                        pn = peek(i);
                        i = i + 1;
                    } while (pn.id === "(endline)");

                    if (pn.id !== ";") {
                        if (pn.id !== "(string)" && pn.id !== "(number)" &&
                            pn.id !== "(regexp)" && pn.identifier !== true &&
                            pn.id !== "}") {
                            break;
                        }
                        warning("Missing semicolon.", nexttoken);
                    } else {
                        p = pn;
                    }
                } else if (p.id === "}") {
                    // directive with no other statements, warn about missing semicolon
                    warning("Missing semicolon.", p);
                } else if (p.id !== ";") {
                    break;
                }

                indentation();
                advance();
                if (directive[token.value]) {
                    warning("Unnecessary directive \"{a}\".", token, token.value);
                }

                if (token.value === "use strict") {
                    option.newcap = true;
                    option.undef = true;
                }

                // there's no directive negation, so always set to true
                directive[token.value] = true;

                if (p.id === ";") {
                    advance(";");
                }
                continue;
            }
            break;
        }
    }


    /*
     * Parses a single block. A block is a sequence of statements wrapped in
     * braces.
     *
     * ordinary - true for everything but function bodies and try blocks.
     * stmt     - true if block can be a single statement (e.g. in if/for/while).
     * isfunc   - true if block is a function body
     */
    function block(ordinary, stmt, isfunc) {
        var a,
            b = inblock,
            old_indent = indent,
            m,
            s = scope,
            t,
            line,
            d;

        inblock = ordinary;
        if (!ordinary || !option.funcscope) scope = Object.create(scope);
        nonadjacent(token, nexttoken);
        t = nexttoken;

        if (nexttoken.id === '{') {
            advance('{');
            line = token.line;
            if (nexttoken.id !== '}') {
                indent += option.indent;
                while (!ordinary && nexttoken.from > indent) {
                    indent += option.indent;
                }

                if (isfunc) {
                    m = {};
                    for (d in directive) {
                        if (is_own(directive, d)) {
                            m[d] = directive[d];
                        }
                    }
                    directives();

                    if (option.strict && funct['(context)']['(global)']) {
                        if (!m["use strict"] && !directive["use strict"]) {
                            warning("Missing \"use strict\" statement.");
                        }
                    }
                }

                a = statements(line);

                if (isfunc) {
                    directive = m;
                }

                indent -= option.indent;
                if (line !== nexttoken.line) {
                    indentation();
                }
            } else if (line !== nexttoken.line) {
                indentation();
            }
            advance('}', t);
            indent = old_indent;
        } else if (!ordinary) {
            error("Expected '{a}' and instead saw '{b}'.",
                  nexttoken, '{', nexttoken.value);
        } else {
            if (!stmt || option.curly)
                warning("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, '{', nexttoken.value);

            noreach = true;
            indent += option.indent;
            // test indentation only if statement is in new line
            a = [statement(nexttoken.line === token.line)];
            indent -= option.indent;
            noreach = false;
        }
        funct['(verb)'] = null;
        if (!ordinary || !option.funcscope) scope = s;
        inblock = b;
        if (ordinary && option.noempty && (!a || a.length === 0)) {
            warning("Empty block.");
        }
        return a;
    }


    function countMember(m) {
        if (membersOnly && typeof membersOnly[m] !== 'boolean') {
            warning("Unexpected /*member '{a}'.", token, m);
        }
        if (typeof member[m] === 'number') {
            member[m] += 1;
        } else {
            member[m] = 1;
        }
    }


    function note_implied(token) {
        var name = token.value, line = token.line, a = implied[name];
        if (typeof a === 'function') {
            a = false;
        }

        if (!a) {
            a = [line];
            implied[name] = a;
        } else if (a[a.length - 1] !== line) {
            a.push(line);
        }
    }


    // Build the syntax table by declaring the syntactic elements of the language.

    type('(number)', function () {
        return this;
    });

    type('(string)', function () {
        return this;
    });

    syntax['(identifier)'] = {
        type: '(identifier)',
        lbp: 0,
        identifier: true,
        nud: function () {
            var v = this.value,
                s = scope[v],
                f;

            if (typeof s === 'function') {
                // Protection against accidental inheritance.
                s = undefined;
            } else if (typeof s === 'boolean') {
                f = funct;
                funct = functions[0];
                addlabel(v, 'var');
                s = funct;
                funct = f;
            }

            // The name is in scope and defined in the current function.
            if (funct === s) {
                // Change 'unused' to 'var', and reject labels.
                switch (funct[v]) {
                case 'unused':
                    funct[v] = 'var';
                    break;
                case 'unction':
                    funct[v] = 'function';
                    this['function'] = true;
                    break;
                case 'function':
                    this['function'] = true;
                    break;
                case 'label':
                    warning("'{a}' is a statement label.", token, v);
                    break;
                }
            } else if (funct['(global)']) {
                // The name is not defined in the function.  If we are in the global
                // scope, then we have an undefined variable.
                //
                // Operators typeof and delete do not raise runtime errors even if
                // the base object of a reference is null so no need to display warning
                // if we're inside of typeof or delete.

                if (option.undef && typeof predefined[v] !== 'boolean') {
                    // Attempting to subscript a null reference will throw an
                    // error, even within the typeof and delete operators
                    if (!(anonname === 'typeof' || anonname === 'delete') ||
                        (nexttoken && (nexttoken.value === '.' || nexttoken.value === '['))) {

                        isundef(funct, "'{a}' is not defined.", token, v);
                    }
                }
                note_implied(token);
            } else {
                // If the name is already defined in the current
                // function, but not as outer, then there is a scope error.

                switch (funct[v]) {
                case 'closure':
                case 'function':
                case 'var':
                case 'unused':
                    warning("'{a}' used out of scope.", token, v);
                    break;
                case 'label':
                    warning("'{a}' is a statement label.", token, v);
                    break;
                case 'outer':
                case 'global':
                    break;
                default:
                    // If the name is defined in an outer function, make an outer entry,
                    // and if it was unused, make it var.
                    if (s === true) {
                        funct[v] = true;
                    } else if (s === null) {
                        warning("'{a}' is not allowed.", token, v);
                        note_implied(token);
                    } else if (typeof s !== 'object') {
                        // Operators typeof and delete do not raise runtime errors even
                        // if the base object of a reference is null so no need to
                        // display warning if we're inside of typeof or delete.
                        if (option.undef) {
                            // Attempting to subscript a null reference will throw an
                            // error, even within the typeof and delete operators
                            if (!(anonname === 'typeof' || anonname === 'delete') ||
                                (nexttoken &&
                                    (nexttoken.value === '.' || nexttoken.value === '['))) {

                                isundef(funct, "'{a}' is not defined.", token, v);
                            }
                        }
                        funct[v] = true;
                        note_implied(token);
                    } else {
                        switch (s[v]) {
                        case 'function':
                        case 'unction':
                            this['function'] = true;
                            s[v] = 'closure';
                            funct[v] = s['(global)'] ? 'global' : 'outer';
                            break;
                        case 'var':
                        case 'unused':
                            s[v] = 'closure';
                            funct[v] = s['(global)'] ? 'global' : 'outer';
                            break;
                        case 'closure':
                        case 'parameter':
                            funct[v] = s['(global)'] ? 'global' : 'outer';
                            break;
                        case 'label':
                            warning("'{a}' is a statement label.", token, v);
                        }
                    }
                }
            }
            return this;
        },
        led: function () {
            error("Expected an operator and instead saw '{a}'.",
                nexttoken, nexttoken.value);
        }
    };

    type('(regexp)', function () {
        return this;
    });


// ECMAScript parser

    delim('(endline)');
    delim('(begin)');
    delim('(end)').reach = true;
    delim('</').reach = true;
    delim('<!');
    delim('<!--');
    delim('-->');
    delim('(error)').reach = true;
    delim('}').reach = true;
    delim(')');
    delim(']');
    delim('"').reach = true;
    delim("'").reach = true;
    delim(';');
    delim(':').reach = true;
    delim(',');
    delim('#');
    delim('@');
    reserve('else');
    reserve('case').reach = true;
    reserve('catch');
    reserve('default').reach = true;
    reserve('finally');
    reservevar('arguments', function (x) {
        if (directive['use strict'] && funct['(global)']) {
            warning("Strict violation.", x);
        }
    });
    reservevar('eval');
    reservevar('false');
    reservevar('Infinity');
    reservevar('NaN');
    reservevar('null');
    reservevar('this', function (x) {
        if (directive['use strict'] && !option.validthis && ((funct['(statement)'] &&
                funct['(name)'].charAt(0) > 'Z') || funct['(global)'])) {
            warning("Possible strict violation.", x);
        }
    });
    reservevar('true');
    reservevar('undefined');
    assignop('=', 'assign', 20);
    assignop('+=', 'assignadd', 20);
    assignop('-=', 'assignsub', 20);
    assignop('*=', 'assignmult', 20);
    assignop('/=', 'assigndiv', 20).nud = function () {
        error("A regular expression literal can be confused with '/='.");
    };
    assignop('%=', 'assignmod', 20);
    bitwiseassignop('&=', 'assignbitand', 20);
    bitwiseassignop('|=', 'assignbitor', 20);
    bitwiseassignop('^=', 'assignbitxor', 20);
    bitwiseassignop('<<=', 'assignshiftleft', 20);
    bitwiseassignop('>>=', 'assignshiftright', 20);
    bitwiseassignop('>>>=', 'assignshiftrightunsigned', 20);
    infix('?', function (left, that) {
        that.left = left;
        that.right = expression(10);
        advance(':');
        that['else'] = expression(10);
        return that;
    }, 30);

    infix('||', 'or', 40);
    infix('&&', 'and', 50);
    bitwise('|', 'bitor', 70);
    bitwise('^', 'bitxor', 80);
    bitwise('&', 'bitand', 90);
    relation('==', function (left, right) {
        var eqnull = option.eqnull && (left.value === 'null' || right.value === 'null');

        if (!eqnull && option.eqeqeq)
            warning("Expected '{a}' and instead saw '{b}'.", this, '===', '==');
        else if (isPoorRelation(left))
            warning("Use '{a}' to compare with '{b}'.", this, '===', left.value);
        else if (isPoorRelation(right))
            warning("Use '{a}' to compare with '{b}'.", this, '===', right.value);

        return this;
    });
    relation('===');
    relation('!=', function (left, right) {
        var eqnull = option.eqnull &&
                (left.value === 'null' || right.value === 'null');

        if (!eqnull && option.eqeqeq) {
            warning("Expected '{a}' and instead saw '{b}'.",
                    this, '!==', '!=');
        } else if (isPoorRelation(left)) {
            warning("Use '{a}' to compare with '{b}'.",
                    this, '!==', left.value);
        } else if (isPoorRelation(right)) {
            warning("Use '{a}' to compare with '{b}'.",
                    this, '!==', right.value);
        }
        return this;
    });
    relation('!==');
    relation('<');
    relation('>');
    relation('<=');
    relation('>=');
    bitwise('<<', 'shiftleft', 120);
    bitwise('>>', 'shiftright', 120);
    bitwise('>>>', 'shiftrightunsigned', 120);
    infix('in', 'in', 120);
    infix('instanceof', 'instanceof', 120);
    infix('+', function (left, that) {
        var right = expression(130);
        if (left && right && left.id === '(string)' && right.id === '(string)') {
            left.value += right.value;
            left.character = right.character;
            if (!option.scripturl && jx.test(left.value)) {
                warning("JavaScript URL.", left);
            }
            return left;
        }
        that.left = left;
        that.right = right;
        return that;
    }, 130);
    prefix('+', 'num');
    prefix('+++', function () {
        warning("Confusing pluses.");
        this.right = expression(150);
        this.arity = 'unary';
        return this;
    });
    infix('+++', function (left) {
        warning("Confusing pluses.");
        this.left = left;
        this.right = expression(130);
        return this;
    }, 130);
    infix('-', 'sub', 130);
    prefix('-', 'neg');
    prefix('---', function () {
        warning("Confusing minuses.");
        this.right = expression(150);
        this.arity = 'unary';
        return this;
    });
    infix('---', function (left) {
        warning("Confusing minuses.");
        this.left = left;
        this.right = expression(130);
        return this;
    }, 130);
    infix('*', 'mult', 140);
    infix('/', 'div', 140);
    infix('%', 'mod', 140);

    suffix('++', 'postinc');
    prefix('++', 'preinc');
    syntax['++'].exps = true;

    suffix('--', 'postdec');
    prefix('--', 'predec');
    syntax['--'].exps = true;
    prefix('delete', function () {
        var p = expression(0);
        if (!p || (p.id !== '.' && p.id !== '[')) {
            warning("Variables should not be deleted.");
        }
        this.first = p;
        return this;
    }).exps = true;

    prefix('~', function () {
        if (option.bitwise) {
            warning("Unexpected '{a}'.", this, '~');
        }
        expression(150);
        return this;
    });

    prefix('!', function () {
        this.right = expression(150);
        this.arity = 'unary';
        if (bang[this.right.id] === true) {
            warning("Confusing use of '{a}'.", this, '!');
        }
        return this;
    });
    prefix('typeof', 'typeof');
    prefix('new', function () {
        var c = expression(155), i;
        if (c && c.id !== 'function') {
            if (c.identifier) {
                c['new'] = true;
                switch (c.value) {
                case 'Number':
                case 'String':
                case 'Boolean':
                case 'Math':
                case 'JSON':
                    warning("Do not use {a} as a constructor.", token, c.value);
                    break;
                case 'Function':
                    if (!option.evil) {
                        warning("The Function constructor is eval.");
                    }
                    break;
                case 'Date':
                case 'RegExp':
                    break;
                default:
                    if (c.id !== 'function') {
                        i = c.value.substr(0, 1);
                        if (option.newcap && (i < 'A' || i > 'Z')) {
                            warning("A constructor name should start with an uppercase letter.",
                                token);
                        }
                    }
                }
            } else {
                if (c.id !== '.' && c.id !== '[' && c.id !== '(') {
                    warning("Bad constructor.", token);
                }
            }
        } else {
            if (!option.supernew)
                warning("Weird construction. Delete 'new'.", this);
        }
        adjacent(token, nexttoken);
        if (nexttoken.id !== '(' && !option.supernew) {
            warning("Missing '()' invoking a constructor.");
        }
        this.first = c;
        return this;
    });
    syntax['new'].exps = true;

    prefix('void').exps = true;

    infix('.', function (left, that) {
        adjacent(prevtoken, token);
        nobreak();
        var m = identifier();
        if (typeof m === 'string') {
            countMember(m);
        }
        that.left = left;
        that.right = m;
        if (left && left.value === 'arguments' && (m === 'callee' || m === 'caller')) {
            if (option.noarg)
                warning("Avoid arguments.{a}.", left, m);
            else if (directive['use strict'])
                error('Strict violation.');
        } else if (!option.evil && left && left.value === 'document' &&
                (m === 'write' || m === 'writeln')) {
            warning("document.write can be a form of eval.", left);
        }
        if (!option.evil && (m === 'eval' || m === 'execScript')) {
            warning('eval is evil.');
        }
        return that;
    }, 160, true);

    infix('(', function (left, that) {
        if (prevtoken.id !== '}' && prevtoken.id !== ')') {
            nobreak(prevtoken, token);
        }
        nospace();
        if (option.immed && !left.immed && left.id === 'function') {
            warning("Wrap an immediate function invocation in parentheses " +
                "to assist the reader in understanding that the expression " +
                "is the result of a function, and not the function itself.");
        }
        var n = 0,
            p = [];
        if (left) {
            if (left.type === '(identifier)') {
                if (left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)) {
                    if (left.value !== 'Number' && left.value !== 'String' &&
                            left.value !== 'Boolean' &&
                            left.value !== 'Date') {
                        if (left.value === 'Math') {
                            warning("Math is not a function.", left);
                        } else if (option.newcap) {
                            warning(
"Missing 'new' prefix when invoking a constructor.", left);
                        }
                    }
                }
            }
        }
        if (nexttoken.id !== ')') {
            for (;;) {
                p[p.length] = expression(10);
                n += 1;
                if (nexttoken.id !== ',') {
                    break;
                }
                comma();
            }
        }
        advance(')');
        nospace(prevtoken, token);
        if (typeof left === 'object') {
            if (left.value === 'parseInt' && n === 1) {
                warning("Missing radix parameter.", left);
            }
            if (!option.evil) {
                if (left.value === 'eval' || left.value === 'Function' ||
                        left.value === 'execScript') {
                    warning("eval is evil.", left);
                } else if (p[0] && p[0].id === '(string)' &&
                       (left.value === 'setTimeout' ||
                        left.value === 'setInterval')) {
                    warning(
    "Implied eval is evil. Pass a function instead of a string.", left);
                }
            }
            if (!left.identifier && left.id !== '.' && left.id !== '[' &&
                    left.id !== '(' && left.id !== '&&' && left.id !== '||' &&
                    left.id !== '?') {
                warning("Bad invocation.", left);
            }
        }
        that.left = left;
        return that;
    }, 155, true).exps = true;

    prefix('(', function () {
        nospace();
        if (nexttoken.id === 'function') {
            nexttoken.immed = true;
        }
        var v = expression(0);
        advance(')', this);
        nospace(prevtoken, token);
        if (option.immed && v.id === 'function') {
            if (nexttoken.id === '(' ||
              (nexttoken.id === '.' && (peek().value === 'call' || peek().value === 'apply'))) {
                warning(
"Move the invocation into the parens that contain the function.", nexttoken);
            } else {
                warning(
"Do not wrap function literals in parens unless they are to be immediately invoked.",
                        this);
            }
        }
        return v;
    });

    infix('[', function (left, that) {
        nobreak(prevtoken, token);
        nospace();
        var e = expression(0), s;
        if (e && e.type === '(string)') {
            if (!option.evil && (e.value === 'eval' || e.value === 'execScript')) {
                warning("eval is evil.", that);
            }
            countMember(e.value);
            if (!option.sub && ix.test(e.value)) {
                s = syntax[e.value];
                if (!s || !s.reserved) {
                    warning("['{a}'] is better written in dot notation.",
                            e, e.value);
                }
            }
        }
        advance(']', that);
        nospace(prevtoken, token);
        that.left = left;
        that.right = e;
        return that;
    }, 160, true);

    prefix('[', function () {
        var b = token.line !== nexttoken.line;
        this.first = [];
        if (b) {
            indent += option.indent;
            if (nexttoken.from === indent + option.indent) {
                indent += option.indent;
            }
        }
        while (nexttoken.id !== '(end)') {
            while (nexttoken.id === ',') {
                warning("Extra comma.");
                advance(',');
            }
            if (nexttoken.id === ']') {
                break;
            }
            if (b && token.line !== nexttoken.line) {
                indentation();
            }
            this.first.push(expression(10));
            if (nexttoken.id === ',') {
                comma();
                if (nexttoken.id === ']' && !option.es5) {
                    warning("Extra comma.", token);
                    break;
                }
            } else {
                break;
            }
        }
        if (b) {
            indent -= option.indent;
            indentation();
        }
        advance(']', this);
        return this;
    }, 160);


    function property_name() {
        var id = optionalidentifier(true);
        if (!id) {
            if (nexttoken.id === '(string)') {
                id = nexttoken.value;
                advance();
            } else if (nexttoken.id === '(number)') {
                id = nexttoken.value.toString();
                advance();
            }
        }
        return id;
    }


    function functionparams() {
        var i, t = nexttoken, p = [];
        advance('(');
        nospace();
        if (nexttoken.id === ')') {
            advance(')');
            return;
        }
        for (;;) {
            i = identifier(true);
            p.push(i);
            addlabel(i, 'parameter');
            if (nexttoken.id === ',') {
                comma();
            } else {
                advance(')', t);
                nospace(prevtoken, token);
                return p;
            }
        }
    }


    function doFunction(i, statement) {
        var f,
            oldOption = option,
            oldScope  = scope;

        option = Object.create(option);
        scope = Object.create(scope);

        funct = {
            '(name)'     : i || '"' + anonname + '"',
            '(line)'     : nexttoken.line,
            '(context)'  : funct,
            '(breakage)' : 0,
            '(loopage)'  : 0,
            '(scope)'    : scope,
            '(statement)': statement
        };
        f = funct;
        token.funct = funct;
        functions.push(funct);
        if (i) {
            addlabel(i, 'function');
        }
        funct['(params)'] = functionparams();

        block(false, false, true);
        scope = oldScope;
        option = oldOption;
        funct['(last)'] = token.line;
        funct = funct['(context)'];
        return f;
    }


    (function (x) {
        x.nud = function () {
            var b, f, i, j, p, t;
            var props = {}; // All properties, including accessors

            function saveProperty(name, token) {
                if (props[name] && is_own(props, name))
                    warning("Duplicate member '{a}'.", nexttoken, i);
                else
                    props[name] = {};

                props[name].basic = true;
                props[name].basicToken = token;
            }

            function saveSetter(name, token) {
                if (props[name] && is_own(props, name)) {
                    if (props[name].basic || props[name].setter)
                        warning("Duplicate member '{a}'.", nexttoken, i);
                } else {
                    props[name] = {};
                }

                props[name].setter = true;
                props[name].setterToken = token;
            }

            function saveGetter(name) {
                if (props[name] && is_own(props, name)) {
                    if (props[name].basic || props[name].getter)
                        warning("Duplicate member '{a}'.", nexttoken, i);
                } else {
                    props[name] = {};
                }

                props[name].getter = true;
                props[name].getterToken = token;
            }

            b = token.line !== nexttoken.line;
            if (b) {
                indent += option.indent;
                if (nexttoken.from === indent + option.indent) {
                    indent += option.indent;
                }
            }
            for (;;) {
                if (nexttoken.id === '}') {
                    break;
                }
                if (b) {
                    indentation();
                }
                if (nexttoken.value === 'get' && peek().id !== ':') {
                    advance('get');
                    if (!option.es5) {
                        error("get/set are ES5 features.");
                    }
                    i = property_name();
                    if (!i) {
                        error("Missing property name.");
                    }
                    saveGetter(i);
                    t = nexttoken;
                    adjacent(token, nexttoken);
                    f = doFunction();
                    p = f['(params)'];
                    if (p) {
                        warning("Unexpected parameter '{a}' in get {b} function.", t, p[0], i);
                    }
                    adjacent(token, nexttoken);
                } else if (nexttoken.value === 'set' && peek().id !== ':') {
                    advance('set');
                    if (!option.es5) {
                        error("get/set are ES5 features.");
                    }
                    i = property_name();
                    if (!i) {
                        error("Missing property name.");
                    }
                    saveSetter(i, nexttoken);
                    t = nexttoken;
                    adjacent(token, nexttoken);
                    f = doFunction();
                    p = f['(params)'];
                    if (!p || p.length !== 1) {
                        warning("Expected a single parameter in set {a} function.", t, i);
                    }
                } else {
                    i = property_name();
                    saveProperty(i, nexttoken);
                    if (typeof i !== 'string') {
                        break;
                    }
                    advance(':');
                    nonadjacent(token, nexttoken);
                    expression(10);
                }

                countMember(i);
                if (nexttoken.id === ',') {
                    comma();
                    if (nexttoken.id === ',') {
                        warning("Extra comma.", token);
                    } else if (nexttoken.id === '}' && !option.es5) {
                        warning("Extra comma.", token);
                    }
                } else {
                    break;
                }
            }
            if (b) {
                indent -= option.indent;
                indentation();
            }
            advance('}', this);

            // Check for lonely setters if in the ES5 mode.
            if (option.es5) {
                for (var name in props) {
                    if (is_own(props, name) && props[name].setter && !props[name].getter) {
                        warning("Setter is defined without getter.", props[name].setterToken);
                    }
                }
            }
            return this;
        };
        x.fud = function () {
            error("Expected to see a statement and instead saw a block.", token);
        };
    }(delim('{')));

// This Function is called when esnext option is set to true
// it adds the `const` statement to JSHINT

    useESNextSyntax = function () {
        var conststatement = stmt('const', function (prefix) {
            var id, name, value;

            this.first = [];
            for (;;) {
                nonadjacent(token, nexttoken);
                id = identifier();
                if (funct[id] === "const") {
                    warning("const '" + id + "' has already been declared");
                }
                if (funct['(global)'] && predefined[id] === false) {
                    warning("Redefinition of '{a}'.", token, id);
                }
                addlabel(id, 'const');
                if (prefix) {
                    break;
                }
                name = token;
                this.first.push(token);

                if (nexttoken.id !== "=") {
                    warning("const " +
                      "'{a}' is initialized to 'undefined'.", token, id);
                }

                if (nexttoken.id === '=') {
                    nonadjacent(token, nexttoken);
                    advance('=');
                    nonadjacent(token, nexttoken);
                    if (nexttoken.id === 'undefined') {
                        warning("It is not necessary to initialize " +
                          "'{a}' to 'undefined'.", token, id);
                    }
                    if (peek(0).id === '=' && nexttoken.identifier) {
                        error("Constant {a} was not declared correctly.",
                                nexttoken, nexttoken.value);
                    }
                    value = expression(0);
                    name.first = value;
                }

                if (nexttoken.id !== ',') {
                    break;
                }
                comma();
            }
            return this;
        });
        conststatement.exps = true;
    };

    var varstatement = stmt('var', function (prefix) {
        // JavaScript does not have block scope. It only has function scope. So,
        // declaring a variable in a block can have unexpected consequences.
        var id, name, value;

        if (funct['(onevar)'] && option.onevar) {
            warning("Too many var statements.");
        } else if (!funct['(global)']) {
            funct['(onevar)'] = true;
        }
        this.first = [];
        for (;;) {
            nonadjacent(token, nexttoken);
            id = identifier();
            if (option.esnext && funct[id] === "const") {
                warning("const '" + id + "' has already been declared");
            }
            if (funct['(global)'] && predefined[id] === false) {
                warning("Redefinition of '{a}'.", token, id);
            }
            addlabel(id, 'unused');
            if (prefix) {
                break;
            }
            name = token;
            this.first.push(token);
            if (nexttoken.id === '=') {
                nonadjacent(token, nexttoken);
                advance('=');
                nonadjacent(token, nexttoken);
                if (nexttoken.id === 'undefined') {
                    warning("It is not necessary to initialize '{a}' to 'undefined'.", token, id);
                }
                if (peek(0).id === '=' && nexttoken.identifier) {
                    error("Variable {a} was not declared correctly.",
                            nexttoken, nexttoken.value);
                }
                value = expression(0);
                name.first = value;
            }
            if (nexttoken.id !== ',') {
                break;
            }
            comma();
        }
        return this;
    });
    varstatement.exps = true;

    blockstmt('function', function () {
        if (inblock) {
            warning("Function declarations should not be placed in blocks. " +
                "Use a function expression or move the statement to the top of " +
                "the outer function.", token);

        }
        var i = identifier();
        if (option.esnext && funct[i] === "const") {
            warning("const '" + i + "' has already been declared");
        }
        adjacent(token, nexttoken);
        addlabel(i, 'unction');
        doFunction(i, true);
        if (nexttoken.id === '(' && nexttoken.line === token.line) {
            error(
"Function declarations are not invocable. Wrap the whole function invocation in parens.");
        }
        return this;
    });

    prefix('function', function () {
        var i = optionalidentifier();
        if (i) {
            adjacent(token, nexttoken);
        } else {
            nonadjacent(token, nexttoken);
        }
        doFunction(i);
        if (!option.loopfunc && funct['(loopage)']) {
            warning("Don't make functions within a loop.");
        }
        return this;
    });

    blockstmt('if', function () {
        var t = nexttoken;
        advance('(');
        nonadjacent(this, t);
        nospace();
        expression(20);
        if (nexttoken.id === '=') {
            if (!option.boss)
                warning("Expected a conditional expression and instead saw an assignment.");
            advance('=');
            expression(20);
        }
        advance(')', t);
        nospace(prevtoken, token);
        block(true, true);
        if (nexttoken.id === 'else') {
            nonadjacent(token, nexttoken);
            advance('else');
            if (nexttoken.id === 'if' || nexttoken.id === 'switch') {
                statement(true);
            } else {
                block(true, true);
            }
        }
        return this;
    });

    blockstmt('try', function () {
        var b, e, s;

        block(false);
        if (nexttoken.id === 'catch') {
            advance('catch');
            nonadjacent(token, nexttoken);
            advance('(');
            s = scope;
            scope = Object.create(s);
            e = nexttoken.value;
            if (nexttoken.type !== '(identifier)') {
                warning("Expected an identifier and instead saw '{a}'.",
                    nexttoken, e);
            } else {
                addlabel(e, 'exception');
            }
            advance();
            advance(')');
            block(false);
            b = true;
            scope = s;
        }
        if (nexttoken.id === 'finally') {
            advance('finally');
            block(false);
            return;
        } else if (!b) {
            error("Expected '{a}' and instead saw '{b}'.",
                    nexttoken, 'catch', nexttoken.value);
        }
        return this;
    });

    blockstmt('while', function () {
        var t = nexttoken;
        funct['(breakage)'] += 1;
        funct['(loopage)'] += 1;
        advance('(');
        nonadjacent(this, t);
        nospace();
        expression(20);
        if (nexttoken.id === '=') {
            if (!option.boss)
                warning("Expected a conditional expression and instead saw an assignment.");
            advance('=');
            expression(20);
        }
        advance(')', t);
        nospace(prevtoken, token);
        block(true, true);
        funct['(breakage)'] -= 1;
        funct['(loopage)'] -= 1;
        return this;
    }).labelled = true;

    blockstmt('with', function () {
        var t = nexttoken;
        if (directive['use strict']) {
            error("'with' is not allowed in strict mode.", token);
        } else if (!option.withstmt) {
            warning("Don't use 'with'.", token);
        }

        advance('(');
        nonadjacent(this, t);
        nospace();
        expression(0);
        advance(')', t);
        nospace(prevtoken, token);
        block(true, true);

        return this;
    });

    blockstmt('switch', function () {
        var t = nexttoken,
            g = false;
        funct['(breakage)'] += 1;
        advance('(');
        nonadjacent(this, t);
        nospace();
        this.condition = expression(20);
        advance(')', t);
        nospace(prevtoken, token);
        nonadjacent(token, nexttoken);
        t = nexttoken;
        advance('{');
        nonadjacent(token, nexttoken);
        indent += option.indent;
        this.cases = [];
        for (;;) {
            switch (nexttoken.id) {
            case 'case':
                switch (funct['(verb)']) {
                case 'break':
                case 'case':
                case 'continue':
                case 'return':
                case 'switch':
                case 'throw':
                    break;
                default:
                    // You can tell JSHint that you don't use break intentionally by
                    // adding a comment /* falls through */ on a line just before
                    // the next `case`.
                    if (!ft.test(lines[nexttoken.line - 2])) {
                        warning(
                            "Expected a 'break' statement before 'case'.",
                            token);
                    }
                }
                indentation(-option.indent);
                advance('case');
                this.cases.push(expression(20));
                g = true;
                advance(':');
                funct['(verb)'] = 'case';
                break;
            case 'default':
                switch (funct['(verb)']) {
                case 'break':
                case 'continue':
                case 'return':
                case 'throw':
                    break;
                default:
                    if (!ft.test(lines[nexttoken.line - 2])) {
                        warning(
                            "Expected a 'break' statement before 'default'.",
                            token);
                    }
                }
                indentation(-option.indent);
                advance('default');
                g = true;
                advance(':');
                break;
            case '}':
                indent -= option.indent;
                indentation();
                advance('}', t);
                if (this.cases.length === 1 || this.condition.id === 'true' ||
                        this.condition.id === 'false') {
                    if (!option.onecase)
                        warning("This 'switch' should be an 'if'.", this);
                }
                funct['(breakage)'] -= 1;
                funct['(verb)'] = undefined;
                return;
            case '(end)':
                error("Missing '{a}'.", nexttoken, '}');
                return;
            default:
                if (g) {
                    switch (token.id) {
                    case ',':
                        error("Each value should have its own case label.");
                        return;
                    case ':':
                        g = false;
                        statements();
                        break;
                    default:
                        error("Missing ':' on a case clause.", token);
                        return;
                    }
                } else {
                    if (token.id === ':') {
                        advance(':');
                        error("Unexpected '{a}'.", token, ':');
                        statements();
                    } else {
                        error("Expected '{a}' and instead saw '{b}'.",
                            nexttoken, 'case', nexttoken.value);
                        return;
                    }
                }
            }
        }
    }).labelled = true;

    stmt('debugger', function () {
        if (!option.debug) {
            warning("All 'debugger' statements should be removed.");
        }
        return this;
    }).exps = true;

    (function () {
        var x = stmt('do', function () {
            funct['(breakage)'] += 1;
            funct['(loopage)'] += 1;
            this.first = block(true);
            advance('while');
            var t = nexttoken;
            nonadjacent(token, t);
            advance('(');
            nospace();
            expression(20);
            if (nexttoken.id === '=') {
                if (!option.boss)
                    warning("Expected a conditional expression and instead saw an assignment.");
                advance('=');
                expression(20);
            }
            advance(')', t);
            nospace(prevtoken, token);
            funct['(breakage)'] -= 1;
            funct['(loopage)'] -= 1;
            return this;
        });
        x.labelled = true;
        x.exps = true;
    }());

    blockstmt('for', function () {
        var s, t = nexttoken;
        funct['(breakage)'] += 1;
        funct['(loopage)'] += 1;
        advance('(');
        nonadjacent(this, t);
        nospace();
        if (peek(nexttoken.id === 'var' ? 1 : 0).id === 'in') {
            if (nexttoken.id === 'var') {
                advance('var');
                varstatement.fud.call(varstatement, true);
            } else {
                switch (funct[nexttoken.value]) {
                case 'unused':
                    funct[nexttoken.value] = 'var';
                    break;
                case 'var':
                    break;
                default:
                    warning("Bad for in variable '{a}'.",
                            nexttoken, nexttoken.value);
                }
                advance();
            }
            advance('in');
            expression(20);
            advance(')', t);
            s = block(true, true);
            if (option.forin && s && (s.length > 1 || typeof s[0] !== 'object' ||
                    s[0].value !== 'if')) {
                warning("The body of a for in should be wrapped in an if statement to filter " +
                        "unwanted properties from the prototype.", this);
            }
            funct['(breakage)'] -= 1;
            funct['(loopage)'] -= 1;
            return this;
        } else {
            if (nexttoken.id !== ';') {
                if (nexttoken.id === 'var') {
                    advance('var');
                    varstatement.fud.call(varstatement);
                } else {
                    for (;;) {
                        expression(0, 'for');
                        if (nexttoken.id !== ',') {
                            break;
                        }
                        comma();
                    }
                }
            }
            nolinebreak(token);
            advance(';');
            if (nexttoken.id !== ';') {
                expression(20);
                if (nexttoken.id === '=') {
                    if (!option.boss)
                        warning("Expected a conditional expression and instead saw an assignment.");
                    advance('=');
                    expression(20);
                }
            }
            nolinebreak(token);
            advance(';');
            if (nexttoken.id === ';') {
                error("Expected '{a}' and instead saw '{b}'.",
                        nexttoken, ')', ';');
            }
            if (nexttoken.id !== ')') {
                for (;;) {
                    expression(0, 'for');
                    if (nexttoken.id !== ',') {
                        break;
                    }
                    comma();
                }
            }
            advance(')', t);
            nospace(prevtoken, token);
            block(true, true);
            funct['(breakage)'] -= 1;
            funct['(loopage)'] -= 1;
            return this;
        }
    }).labelled = true;


    stmt('break', function () {
        var v = nexttoken.value;

        if (funct['(breakage)'] === 0)
            warning("Unexpected '{a}'.", nexttoken, this.value);

        if (!option.asi)
            nolinebreak(this);

        if (nexttoken.id !== ';') {
            if (token.line === nexttoken.line) {
                if (funct[v] !== 'label') {
                    warning("'{a}' is not a statement label.", nexttoken, v);
                } else if (scope[v] !== funct) {
                    warning("'{a}' is out of scope.", nexttoken, v);
                }
                this.first = nexttoken;
                advance();
            }
        }
        reachable('break');
        return this;
    }).exps = true;


    stmt('continue', function () {
        var v = nexttoken.value;

        if (funct['(breakage)'] === 0)
            warning("Unexpected '{a}'.", nexttoken, this.value);

        if (!option.asi)
            nolinebreak(this);

        if (nexttoken.id !== ';') {
            if (token.line === nexttoken.line) {
                if (funct[v] !== 'label') {
                    warning("'{a}' is not a statement label.", nexttoken, v);
                } else if (scope[v] !== funct) {
                    warning("'{a}' is out of scope.", nexttoken, v);
                }
                this.first = nexttoken;
                advance();
            }
        } else if (!funct['(loopage)']) {
            warning("Unexpected '{a}'.", nexttoken, this.value);
        }
        reachable('continue');
        return this;
    }).exps = true;


    stmt('return', function () {
        if (this.line === nexttoken.line) {
            if (nexttoken.id === '(regexp)')
                warning("Wrap the /regexp/ literal in parens to disambiguate the slash operator.");

            if (nexttoken.id !== ';' && !nexttoken.reach) {
                nonadjacent(token, nexttoken);
                if (peek().value === "=" && !option.boss) {
                    warningAt("Did you mean to return a conditional instead of an assignment?",
                              token.line, token.character + 1);
                }
                this.first = expression(0);
            }
        } else if (!option.asi) {
            nolinebreak(this); // always warn (Line breaking error)
        }
        reachable('return');
        return this;
    }).exps = true;


    stmt('throw', function () {
        nolinebreak(this);
        nonadjacent(token, nexttoken);
        this.first = expression(20);
        reachable('throw');
        return this;
    }).exps = true;

//  Superfluous reserved words

    reserve('class');
    reserve('const');
    reserve('enum');
    reserve('export');
    reserve('extends');
    reserve('import');
    reserve('super');

    reserve('let');
    reserve('yield');
    reserve('implements');
    reserve('interface');
    reserve('package');
    reserve('private');
    reserve('protected');
    reserve('public');
    reserve('static');


// Parse JSON

    function jsonValue() {

        function jsonObject() {
            var o = {}, t = nexttoken;
            advance('{');
            if (nexttoken.id !== '}') {
                for (;;) {
                    if (nexttoken.id === '(end)') {
                        error("Missing '}' to match '{' from line {a}.",
                                nexttoken, t.line);
                    } else if (nexttoken.id === '}') {
                        warning("Unexpected comma.", token);
                        break;
                    } else if (nexttoken.id === ',') {
                        error("Unexpected comma.", nexttoken);
                    } else if (nexttoken.id !== '(string)') {
                        warning("Expected a string and instead saw {a}.",
                                nexttoken, nexttoken.value);
                    }
                    if (o[nexttoken.value] === true) {
                        warning("Duplicate key '{a}'.",
                                nexttoken, nexttoken.value);
                    } else if ((nexttoken.value === '__proto__' &&
                        !option.proto) || (nexttoken.value === '__iterator__' &&
                        !option.iterator)) {
                        warning("The '{a}' key may produce unexpected results.",
                            nexttoken, nexttoken.value);
                    } else {
                        o[nexttoken.value] = true;
                    }
                    advance();
                    advance(':');
                    jsonValue();
                    if (nexttoken.id !== ',') {
                        break;
                    }
                    advance(',');
                }
            }
            advance('}');
        }

        function jsonArray() {
            var t = nexttoken;
            advance('[');
            if (nexttoken.id !== ']') {
                for (;;) {
                    if (nexttoken.id === '(end)') {
                        error("Missing ']' to match '[' from line {a}.",
                                nexttoken, t.line);
                    } else if (nexttoken.id === ']') {
                        warning("Unexpected comma.", token);
                        break;
                    } else if (nexttoken.id === ',') {
                        error("Unexpected comma.", nexttoken);
                    }
                    jsonValue();
                    if (nexttoken.id !== ',') {
                        break;
                    }
                    advance(',');
                }
            }
            advance(']');
        }

        switch (nexttoken.id) {
        case '{':
            jsonObject();
            break;
        case '[':
            jsonArray();
            break;
        case 'true':
        case 'false':
        case 'null':
        case '(number)':
        case '(string)':
            advance();
            break;
        case '-':
            advance('-');
            if (token.character !== nexttoken.from) {
                warning("Unexpected space after '-'.", token);
            }
            adjacent(token, nexttoken);
            advance('(number)');
            break;
        default:
            error("Expected a JSON value.", nexttoken);
        }
    }


// The actual JSHINT function itself.

    var itself = function (s, o, g) {
        var a, i, k, x,
            optionKeys,
            newOptionObj = {};

        JSHINT.errors = [];
        JSHINT.undefs = [];
        predefined = Object.create(standard);
        combine(predefined, g || {});
        if (o) {
            a = o.predef;
            if (a) {
                if (Array.isArray(a)) {
                    for (i = 0; i < a.length; i += 1) {
                        predefined[a[i]] = true;
                    }
                } else if (typeof a === 'object') {
                    k = Object.keys(a);
                    for (i = 0; i < k.length; i += 1) {
                        predefined[k[i]] = !!a[k[i]];
                    }
                }
            }
            optionKeys = Object.keys(o);
            for (x = 0; x < optionKeys.length; x++) {
                newOptionObj[optionKeys[x]] = o[optionKeys[x]];
            }
        }

        option = newOptionObj;

        option.indent = option.indent || 4;
        option.maxerr = option.maxerr || 50;

        tab = '';
        for (i = 0; i < option.indent; i += 1) {
            tab += ' ';
        }
        indent = 1;
        global = Object.create(predefined);
        scope = global;
        funct = {
            '(global)': true,
            '(name)': '(global)',
            '(scope)': scope,
            '(breakage)': 0,
            '(loopage)': 0
        };
        functions = [funct];
        urls = [];
        stack = null;
        member = {};
        membersOnly = null;
        implied = {};
        inblock = false;
        lookahead = [];
        jsonmode = false;
        warnings = 0;
        lex.init(s);
        prereg = true;
        directive = {};

        prevtoken = token = nexttoken = syntax['(begin)'];

        // Check options
        for (var name in o) {
            if (is_own(o, name)) {
                checkOption(name, token);
            }
        }

        assume();

        // combine the passed globals after we've assumed all our options
        combine(predefined, g || {});

        //reset values
        comma.first = true;

        try {
            advance();
            switch (nexttoken.id) {
            case '{':
            case '[':
                option.laxbreak = true;
                jsonmode = true;
                jsonValue();
                break;
            default:
                directives();
                if (directive["use strict"] && !option.globalstrict) {
                    warning("Use the function form of \"use strict\".", prevtoken);
                }

                statements();
            }
            advance('(end)');

            var markDefined = function (name, context) {
                do {
                    if (typeof context[name] === 'string') {
                        // JSHINT marks unused variables as 'unused' and
                        // unused function declaration as 'unction'. This
                        // code changes such instances back 'var' and
                        // 'closure' so that the code in JSHINT.data()
                        // doesn't think they're unused.

                        if (context[name] === 'unused')
                            context[name] = 'var';
                        else if (context[name] === 'unction')
                            context[name] = 'closure';

                        return true;
                    }

                    context = context['(context)'];
                } while (context);

                return false;
            };

            var clearImplied = function (name, line) {
                if (!implied[name])
                    return;

                var newImplied = [];
                for (var i = 0; i < implied[name].length; i += 1) {
                    if (implied[name][i] !== line)
                        newImplied.push(implied[name][i]);
                }

                if (newImplied.length === 0)
                    delete implied[name];
                else
                    implied[name] = newImplied;
            };

            // Check queued 'x is not defined' instances to see if they're still undefined.
            for (i = 0; i < JSHINT.undefs.length; i += 1) {
                k = JSHINT.undefs[i].slice(0);

                if (markDefined(k[2].value, k[0])) {
                    clearImplied(k[2].value, k[2].line);
                } else {
                    warning.apply(warning, k.slice(1));
                }
            }
        } catch (e) {
            if (e) {
                var nt = nexttoken || {};
                JSHINT.errors.push({
                    raw       : e.raw,
                    reason    : e.message,
                    line      : e.line || nt.line,
                    character : e.character || nt.from
                }, null);
            }
        }

        return JSHINT.errors.length === 0;
    };

    // Data summary.
    itself.data = function () {

        var data = { functions: [], options: option }, fu, globals, implieds = [], f, i, j,
            members = [], n, unused = [], v;
        if (itself.errors.length) {
            data.errors = itself.errors;
        }

        if (jsonmode) {
            data.json = true;
        }

        for (n in implied) {
            if (is_own(implied, n)) {
                implieds.push({
                    name: n,
                    line: implied[n]
                });
            }
        }
        if (implieds.length > 0) {
            data.implieds = implieds;
        }

        if (urls.length > 0) {
            data.urls = urls;
        }

        globals = Object.keys(scope);
        if (globals.length > 0) {
            data.globals = globals;
        }
        for (i = 1; i < functions.length; i += 1) {
            f = functions[i];
            fu = {};
            for (j = 0; j < functionicity.length; j += 1) {
                fu[functionicity[j]] = [];
            }
            for (n in f) {
                if (is_own(f, n) && n.charAt(0) !== '(') {
                    v = f[n];
                    if (v === 'unction') {
                        v = 'unused';
                    }
                    if (Array.isArray(fu[v])) {
                        fu[v].push(n);
                        if (v === 'unused') {
                            unused.push({
                                name: n,
                                line: f['(line)'],
                                'function': f['(name)']
                            });
                        }
                    }
                }
            }
            for (j = 0; j < functionicity.length; j += 1) {
                if (fu[functionicity[j]].length === 0) {
                    delete fu[functionicity[j]];
                }
            }
            fu.name = f['(name)'];
            fu.param = f['(params)'];
            fu.line = f['(line)'];
            fu.last = f['(last)'];
            data.functions.push(fu);
        }

        if (unused.length > 0) {
            data.unused = unused;
        }

        members = [];
        for (n in member) {
            if (typeof member[n] === 'number') {
                data.member = member;
                break;
            }
        }

        return data;
    };

    itself.report = function (option) {
        var data = itself.data();

        var a = [], c, e, err, f, i, k, l, m = '', n, o = [], s;

        function detail(h, array) {
            var b, i, singularity;
            if (array) {
                o.push('<div><i>' + h + '</i> ');
                array = array.sort();
                for (i = 0; i < array.length; i += 1) {
                    if (array[i] !== singularity) {
                        singularity = array[i];
                        o.push((b ? ', ' : '') + singularity);
                        b = true;
                    }
                }
                o.push('</div>');
            }
        }


        if (data.errors || data.implieds || data.unused) {
            err = true;
            o.push('<div id=errors><i>Error:</i>');
            if (data.errors) {
                for (i = 0; i < data.errors.length; i += 1) {
                    c = data.errors[i];
                    if (c) {
                        e = c.evidence || '';
                        o.push('<p>Problem' + (isFinite(c.line) ? ' at line ' +
                                c.line + ' character ' + c.character : '') +
                                ': ' + c.reason.entityify() +
                                '</p><p class=evidence>' +
                                (e && (e.length > 80 ? e.slice(0, 77) + '...' :
                                e).entityify()) + '</p>');
                    }
                }
            }

            if (data.implieds) {
                s = [];
                for (i = 0; i < data.implieds.length; i += 1) {
                    s[i] = '<code>' + data.implieds[i].name + '</code>&nbsp;<i>' +
                        data.implieds[i].line + '</i>';
                }
                o.push('<p><i>Implied global:</i> ' + s.join(', ') + '</p>');
            }

            if (data.unused) {
                s = [];
                for (i = 0; i < data.unused.length; i += 1) {
                    s[i] = '<code><u>' + data.unused[i].name + '</u></code>&nbsp;<i>' +
                        data.unused[i].line + '</i> <code>' +
                        data.unused[i]['function'] + '</code>';
                }
                o.push('<p><i>Unused variable:</i> ' + s.join(', ') + '</p>');
            }
            if (data.json) {
                o.push('<p>JSON: bad.</p>');
            }
            o.push('</div>');
        }

        if (!option) {

            o.push('<br><div id=functions>');

            if (data.urls) {
                detail("URLs<br>", data.urls, '<br>');
            }

            if (data.json && !err) {
                o.push('<p>JSON: good.</p>');
            } else if (data.globals) {
                o.push('<div><i>Global</i> ' +
                        data.globals.sort().join(', ') + '</div>');
            } else {
                o.push('<div><i>No new global variables introduced.</i></div>');
            }

            for (i = 0; i < data.functions.length; i += 1) {
                f = data.functions[i];

                o.push('<br><div class=function><i>' + f.line + '-' +
                        f.last + '</i> ' + (f.name || '') + '(' +
                        (f.param ? f.param.join(', ') : '') + ')</div>');
                detail('<big><b>Unused</b></big>', f.unused);
                detail('Closure', f.closure);
                detail('Variable', f['var']);
                detail('Exception', f.exception);
                detail('Outer', f.outer);
                detail('Global', f.global);
                detail('Label', f.label);
            }

            if (data.member) {
                a = Object.keys(data.member);
                if (a.length) {
                    a = a.sort();
                    m = '<br><pre id=members>/*members ';
                    l = 10;
                    for (i = 0; i < a.length; i += 1) {
                        k = a[i];
                        n = k.name();
                        if (l + n.length > 72) {
                            o.push(m + '<br>');
                            m = '    ';
                            l = 1;
                        }
                        l += n.length + 2;
                        if (data.member[k] === 1) {
                            n = '<i>' + n + '</i>';
                        }
                        if (i < a.length - 1) {
                            n += ', ';
                        }
                        m += n;
                    }
                    o.push(m + '<br>*/</pre>');
                }
                o.push('</div>');
            }
        }
        return o.join('');
    };

    itself.jshint = itself;

    return itself;
}());

// Make JSHINT a Node module, if possible.
if (typeof exports === 'object' && exports)
    exports.JSHINT = JSHINT;

// Because sometimes you need to style the cursor's line.
//
// Adds an option 'styleActiveLine' which, when enabled, gives the
// active line's wrapping <div> the CSS class "CodeMirror-activeline",
// and gives its background <div> the class "CodeMirror-activeline-background".

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var WRAP_CLASS = "CodeMirror-activeline";
  var BACK_CLASS = "CodeMirror-activeline-background";

  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {
    var prev = old && old != CodeMirror.Init;
    if (val && !prev) {
      cm.state.activeLines = [];
      updateActiveLines(cm, cm.listSelections());
      cm.on("beforeSelectionChange", selectionChange);
    } else if (!val && prev) {
      cm.off("beforeSelectionChange", selectionChange);
      clearActiveLines(cm);
      delete cm.state.activeLines;
    }
  });

  function clearActiveLines(cm) {
    for (var i = 0; i < cm.state.activeLines.length; i++) {
      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);
      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);
    }
  }

  function sameArray(a, b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++)
      if (a[i] != b[i]) return false;
    return true;
  }

  function updateActiveLines(cm, ranges) {
    var active = [];
    for (var i = 0; i < ranges.length; i++) {
      var line = cm.getLineHandleVisualStart(ranges[i].head.line);
      if (active[active.length - 1] != line) active.push(line);
    }
    if (sameArray(cm.state.activeLines, active)) return;
    cm.operation(function() {
      clearActiveLines(cm);
      for (var i = 0; i < active.length; i++) {
        cm.addLineClass(active[i], "wrap", WRAP_CLASS);
        cm.addLineClass(active[i], "background", BACK_CLASS);
      }
      cm.state.activeLines = active;
    });
  }

  function selectionChange(cm, sel) {
    updateActiveLines(cm, sel.ranges);
  }
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var Pos = CodeMirror.Pos;

  function SearchCursor(doc, query, pos, caseFold) {
    this.atOccurrence = false; this.doc = doc;
    if (caseFold == null && typeof query == "string") caseFold = false;

    pos = pos ? doc.clipPos(pos) : Pos(0, 0);
    this.pos = {from: pos, to: pos};

    // The matches method is filled in based on the type of query.
    // It takes a position and a direction, and returns an object
    // describing the next occurrence of the query, or null if no
    // more matches were found.
    if (typeof query != "string") { // Regexp match
      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");
      this.matches = function(reverse, pos) {
        if (reverse) {
          query.lastIndex = 0;
          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;
          for (;;) {
            query.lastIndex = cutOff;
            var newMatch = query.exec(line);
            if (!newMatch) break;
            match = newMatch;
            start = match.index;
            cutOff = match.index + (match[0].length || 1);
            if (cutOff == line.length) break;
          }
          var matchLen = (match && match[0].length) || 0;
          if (!matchLen) {
            if (start == 0 && line.length == 0) {match = undefined;}
            else if (start != doc.getLine(pos.line).length) {
              matchLen++;
            }
          }
        } else {
          query.lastIndex = pos.ch;
          var line = doc.getLine(pos.line), match = query.exec(line);
          var matchLen = (match && match[0].length) || 0;
          var start = match && match.index;
          if (start + matchLen != line.length && !matchLen) matchLen = 1;
        }
        if (match && matchLen)
          return {from: Pos(pos.line, start),
                  to: Pos(pos.line, start + matchLen),
                  match: match};
      };
    } else { // String query
      var origQuery = query;
      if (caseFold) query = query.toLowerCase();
      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};
      var target = query.split("\n");
      // Different methods for single-line and multi-line queries
      if (target.length == 1) {
        if (!query.length) {
          // Empty string would match anything and never progress, so
          // we define it to match nothing instead.
          this.matches = function() {};
        } else {
          this.matches = function(reverse, pos) {
            if (reverse) {
              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);
              var match = line.lastIndexOf(query);
              if (match > -1) {
                match = adjustPos(orig, line, match);
                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
              }
             } else {
               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);
               var match = line.indexOf(query);
               if (match > -1) {
                 match = adjustPos(orig, line, match) + pos.ch;
                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};
               }
            }
          };
        }
      } else {
        var origTarget = origQuery.split("\n");
        this.matches = function(reverse, pos) {
          var last = target.length - 1;
          if (reverse) {
            if (pos.line - (target.length - 1) < doc.firstLine()) return;
            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;
            var to = Pos(pos.line, origTarget[last].length);
            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)
              if (target[i] != fold(doc.getLine(ln))) return;
            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;
            if (fold(line.slice(cut)) != target[0]) return;
            return {from: Pos(ln, cut), to: to};
          } else {
            if (pos.line + (target.length - 1) > doc.lastLine()) return;
            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;
            if (fold(line.slice(cut)) != target[0]) return;
            var from = Pos(pos.line, cut);
            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)
              if (target[i] != fold(doc.getLine(ln))) return;
            if (doc.getLine(ln).slice(0, origTarget[last].length) != target[last]) return;
            return {from: from, to: Pos(ln, origTarget[last].length)};
          }
        };
      }
    }
  }

  SearchCursor.prototype = {
    findNext: function() {return this.find(false);},
    findPrevious: function() {return this.find(true);},

    find: function(reverse) {
      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
      function savePosAndFail(line) {
        var pos = Pos(line, 0);
        self.pos = {from: pos, to: pos};
        self.atOccurrence = false;
        return false;
      }

      for (;;) {
        if (this.pos = this.matches(reverse, pos)) {
          this.atOccurrence = true;
          return this.pos.match || true;
        }
        if (reverse) {
          if (!pos.line) return savePosAndFail(0);
          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);
        }
        else {
          var maxLine = this.doc.lineCount();
          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);
          pos = Pos(pos.line + 1, 0);
        }
      }
    },

    from: function() {if (this.atOccurrence) return this.pos.from;},
    to: function() {if (this.atOccurrence) return this.pos.to;},

    replace: function(newText) {
      if (!this.atOccurrence) return;
      var lines = CodeMirror.splitLines(newText);
      this.doc.replaceRange(lines, this.pos.from, this.pos.to);
      this.pos.to = Pos(this.pos.from.line + lines.length - 1,
                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
    }
  };

  // Maps a position in a case-folded line back to a position in the original line
  // (compensating for codepoints increasing in number during folding)
  function adjustPos(orig, folded, pos) {
    if (orig.length == folded.length) return pos;
    for (var pos1 = Math.min(pos, orig.length);;) {
      var len1 = orig.slice(0, pos1).toLowerCase().length;
      if (len1 < pos) ++pos1;
      else if (len1 > pos) --pos1;
      else return pos1;
    }
  }

  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this.doc, query, pos, caseFold);
  });
  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
    return new SearchCursor(this, query, pos, caseFold);
  });

  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {
    var ranges = [], next;
    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
    while (next = cur.findNext()) {
      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;
      ranges.push({anchor: cur.from(), head: cur.to()});
    }
    if (ranges.length)
      this.setSelections(ranges, 0);
  });
});

// Define search commands. Depends on dialog.js or another
// implementation of the openDialog method.

// Replace works a little oddly -- it will do the replace on the next
// Ctrl-G (or whatever is bound to findNext) press. You prevent a
// replace by making sure the match is no longer selected when hitting
// Ctrl-G.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("./searchcursor"), require("../dialog/dialog"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./searchcursor", "../dialog/dialog"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  function searchOverlay(query, caseInsensitive) {
    if (typeof query == "string")
      query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");
    else if (!query.global)
      query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");

    return {token: function(stream) {
      query.lastIndex = stream.pos;
      var match = query.exec(stream.string);
      if (match && match.index == stream.pos) {
        stream.pos += match[0].length;
        return "searching";
      } else if (match) {
        stream.pos = match.index;
      } else {
        stream.skipToEnd();
      }
    }};
  }

  function SearchState() {
    this.posFrom = this.posTo = this.query = null;
    this.overlay = null;
  }
  function getSearchState(cm) {
    return cm.state.search || (cm.state.search = new SearchState());
  }
  function queryCaseInsensitive(query) {
    return typeof query == "string" && query == query.toLowerCase();
  }
  function getSearchCursor(cm, query, pos) {
    // Heuristic: if the query string is all lowercase, do a case insensitive search.
    return cm.getSearchCursor(query, pos, queryCaseInsensitive(query));
  }
  function dialog(cm, text, shortText, deflt, f) {
    if (cm.openDialog) cm.openDialog(text, f, {value: deflt});
    else f(prompt(shortText, deflt));
  }
  function confirmDialog(cm, text, shortText, fs) {
    if (cm.openConfirm) cm.openConfirm(text, fs);
    else if (confirm(shortText)) fs[0]();
  }
  function parseQuery(query) {
    var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
    if (isRE) {
      query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i");
      if (query.test("")) query = /x^/;
    } else if (query == "") {
      query = /x^/;
    }
    return query;
  }
  var queryDialog =
    'Search: <input type="text" style="width: 10em"/> <span style="color: #888">(Use /re/ syntax for regexp search)</span>';
  function doSearch(cm, rev) {
    var state = getSearchState(cm);
    if (state.query) return findNext(cm, rev);
    dialog(cm, queryDialog, "Search for:", cm.getSelection(), function(query) {
      cm.operation(function() {
        if (!query || state.query) return;
        state.query = parseQuery(query);
        cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
        state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
        cm.addOverlay(state.overlay);
        state.posFrom = state.posTo = cm.getCursor();
        findNext(cm, rev);
      });
    });
  }
  function findNext(cm, rev) {cm.operation(function() {
    var state = getSearchState(cm);
    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
    if (!cursor.find(rev)) {
      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
      if (!cursor.find(rev)) return;
    }
    cm.setSelection(cursor.from(), cursor.to());
    cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
    state.posFrom = cursor.from(); state.posTo = cursor.to();
  });}
  function clearSearch(cm) {cm.operation(function() {
    var state = getSearchState(cm);
    if (!state.query) return;
    state.query = null;
    cm.removeOverlay(state.overlay);
  });}

  var replaceQueryDialog =
    'Replace: <input type="text" style="width: 10em"/> <span style="color: #888">(Use /re/ syntax for regexp search)</span>';
  var replacementQueryDialog = 'With: <input type="text" style="width: 10em"/>';
  var doReplaceConfirm = "Replace? <button>Yes</button> <button>No</button> <button>Stop</button>";
  function replace(cm, all) {
    dialog(cm, replaceQueryDialog, "Replace:", cm.getSelection(), function(query) {
      if (!query) return;
      query = parseQuery(query);
      dialog(cm, replacementQueryDialog, "Replace with:", "", function(text) {
        if (all) {
          cm.operation(function() {
            for (var cursor = getSearchCursor(cm, query); cursor.findNext();) {
              if (typeof query != "string") {
                var match = cm.getRange(cursor.from(), cursor.to()).match(query);
                cursor.replace(text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
              } else cursor.replace(text);
            }
          });
        } else {
          clearSearch(cm);
          var cursor = getSearchCursor(cm, query, cm.getCursor());
          var advance = function() {
            var start = cursor.from(), match;
            if (!(match = cursor.findNext())) {
              cursor = getSearchCursor(cm, query);
              if (!(match = cursor.findNext()) ||
                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;
            }
            cm.setSelection(cursor.from(), cursor.to());
            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
            confirmDialog(cm, doReplaceConfirm, "Replace?",
                          [function() {doReplace(match);}, advance]);
          };
          var doReplace = function(match) {
            cursor.replace(typeof query == "string" ? text :
                           text.replace(/\$(\d)/g, function(_, i) {return match[i];}));
            advance();
          };
          advance();
        }
      });
    });
  }

  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};
  CodeMirror.commands.findNext = doSearch;
  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};
  CodeMirror.commands.clearSearch = clearSearch;
  CodeMirror.commands.replace = replace;
  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
});

// Open simple dialogs on top of an editor. Relies on dialog.css.

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  function dialogDiv(cm, template, bottom) {
    var wrap = cm.getWrapperElement();
    var dialog;
    dialog = wrap.appendChild(document.createElement("div"));
    if (bottom) {
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
    } else {
      dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";
    }
    if (typeof template == "string") {
      dialog.innerHTML = template;
    } else { // Assuming it's a detached DOM element.
      dialog.appendChild(template);
    }
    return dialog;
  }

  function closeNotification(cm, newVal) {
    if (cm.state.currentNotificationClose)
      cm.state.currentNotificationClose();
    cm.state.currentNotificationClose = newVal;
  }

  CodeMirror.defineExtension("openDialog", function(template, callback, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var closed = false, me = this;
    function close() {
      if (closed) return;
      closed = true;
      dialog.parentNode.removeChild(dialog);
    }
    var inp = dialog.getElementsByTagName("input")[0], button;
    if (inp) {
      if (options && options.value) inp.value = options.value;
      CodeMirror.on(inp, "keydown", function(e) {
        if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) { return; }
        if (e.keyCode == 13 || e.keyCode == 27) {
          inp.blur();
          CodeMirror.e_stop(e);
          close();
          me.focus();
          if (e.keyCode == 13) callback(inp.value);
        }
      });
      if (options && options.onKeyUp) {
        CodeMirror.on(inp, "keyup", function(e) {options.onKeyUp(e, inp.value, close);});
      }
      if (options && options.value) inp.value = options.value;
      inp.focus();
      CodeMirror.on(inp, "blur", close);
    } else if (button = dialog.getElementsByTagName("button")[0]) {
      CodeMirror.on(button, "click", function() {
        close();
        me.focus();
      });
      button.focus();
      CodeMirror.on(button, "blur", close);
    }
    return close;
  });

  CodeMirror.defineExtension("openConfirm", function(template, callbacks, options) {
    closeNotification(this, null);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var buttons = dialog.getElementsByTagName("button");
    var closed = false, me = this, blurring = 1;
    function close() {
      if (closed) return;
      closed = true;
      dialog.parentNode.removeChild(dialog);
      me.focus();
    }
    buttons[0].focus();
    for (var i = 0; i < buttons.length; ++i) {
      var b = buttons[i];
      (function(callback) {
        CodeMirror.on(b, "click", function(e) {
          CodeMirror.e_preventDefault(e);
          close();
          if (callback) callback(me);
        });
      })(callbacks[i]);
      CodeMirror.on(b, "blur", function() {
        --blurring;
        setTimeout(function() { if (blurring <= 0) close(); }, 200);
      });
      CodeMirror.on(b, "focus", function() { ++blurring; });
    }
  });

  /*
   * openNotification
   * Opens a notification, that can be closed with an optional timer
   * (default 5000ms timer) and always closes on click.
   *
   * If a notification is opened while another is opened, it will close the
   * currently opened one and open the new one immediately.
   */
  CodeMirror.defineExtension("openNotification", function(template, options) {
    closeNotification(this, close);
    var dialog = dialogDiv(this, template, options && options.bottom);
    var duration = options && (options.duration === undefined ? 5000 : options.duration);
    var closed = false, doneTimer;

    function close() {
      if (closed) return;
      closed = true;
      clearTimeout(doneTimer);
      dialog.parentNode.removeChild(dialog);
    }

    CodeMirror.on(dialog, 'click', function(e) {
      CodeMirror.e_preventDefault(e);
      close();
    });
    if (duration)
      doneTimer = setTimeout(close, options.duration);
  });
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var ie_lt8 = /MSIE \d/.test(navigator.userAgent) &&
    (document.documentMode == null || document.documentMode < 8);

  var Pos = CodeMirror.Pos;

  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};

  function findMatchingBracket(cm, where, strict, config) {
    var line = cm.getLineHandle(where.line), pos = where.ch - 1;
    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];
    if (!match) return null;
    var dir = match.charAt(1) == ">" ? 1 : -1;
    if (strict && (dir > 0) != (pos == where.ch)) return null;
    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));

    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);
    if (found == null) return null;
    return {from: Pos(where.line, pos), to: found && found.pos,
            match: found && found.ch == match.charAt(0), forward: dir > 0};
  }

  // bracketRegex is used to specify which type of bracket to scan
  // should be a regexp, e.g. /[[\]]/
  //
  // Note: If "where" is on an open bracket, then this bracket is ignored.
  //
  // Returns false when no bracket was found, null when it reached
  // maxScanLines and gave up
  function scanForBracket(cm, where, dir, style, config) {
    var maxScanLen = (config && config.maxScanLineLength) || 10000;
    var maxScanLines = (config && config.maxScanLines) || 1000;

    var stack = [];
    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\]]/;
    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
      var line = cm.getLine(lineNo);
      if (!line) continue;
      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
      if (line.length > maxScanLen) continue;
      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);
      for (; pos != end; pos += dir) {
        var ch = line.charAt(pos);
        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {
          var match = matching[ch];
          if ((match.charAt(1) == ">") == (dir > 0)) stack.push(ch);
          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};
          else stack.pop();
        }
      }
    }
    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
  }

  function matchBrackets(cm, autoclear, config) {
    // Disable brace matching in long lines, since it'll cause hugely slow updates
    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;
    var marks = [], ranges = cm.listSelections();
    for (var i = 0; i < ranges.length; i++) {
      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);
      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {
        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));
        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));
      }
    }

    if (marks.length) {
      // Kludge to work around the IE bug from issue #1193, where text
      // input stops going to the textare whever this fires.
      if (ie_lt8 && cm.state.focused) cm.display.input.focus();

      var clear = function() {
        cm.operation(function() {
          for (var i = 0; i < marks.length; i++) marks[i].clear();
        });
      };
      if (autoclear) setTimeout(clear, 800);
      else return clear;
    }
  }

  var currentlyHighlighted = null;
  function doMatchBrackets(cm) {
    cm.operation(function() {
      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}
      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
    });
  }

  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init)
      cm.off("cursorActivity", doMatchBrackets);
    if (val) {
      cm.state.matchBrackets = typeof val == "object" ? val : {};
      cm.on("cursorActivity", doMatchBrackets);
    }
  });

  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});
  CodeMirror.defineExtension("findMatchingBracket", function(pos, strict, config){
    return findMatchingBracket(this, pos, strict, config);
  });
  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){
    return scanForBracket(this, pos, dir, style, config);
  });
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var DEFAULT_BRACKETS = "()[]{}''\"\"";
  var DEFAULT_EXPLODE_ON_ENTER = "[]{}";
  var SPACE_CHAR_REGEX = /\s/;

  var Pos = CodeMirror.Pos;

  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {
    if (old != CodeMirror.Init && old)
      cm.removeKeyMap("autoCloseBrackets");
    if (!val) return;
    var pairs = DEFAULT_BRACKETS, explode = DEFAULT_EXPLODE_ON_ENTER;
    if (typeof val == "string") pairs = val;
    else if (typeof val == "object") {
      if (val.pairs != null) pairs = val.pairs;
      if (val.explode != null) explode = val.explode;
    }
    var map = buildKeymap(pairs);
    if (explode) map.Enter = buildExplodeHandler(explode);
    cm.addKeyMap(map);
  });

  function charsAround(cm, pos) {
    var str = cm.getRange(Pos(pos.line, pos.ch - 1),
                          Pos(pos.line, pos.ch + 1));
    return str.length == 2 ? str : null;
  }

  function buildKeymap(pairs) {
    var map = {
      name : "autoCloseBrackets",
      Backspace: function(cm) {
        if (cm.getOption("disableInput")) return CodeMirror.Pass;
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty()) return CodeMirror.Pass;
          var around = charsAround(cm, ranges[i].head);
          if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
        }
        for (var i = ranges.length - 1; i >= 0; i--) {
          var cur = ranges[i].head;
          cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));
        }
      }
    };
    var closingBrackets = "";
    for (var i = 0; i < pairs.length; i += 2) (function(left, right) {
      if (left != right) closingBrackets += right;
      map["'" + left + "'"] = function(cm) {
        if (cm.getOption("disableInput")) return CodeMirror.Pass;
        var ranges = cm.listSelections(), type, next;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], cur = range.head, curType;
          if (left == "'" && cm.getTokenTypeAt(cur) == "comment")
            return CodeMirror.Pass;
          var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
          if (!range.empty())
            curType = "surround";
          else if (left == right && next == right) {
            if (cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == left + left + left)
              curType = "skipThree";
            else
              curType = "skip";
          } else if (left == right && cur.ch > 1 &&
                     cm.getRange(Pos(cur.line, cur.ch - 2), cur) == left + left &&
                     (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != left))
            curType = "addFour";
          else if (left == right && CodeMirror.isWordChar(next))
            return CodeMirror.Pass;
          else if (cm.getLine(cur.line).length == cur.ch || closingBrackets.indexOf(next) >= 0 || SPACE_CHAR_REGEX.test(next))
            curType = "both";
          else
            return CodeMirror.Pass;
          if (!type) type = curType;
          else if (type != curType) return CodeMirror.Pass;
        }

        cm.operation(function() {
          if (type == "skip") {
            cm.execCommand("goCharRight");
          } else if (type == "skipThree") {
            for (var i = 0; i < 3; i++)
              cm.execCommand("goCharRight");
          } else if (type == "surround") {
            var sels = cm.getSelections();
            for (var i = 0; i < sels.length; i++)
              sels[i] = left + sels[i] + right;
            cm.replaceSelections(sels, "around");
          } else if (type == "both") {
            cm.replaceSelection(left + right, null);
            cm.execCommand("goCharLeft");
          } else if (type == "addFour") {
            cm.replaceSelection(left + left + left + left, "before");
            cm.execCommand("goCharRight");
          }
        });
      };
      if (left != right) map["'" + right + "'"] = function(cm) {
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty() ||
              cm.getRange(range.head, Pos(range.head.line, range.head.ch + 1)) != right)
            return CodeMirror.Pass;
        }
        cm.execCommand("goCharRight");
      };
    })(pairs.charAt(i), pairs.charAt(i + 1));
    return map;
  }

  function buildExplodeHandler(pairs) {
    return function(cm) {
      if (cm.getOption("disableInput")) return CodeMirror.Pass;
      var ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) return CodeMirror.Pass;
        var around = charsAround(cm, ranges[i].head);
        if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;
      }
      cm.operation(function() {
        cm.replaceSelection("\n\n", null);
        cm.execCommand("goCharLeft");
        ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          var line = ranges[i].head.line;
          cm.indentLine(line, null, true);
          cm.indentLine(line + 1, null, true);
        }
      });
    };
  }
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var noOptions = {};
  var nonWS = /[^\s\u00a0]/;
  var Pos = CodeMirror.Pos;

  function firstNonWS(str) {
    var found = str.search(nonWS);
    return found == -1 ? 0 : found;
  }

  CodeMirror.commands.toggleComment = function(cm) {
    var minLine = Infinity, ranges = cm.listSelections(), mode = null;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var from = ranges[i].from(), to = ranges[i].to();
      if (from.line >= minLine) continue;
      if (to.line >= minLine) to = Pos(minLine, 0);
      minLine = from.line;
      if (mode == null) {
        if (cm.uncomment(from, to)) mode = "un";
        else { cm.lineComment(from, to); mode = "line"; }
      } else if (mode == "un") {
        cm.uncomment(from, to);
      } else {
        cm.lineComment(from, to);
      }
    }
  };

  CodeMirror.defineExtension("lineComment", function(from, to, options) {
    if (!options) options = noOptions;
    var self = this, mode = self.getModeAt(from);
    var commentString = options.lineComment || mode.lineComment;
    if (!commentString) {
      if (options.blockCommentStart || mode.blockCommentStart) {
        options.fullLines = true;
        self.blockComment(from, to, options);
      }
      return;
    }
    var firstLine = self.getLine(from.line);
    if (firstLine == null) return;
    var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self.lastLine() + 1);
    var pad = options.padding == null ? " " : options.padding;
    var blankLines = options.commentBlankLines || from.line == to.line;

    self.operation(function() {
      if (options.indent) {
        var baseString = firstLine.slice(0, firstNonWS(firstLine));
        for (var i = from.line; i < end; ++i) {
          var line = self.getLine(i), cut = baseString.length;
          if (!blankLines && !nonWS.test(line)) continue;
          if (line.slice(0, cut) != baseString) cut = firstNonWS(line);
          self.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
        }
      } else {
        for (var i = from.line; i < end; ++i) {
          if (blankLines || nonWS.test(self.getLine(i)))
            self.replaceRange(commentString + pad, Pos(i, 0));
        }
      }
    });
  });

  CodeMirror.defineExtension("blockComment", function(from, to, options) {
    if (!options) options = noOptions;
    var self = this, mode = self.getModeAt(from);
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) {
      if ((options.lineComment || mode.lineComment) && options.fullLines != false)
        self.lineComment(from, to, options);
      return;
    }

    var end = Math.min(to.line, self.lastLine());
    if (end != from.line && to.ch == 0 && nonWS.test(self.getLine(end))) --end;

    var pad = options.padding == null ? " " : options.padding;
    if (from.line > end) return;

    self.operation(function() {
      if (options.fullLines != false) {
        var lastLineHasText = nonWS.test(self.getLine(end));
        self.replaceRange(pad + endString, Pos(end));
        self.replaceRange(startString + pad, Pos(from.line, 0));
        var lead = options.blockCommentLead || mode.blockCommentLead;
        if (lead != null) for (var i = from.line + 1; i <= end; ++i)
          if (i != end || lastLineHasText)
            self.replaceRange(lead + pad, Pos(i, 0));
      } else {
        self.replaceRange(endString, to);
        self.replaceRange(startString, from);
      }
    });
  });

  CodeMirror.defineExtension("uncomment", function(from, to, options) {
    if (!options) options = noOptions;
    var self = this, mode = self.getModeAt(from);
    var end = Math.min(to.line, self.lastLine()), start = Math.min(from.line, end);

    // Try finding line comments
    var lineString = options.lineComment || mode.lineComment, lines = [];
    var pad = options.padding == null ? " " : options.padding, didSomething;
    lineComment: {
      if (!lineString) break lineComment;
      for (var i = start; i <= end; ++i) {
        var line = self.getLine(i);
        var found = line.indexOf(lineString);
        if (found > -1 && !/comment/.test(self.getTokenTypeAt(Pos(i, found + 1)))) found = -1;
        if (found == -1 && (i != end || i == start) && nonWS.test(line)) break lineComment;
        if (found > -1 && nonWS.test(line.slice(0, found))) break lineComment;
        lines.push(line);
      }
      self.operation(function() {
        for (var i = start; i <= end; ++i) {
          var line = lines[i - start];
          var pos = line.indexOf(lineString), endPos = pos + lineString.length;
          if (pos < 0) continue;
          if (line.slice(endPos, endPos + pad.length) == pad) endPos += pad.length;
          didSomething = true;
          self.replaceRange("", Pos(i, pos), Pos(i, endPos));
        }
      });
      if (didSomething) return true;
    }

    // Try block comments
    var startString = options.blockCommentStart || mode.blockCommentStart;
    var endString = options.blockCommentEnd || mode.blockCommentEnd;
    if (!startString || !endString) return false;
    var lead = options.blockCommentLead || mode.blockCommentLead;
    var startLine = self.getLine(start), endLine = end == start ? startLine : self.getLine(end);
    var open = startLine.indexOf(startString), close = endLine.lastIndexOf(endString);
    if (close == -1 && start != end) {
      endLine = self.getLine(--end);
      close = endLine.lastIndexOf(endString);
    }
    if (open == -1 || close == -1 ||
        !/comment/.test(self.getTokenTypeAt(Pos(start, open + 1))) ||
        !/comment/.test(self.getTokenTypeAt(Pos(end, close + 1))))
      return false;

    self.operation(function() {
      self.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)),
                        Pos(end, close + endString.length));
      var openEnd = open + startString.length;
      if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad) openEnd += pad.length;
      self.replaceRange("", Pos(start, open), Pos(start, openEnd));
      if (lead) for (var i = start + 1; i <= end; ++i) {
        var line = self.getLine(i), found = line.indexOf(lead);
        if (found == -1 || nonWS.test(line.slice(0, found))) continue;
        var foundEnd = found + lead.length;
        if (pad && line.slice(foundEnd, foundEnd + pad.length) == pad) foundEnd += pad.length;
        self.replaceRange("", Pos(i, found), Pos(i, foundEnd));
      }
    });
    return true;
  });
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;

  function findParagraph(cm, pos, options) {
    var startRE = options.paragraphStart || cm.getHelper(pos, "paragraphStart");
    for (var start = pos.line, first = cm.firstLine(); start > first; --start) {
      var line = cm.getLine(start);
      if (startRE && startRE.test(line)) break;
      if (!/\S/.test(line)) { ++start; break; }
    }
    var endRE = options.paragraphEnd || cm.getHelper(pos, "paragraphEnd");
    for (var end = pos.line + 1, last = cm.lastLine(); end <= last; ++end) {
      var line = cm.getLine(end);
      if (endRE && endRE.test(line)) { ++end; break; }
      if (!/\S/.test(line)) break;
    }
    return {from: start, to: end};
  }

  function findBreakPoint(text, column, wrapOn, killTrailingSpace) {
    for (var at = column; at > 0; --at)
      if (wrapOn.test(text.slice(at - 1, at + 1))) break;
    if (at == 0) at = column;
    var endOfText = at;
    if (killTrailingSpace)
      while (text.charAt(endOfText - 1) == " ") --endOfText;
    return {from: endOfText, to: at};
  }

  function wrapRange(cm, from, to, options) {
    from = cm.clipPos(from); to = cm.clipPos(to);
    var column = options.column || 80;
    var wrapOn = options.wrapOn || /\s\S|-[^\.\d]/;
    var killTrailing = options.killTrailingSpace !== false;
    var changes = [], curLine = "", curNo = from.line;
    var lines = cm.getRange(from, to, false);
    if (!lines.length) return null;
    var leadingSpace = lines[0].match(/^[ \t]*/)[0];

    for (var i = 0; i < lines.length; ++i) {
      var text = lines[i], oldLen = curLine.length, spaceInserted = 0;
      if (curLine && text && !wrapOn.test(curLine.charAt(curLine.length - 1) + text.charAt(0))) {
        curLine += " ";
        spaceInserted = 1;
      }
      var spaceTrimmed = "";
      if (i) {
        spaceTrimmed = text.match(/^\s*/)[0];
        text = text.slice(spaceTrimmed.length);
      }
      curLine += text;
      if (i) {
        var firstBreak = curLine.length > column && leadingSpace == spaceTrimmed &&
          findBreakPoint(curLine, column, wrapOn, killTrailing);
        // If this isn't broken, or is broken at a different point, remove old break
        if (!firstBreak || firstBreak.from != oldLen || firstBreak.to != oldLen + spaceInserted) {
          changes.push({text: [spaceInserted ? " " : ""],
                        from: Pos(curNo, oldLen),
                        to: Pos(curNo + 1, spaceTrimmed.length)});
        } else {
          curLine = leadingSpace + text;
          ++curNo;
        }
      }
      while (curLine.length > column) {
        var bp = findBreakPoint(curLine, column, wrapOn, killTrailing);
        changes.push({text: ["", leadingSpace],
                      from: Pos(curNo, bp.from),
                      to: Pos(curNo, bp.to)});
        curLine = leadingSpace + curLine.slice(bp.to);
        ++curNo;
      }
    }
    if (changes.length) cm.operation(function() {
      for (var i = 0; i < changes.length; ++i) {
        var change = changes[i];
        cm.replaceRange(change.text, change.from, change.to);
      }
    });
    return changes.length ? {from: changes[0].from, to: CodeMirror.changeEnd(changes[changes.length - 1])} : null;
  }

  CodeMirror.defineExtension("wrapParagraph", function(pos, options) {
    options = options || {};
    if (!pos) pos = this.getCursor();
    var para = findParagraph(this, pos, options);
    return wrapRange(this, Pos(para.from, 0), Pos(para.to - 1), options);
  });

  CodeMirror.commands.wrapLines = function(cm) {
    cm.operation(function() {
      var ranges = cm.listSelections(), at = cm.lastLine() + 1;
      for (var i = ranges.length - 1; i >= 0; i--) {
        var range = ranges[i], span;
        if (range.empty()) {
          var para = findParagraph(cm, range.head, {});
          span = {from: Pos(para.from, 0), to: Pos(para.to - 1)};
        } else {
          span = {from: range.from(), to: range.to()};
        }
        if (span.to.line >= at) continue;
        at = span.from.line;
        wrapRange(cm, span.from, span.to, {});
      }
    });
  };

  CodeMirror.defineExtension("wrapRange", function(from, to, options) {
    return wrapRange(this, from, to, options || {});
  });

  CodeMirror.defineExtension("wrapParagraphsInRange", function(from, to, options) {
    options = options || {};
    var cm = this, paras = [];
    for (var line = from.line; line <= to.line;) {
      var para = findParagraph(cm, Pos(line, 0), options);
      paras.push(para);
      line = para.to;
    }
    var madeChange = false;
    if (paras.length) cm.operation(function() {
      for (var i = paras.length - 1; i >= 0; --i)
        madeChange = madeChange || wrapRange(cm, Pos(paras[i].from, 0), Pos(paras[i].to - 1), options);
    });
    return madeChange;
  });
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  function doFold(cm, pos, options, force) {
    var finder = options && (options.call ? options : options.rangeFinder);
    if (!finder) finder = CodeMirror.fold.auto;
    if (typeof pos == "number") pos = CodeMirror.Pos(pos, 0);
    var minSize = options && options.minFoldSize || 0;

    function getRange(allowFolded) {
      var range = finder(cm, pos);
      if (!range || range.to.line - range.from.line < minSize) return null;
      var marks = cm.findMarksAt(range.from);
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold && force !== "fold") {
          if (!allowFolded) return null;
          range.cleared = true;
          marks[i].clear();
        }
      }
      return range;
    }

    var range = getRange(true);
    if (options && options.scanUp) while (!range && pos.line > cm.firstLine()) {
      pos = CodeMirror.Pos(pos.line - 1, 0);
      range = getRange(false);
    }
    if (!range || range.cleared || force === "unfold") return;

    var myWidget = makeWidget(options);
    CodeMirror.on(myWidget, "mousedown", function() { myRange.clear(); });
    var myRange = cm.markText(range.from, range.to, {
      replacedWith: myWidget,
      clearOnEnter: true,
      __isFold: true
    });
    myRange.on("clear", function(from, to) {
      CodeMirror.signal(cm, "unfold", cm, from, to);
    });
    CodeMirror.signal(cm, "fold", cm, range.from, range.to);
  }

  function makeWidget(options) {
    var widget = (options && options.widget) || "\u2194";
    if (typeof widget == "string") {
      var text = document.createTextNode(widget);
      widget = document.createElement("span");
      widget.appendChild(text);
      widget.className = "CodeMirror-foldmarker";
    }
    return widget;
  }

  // Clumsy backwards-compatible interface
  CodeMirror.newFoldFunction = function(rangeFinder, widget) {
    return function(cm, pos) { doFold(cm, pos, {rangeFinder: rangeFinder, widget: widget}); };
  };

  // New-style interface
  CodeMirror.defineExtension("foldCode", function(pos, options, force) {
    doFold(this, pos, options, force);
  });

  CodeMirror.defineExtension("isFolded", function(pos) {
    var marks = this.findMarksAt(pos);
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold) return true;
  });

  CodeMirror.commands.toggleFold = function(cm) {
    cm.foldCode(cm.getCursor());
  };
  CodeMirror.commands.fold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "fold");
  };
  CodeMirror.commands.unfold = function(cm) {
    cm.foldCode(cm.getCursor(), null, "unfold");
  };
  CodeMirror.commands.foldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
    });
  };
  CodeMirror.commands.unfoldAll = function(cm) {
    cm.operation(function() {
      for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
        cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
    });
  };

  CodeMirror.registerHelper("fold", "combine", function() {
    var funcs = Array.prototype.slice.call(arguments, 0);
    return function(cm, start) {
      for (var i = 0; i < funcs.length; ++i) {
        var found = funcs[i](cm, start);
        if (found) return found;
      }
    };
  });

  CodeMirror.registerHelper("fold", "auto", function(cm, start) {
    var helpers = cm.getHelpers(start, "fold");
    for (var i = 0; i < helpers.length; i++) {
      var cur = helpers[i](cm, start);
      if (cur) return cur;
    }
  });
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.registerHelper("fold", "brace", function(cm, start) {
  var line = start.line, lineText = cm.getLine(line);
  var startCh, tokenType;

  function findOpening(openCh) {
    for (var at = start.ch, pass = 0;;) {
      var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
      if (found == -1) {
        if (pass == 1) break;
        pass = 1;
        at = lineText.length;
        continue;
      }
      if (pass == 1 && found < start.ch) break;
      tokenType = cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1));
      if (!/^(comment|string)/.test(tokenType)) return found + 1;
      at = found - 1;
    }
  }

  var startToken = "{", endToken = "}", startCh = findOpening("{");
  if (startCh == null) {
    startToken = "[", endToken = "]";
    startCh = findOpening("[");
  }

  if (startCh == null) return;
  var count = 1, lastLine = cm.lastLine(), end, endCh;
  outer: for (var i = line; i <= lastLine; ++i) {
    var text = cm.getLine(i), pos = i == line ? startCh : 0;
    for (;;) {
      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
      if (nextOpen < 0) nextOpen = text.length;
      if (nextClose < 0) nextClose = text.length;
      pos = Math.min(nextOpen, nextClose);
      if (pos == text.length) break;
      if (cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType) {
        if (pos == nextOpen) ++count;
        else if (!--count) { end = i; endCh = pos; break outer; }
      }
      ++pos;
    }
  }
  if (end == null || line == end && endCh == startCh) return;
  return {from: CodeMirror.Pos(line, startCh),
          to: CodeMirror.Pos(end, endCh)};
});

CodeMirror.registerHelper("fold", "import", function(cm, start) {
  function hasImport(line) {
    if (line < cm.firstLine() || line > cm.lastLine()) return null;
    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
    if (start.type != "keyword" || start.string != "import") return null;
    // Now find closing semicolon, return its position
    for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
      var text = cm.getLine(i), semi = text.indexOf(";");
      if (semi != -1) return {startCh: start.end, end: CodeMirror.Pos(i, semi)};
    }
  }

  var start = start.line, has = hasImport(start), prev;
  if (!has || hasImport(start - 1) || ((prev = hasImport(start - 2)) && prev.end.line == start - 1))
    return null;
  for (var end = has.end;;) {
    var next = hasImport(end.line + 1);
    if (next == null) break;
    end = next.end;
  }
  return {from: cm.clipPos(CodeMirror.Pos(start, has.startCh + 1)), to: end};
});

CodeMirror.registerHelper("fold", "include", function(cm, start) {
  function hasInclude(line) {
    if (line < cm.firstLine() || line > cm.lastLine()) return null;
    var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
    if (!/\S/.test(start.string)) start = cm.getTokenAt(CodeMirror.Pos(line, start.end + 1));
    if (start.type == "meta" && start.string.slice(0, 8) == "#include") return start.start + 8;
  }

  var start = start.line, has = hasInclude(start);
  if (has == null || hasInclude(start - 1) != null) return null;
  for (var end = start;;) {
    var next = hasInclude(end + 1);
    if (next == null) break;
    ++end;
  }
  return {from: CodeMirror.Pos(start, has + 1),
          to: cm.clipPos(CodeMirror.Pos(end))};
});

});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("./foldcode"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./foldcode"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption("foldGutter", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      cm.clearGutter(cm.state.foldGutter.options.gutter);
      cm.state.foldGutter = null;
      cm.off("gutterClick", onGutterClick);
      cm.off("change", onChange);
      cm.off("viewportChange", onViewportChange);
      cm.off("fold", onFold);
      cm.off("unfold", onFold);
      cm.off("swapDoc", updateInViewport);
    }
    if (val) {
      cm.state.foldGutter = new State(parseOptions(val));
      updateInViewport(cm);
      cm.on("gutterClick", onGutterClick);
      cm.on("change", onChange);
      cm.on("viewportChange", onViewportChange);
      cm.on("fold", onFold);
      cm.on("unfold", onFold);
      cm.on("swapDoc", updateInViewport);
    }
  });

  var Pos = CodeMirror.Pos;

  function State(options) {
    this.options = options;
    this.from = this.to = 0;
  }

  function parseOptions(opts) {
    if (opts === true) opts = {};
    if (opts.gutter == null) opts.gutter = "CodeMirror-foldgutter";
    if (opts.indicatorOpen == null) opts.indicatorOpen = "CodeMirror-foldgutter-open";
    if (opts.indicatorFolded == null) opts.indicatorFolded = "CodeMirror-foldgutter-folded";
    return opts;
  }

  function isFolded(cm, line) {
    var marks = cm.findMarksAt(Pos(line));
    for (var i = 0; i < marks.length; ++i)
      if (marks[i].__isFold && marks[i].find().from.line == line) return true;
  }

  function marker(spec) {
    if (typeof spec == "string") {
      var elt = document.createElement("div");
      elt.className = spec;
      return elt;
    } else {
      return spec.cloneNode(true);
    }
  }

  function updateFoldInfo(cm, from, to) {
    var opts = cm.state.foldGutter.options, cur = from;
    cm.eachLine(from, to, function(line) {
      var mark = null;
      if (isFolded(cm, cur)) {
        mark = marker(opts.indicatorFolded);
      } else {
        var pos = Pos(cur, 0), func = opts.rangeFinder || CodeMirror.fold.auto;
        var range = func && func(cm, pos);
        if (range && range.from.line + 1 < range.to.line)
          mark = marker(opts.indicatorOpen);
      }
      cm.setGutterMarker(line, opts.gutter, mark);
      ++cur;
    });
  }

  function updateInViewport(cm) {
    var vp = cm.getViewport(), state = cm.state.foldGutter;
    if (!state) return;
    cm.operation(function() {
      updateFoldInfo(cm, vp.from, vp.to);
    });
    state.from = vp.from; state.to = vp.to;
  }

  function onGutterClick(cm, line, gutter) {
    var opts = cm.state.foldGutter.options;
    if (gutter != opts.gutter) return;
    cm.foldCode(Pos(line, 0), opts.rangeFinder);
  }

  function onChange(cm) {
    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;
    state.from = state.to = 0;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() { updateInViewport(cm); }, opts.foldOnChangeTimeSpan || 600);
  }

  function onViewportChange(cm) {
    var state = cm.state.foldGutter, opts = cm.state.foldGutter.options;
    clearTimeout(state.changeUpdate);
    state.changeUpdate = setTimeout(function() {
      var vp = cm.getViewport();
      if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
        updateInViewport(cm);
      } else {
        cm.operation(function() {
          if (vp.from < state.from) {
            updateFoldInfo(cm, vp.from, state.from);
            state.from = vp.from;
          }
          if (vp.to > state.to) {
            updateFoldInfo(cm, state.to, vp.to);
            state.to = vp.to;
          }
        });
      }
    }, opts.updateViewportTimeSpan || 400);
  }

  function onFold(cm, from) {
    var state = cm.state.foldGutter, line = from.line;
    if (line >= state.from && line < state.to)
      updateFoldInfo(cm, line, line + 1);
  }
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.registerGlobalHelper("fold", "comment", function(mode) {
  return mode.blockCommentStart && mode.blockCommentEnd;
}, function(cm, start) {
  var mode = cm.getModeAt(start), startToken = mode.blockCommentStart, endToken = mode.blockCommentEnd;
  if (!startToken || !endToken) return;
  var line = start.line, lineText = cm.getLine(line);

  var startCh;
  for (var at = start.ch, pass = 0;;) {
    var found = at <= 0 ? -1 : lineText.lastIndexOf(startToken, at - 1);
    if (found == -1) {
      if (pass == 1) return;
      pass = 1;
      at = lineText.length;
      continue;
    }
    if (pass == 1 && found < start.ch) return;
    if (/comment/.test(cm.getTokenTypeAt(CodeMirror.Pos(line, found + 1)))) {
      startCh = found + startToken.length;
      break;
    }
    at = found - 1;
  }

  var depth = 1, lastLine = cm.lastLine(), end, endCh;
  outer: for (var i = line; i <= lastLine; ++i) {
    var text = cm.getLine(i), pos = i == line ? startCh : 0;
    for (;;) {
      var nextOpen = text.indexOf(startToken, pos), nextClose = text.indexOf(endToken, pos);
      if (nextOpen < 0) nextOpen = text.length;
      if (nextClose < 0) nextClose = text.length;
      pos = Math.min(nextOpen, nextClose);
      if (pos == text.length) break;
      if (pos == nextOpen) ++depth;
      else if (!--depth) { end = i; endCh = pos; break outer; }
      ++pos;
    }
  }
  if (end == null || line == end && endCh == startCh) return;
  return {from: CodeMirror.Pos(line, startCh),
          to: CodeMirror.Pos(end, endCh)};
});

});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.registerHelper("fold", "indent", function(cm, start) {
  var tabSize = cm.getOption("tabSize"), firstLine = cm.getLine(start.line);
  if (!/\S/.test(firstLine)) return;
  var getIndent = function(line) {
    return CodeMirror.countColumn(line, null, tabSize);
  };
  var myIndent = getIndent(firstLine);
  var lastLineInFold = null;
  // Go through lines until we find a line that definitely doesn't belong in
  // the block we're folding, or to the end.
  for (var i = start.line + 1, end = cm.lastLine(); i <= end; ++i) {
    var curLine = cm.getLine(i);
    var curIndent = getIndent(curLine);
    if (curIndent > myIndent) {
      // Lines with a greater indent are considered part of the block.
      lastLineInFold = i;
    } else if (!/\S/.test(curLine)) {
      // Empty lines might be breaks within the block we're trying to fold.
    } else {
      // A non-empty line at an indent equal to or less than ours marks the
      // start of another block.
      break;
    }
  }
  if (lastLineInFold) return {
    from: CodeMirror.Pos(start.line, firstLine.length),
    to: CodeMirror.Pos(lastLineInFold, cm.getLine(lastLineInFold).length)
  };
});

});

!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.coffeelint=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={
  "name": "coffeelint",
  "description": "Lint your CoffeeScript",
  "version": "1.3.0",
  "homepage": "http://www.coffeelint.org",
  "keywords": [
    "lint",
    "coffeescript",
    "coffee-script"
  ],
  "author": "Matthew Perpick <clutchski@gmail.com>",
  "main": "./lib/coffeelint.js",
  "engines": {
    "node": ">=0.8.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/clutchski/coffeelint.git"
  },
  "bin": {
    "coffeelint": "./bin/coffeelint"
  },
  "dependencies": {
    "optimist": ">=0.2.8",
    "coffee-script": "~1.7",
    "glob": ">=3.1.9",
    "browserify": "~3.37",
    "coffeeify": "~0.6.0"
  },
  "devDependencies": {
    "vows": ">=0.6.0",
    "underscore": ">=1.4.4"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/clutchski/coffeelint/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "pretest": "cake compile",
    "test": "coffee vowsrunner.coffee --spec test/*.coffee test/*.litcoffee",
    "posttest": "npm run lint",
    "prepublish": "cake prepublish",
    "publish": "cake publish",
    "install": "cake install",
    "lint": "cake compile && ./bin/coffeelint -f coffeelint.json src/*.coffee test/*.coffee test/*.litcoffee",
    "lint-csv": "cake compile && ./bin/coffeelint --csv -f coffeelint.json src/*.coffee test/*.coffee",
    "lint-jslint": "cake compile && ./bin/coffeelint --jslint -f coffeelint.json src/*.coffee test/*.coffee",
    "compile": "cake compile"
  }
}

},{}],2:[function(_dereq_,module,exports){
var ASTApi, ASTLinter, BaseLinter, hasChildren, node_children,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BaseLinter = _dereq_('./base_linter.coffee');

node_children = {
  Class: ['variable', 'parent', 'body'],
  Code: ['params', 'body'],
  For: ['body', 'source', 'guard', 'step'],
  If: ['condition', 'body', 'elseBody'],
  Obj: ['properties'],
  Op: ['first', 'second'],
  Switch: ['subject', 'cases', 'otherwise'],
  Try: ['attempt', 'recovery', 'ensure'],
  Value: ['base', 'properties'],
  While: ['condition', 'guard', 'body']
};

hasChildren = function(node, children) {
  var _ref;
  return (node != null ? (_ref = node.children) != null ? _ref.length : void 0 : void 0) === children.length && (node != null ? node.children.every(function(elem, i) {
    return elem === children[i];
  }) : void 0);
};

ASTApi = (function() {
  function ASTApi(config) {
    this.config = config;
  }

  ASTApi.prototype.getNodeName = function(node) {
    var children, name, _ref;
    name = node != null ? (_ref = node.constructor) != null ? _ref.name : void 0 : void 0;
    if (node_children[name]) {
      return name;
    } else {
      for (name in node_children) {
        if (!__hasProp.call(node_children, name)) continue;
        children = node_children[name];
        if (hasChildren(node, children)) {
          return name;
        }
      }
    }
  };

  return ASTApi;

})();

module.exports = ASTLinter = (function(_super) {
  __extends(ASTLinter, _super);

  function ASTLinter(source, config, rules, CoffeeScript) {
    this.CoffeeScript = CoffeeScript;
    ASTLinter.__super__.constructor.call(this, source, config, rules);
    this.astApi = new ASTApi(this.config);
  }

  ASTLinter.prototype.acceptRule = function(rule) {
    return typeof rule.lintAST === 'function';
  };

  ASTLinter.prototype.lint = function() {
    var coffeeError, err, errors, rule, v, _i, _len, _ref;
    errors = [];
    try {
      this.node = this.CoffeeScript.nodes(this.source);
    } catch (_error) {
      coffeeError = _error;
      err = this._parseCoffeeScriptError(coffeeError);
      if (err != null) {
        errors.push(err);
      }
      return errors;
    }
    _ref = this.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rule = _ref[_i];
      this.astApi.createError = (function(_this) {
        return function(attrs) {
          if (attrs == null) {
            attrs = {};
          }
          return _this.createError(rule.rule.name, attrs);
        };
      })(this);
      rule.errors = errors;
      v = this.normalizeResult(rule, rule.lintAST(this.node, this.astApi));
      if (v != null) {
        return v;
      }
    }
    return errors;
  };

  ASTLinter.prototype._parseCoffeeScriptError = function(coffeeError) {
    var attrs, lineNumber, match, message, rule;
    rule = this.config['coffeescript_error'];
    message = coffeeError.toString();
    lineNumber = -1;
    if (coffeeError.location != null) {
      lineNumber = coffeeError.location.first_line + 1;
    } else {
      match = /line (\d+)/.exec(message);
      if ((match != null ? match.length : void 0) > 1) {
        lineNumber = parseInt(match[1], 10);
      }
    }
    attrs = {
      message: message,
      level: rule.level,
      lineNumber: lineNumber
    };
    return this.createError('coffeescript_error', attrs);
  };

  return ASTLinter;

})(BaseLinter);


},{"./base_linter.coffee":3}],3:[function(_dereq_,module,exports){
var BaseLinter, defaults, extend,
  __slice = [].slice;

extend = function() {
  var destination, k, source, sources, v, _i, _len;
  destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = sources.length; _i < _len; _i++) {
    source = sources[_i];
    for (k in source) {
      v = source[k];
      destination[k] = v;
    }
  }
  return destination;
};

defaults = function(source, defaults) {
  return extend({}, defaults, source);
};

module.exports = BaseLinter = (function() {
  function BaseLinter(source, config, rules) {
    this.source = source;
    this.config = config;
    this.setupRules(rules);
  }

  BaseLinter.prototype.isObject = function(obj) {
    return obj === Object(obj);
  };

  BaseLinter.prototype.createError = function(ruleName, attrs) {
    var level;
    if (attrs == null) {
      attrs = {};
    }
    if (attrs.level == null) {
      attrs.level = this.config[ruleName].level;
    }
    level = attrs.level;
    if (level !== 'ignore' && level !== 'warn' && level !== 'error') {
      throw new Error("unknown level " + level);
    }
    if (level === 'error' || level === 'warn') {
      attrs.rule = ruleName;
      return defaults(attrs, this.config[ruleName]);
    } else {
      return null;
    }
  };

  BaseLinter.prototype.acceptRule = function(rule) {
    throw new Error("acceptRule needs to be overridden in the subclass");
  };

  BaseLinter.prototype.setupRules = function(rules) {
    var RuleConstructor, level, name, rule, _results;
    this.rules = [];
    _results = [];
    for (name in rules) {
      RuleConstructor = rules[name];
      level = this.config[name].level;
      if (level === 'error' || level === 'warn') {
        rule = new RuleConstructor(this, this.config);
        if (this.acceptRule(rule)) {
          _results.push(this.rules.push(rule));
        } else {
          _results.push(void 0);
        }
      } else if (level !== 'ignore') {
        throw new Error("unknown level " + level);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  BaseLinter.prototype.normalizeResult = function(p, result) {
    if (result === true) {
      return this.createError(p.rule.name);
    }
    if (this.isObject(result)) {
      return this.createError(p.rule.name, result);
    }
  };

  return BaseLinter;

})();


},{}],4:[function(_dereq_,module,exports){

/*
CoffeeLint

Copyright (c) 2011 Matthew Perpick.
CoffeeLint is freely distributable under the MIT license.
 */
var ASTLinter, CoffeeScript, ERROR, IGNORE, LexicalLinter, LineLinter, RULES, WARN, coffeelint, cs, defaults, difference, extend, hasSyntaxError, mergeDefaultConfig, packageJSON, _rules,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

coffeelint = exports;

if (typeof window !== "undefined" && window !== null) {
  CoffeeScript = window.CoffeeScript;
} else {
  cs = 'coffee-script';
  CoffeeScript = _dereq_(cs);
}

packageJSON = _dereq_('./../package.json');

coffeelint.VERSION = packageJSON.version;

ERROR = 'error';

WARN = 'warn';

IGNORE = 'ignore';

coffeelint.RULES = RULES = _dereq_('./rules.coffee');

extend = function() {
  var destination, k, source, sources, v, _i, _len;
  destination = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = sources.length; _i < _len; _i++) {
    source = sources[_i];
    for (k in source) {
      v = source[k];
      destination[k] = v;
    }
  }
  return destination;
};

defaults = function(source, defaults) {
  return extend({}, defaults, source);
};

difference = function(a, b) {
  var j, _ref, _results;
  j = 0;
  _results = [];
  while (j < a.length) {
    if (_ref = a[j], __indexOf.call(b, _ref) >= 0) {
      _results.push(a.splice(j, 1));
    } else {
      _results.push(j++);
    }
  }
  return _results;
};

LineLinter = _dereq_('./line_linter.coffee');

LexicalLinter = _dereq_('./lexical_linter.coffee');

ASTLinter = _dereq_('./ast_linter.coffee');

mergeDefaultConfig = function(userConfig) {
  var config, rule, ruleConfig;
  config = {};
  for (rule in RULES) {
    ruleConfig = RULES[rule];
    config[rule] = defaults(userConfig[rule], ruleConfig);
  }
  return config;
};

coffeelint.invertLiterate = function(source) {
  var line, newSource, _i, _len, _ref;
  source = CoffeeScript.helpers.invertLiterate(source);
  newSource = "";
  _ref = source.split("\n");
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    line = _ref[_i];
    if (line.match(/^#/)) {
      line = line.replace(/\s*$/, '');
    }
    line = line.replace(/^\s{4}/g, '');
    newSource += "" + line + "\n";
  }
  return newSource;
};

_rules = {};

coffeelint.registerRule = function(RuleConstructor, ruleName) {
  var e, name, p, _ref, _ref1;
  if (ruleName == null) {
    ruleName = void 0;
  }
  p = new RuleConstructor;
  name = (p != null ? (_ref = p.rule) != null ? _ref.name : void 0 : void 0) || "(unknown)";
  e = function(msg) {
    throw new Error("Invalid rule: " + name + " " + msg);
  };
  if (p.rule == null) {
    e("Rules must provide rule attribute with a default configuration.");
  }
  if (p.rule.name == null) {
    e("Rule defaults require a name");
  }
  if ((ruleName != null) && ruleName !== p.rule.name) {
    e("Mismatched rule name: " + ruleName);
  }
  if (p.rule.message == null) {
    e("Rule defaults require a message");
  }
  if (p.rule.description == null) {
    e("Rule defaults require a description");
  }
  if ((_ref1 = p.rule.level) !== 'ignore' && _ref1 !== 'warn' && _ref1 !== 'error') {
    e("Default level must be 'ignore', 'warn', or 'error'");
  }
  if (typeof p.lintToken === 'function') {
    if (!p.tokens) {
      e("'tokens' is required for 'lintToken'");
    }
  } else if (typeof p.lintLine !== 'function' && typeof p.lintAST !== 'function') {
    e("Rules must implement lintToken, lintLine, or lintAST");
  }
  RULES[p.rule.name] = p.rule;
  return _rules[p.rule.name] = RuleConstructor;
};

coffeelint.registerRule(_dereq_('./rules/arrow_spacing.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_tabs.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_trailing_whitespace.coffee'));

coffeelint.registerRule(_dereq_('./rules/max_line_length.coffee'));

coffeelint.registerRule(_dereq_('./rules/line_endings.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_trailing_semicolons.coffee'));

coffeelint.registerRule(_dereq_('./rules/indentation.coffee'));

coffeelint.registerRule(_dereq_('./rules/camel_case_classes.coffee'));

coffeelint.registerRule(_dereq_('./rules/colon_assignment_spacing.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_implicit_braces.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_plusplus.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_throwing_strings.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_backticks.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_implicit_parens.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_empty_param_list.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_stand_alone_at.coffee'));

coffeelint.registerRule(_dereq_('./rules/space_operators.coffee'));

coffeelint.registerRule(_dereq_('./rules/duplicate_key.coffee'));

coffeelint.registerRule(_dereq_('./rules/empty_constructor_needs_parens.coffee'));

coffeelint.registerRule(_dereq_('./rules/cyclomatic_complexity.coffee'));

coffeelint.registerRule(_dereq_('./rules/newlines_after_classes.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_unnecessary_fat_arrows.coffee'));

coffeelint.registerRule(_dereq_('./rules/missing_fat_arrows.coffee'));

coffeelint.registerRule(_dereq_('./rules/non_empty_constructor_needs_parens.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_unnecessary_double_quotes.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_debugger.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_interpolation_in_single_quotes.coffee'));

coffeelint.registerRule(_dereq_('./rules/no_empty_functions.coffee'));

hasSyntaxError = function(source) {
  try {
    CoffeeScript.tokens(source);
    return false;
  } catch (_error) {}
  return true;
};

coffeelint.lint = function(source, userConfig, literate) {
  var all_errors, astErrors, block_config, cmd, config, disabled, disabled_initially, e, errors, i, l, lexErrors, lexicalLinter, lineErrors, lineLinter, next_line, r, rules, s, tokensByLine, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
  if (userConfig == null) {
    userConfig = {};
  }
  if (literate == null) {
    literate = false;
  }
  if (literate) {
    source = this.invertLiterate(source);
  }
  config = mergeDefaultConfig(userConfig);
  disabled_initially = [];
  _ref = source.split('\n');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    l = _ref[_i];
    s = LineLinter.configStatement.exec(l);
    if ((s != null ? s.length : void 0) > 2 && __indexOf.call(s, 'enable') >= 0) {
      _ref1 = s.slice(1);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        r = _ref1[_j];
        if (r !== 'enable' && r !== 'disable') {
          if (!(r in config && ((_ref2 = config[r].level) === 'warn' || _ref2 === 'error'))) {
            disabled_initially.push(r);
            config[r] = {
              level: 'error'
            };
          }
        }
      }
    }
  }
  astErrors = new ASTLinter(source, config, _rules, CoffeeScript).lint();
  errors = [].concat(astErrors);
  if (!hasSyntaxError(source)) {
    lexicalLinter = new LexicalLinter(source, config, _rules, CoffeeScript);
    lexErrors = lexicalLinter.lint();
    errors = errors.concat(lexErrors);
    tokensByLine = lexicalLinter.tokensByLine;
    lineLinter = new LineLinter(source, config, _rules, tokensByLine, literate);
    lineErrors = lineLinter.lint();
    errors = errors.concat(lineErrors);
    block_config = lineLinter.block_config;
  } else {
    block_config = {
      enable: {},
      disable: {}
    };
  }
  errors.sort(function(a, b) {
    return a.lineNumber - b.lineNumber;
  });
  all_errors = errors;
  errors = [];
  disabled = disabled_initially;
  next_line = 0;
  for (i = _k = 0, _ref3 = source.split('\n').length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
    for (cmd in block_config) {
      rules = block_config[cmd][i];
      if (rules != null) {
        ({
          'disable': function() {
            return disabled = disabled.concat(rules);
          },
          'enable': function() {
            difference(disabled, rules);
            if (rules.length === 0) {
              return disabled = disabled_initially;
            }
          }
        })[cmd]();
      }
    }
    while (next_line === i && all_errors.length > 0) {
      next_line = all_errors[0].lineNumber - 1;
      e = all_errors[0];
      if (e.lineNumber === i + 1 || (e.lineNumber == null)) {
        e = all_errors.shift();
        if (_ref4 = e.rule, __indexOf.call(disabled, _ref4) < 0) {
          errors.push(e);
        }
      }
    }
  }
  return errors;
};


},{"./../package.json":1,"./ast_linter.coffee":2,"./lexical_linter.coffee":5,"./line_linter.coffee":6,"./rules.coffee":7,"./rules/arrow_spacing.coffee":8,"./rules/camel_case_classes.coffee":9,"./rules/colon_assignment_spacing.coffee":10,"./rules/cyclomatic_complexity.coffee":11,"./rules/duplicate_key.coffee":12,"./rules/empty_constructor_needs_parens.coffee":13,"./rules/indentation.coffee":14,"./rules/line_endings.coffee":15,"./rules/max_line_length.coffee":16,"./rules/missing_fat_arrows.coffee":17,"./rules/newlines_after_classes.coffee":18,"./rules/no_backticks.coffee":19,"./rules/no_debugger.coffee":20,"./rules/no_empty_functions.coffee":21,"./rules/no_empty_param_list.coffee":22,"./rules/no_implicit_braces.coffee":23,"./rules/no_implicit_parens.coffee":24,"./rules/no_interpolation_in_single_quotes.coffee":25,"./rules/no_plusplus.coffee":26,"./rules/no_stand_alone_at.coffee":27,"./rules/no_tabs.coffee":28,"./rules/no_throwing_strings.coffee":29,"./rules/no_trailing_semicolons.coffee":30,"./rules/no_trailing_whitespace.coffee":31,"./rules/no_unnecessary_double_quotes.coffee":32,"./rules/no_unnecessary_fat_arrows.coffee":33,"./rules/non_empty_constructor_needs_parens.coffee":34,"./rules/space_operators.coffee":35}],5:[function(_dereq_,module,exports){
var BaseLinter, LexicalLinter, TokenApi,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

TokenApi = (function() {
  function TokenApi(CoffeeScript, source, config, tokensByLine) {
    this.config = config;
    this.tokensByLine = tokensByLine;
    this.tokens = CoffeeScript.tokens(source);
    this.lines = source.split('\n');
    this.tokensByLine = {};
  }

  TokenApi.prototype.i = 0;

  TokenApi.prototype.peek = function(n) {
    if (n == null) {
      n = 1;
    }
    return this.tokens[this.i + n] || null;
  };

  return TokenApi;

})();

BaseLinter = _dereq_('./base_linter.coffee');

module.exports = LexicalLinter = (function(_super) {
  __extends(LexicalLinter, _super);

  function LexicalLinter(source, config, rules, CoffeeScript) {
    LexicalLinter.__super__.constructor.call(this, source, config, rules);
    this.tokenApi = new TokenApi(CoffeeScript, source, this.config, this.tokensByLine);
    this.tokensByLine = this.tokenApi.tokensByLine;
  }

  LexicalLinter.prototype.acceptRule = function(rule) {
    return typeof rule.lintToken === 'function';
  };

  LexicalLinter.prototype.lint = function() {
    var error, errors, i, token, _i, _j, _len, _len1, _ref, _ref1;
    errors = [];
    _ref = this.tokenApi.tokens;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      token = _ref[i];
      this.tokenApi.i = i;
      _ref1 = this.lintToken(token);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        error = _ref1[_j];
        errors.push(error);
      }
    }
    return errors;
  };

  LexicalLinter.prototype.lintToken = function(token) {
    var errors, lineNumber, rule, type, v, value, _base, _i, _len, _ref, _ref1;
    type = token[0], value = token[1], lineNumber = token[2];
    if (typeof lineNumber === "object") {
      if (type === 'OUTDENT' || type === 'INDENT') {
        lineNumber = lineNumber.last_line;
      } else {
        lineNumber = lineNumber.first_line;
      }
    }
    if ((_base = this.tokensByLine)[lineNumber] == null) {
      _base[lineNumber] = [];
    }
    this.tokensByLine[lineNumber].push(token);
    this.lineNumber = lineNumber || this.lineNumber || 0;
    this.tokenApi.lineNumber = this.lineNumber;
    errors = [];
    _ref = this.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rule = _ref[_i];
      if (!(_ref1 = token[0], __indexOf.call(rule.tokens, _ref1) >= 0)) {
        continue;
      }
      v = this.normalizeResult(rule, rule.lintToken(token, this.tokenApi));
      if (v != null) {
        errors.push(v);
      }
    }
    return errors;
  };

  LexicalLinter.prototype.createError = function(ruleName, attrs) {
    if (attrs == null) {
      attrs = {};
    }
    attrs.lineNumber = this.lineNumber + 1;
    attrs.line = this.tokenApi.lines[this.lineNumber];
    return LexicalLinter.__super__.createError.call(this, ruleName, attrs);
  };

  return LexicalLinter;

})(BaseLinter);


},{"./base_linter.coffee":3}],6:[function(_dereq_,module,exports){
var BaseLinter, LineApi, LineLinter, configStatement,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

LineApi = (function() {
  function LineApi(source, config, tokensByLine, literate) {
    this.config = config;
    this.tokensByLine = tokensByLine;
    this.literate = literate;
    this.line = null;
    this.lines = source.split('\n');
    this.lineCount = this.lines.length;
    this.context = {
      "class": {
        inClass: false,
        lastUnemptyLineInClass: null,
        classIndents: null
      }
    };
  }

  LineApi.prototype.lineNumber = 0;

  LineApi.prototype.isLiterate = function() {
    return this.literate;
  };

  LineApi.prototype.maintainClassContext = function(line) {
    if (this.context["class"].inClass) {
      if (this.lineHasToken('INDENT')) {
        this.context["class"].classIndents++;
      } else if (this.lineHasToken('OUTDENT')) {
        this.context["class"].classIndents--;
        if (this.context["class"].classIndents === 0) {
          this.context["class"].inClass = false;
          this.context["class"].classIndents = null;
        }
      }
      if (this.context["class"].inClass && !line.match(/^\s*$/)) {
        this.context["class"].lastUnemptyLineInClass = this.lineNumber;
      }
    } else {
      if (!line.match(/\\s*/)) {
        this.context["class"].lastUnemptyLineInClass = null;
      }
      if (this.lineHasToken('CLASS')) {
        this.context["class"].inClass = true;
        this.context["class"].lastUnemptyLineInClass = this.lineNumber;
        this.context["class"].classIndents = 0;
      }
    }
    return null;
  };

  LineApi.prototype.isLastLine = function() {
    return this.lineNumber === this.lineCount - 1;
  };

  LineApi.prototype.lineHasToken = function(tokenType, lineNumber) {
    var token, tokens, _i, _len;
    if (tokenType == null) {
      tokenType = null;
    }
    if (lineNumber == null) {
      lineNumber = null;
    }
    lineNumber = lineNumber != null ? lineNumber : this.lineNumber;
    if (tokenType == null) {
      return this.tokensByLine[lineNumber] != null;
    } else {
      tokens = this.tokensByLine[lineNumber];
      if (tokens == null) {
        return null;
      }
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        token = tokens[_i];
        if (token[0] === tokenType) {
          return true;
        }
      }
      return false;
    }
  };

  LineApi.prototype.getLineTokens = function() {
    return this.tokensByLine[this.lineNumber] || [];
  };

  return LineApi;

})();

BaseLinter = _dereq_('./base_linter.coffee');

configStatement = /coffeelint:\s*(disable|enable)(?:=([\w\s,]*))?/;

module.exports = LineLinter = (function(_super) {
  __extends(LineLinter, _super);

  LineLinter.configStatement = configStatement;

  function LineLinter(source, config, rules, tokensByLine, literate) {
    if (literate == null) {
      literate = false;
    }
    LineLinter.__super__.constructor.call(this, source, config, rules);
    this.lineApi = new LineApi(source, config, tokensByLine, literate);
    this.block_config = {
      enable: {},
      disable: {}
    };
  }

  LineLinter.prototype.acceptRule = function(rule) {
    return typeof rule.lintLine === 'function';
  };

  LineLinter.prototype.lint = function() {
    var error, errors, line, lineNumber, _i, _j, _len, _len1, _ref, _ref1;
    errors = [];
    _ref = this.lineApi.lines;
    for (lineNumber = _i = 0, _len = _ref.length; _i < _len; lineNumber = ++_i) {
      line = _ref[lineNumber];
      this.lineApi.lineNumber = this.lineNumber = lineNumber;
      this.lineApi.maintainClassContext(line);
      this.collectInlineConfig(line);
      _ref1 = this.lintLine(line);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        error = _ref1[_j];
        errors.push(error);
      }
    }
    return errors;
  };

  LineLinter.prototype.lintLine = function(line) {
    var errors, rule, v, _i, _len, _ref;
    errors = [];
    _ref = this.rules;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rule = _ref[_i];
      v = this.normalizeResult(rule, rule.lintLine(line, this.lineApi));
      if (v != null) {
        errors.push(v);
      }
    }
    return errors;
  };

  LineLinter.prototype.collectInlineConfig = function(line) {
    var cmd, r, result, rules, _i, _len, _ref;
    result = configStatement.exec(line);
    if (result != null) {
      cmd = result[1];
      rules = [];
      if (result[2] != null) {
        _ref = result[2].split(',');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          r = _ref[_i];
          rules.push(r.replace(/^\s+|\s+$/g, ""));
        }
      }
      this.block_config[cmd][this.lineNumber] = rules;
    }
    return null;
  };

  LineLinter.prototype.createError = function(rule, attrs) {
    var _ref;
    if (attrs == null) {
      attrs = {};
    }
    attrs.lineNumber = this.lineNumber + 1;
    attrs.level = (_ref = this.config[rule]) != null ? _ref.level : void 0;
    return LineLinter.__super__.createError.call(this, rule, attrs);
  };

  return LineLinter;

})(BaseLinter);


},{"./base_linter.coffee":3}],7:[function(_dereq_,module,exports){
var ERROR, IGNORE, WARN;

ERROR = 'error';

WARN = 'warn';

IGNORE = 'ignore';

module.exports = {
  coffeescript_error: {
    level: ERROR,
    message: ''
  }
};


},{}],8:[function(_dereq_,module,exports){
var ArrowSpacing;

module.exports = ArrowSpacing = (function() {
  function ArrowSpacing() {}

  ArrowSpacing.prototype.rule = {
    name: 'arrow_spacing',
    level: 'ignore',
    message: 'Function arrow (->) must be spaced properly',
    description: "<p>This rule checks to see that there is spacing before and after\nthe arrow operator that declares a function. This rule is disabled\nby default.</p> <p>Note that if arrow_spacing is enabled, and you\npass an empty function as a parameter, arrow_spacing will accept\neither a space or no space in-between the arrow operator and the\nparenthesis</p>\n<pre><code># Both of this will not trigger an error,\n# even with arrow_spacing enabled.\nx(-> 3)\nx( -> 3)\n\n# However, this will trigger an error\nx((a,b)-> 3)\n</code>\n</pre>"
  };

  ArrowSpacing.prototype.tokens = ['->'];

  ArrowSpacing.prototype.lintToken = function(token, tokenApi) {
    var pp;
    pp = tokenApi.peek(-1);
    if (!(((token.spaced != null) || (token.newLine != null) || this.atEof(tokenApi)) && (((pp.spaced != null) || pp[0] === 'TERMINATOR') || (pp.generated != null) || pp[0] === "INDENT" || (pp[1] === "(" && (pp.generated == null))))) {
      return true;
    } else {
      return null;
    }
  };

  ArrowSpacing.prototype.atEof = function(tokenApi) {
    var i, token, tokens, _i, _len, _ref, _ref1;
    tokens = tokenApi.tokens, i = tokenApi.i;
    _ref = tokens.slice(i + 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      token = _ref[_i];
      if (!(token.generated || ((_ref1 = token[0]) === 'OUTDENT' || _ref1 === 'TERMINATOR'))) {
        return false;
      }
    }
    return true;
  };

  return ArrowSpacing;

})();


},{}],9:[function(_dereq_,module,exports){
var CamelCaseClasses, regexes;

regexes = {
  camelCase: /^[A-Z][a-zA-Z\d]*$/
};

module.exports = CamelCaseClasses = (function() {
  function CamelCaseClasses() {}

  CamelCaseClasses.prototype.rule = {
    name: 'camel_case_classes',
    level: 'error',
    message: 'Class names should be camel cased',
    description: "This rule mandates that all class names are CamelCased. Camel\ncasing class names is a generally accepted way of distinguishing\nconstructor functions - which require the 'new' prefix to behave\nproperly - from plain old functions.\n<pre>\n<code># Good!\nclass BoaConstrictor\n\n# Bad!\nclass boaConstrictor\n</code>\n</pre>\nThis rule is enabled by default."
  };

  CamelCaseClasses.prototype.tokens = ['CLASS'];

  CamelCaseClasses.prototype.lintToken = function(token, tokenApi) {
    var className, offset, _ref, _ref1, _ref2;
    if ((token.newLine != null) || ((_ref = tokenApi.peek()[0]) === 'INDENT' || _ref === 'EXTENDS')) {
      return null;
    }
    className = null;
    offset = 1;
    while (!className) {
      if (((_ref1 = tokenApi.peek(offset + 1)) != null ? _ref1[0] : void 0) === '.') {
        offset += 2;
      } else if (((_ref2 = tokenApi.peek(offset)) != null ? _ref2[0] : void 0) === '@') {
        offset += 1;
      } else {
        className = tokenApi.peek(offset)[1];
      }
    }
    if (!regexes.camelCase.test(className)) {
      return {
        context: "class name: " + className
      };
    }
  };

  return CamelCaseClasses;

})();


},{}],10:[function(_dereq_,module,exports){
var ColonAssignmentSpacing;

module.exports = ColonAssignmentSpacing = (function() {
  function ColonAssignmentSpacing() {}

  ColonAssignmentSpacing.prototype.rule = {
    name: 'colon_assignment_spacing',
    level: 'ignore',
    message: 'Colon assignment without proper spacing',
    spacing: {
      left: 0,
      right: 0
    },
    description: "<p>This rule checks to see that there is spacing before and\nafter the colon in a colon assignment (i.e., classes, objects).\nThe spacing amount is specified by\nspacing.left and spacing.right, respectively.\nA zero value means no spacing required.\n</p>\n<pre><code>\n#\n# If spacing.left and spacing.right is 1\n#\n\n# Good\nobject = {spacing : true}\nclass Dog\n  canBark : true\n\n# Bad\nobject = {spacing: true}\nclass Cat\n  canBark: false\n</code></pre>"
  };

  ColonAssignmentSpacing.prototype.tokens = [':'];

  ColonAssignmentSpacing.prototype.lintToken = function(token, tokenApi) {
    var checkSpacing, getSpaceFromToken, isLeftSpaced, isRightSpaced, leftSpacing, nextToken, previousToken, rightSpacing, spacingAllowances, _ref, _ref1;
    spacingAllowances = tokenApi.config[this.rule.name].spacing;
    previousToken = tokenApi.peek(-1);
    nextToken = tokenApi.peek(1);
    getSpaceFromToken = function(direction) {
      switch (direction) {
        case 'left':
          return token[2].first_column - previousToken[2].last_column - 1;
        case 'right':
          return nextToken[2].first_column - token[2].first_column - 1;
      }
    };
    checkSpacing = function(direction) {
      var isSpaced, spacing;
      spacing = getSpaceFromToken(direction);
      isSpaced = spacing < 0 ? true : spacing === parseInt(spacingAllowances[direction]);
      return [isSpaced, spacing];
    };
    _ref = checkSpacing('left'), isLeftSpaced = _ref[0], leftSpacing = _ref[1];
    _ref1 = checkSpacing('right'), isRightSpaced = _ref1[0], rightSpacing = _ref1[1];
    if (isLeftSpaced && isRightSpaced) {
      return null;
    } else {
      return {
        context: "Incorrect spacing around column " + token[2].first_column + ".\nExpected left: " + spacingAllowances.left + ", right: " + spacingAllowances.right + ".\nGot left: " + leftSpacing + ", right: " + rightSpacing + "."
      };
    }
  };

  return ColonAssignmentSpacing;

})();


},{}],11:[function(_dereq_,module,exports){
var NoTabs;

module.exports = NoTabs = (function() {
  function NoTabs() {}

  NoTabs.prototype.rule = {
    name: 'cyclomatic_complexity',
    value: 10,
    level: 'ignore',
    message: 'The cyclomatic complexity is too damn high',
    description: 'Examine the complexity of your application.'
  };

  NoTabs.prototype.getComplexity = function(node) {
    var complexity, name, _ref;
    name = this.astApi.getNodeName(node);
    complexity = name === 'If' || name === 'While' || name === 'For' || name === 'Try' ? 1 : name === 'Op' && ((_ref = node.operator) === '&&' || _ref === '||') ? 1 : name === 'Switch' ? node.cases.length : 0;
    return complexity;
  };

  NoTabs.prototype.lintAST = function(node, astApi) {
    this.astApi = astApi;
    this.lintNode(node);
    return void 0;
  };

  NoTabs.prototype.lintNode = function(node, line) {
    var complexity, error, name, rule, _ref;
    name = (_ref = this.astApi) != null ? _ref.getNodeName(node) : void 0;
    complexity = this.getComplexity(node);
    node.eachChild((function(_this) {
      return function(childNode) {
        var nodeLine;
        nodeLine = childNode.locationData.first_line;
        if (childNode) {
          return complexity += _this.lintNode(childNode, nodeLine);
        }
      };
    })(this));
    rule = this.astApi.config[this.rule.name];
    if (name === 'Code' && complexity >= rule.value) {
      error = this.astApi.createError({
        context: complexity + 1,
        lineNumber: line + 1,
        lineNumberEnd: node.locationData.last_line + 1
      });
      if (error) {
        this.errors.push(error);
      }
    }
    return complexity;
  };

  return NoTabs;

})();


},{}],12:[function(_dereq_,module,exports){
var DuplicateKey;

module.exports = DuplicateKey = (function() {
  DuplicateKey.prototype.rule = {
    name: 'duplicate_key',
    level: 'error',
    message: 'Duplicate key defined in object or class',
    description: "Prevents defining duplicate keys in object literals and classes"
  };

  DuplicateKey.prototype.tokens = ['IDENTIFIER', "{", "}"];

  function DuplicateKey() {
    this.braceScopes = [];
  }

  DuplicateKey.prototype.lintToken = function(_arg, tokenApi) {
    var type;
    type = _arg[0];
    if (type === "{" || type === "}") {
      this.lintBrace.apply(this, arguments);
      return void 0;
    }
    if (type === "IDENTIFIER") {
      return this.lintIdentifier.apply(this, arguments);
    }
  };

  DuplicateKey.prototype.lintIdentifier = function(token, tokenApi) {
    var key, nextToken, previousToken;
    key = token[1];
    if (this.currentScope == null) {
      return null;
    }
    nextToken = tokenApi.peek(1);
    if (nextToken[1] !== ':') {
      return null;
    }
    previousToken = tokenApi.peek(-1);
    if (previousToken[0] === '@') {
      key = "@" + key;
    }
    key = "identifier-" + key;
    if (this.currentScope[key]) {
      return true;
    } else {
      this.currentScope[key] = token;
      return null;
    }
  };

  DuplicateKey.prototype.lintBrace = function(token) {
    if (token[0] === '{') {
      if (this.currentScope != null) {
        this.braceScopes.push(this.currentScope);
      }
      this.currentScope = {};
    } else {
      this.currentScope = this.braceScopes.pop();
    }
    return null;
  };

  return DuplicateKey;

})();


},{}],13:[function(_dereq_,module,exports){
var EmptyConstructorNeedsParens;

module.exports = EmptyConstructorNeedsParens = (function() {
  function EmptyConstructorNeedsParens() {}

  EmptyConstructorNeedsParens.prototype.rule = {
    name: 'empty_constructor_needs_parens',
    level: 'ignore',
    message: 'Invoking a constructor without parens and without arguments',
    description: "Requires constructors with no parameters to include the parens"
  };

  EmptyConstructorNeedsParens.prototype.tokens = ['UNARY'];

  EmptyConstructorNeedsParens.prototype.lintToken = function(token, tokenApi) {
    var expectedCallStart, expectedIdentifier, identifierIndex;
    if (token[1] === 'new') {
      identifierIndex = 1;
      while (true) {
        expectedIdentifier = tokenApi.peek(identifierIndex);
        expectedCallStart = tokenApi.peek(identifierIndex + 1);
        if ((expectedIdentifier != null ? expectedIdentifier[0] : void 0) === 'IDENTIFIER') {
          if ((expectedCallStart != null ? expectedCallStart[0] : void 0) === '.') {
            identifierIndex += 2;
            continue;
          }
        }
        break;
      }
      if ((expectedIdentifier != null ? expectedIdentifier[0] : void 0) === 'IDENTIFIER' && (expectedCallStart != null)) {
        return this.handleExpectedCallStart(expectedCallStart);
      }
    }
  };

  EmptyConstructorNeedsParens.prototype.handleExpectedCallStart = function(expectedCallStart) {
    if (expectedCallStart[0] !== 'CALL_START') {
      return true;
    }
  };

  return EmptyConstructorNeedsParens;

})();


},{}],14:[function(_dereq_,module,exports){
var Indentation;

module.exports = Indentation = (function() {
  Indentation.prototype.rule = {
    name: 'indentation',
    value: 2,
    level: 'error',
    message: 'Line contains inconsistent indentation',
    description: "This rule imposes a standard number of spaces to be used for\nindentation. Since whitespace is significant in CoffeeScript, it's\ncritical that a project chooses a standard indentation format and\nstays consistent. Other roads lead to darkness. <pre> <code>#\nEnabling this option will prevent this ugly\n# but otherwise valid CoffeeScript.\ntwoSpaces = () ->\n  fourSpaces = () ->\n      eightSpaces = () ->\n            'this is valid CoffeeScript'\n\n</code>\n</pre>\nTwo space indentation is enabled by default."
  };

  Indentation.prototype.tokens = ['INDENT', "[", "]"];

  function Indentation() {
    this.arrayTokens = [];
  }

  Indentation.prototype.lintToken = function(token, tokenApi) {
    var currentLine, expected, ignoreIndent, isArrayIndent, isInterpIndent, isMultiline, lineNumber, lines, numIndents, prevNum, previous, previousIndentation, previousLine, previousSymbol, type, _ref;
    type = token[0], numIndents = token[1], lineNumber = token[2];
    if (type === "[" || type === "]") {
      this.lintArray(token);
      return void 0;
    }
    if (token.generated != null) {
      return null;
    }
    previous = tokenApi.peek(-2);
    isInterpIndent = previous && previous[0] === '+';
    previous = tokenApi.peek(-1);
    isArrayIndent = this.inArray() && (previous != null ? previous.newLine : void 0);
    previousSymbol = (_ref = tokenApi.peek(-1)) != null ? _ref[0] : void 0;
    isMultiline = previousSymbol === '=' || previousSymbol === ',';
    ignoreIndent = isInterpIndent || isArrayIndent || isMultiline;
    if (this.isChainedCall(tokenApi)) {
      lines = tokenApi.lines, lineNumber = tokenApi.lineNumber;
      currentLine = lines[lineNumber];
      prevNum = 1;
      while (/^\s*(#|$)/.test(lines[lineNumber - prevNum])) {
        prevNum += 1;
      }
      previousLine = lines[lineNumber - prevNum];
      previousIndentation = previousLine.match(/^(\s*)/)[1].length;
      numIndents = currentLine.match(/^(\s*)/)[1].length;
      numIndents -= previousIndentation;
    }
    expected = tokenApi.config[this.rule.name].value;
    if (!ignoreIndent && numIndents !== expected) {
      return {
        context: "Expected " + expected + " got " + numIndents
      };
    }
  };

  Indentation.prototype.inArray = function() {
    return this.arrayTokens.length > 0;
  };

  Indentation.prototype.lintArray = function(token) {
    if (token[0] === '[') {
      this.arrayTokens.push(token);
    } else if (token[0] === ']') {
      this.arrayTokens.pop();
    }
    return null;
  };

  Indentation.prototype.isChainedCall = function(tokenApi) {
    var i, lastNewLineIndex, lines, t, token, tokens;
    tokens = tokenApi.tokens, i = tokenApi.i;
    lines = (function() {
      var _i, _len, _ref, _results;
      _ref = tokens.slice(0, +i + 1 || 9e9);
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        token = _ref[i];
        if (token.newLine != null) {
          _results.push(i);
        }
      }
      return _results;
    })();
    lastNewLineIndex = lines ? lines[lines.length - 2] : null;
    if (lastNewLineIndex == null) {
      return false;
    }
    tokens = [tokens[lastNewLineIndex], tokens[lastNewLineIndex + 1]];
    return !!((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = tokens.length; _i < _len; _i++) {
        t = tokens[_i];
        if (t && t[0] === '.') {
          _results.push(t);
        }
      }
      return _results;
    })()).length;
  };

  return Indentation;

})();


},{}],15:[function(_dereq_,module,exports){
var LineEndings;

module.exports = LineEndings = (function() {
  function LineEndings() {}

  LineEndings.prototype.rule = {
    name: 'line_endings',
    level: 'ignore',
    value: 'unix',
    message: 'Line contains incorrect line endings',
    description: "This rule ensures your project uses only <tt>windows</tt> or\n<tt>unix</tt> line endings. This rule is disabled by default."
  };

  LineEndings.prototype.lintLine = function(line, lineApi) {
    var ending, lastChar, valid, _ref;
    ending = (_ref = lineApi.config[this.rule.name]) != null ? _ref.value : void 0;
    if (!ending || lineApi.isLastLine() || !line) {
      return null;
    }
    lastChar = line[line.length - 1];
    valid = (function() {
      if (ending === 'windows') {
        return lastChar === '\r';
      } else if (ending === 'unix') {
        return lastChar !== '\r';
      } else {
        throw new Error("unknown line ending type: " + ending);
      }
    })();
    if (!valid) {
      return {
        context: "Expected " + ending
      };
    } else {
      return null;
    }
  };

  return LineEndings;

})();


},{}],16:[function(_dereq_,module,exports){
var MaxLineLength, regexes;

regexes = {
  literateComment: /^\#\s/,
  longUrlComment: /^\s*\#\s*http[^\s]+$/
};

module.exports = MaxLineLength = (function() {
  function MaxLineLength() {}

  MaxLineLength.prototype.rule = {
    name: 'max_line_length',
    value: 80,
    level: 'error',
    limitComments: true,
    message: 'Line exceeds maximum allowed length',
    description: "This rule imposes a maximum line length on your code. <a\nhref=\"http://www.python.org/dev/peps/pep-0008/\">Python's style\nguide</a> does a good job explaining why you might want to limit the\nlength of your lines, though this is a matter of taste.\n\nLines can be no longer than eighty characters by default."
  };

  MaxLineLength.prototype.lintLine = function(line, lineApi) {
    var limitComments, lineLength, max, _ref, _ref1;
    max = (_ref = lineApi.config[this.rule.name]) != null ? _ref.value : void 0;
    limitComments = (_ref1 = lineApi.config[this.rule.name]) != null ? _ref1.limitComments : void 0;
    lineLength = line.trimRight().length;
    if (lineApi.isLiterate() && regexes.literateComment.test(line)) {
      lineLength -= 2;
    }
    if (max && max < lineLength && !regexes.longUrlComment.test(line)) {
      if (!limitComments) {
        if (lineApi.getLineTokens().length === 0) {
          return;
        }
      }
      return {
        context: "Length is " + lineLength + ", max is " + max
      };
    }
  };

  return MaxLineLength;

})();


},{}],17:[function(_dereq_,module,exports){
var MissingFatArrows, any,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

any = function(arr, test) {
  return arr.reduce((function(res, elt) {
    return res || test(elt);
  }), false);
};

module.exports = MissingFatArrows = (function() {
  function MissingFatArrows() {
    this.isFatArrowCode = __bind(this.isFatArrowCode, this);
    this.isThis = __bind(this.isThis, this);
    this.isObject = __bind(this.isObject, this);
    this.isValue = __bind(this.isValue, this);
    this.isClass = __bind(this.isClass, this);
    this.isCode = __bind(this.isCode, this);
  }

  MissingFatArrows.prototype.rule = {
    name: 'missing_fat_arrows',
    level: 'ignore',
    message: 'Used `this` in a function without a fat arrow',
    description: "Warns when you use `this` inside a function that wasn't defined\nwith a fat arrow. This rule does not apply to methods defined in a\nclass, since they have `this` bound to the class instance (or the\nclass itself, for class methods).\n\nIt is impossible to statically determine whether a function using\n`this` will be bound with the correct `this` value due to language\nfeatures like `Function.prototype.call` and\n`Function.prototype.bind`, so this rule may produce false positives."
  };

  MissingFatArrows.prototype.lintAST = function(node, astApi) {
    this.astApi = astApi;
    this.lintNode(node);
    return void 0;
  };

  MissingFatArrows.prototype.lintNode = function(node, methods) {
    var error;
    if (methods == null) {
      methods = [];
    }
    if ((!this.isFatArrowCode(node)) && (__indexOf.call(methods, node) < 0) && (this.needsFatArrow(node))) {
      error = this.astApi.createError({
        lineNumber: node.locationData.first_line + 1
      });
      this.errors.push(error);
    }
    return node.eachChild((function(_this) {
      return function(child) {
        return _this.lintNode(child, (function() {
          switch (false) {
            case !this.isClass(node):
              return this.methodsOfClass(node);
            case !this.isCode(node):
              return [];
            default:
              return methods;
          }
        }).call(_this));
      };
    })(this));
  };

  MissingFatArrows.prototype.isCode = function(node) {
    return this.astApi.getNodeName(node) === 'Code';
  };

  MissingFatArrows.prototype.isClass = function(node) {
    return this.astApi.getNodeName(node) === 'Class';
  };

  MissingFatArrows.prototype.isValue = function(node) {
    return this.astApi.getNodeName(node) === 'Value';
  };

  MissingFatArrows.prototype.isObject = function(node) {
    return this.astApi.getNodeName(node) === 'Obj';
  };

  MissingFatArrows.prototype.isThis = function(node) {
    return this.isValue(node) && node.base.value === 'this';
  };

  MissingFatArrows.prototype.isFatArrowCode = function(node) {
    return this.isCode(node) && node.bound;
  };

  MissingFatArrows.prototype.needsFatArrow = function(node) {
    return this.isCode(node) && (any(node.params, (function(_this) {
      return function(param) {
        return param.contains(_this.isThis) != null;
      };
    })(this)) || (node.body.contains(this.isThis) != null));
  };

  MissingFatArrows.prototype.methodsOfClass = function(classNode) {
    var bodyNodes, returnNode;
    bodyNodes = classNode.body.expressions;
    returnNode = bodyNodes[bodyNodes.length - 1];
    if ((returnNode != null) && this.isValue(returnNode) && this.isObject(returnNode.base)) {
      return returnNode.base.properties.map(function(assignNode) {
        return assignNode.value;
      }).filter(this.isCode);
    } else {
      return [];
    }
  };

  return MissingFatArrows;

})();


},{}],18:[function(_dereq_,module,exports){
var NewlinesAfterClasses;

module.exports = NewlinesAfterClasses = (function() {
  function NewlinesAfterClasses() {}

  NewlinesAfterClasses.prototype.rule = {
    name: 'newlines_after_classes',
    value: 3,
    level: 'ignore',
    message: 'Wrong count of newlines between a class and other code',
    description: "Checks the number of newlines between classes and other code"
  };

  NewlinesAfterClasses.prototype.lintLine = function(line, lineApi) {
    var context, ending, got, lineNumber;
    ending = lineApi.config[this.rule.name].value;
    if (!ending || lineApi.isLastLine()) {
      return null;
    }
    lineNumber = lineApi.lineNumber, context = lineApi.context;
    if (!context["class"].inClass && (context["class"].lastUnemptyLineInClass != null) && (lineNumber - context["class"].lastUnemptyLineInClass) !== ending) {
      got = lineNumber - context["class"].lastUnemptyLineInClass;
      return {
        context: "Expected " + ending + " got " + got
      };
    }
    return null;
  };

  return NewlinesAfterClasses;

})();


},{}],19:[function(_dereq_,module,exports){
var NoBackticks;

module.exports = NoBackticks = (function() {
  function NoBackticks() {}

  NoBackticks.prototype.rule = {
    name: 'no_backticks',
    level: 'error',
    message: 'Backticks are forbidden',
    description: "Backticks allow snippets of JavaScript to be embedded in\nCoffeeScript. While some folks consider backticks useful in a few\nniche circumstances, they should be avoided because so none of\nJavaScript's \"bad parts\", like <tt>with</tt> and <tt>eval</tt>,\nsneak into CoffeeScript.\nThis rule is enabled by default."
  };

  NoBackticks.prototype.tokens = ["JS"];

  NoBackticks.prototype.lintToken = function(token, tokenApi) {
    return true;
  };

  return NoBackticks;

})();


},{}],20:[function(_dereq_,module,exports){
var NoDebugger;

module.exports = NoDebugger = (function() {
  function NoDebugger() {}

  NoDebugger.prototype.rule = {
    name: 'no_debugger',
    level: 'warn',
    message: 'Debugger statements will cause warnings',
    description: "This rule detects the `debugger` statement.\nThis rule is `warn` by default."
  };

  NoDebugger.prototype.tokens = ["DEBUGGER"];

  NoDebugger.prototype.lintToken = function(token, tokenApi) {
    return {
      context: "found '" + token[0] + "'"
    };
  };

  return NoDebugger;

})();


},{}],21:[function(_dereq_,module,exports){
var NoEmptyFunctions, isEmptyCode;

isEmptyCode = function(node, astApi) {
  var nodeName;
  nodeName = astApi.getNodeName(node);
  return nodeName === 'Code' && node.body.isEmpty();
};

module.exports = NoEmptyFunctions = (function() {
  function NoEmptyFunctions() {}

  NoEmptyFunctions.prototype.rule = {
    name: 'no_empty_functions',
    level: 'ignore',
    message: 'Empty function',
    description: "Disallows declaring empty functions. The goal of this rule is that\nunintentional empty callbacks can be detected:\n<pre>\n<code>someFunctionWithCallback ->\ndoSomethingSignificant()\n</code>\n</pre>\nThe problem is that the call to\n<tt>doSomethingSignificant</tt> will be made regardless\nof <tt>someFunctionWithCallback</tt>'s execution. It can\nbe because you did not indent the call to\n<tt>doSomethingSignificant</tt> properly.\n\nIf you really meant that <tt>someFunctionWithCallback</tt>\nshould call a callback that does nothing, you can write your code\nthis way:\n<pre>\n<code>someFunctionWithCallback ->\n    undefined\ndoSomethingSignificant()\n</code>\n</pre>"
  };

  NoEmptyFunctions.prototype.lintAST = function(node, astApi) {
    this.lintNode(node, astApi);
    return void 0;
  };

  NoEmptyFunctions.prototype.lintNode = function(node, astApi) {
    var error;
    if (isEmptyCode(node, astApi)) {
      error = astApi.createError({
        lineNumber: node.locationData.first_line + 1
      });
      this.errors.push(error);
    }
    return node.eachChild((function(_this) {
      return function(child) {
        return _this.lintNode(child, astApi);
      };
    })(this));
  };

  return NoEmptyFunctions;

})();


},{}],22:[function(_dereq_,module,exports){
var NoEmptyParamList;

module.exports = NoEmptyParamList = (function() {
  function NoEmptyParamList() {}

  NoEmptyParamList.prototype.rule = {
    name: 'no_empty_param_list',
    level: 'ignore',
    message: 'Empty parameter list is forbidden',
    description: "This rule prohibits empty parameter lists in function definitions.\n<pre>\n<code># The empty parameter list in here is unnecessary:\nmyFunction = () -&gt;\n\n# We might favor this instead:\nmyFunction = -&gt;\n</code>\n</pre>\nEmpty parameter lists are permitted by default."
  };

  NoEmptyParamList.prototype.tokens = ["PARAM_START"];

  NoEmptyParamList.prototype.lintToken = function(token, tokenApi) {
    var nextType;
    nextType = tokenApi.peek()[0];
    return nextType === 'PARAM_END';
  };

  return NoEmptyParamList;

})();


},{}],23:[function(_dereq_,module,exports){
var NoImplicitBraces;

module.exports = NoImplicitBraces = (function() {
  function NoImplicitBraces() {}

  NoImplicitBraces.prototype.rule = {
    name: 'no_implicit_braces',
    level: 'ignore',
    message: 'Implicit braces are forbidden',
    strict: true,
    description: "This rule prohibits implicit braces when declaring object literals.\nImplicit braces can make code more difficult to understand,\nespecially when used in combination with optional parenthesis.\n<pre>\n<code># Do you find this code ambiguous? Is it a\n# function call with three arguments or four?\nmyFunction a, b, 1:2, 3:4\n\n# While the same code written in a more\n# explicit manner has no ambiguity.\nmyFunction(a, b, {1:2, 3:4})\n</code>\n</pre>\nImplicit braces are permitted by default, since their use is\nidiomatic CoffeeScript."
  };

  NoImplicitBraces.prototype.tokens = ["{"];

  NoImplicitBraces.prototype.lintToken = function(token, tokenApi) {
    var previousToken;
    if (token.generated) {
      if (!tokenApi.config[this.rule.name].strict) {
        previousToken = tokenApi.peek(-1)[0];
        if (previousToken === 'INDENT') {
          return;
        }
      }
      return this.isPartOfClass(tokenApi);
    }
  };

  NoImplicitBraces.prototype.isPartOfClass = function(tokenApi) {
    var i, t;
    i = -1;
    while (true) {
      t = tokenApi.peek(i);
      if ((t == null) || t[0] === 'TERMINATOR') {
        return true;
      }
      if (t[0] === 'CLASS') {
        return null;
      }
      i -= 1;
    }
  };

  return NoImplicitBraces;

})();


},{}],24:[function(_dereq_,module,exports){
var NoImplicitParens;

module.exports = NoImplicitParens = (function() {
  function NoImplicitParens() {}

  NoImplicitParens.prototype.rule = {
    name: 'no_implicit_parens',
    strict: true,
    level: 'ignore',
    message: 'Implicit parens are forbidden',
    description: "This rule prohibits implicit parens on function calls.\n<pre>\n<code># Some folks don't like this style of coding.\nmyFunction a, b, c\n\n# And would rather it always be written like this:\nmyFunction(a, b, c)\n</code>\n</pre>\nImplicit parens are permitted by default, since their use is\nidiomatic CoffeeScript."
  };

  NoImplicitParens.prototype.tokens = ["CALL_END"];

  NoImplicitParens.prototype.lintToken = function(token, tokenApi) {
    var i, t;
    if (token.generated) {
      if (tokenApi.config[this.rule.name].strict !== false) {
        return true;
      } else {
        i = -1;
        while (true) {
          t = tokenApi.peek(i);
          if ((t == null) || t[0] === 'CALL_START') {
            return true;
          }
          if (t.newLine) {
            return null;
          }
          i -= 1;
        }
      }
    }
  };

  return NoImplicitParens;

})();


},{}],25:[function(_dereq_,module,exports){
var NoInterpolationInSingleQuotes;

module.exports = NoInterpolationInSingleQuotes = (function() {
  function NoInterpolationInSingleQuotes() {}

  NoInterpolationInSingleQuotes.prototype.rule = {
    name: 'no_interpolation_in_single_quotes',
    level: 'ignore',
    message: 'Interpolation in single quoted strings is forbidden',
    description: 'This rule prohibits string interpolation in a single quoted string.\n<pre>\n<code># String interpolation in single quotes is not allowed:\nfoo = \'#{bar}\'\n\n# Double quotes is OK of course\nfoo = "#{bar}"\n</code>\n</pre>\nString interpolation in single quoted strings is permitted by \ndefault.'
  };

  NoInterpolationInSingleQuotes.prototype.tokens = ['STRING'];

  NoInterpolationInSingleQuotes.prototype.lintToken = function(token, tokenApi) {
    var hasInterpolation, tokenValue;
    tokenValue = token[1];
    hasInterpolation = tokenValue.match(/#\{[^}]+\}/);
    return hasInterpolation;
  };

  return NoInterpolationInSingleQuotes;

})();


},{}],26:[function(_dereq_,module,exports){
var NoPlusPlus;

module.exports = NoPlusPlus = (function() {
  function NoPlusPlus() {}

  NoPlusPlus.prototype.rule = {
    name: 'no_plusplus',
    level: 'ignore',
    message: 'The increment and decrement operators are forbidden',
    description: "This rule forbids the increment and decrement arithmetic operators.\nSome people believe the <tt>++</tt> and <tt>--</tt> to be cryptic\nand the cause of bugs due to misunderstandings of their precedence\nrules.\nThis rule is disabled by default."
  };

  NoPlusPlus.prototype.tokens = ["++", "--"];

  NoPlusPlus.prototype.lintToken = function(token, tokenApi) {
    return {
      context: "found '" + token[0] + "'"
    };
  };

  return NoPlusPlus;

})();


},{}],27:[function(_dereq_,module,exports){
var NoStandAloneAt;

module.exports = NoStandAloneAt = (function() {
  function NoStandAloneAt() {}

  NoStandAloneAt.prototype.rule = {
    name: 'no_stand_alone_at',
    level: 'ignore',
    message: '@ must not be used stand alone',
    description: "This rule checks that no stand alone @ are in use, they are\ndiscouraged. Further information in CoffeScript issue <a\nhref=\"https://github.com/jashkenas/coffee-script/issues/1601\">\n#1601</a>"
  };

  NoStandAloneAt.prototype.tokens = ["@"];

  NoStandAloneAt.prototype.lintToken = function(token, tokenApi) {
    var isDot, isIdentifier, isIndexStart, isValidProtoProperty, nextToken, protoProperty, spaced;
    nextToken = tokenApi.peek();
    spaced = token.spaced;
    isIdentifier = nextToken[0] === 'IDENTIFIER';
    isIndexStart = nextToken[0] === 'INDEX_START';
    isDot = nextToken[0] === '.';
    if (nextToken[0] === '::') {
      protoProperty = tokenApi.peek(2);
      isValidProtoProperty = protoProperty[0] === 'IDENTIFIER';
    }
    if (spaced || (!isIdentifier && !isIndexStart && !isDot && !isValidProtoProperty)) {
      return true;
    }
  };

  return NoStandAloneAt;

})();


},{}],28:[function(_dereq_,module,exports){
var NoTabs, indentationRegex,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

indentationRegex = /\S/;

module.exports = NoTabs = (function() {
  function NoTabs() {}

  NoTabs.prototype.rule = {
    name: 'no_tabs',
    level: 'error',
    message: 'Line contains tab indentation',
    description: "This rule forbids tabs in indentation. Enough said. It is enabled by\ndefault."
  };

  NoTabs.prototype.lintLine = function(line, lineApi) {
    var indentation;
    indentation = line.split(indentationRegex)[0];
    if (lineApi.lineHasToken() && __indexOf.call(indentation, '\t') >= 0) {
      return true;
    } else {
      return null;
    }
  };

  return NoTabs;

})();


},{}],29:[function(_dereq_,module,exports){
var NoThrowingStrings;

module.exports = NoThrowingStrings = (function() {
  function NoThrowingStrings() {}

  NoThrowingStrings.prototype.rule = {
    name: 'no_throwing_strings',
    level: 'error',
    message: 'Throwing strings is forbidden',
    description: "This rule forbids throwing string literals or interpolations. While\nJavaScript (and CoffeeScript by extension) allow any expression to\nbe thrown, it is best to only throw <a\nhref=\"https://developer.mozilla.org\n/en/JavaScript/Reference/Global_Objects/Error\"> Error</a> objects,\nbecause they contain valuable debugging information like the stack\ntrace. Because of JavaScript's dynamic nature, CoffeeLint cannot\nensure you are always throwing instances of <tt>Error</tt>. It will\nonly catch the simple but real case of throwing literal strings.\n<pre>\n<code># CoffeeLint will catch this:\nthrow \"i made a boo boo\"\n\n# ... but not this:\nthrow getSomeString()\n</code>\n</pre>\nThis rule is enabled by default."
  };

  NoThrowingStrings.prototype.tokens = ["THROW"];

  NoThrowingStrings.prototype.lintToken = function(token, tokenApi) {
    var n1, n2, nextIsString, _ref;
    _ref = [tokenApi.peek(), tokenApi.peek(2)], n1 = _ref[0], n2 = _ref[1];
    nextIsString = n1[0] === 'STRING' || (n1[0] === '(' && n2[0] === 'STRING');
    return nextIsString;
  };

  return NoThrowingStrings;

})();


},{}],30:[function(_dereq_,module,exports){
var NoTrailingSemicolons, regexes,
  __slice = [].slice;

regexes = {
  trailingSemicolon: /;\r?$/
};

module.exports = NoTrailingSemicolons = (function() {
  function NoTrailingSemicolons() {}

  NoTrailingSemicolons.prototype.rule = {
    name: 'no_trailing_semicolons',
    level: 'error',
    message: 'Line contains a trailing semicolon',
    description: "This rule prohibits trailing semicolons, since they are needless\ncruft in CoffeeScript.\n<pre>\n<code># This semicolon is meaningful.\nx = '1234'; console.log(x)\n\n# This semicolon is redundant.\nalert('end of line');\n</code>\n</pre>\nTrailing semicolons are forbidden by default."
  };

  NoTrailingSemicolons.prototype.lintLine = function(line, lineApi) {
    var endPos, first, hasNewLine, hasSemicolon, last, lineTokens, newLine, startCounter, startPos, _i, _ref;
    lineTokens = lineApi.getLineTokens();
    if (lineTokens.length === 1 && ((_ref = lineTokens[0][0]) === 'TERMINATOR' || _ref === 'HERECOMMENT')) {
      return;
    }
    newLine = line;
    if (lineTokens.length > 1 && lineTokens[lineTokens.length - 1][0] === 'TERMINATOR') {
      startPos = lineTokens[lineTokens.length - 2][2].last_column + 1;
      endPos = lineTokens[lineTokens.length - 1][2].first_column;
      if (startPos !== endPos) {
        startCounter = startPos;
        while (line[startCounter] !== "#" && startCounter < line.length) {
          startCounter++;
        }
        newLine = line.substring(0, startCounter).replace(/\s*$/, '');
      }
    }
    hasSemicolon = regexes.trailingSemicolon.test(newLine);
    first = 2 <= lineTokens.length ? __slice.call(lineTokens, 0, _i = lineTokens.length - 1) : (_i = 0, []), last = lineTokens[_i++];
    hasNewLine = last && (last.newLine != null);
    if (hasSemicolon && !hasNewLine && lineApi.lineHasToken() && last[0] !== 'STRING') {
      return true;
    }
  };

  return NoTrailingSemicolons;

})();


},{}],31:[function(_dereq_,module,exports){
var NoTrailingWhitespace, regexes;

regexes = {
  trailingWhitespace: /[^\s]+[\t ]+\r?$/,
  onlySpaces: /^[\t ]+\r?$/,
  lineHasComment: /^\s*[^\#]*\#/
};

module.exports = NoTrailingWhitespace = (function() {
  function NoTrailingWhitespace() {}

  NoTrailingWhitespace.prototype.rule = {
    name: 'no_trailing_whitespace',
    level: 'error',
    message: 'Line ends with trailing whitespace',
    allowed_in_comments: false,
    allowed_in_empty_lines: true,
    description: "This rule forbids trailing whitespace in your code, since it is\nneedless cruft. It is enabled by default."
  };

  NoTrailingWhitespace.prototype.lintLine = function(line, lineApi) {
    var str, token, tokens, _i, _len, _ref, _ref1, _ref2;
    if (!((_ref = lineApi.config['no_trailing_whitespace']) != null ? _ref.allowed_in_empty_lines : void 0)) {
      if (regexes.onlySpaces.test(line)) {
        return true;
      }
    }
    if (regexes.trailingWhitespace.test(line)) {
      if (!((_ref1 = lineApi.config['no_trailing_whitespace']) != null ? _ref1.allowed_in_comments : void 0)) {
        return true;
      }
      line = line;
      tokens = lineApi.tokensByLine[lineApi.lineNumber];
      if (!tokens) {
        return null;
      }
      _ref2 = (function() {
        var _j, _len, _results;
        _results = [];
        for (_j = 0, _len = tokens.length; _j < _len; _j++) {
          token = tokens[_j];
          if (token[0] === 'STRING') {
            _results.push(token[1]);
          }
        }
        return _results;
      })();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        str = _ref2[_i];
        line = line.replace(str, 'STRING');
      }
      if (!regexes.lineHasComment.test(line)) {
        return true;
      }
    }
  };

  return NoTrailingWhitespace;

})();


},{}],32:[function(_dereq_,module,exports){
var NoUnnecessaryDoubleQuotes;

module.exports = NoUnnecessaryDoubleQuotes = (function() {
  function NoUnnecessaryDoubleQuotes() {}

  NoUnnecessaryDoubleQuotes.prototype.rule = {
    name: 'no_unnecessary_double_quotes',
    level: 'ignore',
    message: 'Unnecessary double quotes are forbidden',
    description: 'This rule prohibits double quotes unless string interpolation is \nused or the string contains single quotes.\n<pre>\n<code># Double quotes are discouraged:\nfoo = "bar"\n\n# Unless string interpolation is used:\nfoo = "#{bar}baz"\n\n# Or they prevent cumbersome escaping:\nfoo = "I\'m just following the \'rules\'"\n</code>\n</pre>\nDouble quotes are permitted by default.'
  };

  NoUnnecessaryDoubleQuotes.prototype.tokens = ['STRING'];

  NoUnnecessaryDoubleQuotes.prototype.lintToken = function(token, tokenApi) {
    var hasLegalConstructs, stringValue, tokenValue;
    tokenValue = token[1];
    stringValue = tokenValue.match(/^\"(.*)\"$/);
    if (!stringValue) {
      return false;
    }
    hasLegalConstructs = this.isInterpolated(tokenApi) || this.containsSingleQuote(tokenValue);
    return !hasLegalConstructs;
  };

  NoUnnecessaryDoubleQuotes.prototype.isInterpolated = function(tokenApi) {
    var currentIndex, i, isInterpolated, lineTokens, token, tokenName, _i, _ref;
    currentIndex = tokenApi.i;
    isInterpolated = false;
    lineTokens = tokenApi.tokensByLine[tokenApi.lineNumber];
    for (i = _i = 1; 1 <= currentIndex ? _i <= currentIndex : _i >= currentIndex; i = 1 <= currentIndex ? ++_i : --_i) {
      token = tokenApi.peek(-i);
      tokenName = token[0];
      if (tokenName === ')' && token.stringEnd) {
        break;
      } else if (tokenName === '(' && ((_ref = token.origin) != null ? _ref[1] : void 0) === "string interpolation") {
        isInterpolated = true;
        break;
      }
    }
    return isInterpolated;
  };

  NoUnnecessaryDoubleQuotes.prototype.containsSingleQuote = function(tokenValue) {
    return tokenValue.indexOf("'") !== -1;
  };

  return NoUnnecessaryDoubleQuotes;

})();


},{}],33:[function(_dereq_,module,exports){
var NoUnnecessaryFatArrows, any,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

any = function(arr, test) {
  return arr.reduce((function(res, elt) {
    return res || test(elt);
  }), false);
};

module.exports = NoUnnecessaryFatArrows = (function() {
  function NoUnnecessaryFatArrows() {
    this.needsFatArrow = __bind(this.needsFatArrow, this);
    this.isThis = __bind(this.isThis, this);
  }

  NoUnnecessaryFatArrows.prototype.rule = {
    name: 'no_unnecessary_fat_arrows',
    level: 'warn',
    message: 'Unnecessary fat arrow',
    description: "Disallows defining functions with fat arrows when `this`\nis not used within the function."
  };

  NoUnnecessaryFatArrows.prototype.lintAST = function(node, astApi) {
    this.astApi = astApi;
    this.lintNode(node);
    return void 0;
  };

  NoUnnecessaryFatArrows.prototype.lintNode = function(node) {
    var error;
    if ((this.isFatArrowCode(node)) && (!this.needsFatArrow(node))) {
      error = this.astApi.createError({
        lineNumber: node.locationData.first_line + 1
      });
      this.errors.push(error);
    }
    return node.eachChild((function(_this) {
      return function(child) {
        return _this.lintNode(child);
      };
    })(this));
  };

  NoUnnecessaryFatArrows.prototype.isCode = function(node) {
    return this.astApi.getNodeName(node) === 'Code';
  };

  NoUnnecessaryFatArrows.prototype.isFatArrowCode = function(node) {
    return this.isCode(node) && node.bound;
  };

  NoUnnecessaryFatArrows.prototype.isValue = function(node) {
    return this.astApi.getNodeName(node) === 'Value';
  };

  NoUnnecessaryFatArrows.prototype.isThis = function(node) {
    return this.isValue(node) && node.base.value === 'this';
  };

  NoUnnecessaryFatArrows.prototype.needsFatArrow = function(node) {
    return this.isCode(node) && (any(node.params, (function(_this) {
      return function(param) {
        return param.contains(_this.isThis) != null;
      };
    })(this)) || (node.body.contains(this.isThis) != null) || (node.body.contains((function(_this) {
      return function(child) {
        return _this.isFatArrowCode(child) && _this.needsFatArrow(child);
      };
    })(this)) != null));
  };

  return NoUnnecessaryFatArrows;

})();


},{}],34:[function(_dereq_,module,exports){
var NonEmptyConstructorNeedsParens, ParentClass,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

ParentClass = _dereq_('./empty_constructor_needs_parens.coffee');

module.exports = NonEmptyConstructorNeedsParens = (function(_super) {
  __extends(NonEmptyConstructorNeedsParens, _super);

  function NonEmptyConstructorNeedsParens() {
    return NonEmptyConstructorNeedsParens.__super__.constructor.apply(this, arguments);
  }

  NonEmptyConstructorNeedsParens.prototype.rule = {
    name: 'non_empty_constructor_needs_parens',
    level: 'ignore',
    message: 'Invoking a constructor without parens and with arguments',
    description: "Requires constructors with parameters to include the parens"
  };

  NonEmptyConstructorNeedsParens.prototype.handleExpectedCallStart = function(expectedCallStart) {
    if (expectedCallStart[0] === 'CALL_START' && expectedCallStart.generated) {
      return true;
    }
  };

  return NonEmptyConstructorNeedsParens;

})(ParentClass);


},{"./empty_constructor_needs_parens.coffee":13}],35:[function(_dereq_,module,exports){
var SpaceOperators,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = SpaceOperators = (function() {
  SpaceOperators.prototype.rule = {
    name: 'space_operators',
    level: 'ignore',
    message: 'Operators must be spaced properly',
    description: "This rule enforces that operators have space around them."
  };

  SpaceOperators.prototype.tokens = ["+", "-", "=", "**", "MATH", "COMPARE", "LOGIC", "COMPOUND_ASSIGN", "(", ")", "CALL_START", "CALL_END"];

  function SpaceOperators() {
    this.callTokens = [];
    this.parenTokens = [];
  }

  SpaceOperators.prototype.lintToken = function(_arg, tokenApi) {
    var type;
    type = _arg[0];
    if (type === "CALL_START" || type === "CALL_END") {
      this.lintCall.apply(this, arguments);
      return void 0;
    }
    if (type === "(" || type === ")") {
      this.lintParens.apply(this, arguments);
      return void 0;
    }
    if (type === "+" || type === "-") {
      return this.lintPlus.apply(this, arguments);
    } else {
      return this.lintMath.apply(this, arguments);
    }
  };

  SpaceOperators.prototype.lintPlus = function(token, tokenApi) {
    var isUnary, p, unaries, _ref;
    if (this.isInInterpolation() || this.isInExtendedRegex()) {
      return null;
    }
    p = tokenApi.peek(-1);
    unaries = ['TERMINATOR', '(', '=', '-', '+', ',', 'CALL_START', 'INDEX_START', '..', '...', 'COMPARE', 'IF', 'THROW', 'LOGIC', 'POST_IF', ':', '[', 'INDENT', 'COMPOUND_ASSIGN', 'RETURN', 'MATH', 'BY', 'LEADING_WHEN'];
    isUnary = !p ? false : (_ref = p[0], __indexOf.call(unaries, _ref) >= 0);
    if ((isUnary && token.spaced) || (!isUnary && !token.spaced && !token.newLine)) {
      return {
        context: token[1]
      };
    } else {
      return null;
    }
  };

  SpaceOperators.prototype.lintMath = function(token, tokenApi) {
    if (!token.spaced && !token.newLine) {
      return {
        context: token[1]
      };
    } else {
      return null;
    }
  };

  SpaceOperators.prototype.isInExtendedRegex = function() {
    var t, _i, _len, _ref;
    _ref = this.callTokens;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      if (t.isRegex) {
        return true;
      }
    }
    return false;
  };

  SpaceOperators.prototype.lintCall = function(token, tokenApi) {
    var p;
    if (token[0] === 'CALL_START') {
      p = tokenApi.peek(-1);
      token.isRegex = p && p[0] === 'IDENTIFIER' && p[1] === 'RegExp';
      this.callTokens.push(token);
    } else {
      this.callTokens.pop();
    }
    return null;
  };

  SpaceOperators.prototype.isInInterpolation = function() {
    var t, _i, _len, _ref;
    _ref = this.parenTokens;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      t = _ref[_i];
      if (t.isInterpolation) {
        return true;
      }
    }
    return false;
  };

  SpaceOperators.prototype.lintParens = function(token, tokenApi) {
    var i, n1, n2, p1;
    if (token[0] === '(') {
      p1 = tokenApi.peek(-1);
      n1 = tokenApi.peek(1);
      n2 = tokenApi.peek(2);
      i = n1 && n2 && n1[0] === 'STRING' && n2[0] === '+';
      token.isInterpolation = i;
      this.parenTokens.push(token);
    } else {
      this.parenTokens.pop();
    }
    return null;
  };

  return SpaceOperators;

})();


},{}]},{},[4])
(4)
});
(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  var GUTTER_ID = "CodeMirror-lint-markers";
  var SEVERITIES = /^(?:error|warning)$/;

  function showTooltip(e, content) {
    var tt = document.createElement("div");
    tt.className = "CodeMirror-lint-tooltip";
    tt.appendChild(content.cloneNode(true));
    document.body.appendChild(tt);

    function position(e) {
      if (!tt.parentNode) return CodeMirror.off(document, "mousemove", position);
      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + "px";
      tt.style.left = (e.clientX + 5) + "px";
    }
    CodeMirror.on(document, "mousemove", position);
    position(e);
    if (tt.style.opacity != null) tt.style.opacity = 1;
    return tt;
  }
  function rm(elt) {
    if (elt.parentNode) elt.parentNode.removeChild(elt);
  }
  function hideTooltip(tt) {
    if (!tt.parentNode) return;
    if (tt.style.opacity == null) rm(tt);
    tt.style.opacity = 0;
    setTimeout(function() { rm(tt); }, 600);
  }

  function showTooltipFor(e, content, node) {
    var tooltip = showTooltip(e, content);
    function hide() {
      CodeMirror.off(node, "mouseout", hide);
      if (tooltip) { hideTooltip(tooltip); tooltip = null; }
    }
    var poll = setInterval(function() {
      if (tooltip) for (var n = node;; n = n.parentNode) {
        if (n == document.body) return;
        if (!n) { hide(); break; }
      }
      if (!tooltip) return clearInterval(poll);
    }, 400);
    CodeMirror.on(node, "mouseout", hide);
  }

  function LintState(cm, options, hasGutter) {
    this.marked = [];
    this.options = options;
    this.timeout = null;
    this.hasGutter = hasGutter;
    this.onMouseOver = function(e) { onMouseOver(cm, e); };
  }

  function parseOptions(cm, options) {
    if (options instanceof Function) return {getAnnotations: options};
    if (!options || options === true) options = {};
    if (!options.getAnnotations) options.getAnnotations = cm.getHelper(CodeMirror.Pos(0, 0), "lint");
    if (!options.getAnnotations) throw new Error("Required option 'getAnnotations' missing (lint addon)");
    return options;
  }

  function clearMarks(cm) {
    var state = cm.state.lint;
    if (state.hasGutter) cm.clearGutter(GUTTER_ID);
    for (var i = 0; i < state.marked.length; ++i)
      state.marked[i].clear();
    state.marked.length = 0;
  }

  function makeMarker(labels, severity, multiple, tooltips) {
    var marker = document.createElement("div"), inner = marker;
    marker.className = "CodeMirror-lint-marker-" + severity;
    if (multiple) {
      inner = marker.appendChild(document.createElement("div"));
      inner.className = "CodeMirror-lint-marker-multiple";
    }

    if (tooltips != false) CodeMirror.on(inner, "mouseover", function(e) {
      showTooltipFor(e, labels, inner);
    });

    return marker;
  }

  function getMaxSeverity(a, b) {
    if (a == "error") return a;
    else return b;
  }

  function groupByLine(annotations) {
    var lines = [];
    for (var i = 0; i < annotations.length; ++i) {
      var ann = annotations[i], line = ann.from.line;
      (lines[line] || (lines[line] = [])).push(ann);
    }
    return lines;
  }

  function annotationTooltip(ann) {
    var severity = ann.severity;
    if (!SEVERITIES.test(severity)) severity = "error";
    var tip = document.createElement("div");
    tip.className = "CodeMirror-lint-message-" + severity;
    tip.appendChild(document.createTextNode(ann.message));
    return tip;
  }

  function startLinting(cm) {
    var state = cm.state.lint, options = state.options;
    if (options.async)
      options.getAnnotations(cm, updateLinting, options);
    else
      updateLinting(cm, options.getAnnotations(cm.getValue(), options.options));
  }

  function updateLinting(cm, annotationsNotSorted) {
    clearMarks(cm);
    var state = cm.state.lint, options = state.options;

    var annotations = groupByLine(annotationsNotSorted);

    for (var line = 0; line < annotations.length; ++line) {
      var anns = annotations[line];
      if (!anns) continue;

      var maxSeverity = null;
      var tipLabel = state.hasGutter && document.createDocumentFragment();

      for (var i = 0; i < anns.length; ++i) {
        var ann = anns[i];
        var severity = ann.severity;
        if (!SEVERITIES.test(severity)) severity = "error";
        maxSeverity = getMaxSeverity(maxSeverity, severity);

        if (options.formatAnnotation) ann = options.formatAnnotation(ann);
        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));

        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {
          className: "CodeMirror-lint-mark-" + severity,
          __annotation: ann
        }));
      }

      if (state.hasGutter)
        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,
                                                       state.options.tooltips));
    }
    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);
  }

  function onChange(cm) {
    var state = cm.state.lint;
    clearTimeout(state.timeout);
    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);
  }

  function popupSpanTooltip(ann, e) {
    var target = e.target || e.srcElement;
    showTooltipFor(e, annotationTooltip(ann), target);
  }

  // When the mouseover fires, the cursor might not actually be over
  // the character itself yet. These pairs of x,y offsets are used to
  // probe a few nearby points when no suitable marked range is found.
  var nearby = [0, 0, 0, 5, 0, -5, 5, 0, -5, 0];

  function onMouseOver(cm, e) {
    if (!/\bCodeMirror-lint-mark-/.test((e.target || e.srcElement).className)) return;
    for (var i = 0; i < nearby.length; i += 2) {
      var spans = cm.findMarksAt(cm.coordsChar({left: e.clientX + nearby[i],
                                                top: e.clientY + nearby[i + 1]}, "client"));
      for (var j = 0; j < spans.length; ++j) {
        var span = spans[j], ann = span.__annotation;
        if (ann) return popupSpanTooltip(ann, e);
      }
    }
  }

  CodeMirror.defineOption("lint", false, function(cm, val, old) {
    if (old && old != CodeMirror.Init) {
      clearMarks(cm);
      cm.off("change", onChange);
      CodeMirror.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
      delete cm.state.lint;
    }

    if (val) {
      var gutters = cm.getOption("gutters"), hasLintGutter = false;
      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;
      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);
      cm.on("change", onChange);
      if (state.options.tooltips != false)
        CodeMirror.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);

      startLinting(cm);
    }
  });
});

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";
  // declare global: JSHINT

  var bogus = [ "Dangerous comment" ];

  var warnings = [ [ "Expected '{'",
                     "Statement body should be inside '{ }' braces." ] ];

  var errors = [ "Missing semicolon", "Extra comma", "Missing property name",
                 "Unmatched ", " and instead saw", " is not defined",
                 "Unclosed string", "Stopping, unable to continue" ];

  function validator(text, options) {
    if (!window.JSHINT) return [];
    JSHINT(text, options);
    var errors = JSHINT.data().errors, result = [];
    if (errors) parseErrors(errors, result);
    return result;
  }

  CodeMirror.registerHelper("lint", "javascript", validator);

  function cleanup(error) {
    // All problems are warnings by default
    fixWith(error, warnings, "warning", true);
    fixWith(error, errors, "error");

    return isBogus(error) ? null : error;
  }

  function fixWith(error, fixes, severity, force) {
    var description, fix, find, replace, found;

    description = error.description;

    for ( var i = 0; i < fixes.length; i++) {
      fix = fixes[i];
      find = (typeof fix === "string" ? fix : fix[0]);
      replace = (typeof fix === "string" ? null : fix[1]);
      found = description.indexOf(find) !== -1;

      if (force || found) {
        error.severity = severity;
      }
      if (found && replace) {
        error.description = replace;
      }
    }
  }

  function isBogus(error) {
    var description = error.description;
    for ( var i = 0; i < bogus.length; i++) {
      if (description.indexOf(bogus[i]) !== -1) {
        return true;
      }
    }
    return false;
  }

  function parseErrors(errors, output) {
    for ( var i = 0; i < errors.length; i++) {
      var error = errors[i];
      if (error) {
        var linetabpositions, index;

        linetabpositions = [];

        // This next block is to fix a problem in jshint. Jshint
        // replaces
        // all tabs with spaces then performs some checks. The error
        // positions (character/space) are then reported incorrectly,
        // not taking the replacement step into account. Here we look
        // at the evidence line and try to adjust the character position
        // to the correct value.
        if (error.evidence) {
          // Tab positions are computed once per line and cached
          var tabpositions = linetabpositions[error.line];
          if (!tabpositions) {
            var evidence = error.evidence;
            tabpositions = [];
            // ugggh phantomjs does not like this
            // forEachChar(evidence, function(item, index) {
            Array.prototype.forEach.call(evidence, function(item,
                                                            index) {
              if (item === '\t') {
                // First col is 1 (not 0) to match error
                // positions
                tabpositions.push(index + 1);
              }
            });
            linetabpositions[error.line] = tabpositions;
          }
          if (tabpositions.length > 0) {
            var pos = error.character;
            tabpositions.forEach(function(tabposition) {
              if (pos > tabposition) pos -= 1;
            });
            error.character = pos;
          }
        }

        var start = error.character - 1, end = start + 1;
        if (error.evidence) {
          index = error.evidence.substring(start).search(/.\b/);
          if (index > -1) {
            end += index;
          }
        }

        // Convert to format expected by validation service
        error.description = error.reason;// + "(jshint)";
        error.start = error.character;
        error.end = end;
        error = cleanup(error);

        if (error)
          output.push({message: error.description,
                       severity: error.severity,
                       from: CodeMirror.Pos(error.line - 1, start),
                       to: CodeMirror.Pos(error.line - 1, end)});
      }
    }
  }
});

// Depends on coffeelint.js from http://www.coffeelint.org/js/coffeelint.js

// declare global: coffeelint

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.registerHelper("lint", "coffeescript", function(text) {
  var found = [];
  var parseError = function(err) {
    var loc = err.lineNumber;
    found.push({from: CodeMirror.Pos(loc-1, 0),
                to: CodeMirror.Pos(loc, 0),
                severity: err.level,
                message: err.message});
  };
  try {
    var res = coffeelint.lint(text);
    for(var i = 0; i < res.length; i++) {
      parseError(res[i]);
    }
  } catch(e) {
    found.push({from: CodeMirror.Pos(e.location.first_line, 0),
                to: CodeMirror.Pos(e.location.last_line, e.location.last_column),
                severity: 'error',
                message: e.message});
  }
  return found;
});

});

// A rough approximation of Sublime Text's keybindings
// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../lib/codemirror"), require("../addon/search/searchcursor"), require("../addon/edit/matchbrackets"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/edit/matchbrackets"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var map = CodeMirror.keyMap.sublime = {fallthrough: "default"};
  var cmds = CodeMirror.commands;
  var Pos = CodeMirror.Pos;
  var ctrl = CodeMirror.keyMap["default"] == CodeMirror.keyMap.pcDefault ? "Ctrl-" : "Cmd-";

  // This is not exactly Sublime's algorithm. I couldn't make heads or tails of that.
  function findPosSubword(doc, start, dir) {
    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));
    var line = doc.getLine(start.line);
    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));
    var state = "start", type;
    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
      var next = line.charAt(dir < 0 ? pos - 1 : pos);
      var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";
      if (cat == "w" && next.toUpperCase() == next) cat = "W";
      if (state == "start") {
        if (cat != "o") { state = "in"; type = cat; }
      } else if (state == "in") {
        if (type != cat) {
          if (type == "w" && cat == "W" && dir < 0) pos--;
          if (type == "W" && cat == "w" && dir > 0) { type = "w"; continue; }
          break;
        }
      }
    }
    return Pos(start.line, pos);
  }

  function moveSubword(cm, dir) {
    cm.extendSelectionsBy(function(range) {
      if (cm.display.shift || cm.doc.extend || range.empty())
        return findPosSubword(cm.doc, range.head, dir);
      else
        return dir < 0 ? range.from() : range.to();
    });
  }

  cmds[map["Alt-Left"] = "goSubwordLeft"] = function(cm) { moveSubword(cm, -1); };
  cmds[map["Alt-Right"] = "goSubwordRight"] = function(cm) { moveSubword(cm, 1); };

  cmds[map[ctrl + "Up"] = "scrollLineUp"] = function(cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");
      if (cm.getCursor().line >= visibleBottomLine)
        cm.execCommand("goLineUp");
    }
    cm.scrollTo(null, info.top - cm.defaultTextHeight());
  };
  cmds[map[ctrl + "Down"] = "scrollLineDown"] = function(cm) {
    var info = cm.getScrollInfo();
    if (!cm.somethingSelected()) {
      var visibleTopLine = cm.lineAtHeight(info.top, "local")+1;
      if (cm.getCursor().line <= visibleTopLine)
        cm.execCommand("goLineDown");
    }
    cm.scrollTo(null, info.top + cm.defaultTextHeight());
  };

  cmds[map["Shift-" + ctrl + "L"] = "splitSelectionByLine"] = function(cm) {
    var ranges = cm.listSelections(), lineRanges = [];
    for (var i = 0; i < ranges.length; i++) {
      var from = ranges[i].from(), to = ranges[i].to();
      for (var line = from.line; line <= to.line; ++line)
        if (!(to.line > from.line && line == to.line && to.ch == 0))
          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),
                           head: line == to.line ? to : Pos(line)});
    }
    cm.setSelections(lineRanges, 0);
  };

  map["Shift-Tab"] = "indentLess";

  cmds[map["Esc"] = "singleSelectionTop"] = function(cm) {
    var range = cm.listSelections()[0];
    cm.setSelection(range.anchor, range.head, {scroll: false});
  };

  cmds[map[ctrl + "L"] = "selectLine"] = function(cm) {
    var ranges = cm.listSelections(), extended = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      extended.push({anchor: Pos(range.from().line, 0),
                     head: Pos(range.to().line + 1, 0)});
    }
    cm.setSelections(extended);
  };

  map["Shift-" + ctrl + "K"] = "deleteLine";

  function insertLine(cm, above) {
    cm.operation(function() {
      var len = cm.listSelections().length, newSelection = [], last = -1;
      for (var i = 0; i < len; i++) {
        var head = cm.listSelections()[i].head;
        if (head.line <= last) continue;
        var at = Pos(head.line + (above ? 0 : 1), 0);
        cm.replaceRange("\n", at, null, "+insertLine");
        cm.indentLine(at.line, null, true);
        newSelection.push({head: at, anchor: at});
        last = head.line + 1;
      }
      cm.setSelections(newSelection);
    });
  }

  cmds[map[ctrl + "Enter"] = "insertLineAfter"] = function(cm) { insertLine(cm, false); };

  cmds[map["Shift-" + ctrl + "Enter"] = "insertLineBefore"] = function(cm) { insertLine(cm, true); };

  function wordAt(cm, pos) {
    var start = pos.ch, end = start, line = cm.getLine(pos.line);
    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;
    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;
    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};
  }

  cmds[map[ctrl + "D"] = "selectNextOccurrence"] = function(cm) {
    var from = cm.getCursor("from"), to = cm.getCursor("to");
    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      cm.setSelection(word.from, word.to);
      fullWord = true;
    } else {
      var text = cm.getRange(from, to);
      var query = fullWord ? new RegExp("\\b" + text + "\\b") : text;
      var cur = cm.getSearchCursor(query, to);
      if (cur.findNext()) {
        cm.addSelection(cur.from(), cur.to());
      } else {
        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
        if (cur.findNext())
          cm.addSelection(cur.from(), cur.to());
      }
    }
    if (fullWord)
      cm.state.sublimeFindFullWord = cm.doc.sel;
  };

  var mirror = "(){}[]";
  function selectBetweenBrackets(cm) {
    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);
    if (!opening) return;
    for (;;) {
      var closing = cm.scanForBracket(pos, 1);
      if (!closing) return;
      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);
        return true;
      }
      pos = Pos(closing.pos.line, closing.pos.ch + 1);
    }
  }

  cmds[map["Shift-" + ctrl + "Space"] = "selectScope"] = function(cm) {
    selectBetweenBrackets(cm) || cm.execCommand("selectAll");
  };
  cmds[map["Shift-" + ctrl + "M"] = "selectBetweenBrackets"] = function(cm) {
    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
  };

  cmds[map[ctrl + "M"] = "goToBracket"] = function(cm) {
    cm.extendSelectionsBy(function(range) {
      var next = cm.scanForBracket(range.head, 1);
      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;
      var prev = cm.scanForBracket(range.head, -1);
      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
    });
  };

  cmds[map["Shift-" + ctrl + "Up"] = "swapLineUp"] = function(cm) {
    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i], from = range.from().line - 1, to = range.to().line;
      if (from > at) linesToMove.push(from, to);
      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function() {
      for (var i = 0; i < linesToMove.length; i += 2) {
        var from = linesToMove[i], to = linesToMove[i + 1];
        var line = cm.getLine(from);
        cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
        if (to > cm.lastLine()) {
          cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");
          var sels = cm.listSelections(), last = sels[sels.length - 1];
          var head = last.head.line == to ? Pos(to - 1) : last.head;
          var anchor = last.anchor.line == to ? Pos(to - 1) : last.anchor;
          cm.setSelections(sels.slice(0, sels.length - 1).concat([{head: head, anchor: anchor}]));
        } else {
          cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
        }
      }
      cm.scrollIntoView();
    });
  };

  cmds[map["Shift-" + ctrl + "Down"] = "swapLineDown"] = function(cm) {
    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;
    for (var i = ranges.length - 1; i >= 0; i--) {
      var range = ranges[i], from = range.to().line + 1, to = range.from().line;
      if (from < at) linesToMove.push(from, to);
      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;
      at = to;
    }
    cm.operation(function() {
      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {
        var from = linesToMove[i], to = linesToMove[i + 1];
        var line = cm.getLine(from);
        if (from == cm.lastLine())
          cm.replaceRange("", Pos(from - 1), Pos(from), "+swapLine");
        else
          cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");
        cm.replaceRange(line + "\n", Pos(to, 0), null, "+swapLine");
      }
      cm.scrollIntoView();
    });
  };

  map[ctrl + "/"] = "toggleComment";

  cmds[map[ctrl + "J"] = "joinLines"] = function(cm) {
    var ranges = cm.listSelections(), joined = [];
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i], from = range.from();
      var start = from.line, end = range.to().line;
      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)
        end = ranges[++i].to().line;
      joined.push({start: start, end: end, anchor: !range.empty() && from});
    }
    cm.operation(function() {
      var offset = 0, ranges = [];
      for (var i = 0; i < joined.length; i++) {
        var obj = joined[i];
        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;
        for (var line = obj.start; line <= obj.end; line++) {
          var actual = line - offset;
          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);
          if (actual < cm.lastLine()) {
            cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
            ++offset;
          }
        }
        ranges.push({anchor: anchor || head, head: head});
      }
      cm.setSelections(ranges, 0);
    });
  };

  cmds[map["Shift-" + ctrl + "D"] = "duplicateLine"] = function(cm) {
    cm.operation(function() {
      var rangeCount = cm.listSelections().length;
      for (var i = 0; i < rangeCount; i++) {
        var range = cm.listSelections()[i];
        if (range.empty())
          cm.replaceRange(cm.getLine(range.head.line) + "\n", Pos(range.head.line, 0));
        else
          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
      }
      cm.scrollIntoView();
    });
  };

  map[ctrl + "T"] = "transposeChars";

  function sortLines(cm, caseSensitive) {
    var ranges = cm.listSelections(), toSort = [], selected;
    for (var i = 0; i < ranges.length; i++) {
      var range = ranges[i];
      if (range.empty()) continue;
      var from = range.from().line, to = range.to().line;
      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)
        to = range[++i].to().line;
      toSort.push(from, to);
    }
    if (toSort.length) selected = true;
    else toSort.push(cm.firstLine(), cm.lastLine());

    cm.operation(function() {
      var ranges = [];
      for (var i = 0; i < toSort.length; i += 2) {
        var from = toSort[i], to = toSort[i + 1];
        var start = Pos(from, 0), end = Pos(to);
        var lines = cm.getRange(start, end, false);
        if (caseSensitive)
          lines.sort();
        else
          lines.sort(function(a, b) {
            var au = a.toUpperCase(), bu = b.toUpperCase();
            if (au != bu) { a = au; b = bu; }
            return a < b ? -1 : a == b ? 0 : 1;
          });
        cm.replaceRange(lines, start, end);
        if (selected) ranges.push({anchor: start, head: end});
      }
      if (selected) cm.setSelections(ranges, 0);
    });
  }

  cmds[map["F9"] = "sortLines"] = function(cm) { sortLines(cm, true); };
  cmds[map[ctrl + "F9"] = "sortLinesInsensitive"] = function(cm) { sortLines(cm, false); };

  cmds[map["F2"] = "nextBookmark"] = function(cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      var current = marks.shift();
      var found = current.find();
      if (found) {
        marks.push(current);
        return cm.setSelection(found.from, found.to);
      }
    }
  };

  cmds[map["Shift-F2"] = "prevBookmark"] = function(cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) while (marks.length) {
      marks.unshift(marks.pop());
      var found = marks[marks.length - 1].find();
      if (!found)
        marks.pop();
      else
        return cm.setSelection(found.from, found.to);
    }
  };

  cmds[map[ctrl + "F2"] = "toggleBookmark"] = function(cm) {
    var ranges = cm.listSelections();
    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
    for (var i = 0; i < ranges.length; i++) {
      var from = ranges[i].from(), to = ranges[i].to();
      var found = cm.findMarks(from, to);
      for (var j = 0; j < found.length; j++) {
        if (found[j].sublimeBookmark) {
          found[j].clear();
          for (var k = 0; k < marks.length; k++)
            if (marks[k] == found[j])
              marks.splice(k--, 1);
          break;
        }
      }
      if (j == found.length)
        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));
    }
  };

  cmds[map["Shift-" + ctrl + "F2"] = "clearBookmarks"] = function(cm) {
    var marks = cm.state.sublimeBookmarks;
    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();
    marks.length = 0;
  };

  cmds[map["Alt-F2"] = "selectBookmarks"] = function(cm) {
    var marks = cm.state.sublimeBookmarks, ranges = [];
    if (marks) for (var i = 0; i < marks.length; i++) {
      var found = marks[i].find();
      if (!found)
        marks.splice(i--, 0);
      else
        ranges.push({anchor: found.from, head: found.to});
    }
    if (ranges.length)
      cm.setSelections(ranges, 0);
  };

  map["Alt-Q"] = "wrapLines";

  var mapK = CodeMirror.keyMap["sublime-Ctrl-K"] = {auto: "sublime", nofallthrough: true};

  map[ctrl + "K"] = function(cm) {cm.setOption("keyMap", "sublime-Ctrl-K");};

  function modifyWordOrSelection(cm, mod) {
    cm.operation(function() {
      var ranges = cm.listSelections(), indices = [], replacements = [];
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.empty()) { indices.push(i); replacements.push(""); }
        else replacements.push(mod(cm.getRange(range.from(), range.to())));
      }
      cm.replaceSelections(replacements, "around", "case");
      for (var i = indices.length - 1, at; i >= 0; i--) {
        var range = ranges[indices[i]];
        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;
        var word = wordAt(cm, range.head);
        at = word.from;
        cm.replaceRange(mod(word.word), word.from, word.to);
      }
    });
  }

  mapK[ctrl + "Backspace"] = "delLineLeft";

  cmds[mapK[ctrl + "K"] = "delLineRight"] = function(cm) {
    cm.operation(function() {
      var ranges = cm.listSelections();
      for (var i = ranges.length - 1; i >= 0; i--)
        cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
      cm.scrollIntoView();
    });
  };

  cmds[mapK[ctrl + "U"] = "upcaseAtCursor"] = function(cm) {
    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });
  };
  cmds[mapK[ctrl + "L"] = "downcaseAtCursor"] = function(cm) {
    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });
  };

  cmds[mapK[ctrl + "Space"] = "setSublimeMark"] = function(cm) {
    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();
    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
  };
  cmds[mapK[ctrl + "A"] = "selectToSublimeMark"] = function(cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) cm.setSelection(cm.getCursor(), found);
  };
  cmds[mapK[ctrl + "W"] = "deleteToSublimeMark"] = function(cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) {
      var from = cm.getCursor(), to = found;
      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }
      cm.state.sublimeKilled = cm.getRange(from, to);
      cm.replaceRange("", from, to);
    }
  };
  cmds[mapK[ctrl + "X"] = "swapWithSublimeMark"] = function(cm) {
    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
    if (found) {
      cm.state.sublimeMark.clear();
      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
      cm.setCursor(found);
    }
  };
  cmds[mapK[ctrl + "Y"] = "sublimeYank"] = function(cm) {
    if (cm.state.sublimeKilled != null)
      cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
  };

  mapK[ctrl + "G"] = "clearBookmarks";
  cmds[mapK[ctrl + "C"] = "showInCenter"] = function(cm) {
    var pos = cm.cursorCoords(null, "local");
    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
  };

  cmds[map["Shift-Alt-Up"] = "selectLinesUpward"] = function(cm) {
    cm.operation(function() {
      var ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.head.line > cm.firstLine())
          cm.addSelection(Pos(range.head.line - 1, range.head.ch));
      }
    });
  };
  cmds[map["Shift-Alt-Down"] = "selectLinesDownward"] = function(cm) {
    cm.operation(function() {
      var ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];
        if (range.head.line < cm.lastLine())
          cm.addSelection(Pos(range.head.line + 1, range.head.ch));
      }
    });
  };

  function findAndGoTo(cm, forward) {
    var from = cm.getCursor("from"), to = cm.getCursor("to");
    if (CodeMirror.cmpPos(from, to) == 0) {
      var word = wordAt(cm, from);
      if (!word.word) return;
      from = word.from;
      to = word.to;
    }

    var query = cm.getRange(from, to);
    var cur = cm.getSearchCursor(query, forward ? to : from);

    if (forward ? cur.findNext() : cur.findPrevious()) {
      cm.setSelection(cur.from(), cur.to());
    } else {
      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)
                                              : cm.clipPos(Pos(cm.lastLine())));
      if (forward ? cur.findNext() : cur.findPrevious())
        cm.setSelection(cur.from(), cur.to());
      else if (word)
        cm.setSelection(from, to);
    }
  };
  cmds[map[ctrl + "F3"] = "findUnder"] = function(cm) { findAndGoTo(cm, true); };
  cmds[map["Shift-" + ctrl + "F3"] = "findUnderPrevious"] = function(cm) { findAndGoTo(cm,false); };

  map["Shift-" + ctrl + "["] = "fold";
  map["Shift-" + ctrl + "]"] = "unfold";
  mapK[ctrl + "0"] = mapK[ctrl + "j"] = "unfoldAll";

  map[ctrl + "I"] = "findIncremental";
  map["Shift-" + ctrl + "I"] = "findIncrementalReverse";
  map[ctrl + "H"] = "replace";
  map["F3"] = "findNext";
  map["Shift-F3"] = "findPrev";

});

document.write=document.writeln=function(){throw new Error("document.[write|writeln] is nisht-nisht")};
Encoder={EncodeType:"entity",isEmpty:function(r){return r?null===r||0==r.length||/^\s+$/.test(r):!0},arr1:["&nbsp;","&iexcl;","&cent;","&pound;","&curren;","&yen;","&brvbar;","&sect;","&uml;","&copy;","&ordf;","&laquo;","&not;","&shy;","&reg;","&macr;","&deg;","&plusmn;","&sup2;","&sup3;","&acute;","&micro;","&para;","&middot;","&cedil;","&sup1;","&ordm;","&raquo;","&frac14;","&frac12;","&frac34;","&iquest;","&Agrave;","&Aacute;","&Acirc;","&Atilde;","&Auml;","&Aring;","&AElig;","&Ccedil;","&Egrave;","&Eacute;","&Ecirc;","&Euml;","&Igrave;","&Iacute;","&Icirc;","&Iuml;","&ETH;","&Ntilde;","&Ograve;","&Oacute;","&Ocirc;","&Otilde;","&Ouml;","&times;","&Oslash;","&Ugrave;","&Uacute;","&Ucirc;","&Uuml;","&Yacute;","&THORN;","&szlig;","&agrave;","&aacute;","&acirc;","&atilde;","&auml;","&aring;","&aelig;","&ccedil;","&egrave;","&eacute;","&ecirc;","&euml;","&igrave;","&iacute;","&icirc;","&iuml;","&eth;","&ntilde;","&ograve;","&oacute;","&ocirc;","&otilde;","&ouml;","&divide;","&oslash;","&ugrave;","&uacute;","&ucirc;","&uuml;","&yacute;","&thorn;","&yuml;","&quot;","&amp;","&lt;","&gt;","&OElig;","&oelig;","&Scaron;","&scaron;","&Yuml;","&circ;","&tilde;","&ensp;","&emsp;","&thinsp;","&zwnj;","&zwj;","&lrm;","&rlm;","&ndash;","&mdash;","&lsquo;","&rsquo;","&sbquo;","&ldquo;","&rdquo;","&bdquo;","&dagger;","&Dagger;","&permil;","&lsaquo;","&rsaquo;","&euro;","&fnof;","&Alpha;","&Beta;","&Gamma;","&Delta;","&Epsilon;","&Zeta;","&Eta;","&Theta;","&Iota;","&Kappa;","&Lambda;","&Mu;","&Nu;","&Xi;","&Omicron;","&Pi;","&Rho;","&Sigma;","&Tau;","&Upsilon;","&Phi;","&Chi;","&Psi;","&Omega;","&alpha;","&beta;","&gamma;","&delta;","&epsilon;","&zeta;","&eta;","&theta;","&iota;","&kappa;","&lambda;","&mu;","&nu;","&xi;","&omicron;","&pi;","&rho;","&sigmaf;","&sigma;","&tau;","&upsilon;","&phi;","&chi;","&psi;","&omega;","&thetasym;","&upsih;","&piv;","&bull;","&hellip;","&prime;","&Prime;","&oline;","&frasl;","&weierp;","&image;","&real;","&trade;","&alefsym;","&larr;","&uarr;","&rarr;","&darr;","&harr;","&crarr;","&lArr;","&uArr;","&rArr;","&dArr;","&hArr;","&forall;","&part;","&exist;","&empty;","&nabla;","&isin;","&notin;","&ni;","&prod;","&sum;","&minus;","&lowast;","&radic;","&prop;","&infin;","&ang;","&and;","&or;","&cap;","&cup;","&int;","&there4;","&sim;","&cong;","&asymp;","&ne;","&equiv;","&le;","&ge;","&sub;","&sup;","&nsub;","&sube;","&supe;","&oplus;","&otimes;","&perp;","&sdot;","&lceil;","&rceil;","&lfloor;","&rfloor;","&lang;","&rang;","&loz;","&spades;","&clubs;","&hearts;","&diams;"],arr2:["&#160;","&#161;","&#162;","&#163;","&#164;","&#165;","&#166;","&#167;","&#168;","&#169;","&#170;","&#171;","&#172;","&#173;","&#174;","&#175;","&#176;","&#177;","&#178;","&#179;","&#180;","&#181;","&#182;","&#183;","&#184;","&#185;","&#186;","&#187;","&#188;","&#189;","&#190;","&#191;","&#192;","&#193;","&#194;","&#195;","&#196;","&#197;","&#198;","&#199;","&#200;","&#201;","&#202;","&#203;","&#204;","&#205;","&#206;","&#207;","&#208;","&#209;","&#210;","&#211;","&#212;","&#213;","&#214;","&#215;","&#216;","&#217;","&#218;","&#219;","&#220;","&#221;","&#222;","&#223;","&#224;","&#225;","&#226;","&#227;","&#228;","&#229;","&#230;","&#231;","&#232;","&#233;","&#234;","&#235;","&#236;","&#237;","&#238;","&#239;","&#240;","&#241;","&#242;","&#243;","&#244;","&#245;","&#246;","&#247;","&#248;","&#249;","&#250;","&#251;","&#252;","&#253;","&#254;","&#255;","&#34;","&#38;","&#60;","&#62;","&#338;","&#339;","&#352;","&#353;","&#376;","&#710;","&#732;","&#8194;","&#8195;","&#8201;","&#8204;","&#8205;","&#8206;","&#8207;","&#8211;","&#8212;","&#8216;","&#8217;","&#8218;","&#8220;","&#8221;","&#8222;","&#8224;","&#8225;","&#8240;","&#8249;","&#8250;","&#8364;","&#402;","&#913;","&#914;","&#915;","&#916;","&#917;","&#918;","&#919;","&#920;","&#921;","&#922;","&#923;","&#924;","&#925;","&#926;","&#927;","&#928;","&#929;","&#931;","&#932;","&#933;","&#934;","&#935;","&#936;","&#937;","&#945;","&#946;","&#947;","&#948;","&#949;","&#950;","&#951;","&#952;","&#953;","&#954;","&#955;","&#956;","&#957;","&#958;","&#959;","&#960;","&#961;","&#962;","&#963;","&#964;","&#965;","&#966;","&#967;","&#968;","&#969;","&#977;","&#978;","&#982;","&#8226;","&#8230;","&#8242;","&#8243;","&#8254;","&#8260;","&#8472;","&#8465;","&#8476;","&#8482;","&#8501;","&#8592;","&#8593;","&#8594;","&#8595;","&#8596;","&#8629;","&#8656;","&#8657;","&#8658;","&#8659;","&#8660;","&#8704;","&#8706;","&#8707;","&#8709;","&#8711;","&#8712;","&#8713;","&#8715;","&#8719;","&#8721;","&#8722;","&#8727;","&#8730;","&#8733;","&#8734;","&#8736;","&#8743;","&#8744;","&#8745;","&#8746;","&#8747;","&#8756;","&#8764;","&#8773;","&#8776;","&#8800;","&#8801;","&#8804;","&#8805;","&#8834;","&#8835;","&#8836;","&#8838;","&#8839;","&#8853;","&#8855;","&#8869;","&#8901;","&#8968;","&#8969;","&#8970;","&#8971;","&#9001;","&#9002;","&#9674;","&#9824;","&#9827;","&#9829;","&#9830;"],HTML2Numerical:function(r){return this.swapArrayVals(r,this.arr1,this.arr2)},NumericalToHTML:function(r){return this.swapArrayVals(r,this.arr2,this.arr1)},numEncode:function(r){if(this.isEmpty(r))return"";for(var e="",a=0;a<r.length;a++){var i=r.charAt(a);(" ">i||i>"~")&&(i="&#"+i.charCodeAt()+";"),e+=i}return e},htmlDecode:function(r){var e,a,i=r;if(this.isEmpty(i))return"";if(i=this.HTML2Numerical(i),arr=i.match(/&#[0-9]{1,5};/g),null!=arr)for(var t=0;t<arr.length;t++)a=arr[t],e=a.substring(2,a.length-1),i=e>=-32768&&65535>=e?i.replace(a,String.fromCharCode(e)):i.replace(a,"");return i},htmlEncode:function(r,e){return this.isEmpty(r)?"":(e=e||!1,e&&(r="numerical"==this.EncodeType?r.replace(/&/g,"&#38;"):r.replace(/&/g,"&amp;")),r=this.XSSEncode(r,!1),"numerical"!=this.EncodeType&&e||(r=this.HTML2Numerical(r)),r=this.numEncode(r),e||(r=r.replace(/&#/g,"##AMPHASH##"),r="numerical"==this.EncodeType?r.replace(/&/g,"&#38;"):r.replace(/&/g,"&amp;"),r=r.replace(/##AMPHASH##/g,"&#")),r=r.replace(/&#\d*([^\d;]|$)/g,"$1"),e||(r=this.correctEncoding(r)),"entity"==this.EncodeType&&(r=this.NumericalToHTML(r)),r)},XSSEncode:function(r,e){return this.isEmpty(r)?"":(e=e||!0,e?(r=r.replace(/\'/g,"&#39;"),r=r.replace(/\"/g,"&quot;"),r=r.replace(/</g,"&lt;"),r=r.replace(/>/g,"&gt;")):(r=r.replace(/\'/g,"&#39;"),r=r.replace(/\"/g,"&#34;"),r=r.replace(/</g,"&#60;"),r=r.replace(/>/g,"&#62;")),r)},hasEncoded:function(r){return/&#[0-9]{1,5};/g.test(r)?!0:/&[A-Z]{2,6};/gi.test(r)?!0:!1},stripUnicode:function(r){return r.replace(/[^\x20-\x7E]/g,"")},correctEncoding:function(r){return r.replace(/(&amp;)(amp;)+/,"$1")},swapArrayVals:function(r,e,a){if(this.isEmpty(r))return"";var i;if(e&&a&&e.length==a.length)for(var t=0,c=e.length;c>t;t++)i=new RegExp(e[t],"g"),r=r.replace(i,a[t]);return r},inArray:function(r,e){for(var a=0,i=e.length;i>a;a++)if(e[a]===r)return a;return-1}};
!function(e,t){"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(e,t){function n(e){var t=e.length,n=Z.type(e);return"function"===n||Z.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||0===t||"number"==typeof t&&t>0&&t-1 in e}function r(e,t,n){if(Z.isFunction(t))return Z.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return Z.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(at.test(t))return Z.filter(t,e,n);t=Z.filter(t,e)}return Z.grep(e,function(e){return U.call(t,e)>=0!==n})}function i(e,t){for(;(e=e[t])&&1!==e.nodeType;);return e}function o(e){var t=ht[e]={};return Z.each(e.match(dt)||[],function(e,n){t[n]=!0}),t}function s(){J.removeEventListener("DOMContentLoaded",s,!1),e.removeEventListener("load",s,!1),Z.ready()}function a(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=Z.expando+Math.random()}function u(e,t,n){var r;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(bt,"-$1").toLowerCase(),n=e.getAttribute(r),"string"==typeof n){try{n="true"===n?!0:"false"===n?!1:"null"===n?null:+n+""===n?+n:xt.test(n)?Z.parseJSON(n):n}catch(i){}yt.set(e,t,n)}else n=void 0;return n}function l(){return!0}function c(){return!1}function f(){try{return J.activeElement}catch(e){}}function p(e,t){return Z.nodeName(e,"table")&&Z.nodeName(11!==t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function d(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function h(e){var t=Pt.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function g(e,t){for(var n=0,r=e.length;r>n;n++)vt.set(e[n],"globalEval",!t||vt.get(t[n],"globalEval"))}function m(e,t){var n,r,i,o,s,a,u,l;if(1===t.nodeType){if(vt.hasData(e)&&(o=vt.access(e),s=vt.set(t,o),l=o.events)){delete s.handle,s.events={};for(i in l)for(n=0,r=l[i].length;r>n;n++)Z.event.add(t,i,l[i][n])}yt.hasData(e)&&(a=yt.access(e),u=Z.extend({},a),yt.set(t,u))}}function v(e,t){var n=e.getElementsByTagName?e.getElementsByTagName(t||"*"):e.querySelectorAll?e.querySelectorAll(t||"*"):[];return void 0===t||t&&Z.nodeName(e,t)?Z.merge([e],n):n}function y(e,t){var n=t.nodeName.toLowerCase();"input"===n&&Nt.test(e.type)?t.checked=e.checked:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}function x(t,n){var r,i=Z(n.createElement(t)).appendTo(n.body),o=e.getDefaultComputedStyle&&(r=e.getDefaultComputedStyle(i[0]))?r.display:Z.css(i[0],"display");return i.detach(),o}function b(e){var t=J,n=$t[e];return n||(n=x(e,t),"none"!==n&&n||(Wt=(Wt||Z("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement),t=Wt[0].contentDocument,t.write(),t.close(),n=x(e,t),Wt.detach()),$t[e]=n),n}function w(e,t,n){var r,i,o,s,a=e.style;return n=n||_t(e),n&&(s=n.getPropertyValue(t)||n[t]),n&&(""!==s||Z.contains(e.ownerDocument,e)||(s=Z.style(e,t)),It.test(s)&&Bt.test(t)&&(r=a.width,i=a.minWidth,o=a.maxWidth,a.minWidth=a.maxWidth=a.width=s,s=n.width,a.width=r,a.minWidth=i,a.maxWidth=o)),void 0!==s?s+"":s}function T(e,t){return{get:function(){return e()?void delete this.get:(this.get=t).apply(this,arguments)}}}function C(e,t){if(t in e)return t;for(var n=t[0].toUpperCase()+t.slice(1),r=t,i=Gt.length;i--;)if(t=Gt[i]+n,t in e)return t;return r}function N(e,t,n){var r=Xt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function k(e,t,n,r,i){for(var o=n===(r?"border":"content")?4:"width"===t?1:0,s=0;4>o;o+=2)"margin"===n&&(s+=Z.css(e,n+Tt[o],!0,i)),r?("content"===n&&(s-=Z.css(e,"padding"+Tt[o],!0,i)),"margin"!==n&&(s-=Z.css(e,"border"+Tt[o]+"Width",!0,i))):(s+=Z.css(e,"padding"+Tt[o],!0,i),"padding"!==n&&(s+=Z.css(e,"border"+Tt[o]+"Width",!0,i)));return s}function E(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=_t(e),s="border-box"===Z.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=w(e,t,o),(0>i||null==i)&&(i=e.style[t]),It.test(i))return i;r=s&&(Q.boxSizingReliable()||i===e.style[t]),i=parseFloat(i)||0}return i+k(e,t,n||(s?"border":"content"),r,o)+"px"}function S(e,t){for(var n,r,i,o=[],s=0,a=e.length;a>s;s++)r=e[s],r.style&&(o[s]=vt.get(r,"olddisplay"),n=r.style.display,t?(o[s]||"none"!==n||(r.style.display=""),""===r.style.display&&Ct(r)&&(o[s]=vt.access(r,"olddisplay",b(r.nodeName)))):(i=Ct(r),"none"===n&&i||vt.set(r,"olddisplay",i?n:Z.css(r,"display"))));for(s=0;a>s;s++)r=e[s],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[s]||"":"none"));return e}function j(e,t,n,r,i){return new j.prototype.init(e,t,n,r,i)}function D(){return setTimeout(function(){Qt=void 0}),Qt=Z.now()}function A(e,t){var n,r=0,i={height:e};for(t=t?1:0;4>r;r+=2-t)n=Tt[r],i["margin"+n]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function L(e,t,n){for(var r,i=(nn[t]||[]).concat(nn["*"]),o=0,s=i.length;s>o;o++)if(r=i[o].call(n,t,e))return r}function q(e,t,n){var r,i,o,s,a,u,l,c,f=this,p={},d=e.style,h=e.nodeType&&Ct(e),g=vt.get(e,"fxshow");n.queue||(a=Z._queueHooks(e,"fx"),null==a.unqueued&&(a.unqueued=0,u=a.empty.fire,a.empty.fire=function(){a.unqueued||u()}),a.unqueued++,f.always(function(){f.always(function(){a.unqueued--,Z.queue(e,"fx").length||a.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[d.overflow,d.overflowX,d.overflowY],l=Z.css(e,"display"),c="none"===l?vt.get(e,"olddisplay")||b(e.nodeName):l,"inline"===c&&"none"===Z.css(e,"float")&&(d.display="inline-block")),n.overflow&&(d.overflow="hidden",f.always(function(){d.overflow=n.overflow[0],d.overflowX=n.overflow[1],d.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Kt.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(h?"hide":"show")){if("show"!==i||!g||void 0===g[r])continue;h=!0}p[r]=g&&g[r]||Z.style(e,r)}else l=void 0;if(Z.isEmptyObject(p))"inline"===("none"===l?b(e.nodeName):l)&&(d.display=l);else{g?"hidden"in g&&(h=g.hidden):g=vt.access(e,"fxshow",{}),o&&(g.hidden=!h),h?Z(e).show():f.done(function(){Z(e).hide()}),f.done(function(){var t;vt.remove(e,"fxshow");for(t in p)Z.style(e,t,p[t])});for(r in p)s=L(h?g[r]:0,r,f),r in g||(g[r]=s.start,h&&(s.end=s.start,s.start="width"===r||"height"===r?1:0))}}function H(e,t){var n,r,i,o,s;for(n in e)if(r=Z.camelCase(n),i=t[r],o=e[n],Z.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),s=Z.cssHooks[r],s&&"expand"in s){o=s.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}function O(e,t,n){var r,i,o=0,s=tn.length,a=Z.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;for(var t=Qt||D(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,s=0,u=l.tweens.length;u>s;s++)l.tweens[s].run(o);return a.notifyWith(e,[l,o,n]),1>o&&u?n:(a.resolveWith(e,[l]),!1)},l=a.promise({elem:e,props:Z.extend({},t),opts:Z.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Qt||D(),duration:n.duration,tweens:[],createTween:function(t,n){var r=Z.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?a.resolveWith(e,[l,t]):a.rejectWith(e,[l,t]),this}}),c=l.props;for(H(c,l.opts.specialEasing);s>o;o++)if(r=tn[o].call(l,e,c,l.opts))return r;return Z.map(c,L,l),Z.isFunction(l.opts.start)&&l.opts.start.call(e,l),Z.fx.timer(Z.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function F(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(dt)||[];if(Z.isFunction(n))for(;r=o[i++];)"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function P(e,t,n,r){function i(a){var u;return o[a]=!0,Z.each(e[a]||[],function(e,a){var l=a(t,n,r);return"string"!=typeof l||s||o[l]?s?!(u=l):void 0:(t.dataTypes.unshift(l),i(l),!1)}),u}var o={},s=e===Tn;return i(t.dataTypes[0])||!o["*"]&&i("*")}function M(e,t){var n,r,i=Z.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&Z.extend(!0,e,r),e}function R(e,t,n){for(var r,i,o,s,a=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in a)if(a[i]&&a[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}s||(s=i)}o=o||s}return o?(o!==u[0]&&u.unshift(o),n[o]):void 0}function W(e,t,n,r){var i,o,s,a,u,l={},c=e.dataTypes.slice();if(c[1])for(s in e.converters)l[s.toLowerCase()]=e.converters[s];for(o=c.shift();o;)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(s=l[u+" "+o]||l["* "+o],!s)for(i in l)if(a=i.split(" "),a[1]===o&&(s=l[u+" "+a[0]]||l["* "+a[0]])){s===!0?s=l[i]:l[i]!==!0&&(o=a[0],c.unshift(a[1]));break}if(s!==!0)if(s&&e["throws"])t=s(t);else try{t=s(t)}catch(f){return{state:"parsererror",error:s?f:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}function $(e,t,n,r){var i;if(Z.isArray(t))Z.each(t,function(t,i){n||En.test(e)?r(e,i):$(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==Z.type(t))r(e,t);else for(i in t)$(e+"["+i+"]",t[i],n,r)}function B(e){return Z.isWindow(e)?e:9===e.nodeType&&e.defaultView}var I=[],_=I.slice,z=I.concat,X=I.push,U=I.indexOf,V={},Y=V.toString,G=V.hasOwnProperty,Q={},J=e.document,K="2.1.1",Z=function(e,t){return new Z.fn.init(e,t)},et=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,tt=/^-ms-/,nt=/-([\da-z])/gi,rt=function(e,t){return t.toUpperCase()};Z.fn=Z.prototype={jquery:K,constructor:Z,selector:"",length:0,toArray:function(){return _.call(this)},get:function(e){return null!=e?0>e?this[e+this.length]:this[e]:_.call(this)},pushStack:function(e){var t=Z.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return Z.each(this,e,t)},map:function(e){return this.pushStack(Z.map(this,function(t,n){return e.call(t,n,t)}))},slice:function(){return this.pushStack(_.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:X,sort:I.sort,splice:I.splice},Z.extend=Z.fn.extend=function(){var e,t,n,r,i,o,s=arguments[0]||{},a=1,u=arguments.length,l=!1;for("boolean"==typeof s&&(l=s,s=arguments[a]||{},a++),"object"==typeof s||Z.isFunction(s)||(s={}),a===u&&(s=this,a--);u>a;a++)if(null!=(e=arguments[a]))for(t in e)n=s[t],r=e[t],s!==r&&(l&&r&&(Z.isPlainObject(r)||(i=Z.isArray(r)))?(i?(i=!1,o=n&&Z.isArray(n)?n:[]):o=n&&Z.isPlainObject(n)?n:{},s[t]=Z.extend(l,o,r)):void 0!==r&&(s[t]=r));return s},Z.extend({expando:"jQuery"+(K+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isFunction:function(e){return"function"===Z.type(e)},isArray:Array.isArray,isWindow:function(e){return null!=e&&e===e.window},isNumeric:function(e){return!Z.isArray(e)&&e-parseFloat(e)>=0},isPlainObject:function(e){return"object"!==Z.type(e)||e.nodeType||Z.isWindow(e)?!1:e.constructor&&!G.call(e.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?V[Y.call(e)]||"object":typeof e},globalEval:function(e){var t,n=eval;e=Z.trim(e),e&&(1===e.indexOf("use strict")?(t=J.createElement("script"),t.text=e,J.head.appendChild(t).parentNode.removeChild(t)):n(e))},camelCase:function(e){return e.replace(tt,"ms-").replace(nt,rt)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,r){var i,o=0,s=e.length,a=n(e);if(r){if(a)for(;s>o&&(i=t.apply(e[o],r),i!==!1);o++);else for(o in e)if(i=t.apply(e[o],r),i===!1)break}else if(a)for(;s>o&&(i=t.call(e[o],o,e[o]),i!==!1);o++);else for(o in e)if(i=t.call(e[o],o,e[o]),i===!1)break;return e},trim:function(e){return null==e?"":(e+"").replace(et,"")},makeArray:function(e,t){var r=t||[];return null!=e&&(n(Object(e))?Z.merge(r,"string"==typeof e?[e]:e):X.call(r,e)),r},inArray:function(e,t,n){return null==t?-1:U.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;n>r;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r,i=[],o=0,s=e.length,a=!n;s>o;o++)r=!t(e[o],o),r!==a&&i.push(e[o]);return i},map:function(e,t,r){var i,o=0,s=e.length,a=n(e),u=[];if(a)for(;s>o;o++)i=t(e[o],o,r),null!=i&&u.push(i);else for(o in e)i=t(e[o],o,r),null!=i&&u.push(i);return z.apply([],u)},guid:1,proxy:function(e,t){var n,r,i;return"string"==typeof t&&(n=e[t],t=e,e=n),Z.isFunction(e)?(r=_.call(arguments,2),i=function(){return e.apply(t||this,r.concat(_.call(arguments)))},i.guid=e.guid=e.guid||Z.guid++,i):void 0},now:Date.now,support:Q}),Z.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){V["[object "+t+"]"]=t.toLowerCase()});var it=function(e){function t(e,t,n,r){var i,o,s,a,u,l,f,d,h,g;if((t?t.ownerDocument||t:$)!==q&&L(t),t=t||q,n=n||[],!e||"string"!=typeof e)return n;if(1!==(a=t.nodeType)&&9!==a)return[];if(O&&!r){if(i=yt.exec(e))if(s=i[1]){if(9===a){if(o=t.getElementById(s),!o||!o.parentNode)return n;if(o.id===s)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(s))&&R(t,o)&&o.id===s)return n.push(o),n}else{if(i[2])return Z.apply(n,t.getElementsByTagName(e)),n;if((s=i[3])&&w.getElementsByClassName&&t.getElementsByClassName)return Z.apply(n,t.getElementsByClassName(s)),n}if(w.qsa&&(!F||!F.test(e))){if(d=f=W,h=t,g=9===a&&e,1===a&&"object"!==t.nodeName.toLowerCase()){for(l=k(e),(f=t.getAttribute("id"))?d=f.replace(bt,"\\$&"):t.setAttribute("id",d),d="[id='"+d+"'] ",u=l.length;u--;)l[u]=d+p(l[u]);h=xt.test(e)&&c(t.parentNode)||t,g=l.join(",")}if(g)try{return Z.apply(n,h.querySelectorAll(g)),n}catch(m){}finally{f||t.removeAttribute("id")}}}return S(e.replace(ut,"$1"),t,n,r)}function n(){function e(n,r){return t.push(n+" ")>T.cacheLength&&delete e[t.shift()],e[n+" "]=r}var t=[];return e}function r(e){return e[W]=!0,e}function i(e){var t=q.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function o(e,t){for(var n=e.split("|"),r=e.length;r--;)T.attrHandle[n[r]]=t}function s(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||Y)-(~e.sourceIndex||Y);if(r)return r;if(n)for(;n=n.nextSibling;)if(n===t)return-1;return e?1:-1}function a(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function u(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function l(e){return r(function(t){return t=+t,r(function(n,r){for(var i,o=e([],n.length,t),s=o.length;s--;)n[i=o[s]]&&(n[i]=!(r[i]=n[i]))})})}function c(e){return e&&typeof e.getElementsByTagName!==V&&e}function f(){}function p(e){for(var t=0,n=e.length,r="";n>t;t++)r+=e[t].value;return r}function d(e,t,n){var r=t.dir,i=n&&"parentNode"===r,o=I++;return t.first?function(t,n,o){for(;t=t[r];)if(1===t.nodeType||i)return e(t,n,o)}:function(t,n,s){var a,u,l=[B,o];if(s){for(;t=t[r];)if((1===t.nodeType||i)&&e(t,n,s))return!0}else for(;t=t[r];)if(1===t.nodeType||i){if(u=t[W]||(t[W]={}),(a=u[r])&&a[0]===B&&a[1]===o)return l[2]=a[2];if(u[r]=l,l[2]=e(t,n,s))return!0}}}function h(e){return e.length>1?function(t,n,r){for(var i=e.length;i--;)if(!e[i](t,n,r))return!1;return!0}:e[0]}function g(e,n,r){for(var i=0,o=n.length;o>i;i++)t(e,n[i],r);return r}function m(e,t,n,r,i){for(var o,s=[],a=0,u=e.length,l=null!=t;u>a;a++)(o=e[a])&&(!n||n(o,r,i))&&(s.push(o),l&&t.push(a));return s}function v(e,t,n,i,o,s){return i&&!i[W]&&(i=v(i)),o&&!o[W]&&(o=v(o,s)),r(function(r,s,a,u){var l,c,f,p=[],d=[],h=s.length,v=r||g(t||"*",a.nodeType?[a]:a,[]),y=!e||!r&&t?v:m(v,p,e,a,u),x=n?o||(r?e:h||i)?[]:s:y;if(n&&n(y,x,a,u),i)for(l=m(x,d),i(l,[],a,u),c=l.length;c--;)(f=l[c])&&(x[d[c]]=!(y[d[c]]=f));if(r){if(o||e){if(o){for(l=[],c=x.length;c--;)(f=x[c])&&l.push(y[c]=f);o(null,x=[],l,u)}for(c=x.length;c--;)(f=x[c])&&(l=o?tt.call(r,f):p[c])>-1&&(r[l]=!(s[l]=f))}}else x=m(x===s?x.splice(h,x.length):x),o?o(null,s,x,u):Z.apply(s,x)})}function y(e){for(var t,n,r,i=e.length,o=T.relative[e[0].type],s=o||T.relative[" "],a=o?1:0,u=d(function(e){return e===t},s,!0),l=d(function(e){return tt.call(t,e)>-1},s,!0),c=[function(e,n,r){return!o&&(r||n!==j)||((t=n).nodeType?u(e,n,r):l(e,n,r))}];i>a;a++)if(n=T.relative[e[a].type])c=[d(h(c),n)];else{if(n=T.filter[e[a].type].apply(null,e[a].matches),n[W]){for(r=++a;i>r&&!T.relative[e[r].type];r++);return v(a>1&&h(c),a>1&&p(e.slice(0,a-1).concat({value:" "===e[a-2].type?"*":""})).replace(ut,"$1"),n,r>a&&y(e.slice(a,r)),i>r&&y(e=e.slice(r)),i>r&&p(e))}c.push(n)}return h(c)}function x(e,n){var i=n.length>0,o=e.length>0,s=function(r,s,a,u,l){var c,f,p,d=0,h="0",g=r&&[],v=[],y=j,x=r||o&&T.find.TAG("*",l),b=B+=null==y?1:Math.random()||.1,w=x.length;for(l&&(j=s!==q&&s);h!==w&&null!=(c=x[h]);h++){if(o&&c){for(f=0;p=e[f++];)if(p(c,s,a)){u.push(c);break}l&&(B=b)}i&&((c=!p&&c)&&d--,r&&g.push(c))}if(d+=h,i&&h!==d){for(f=0;p=n[f++];)p(g,v,s,a);if(r){if(d>0)for(;h--;)g[h]||v[h]||(v[h]=J.call(u));v=m(v)}Z.apply(u,v),l&&!r&&v.length>0&&d+n.length>1&&t.uniqueSort(u)}return l&&(B=b,j=y),g};return i?r(s):s}var b,w,T,C,N,k,E,S,j,D,A,L,q,H,O,F,P,M,R,W="sizzle"+-new Date,$=e.document,B=0,I=0,_=n(),z=n(),X=n(),U=function(e,t){return e===t&&(A=!0),0},V="undefined",Y=1<<31,G={}.hasOwnProperty,Q=[],J=Q.pop,K=Q.push,Z=Q.push,et=Q.slice,tt=Q.indexOf||function(e){for(var t=0,n=this.length;n>t;t++)if(this[t]===e)return t;return-1},nt="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",rt="[\\x20\\t\\r\\n\\f]",it="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",ot=it.replace("w","w#"),st="\\["+rt+"*("+it+")(?:"+rt+"*([*^$|!~]?=)"+rt+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+ot+"))|)"+rt+"*\\]",at=":("+it+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+st+")*)|.*)\\)|)",ut=new RegExp("^"+rt+"+|((?:^|[^\\\\])(?:\\\\.)*)"+rt+"+$","g"),lt=new RegExp("^"+rt+"*,"+rt+"*"),ct=new RegExp("^"+rt+"*([>+~]|"+rt+")"+rt+"*"),ft=new RegExp("="+rt+"*([^\\]'\"]*?)"+rt+"*\\]","g"),pt=new RegExp(at),dt=new RegExp("^"+ot+"$"),ht={ID:new RegExp("^#("+it+")"),CLASS:new RegExp("^\\.("+it+")"),TAG:new RegExp("^("+it.replace("w","w*")+")"),ATTR:new RegExp("^"+st),PSEUDO:new RegExp("^"+at),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+rt+"*(even|odd|(([+-]|)(\\d*)n|)"+rt+"*(?:([+-]|)"+rt+"*(\\d+)|))"+rt+"*\\)|)","i"),bool:new RegExp("^(?:"+nt+")$","i"),needsContext:new RegExp("^"+rt+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+rt+"*((?:-\\d)?\\d*)"+rt+"*\\)|)(?=[^-]|$)","i")},gt=/^(?:input|select|textarea|button)$/i,mt=/^h\d$/i,vt=/^[^{]+\{\s*\[native \w/,yt=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,xt=/[+~]/,bt=/'|\\/g,wt=new RegExp("\\\\([\\da-f]{1,6}"+rt+"?|("+rt+")|.)","ig"),Tt=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)};try{Z.apply(Q=et.call($.childNodes),$.childNodes),Q[$.childNodes.length].nodeType}catch(Ct){Z={apply:Q.length?function(e,t){K.apply(e,et.call(t))}:function(e,t){for(var n=e.length,r=0;e[n++]=t[r++];);e.length=n-1}}}w=t.support={},N=t.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},L=t.setDocument=function(e){var t,n=e?e.ownerDocument||e:$,r=n.defaultView;return n!==q&&9===n.nodeType&&n.documentElement?(q=n,H=n.documentElement,O=!N(n),r&&r!==r.top&&(r.addEventListener?r.addEventListener("unload",function(){L()},!1):r.attachEvent&&r.attachEvent("onunload",function(){L()})),w.attributes=i(function(e){return e.className="i",!e.getAttribute("className")}),w.getElementsByTagName=i(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),w.getElementsByClassName=vt.test(n.getElementsByClassName)&&i(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),w.getById=i(function(e){return H.appendChild(e).id=W,!n.getElementsByName||!n.getElementsByName(W).length}),w.getById?(T.find.ID=function(e,t){if(typeof t.getElementById!==V&&O){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},T.filter.ID=function(e){var t=e.replace(wt,Tt);return function(e){return e.getAttribute("id")===t}}):(delete T.find.ID,T.filter.ID=function(e){var t=e.replace(wt,Tt);return function(e){var n=typeof e.getAttributeNode!==V&&e.getAttributeNode("id");return n&&n.value===t}}),T.find.TAG=w.getElementsByTagName?function(e,t){return typeof t.getElementsByTagName!==V?t.getElementsByTagName(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){for(;n=o[i++];)1===n.nodeType&&r.push(n);return r}return o},T.find.CLASS=w.getElementsByClassName&&function(e,t){return typeof t.getElementsByClassName!==V&&O?t.getElementsByClassName(e):void 0},P=[],F=[],(w.qsa=vt.test(n.querySelectorAll))&&(i(function(e){e.innerHTML="<select msallowclip=''><option selected=''></option></select>",e.querySelectorAll("[msallowclip^='']").length&&F.push("[*^$]="+rt+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||F.push("\\["+rt+"*(?:value|"+nt+")"),e.querySelectorAll(":checked").length||F.push(":checked")}),i(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&F.push("name"+rt+"*[*^$|!~]?="),e.querySelectorAll(":enabled").length||F.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),F.push(",.*:")})),(w.matchesSelector=vt.test(M=H.matches||H.webkitMatchesSelector||H.mozMatchesSelector||H.oMatchesSelector||H.msMatchesSelector))&&i(function(e){w.disconnectedMatch=M.call(e,"div"),M.call(e,"[s!='']:x"),P.push("!=",at)}),F=F.length&&new RegExp(F.join("|")),P=P.length&&new RegExp(P.join("|")),t=vt.test(H.compareDocumentPosition),R=t||vt.test(H.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)for(;t=t.parentNode;)if(t===e)return!0;return!1},U=t?function(e,t){if(e===t)return A=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r?r:(r=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1,1&r||!w.sortDetached&&t.compareDocumentPosition(e)===r?e===n||e.ownerDocument===$&&R($,e)?-1:t===n||t.ownerDocument===$&&R($,t)?1:D?tt.call(D,e)-tt.call(D,t):0:4&r?-1:1)}:function(e,t){if(e===t)return A=!0,0;var r,i=0,o=e.parentNode,a=t.parentNode,u=[e],l=[t];if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:D?tt.call(D,e)-tt.call(D,t):0;if(o===a)return s(e,t);for(r=e;r=r.parentNode;)u.unshift(r);for(r=t;r=r.parentNode;)l.unshift(r);for(;u[i]===l[i];)i++;return i?s(u[i],l[i]):u[i]===$?-1:l[i]===$?1:0},n):q},t.matches=function(e,n){return t(e,null,null,n)},t.matchesSelector=function(e,n){if((e.ownerDocument||e)!==q&&L(e),n=n.replace(ft,"='$1']"),!(!w.matchesSelector||!O||P&&P.test(n)||F&&F.test(n)))try{var r=M.call(e,n);if(r||w.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(i){}return t(n,q,null,[e]).length>0},t.contains=function(e,t){return(e.ownerDocument||e)!==q&&L(e),R(e,t)},t.attr=function(e,t){(e.ownerDocument||e)!==q&&L(e);var n=T.attrHandle[t.toLowerCase()],r=n&&G.call(T.attrHandle,t.toLowerCase())?n(e,t,!O):void 0;return void 0!==r?r:w.attributes||!O?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},t.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},t.uniqueSort=function(e){var t,n=[],r=0,i=0;if(A=!w.detectDuplicates,D=!w.sortStable&&e.slice(0),e.sort(U),A){for(;t=e[i++];)t===e[i]&&(r=n.push(i));for(;r--;)e.splice(n[r],1)}return D=null,e},C=t.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=C(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r++];)n+=C(t);return n},T=t.selectors={cacheLength:50,createPseudo:r,match:ht,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(wt,Tt),e[3]=(e[3]||e[4]||e[5]||"").replace(wt,Tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||t.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&t.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return ht.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&pt.test(n)&&(t=k(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(wt,Tt).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=_[e+" "];return t||(t=new RegExp("(^|"+rt+")"+e+"("+rt+"|$)"))&&_(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==V&&e.getAttribute("class")||"")})},ATTR:function(e,n,r){return function(i){var o=t.attr(i,e);return null==o?"!="===n:n?(o+="","="===n?o===r:"!="===n?o!==r:"^="===n?r&&0===o.indexOf(r):"*="===n?r&&o.indexOf(r)>-1:"$="===n?r&&o.slice(-r.length)===r:"~="===n?(" "+o+" ").indexOf(r)>-1:"|="===n?o===r||o.slice(0,r.length+1)===r+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),s="last"!==e.slice(-4),a="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,f,p,d,h,g=o!==s?"nextSibling":"previousSibling",m=t.parentNode,v=a&&t.nodeName.toLowerCase(),y=!u&&!a;if(m){if(o){for(;g;){for(f=t;f=f[g];)if(a?f.nodeName.toLowerCase()===v:1===f.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[s?m.firstChild:m.lastChild],s&&y){for(c=m[W]||(m[W]={}),l=c[e]||[],d=l[0]===B&&l[1],p=l[0]===B&&l[2],f=d&&m.childNodes[d];f=++d&&f&&f[g]||(p=d=0)||h.pop();)if(1===f.nodeType&&++p&&f===t){c[e]=[B,d,p];break}}else if(y&&(l=(t[W]||(t[W]={}))[e])&&l[0]===B)p=l[1];else for(;(f=++d&&f&&f[g]||(p=d=0)||h.pop())&&((a?f.nodeName.toLowerCase()!==v:1!==f.nodeType)||!++p||(y&&((f[W]||(f[W]={}))[e]=[B,p]),f!==t)););return p-=i,p===r||p%r===0&&p/r>=0}}},PSEUDO:function(e,n){var i,o=T.pseudos[e]||T.setFilters[e.toLowerCase()]||t.error("unsupported pseudo: "+e);return o[W]?o(n):o.length>1?(i=[e,e,"",n],T.setFilters.hasOwnProperty(e.toLowerCase())?r(function(e,t){for(var r,i=o(e,n),s=i.length;s--;)r=tt.call(e,i[s]),e[r]=!(t[r]=i[s])}):function(e){return o(e,0,i)}):o}},pseudos:{not:r(function(e){var t=[],n=[],i=E(e.replace(ut,"$1"));return i[W]?r(function(e,t,n,r){for(var o,s=i(e,null,r,[]),a=e.length;a--;)(o=s[a])&&(e[a]=!(t[a]=o))}):function(e,r,o){return t[0]=e,i(t,null,o,n),!n.pop()}}),has:r(function(e){return function(n){return t(e,n).length>0}}),contains:r(function(e){return function(t){return(t.textContent||t.innerText||C(t)).indexOf(e)>-1}}),lang:r(function(e){return dt.test(e||"")||t.error("unsupported lang: "+e),e=e.replace(wt,Tt).toLowerCase(),function(t){var n;do if(n=O?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===H},focus:function(e){return e===q.activeElement&&(!q.hasFocus||q.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!T.pseudos.empty(e)},header:function(e){return mt.test(e.nodeName)},input:function(e){return gt.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:l(function(){return[0]}),last:l(function(e,t){return[t-1]}),eq:l(function(e,t,n){return[0>n?n+t:n]}),even:l(function(e,t){for(var n=0;t>n;n+=2)e.push(n);return e}),odd:l(function(e,t){for(var n=1;t>n;n+=2)e.push(n);return e}),lt:l(function(e,t,n){for(var r=0>n?n+t:n;--r>=0;)e.push(r);return e}),gt:l(function(e,t,n){for(var r=0>n?n+t:n;++r<t;)e.push(r);return e})}},T.pseudos.nth=T.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})T.pseudos[b]=a(b);for(b in{submit:!0,reset:!0})T.pseudos[b]=u(b);return f.prototype=T.filters=T.pseudos,T.setFilters=new f,k=t.tokenize=function(e,n){var r,i,o,s,a,u,l,c=z[e+" "];if(c)return n?0:c.slice(0);for(a=e,u=[],l=T.preFilter;a;){(!r||(i=lt.exec(a)))&&(i&&(a=a.slice(i[0].length)||a),u.push(o=[])),r=!1,(i=ct.exec(a))&&(r=i.shift(),o.push({value:r,type:i[0].replace(ut," ")}),a=a.slice(r.length));for(s in T.filter)!(i=ht[s].exec(a))||l[s]&&!(i=l[s](i))||(r=i.shift(),o.push({value:r,type:s,matches:i}),a=a.slice(r.length));if(!r)break}return n?a.length:a?t.error(e):z(e,u).slice(0)},E=t.compile=function(e,t){var n,r=[],i=[],o=X[e+" "];if(!o){for(t||(t=k(e)),n=t.length;n--;)o=y(t[n]),o[W]?r.push(o):i.push(o);o=X(e,x(i,r)),o.selector=e}return o},S=t.select=function(e,t,n,r){var i,o,s,a,u,l="function"==typeof e&&e,f=!r&&k(e=l.selector||e);if(n=n||[],1===f.length){if(o=f[0]=f[0].slice(0),o.length>2&&"ID"===(s=o[0]).type&&w.getById&&9===t.nodeType&&O&&T.relative[o[1].type]){if(t=(T.find.ID(s.matches[0].replace(wt,Tt),t)||[])[0],!t)return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}for(i=ht.needsContext.test(e)?0:o.length;i--&&(s=o[i],!T.relative[a=s.type]);)if((u=T.find[a])&&(r=u(s.matches[0].replace(wt,Tt),xt.test(o[0].type)&&c(t.parentNode)||t))){if(o.splice(i,1),e=r.length&&p(o),!e)return Z.apply(n,r),n;break}}return(l||E(e,f))(r,t,!O,n,xt.test(e)&&c(t.parentNode)||t),n},w.sortStable=W.split("").sort(U).join("")===W,w.detectDuplicates=!!A,L(),w.sortDetached=i(function(e){return 1&e.compareDocumentPosition(q.createElement("div"))}),i(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||o("type|href|height|width",function(e,t,n){return n?void 0:e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),w.attributes&&i(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||o("value",function(e,t,n){return n||"input"!==e.nodeName.toLowerCase()?void 0:e.defaultValue}),i(function(e){return null==e.getAttribute("disabled")})||o(nt,function(e,t,n){var r;return n?void 0:e[t]===!0?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),t}(e);Z.find=it,Z.expr=it.selectors,Z.expr[":"]=Z.expr.pseudos,Z.unique=it.uniqueSort,Z.text=it.getText,Z.isXMLDoc=it.isXML,Z.contains=it.contains;var ot=Z.expr.match.needsContext,st=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,at=/^.[^:#\[\.,]*$/;Z.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?Z.find.matchesSelector(r,e)?[r]:[]:Z.find.matches(e,Z.grep(t,function(e){return 1===e.nodeType}))},Z.fn.extend({find:function(e){var t,n=this.length,r=[],i=this;if("string"!=typeof e)return this.pushStack(Z(e).filter(function(){for(t=0;n>t;t++)if(Z.contains(i[t],this))return!0
}));for(t=0;n>t;t++)Z.find(e,i[t],r);return r=this.pushStack(n>1?Z.unique(r):r),r.selector=this.selector?this.selector+" "+e:e,r},filter:function(e){return this.pushStack(r(this,e||[],!1))},not:function(e){return this.pushStack(r(this,e||[],!0))},is:function(e){return!!r(this,"string"==typeof e&&ot.test(e)?Z(e):e||[],!1).length}});var ut,lt=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,ct=Z.fn.init=function(e,t){var n,r;if(!e)return this;if("string"==typeof e){if(n="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:lt.exec(e),!n||!n[1]&&t)return!t||t.jquery?(t||ut).find(e):this.constructor(t).find(e);if(n[1]){if(t=t instanceof Z?t[0]:t,Z.merge(this,Z.parseHTML(n[1],t&&t.nodeType?t.ownerDocument||t:J,!0)),st.test(n[1])&&Z.isPlainObject(t))for(n in t)Z.isFunction(this[n])?this[n](t[n]):this.attr(n,t[n]);return this}return r=J.getElementById(n[2]),r&&r.parentNode&&(this.length=1,this[0]=r),this.context=J,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):Z.isFunction(e)?"undefined"!=typeof ut.ready?ut.ready(e):e(Z):(void 0!==e.selector&&(this.selector=e.selector,this.context=e.context),Z.makeArray(e,this))};ct.prototype=Z.fn,ut=Z(J);var ft=/^(?:parents|prev(?:Until|All))/,pt={children:!0,contents:!0,next:!0,prev:!0};Z.extend({dir:function(e,t,n){for(var r=[],i=void 0!==n;(e=e[t])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&Z(e).is(n))break;r.push(e)}return r},sibling:function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}}),Z.fn.extend({has:function(e){var t=Z(e,this),n=t.length;return this.filter(function(){for(var e=0;n>e;e++)if(Z.contains(this,t[e]))return!0})},closest:function(e,t){for(var n,r=0,i=this.length,o=[],s=ot.test(e)||"string"!=typeof e?Z(e,t||this.context):0;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(s?s.index(n)>-1:1===n.nodeType&&Z.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(o.length>1?Z.unique(o):o)},index:function(e){return e?"string"==typeof e?U.call(Z(e),this[0]):U.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(Z.unique(Z.merge(this.get(),Z(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),Z.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return Z.dir(e,"parentNode")},parentsUntil:function(e,t,n){return Z.dir(e,"parentNode",n)},next:function(e){return i(e,"nextSibling")},prev:function(e){return i(e,"previousSibling")},nextAll:function(e){return Z.dir(e,"nextSibling")},prevAll:function(e){return Z.dir(e,"previousSibling")},nextUntil:function(e,t,n){return Z.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return Z.dir(e,"previousSibling",n)},siblings:function(e){return Z.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return Z.sibling(e.firstChild)},contents:function(e){return e.contentDocument||Z.merge([],e.childNodes)}},function(e,t){Z.fn[e]=function(n,r){var i=Z.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=Z.filter(r,i)),this.length>1&&(pt[e]||Z.unique(i),ft.test(e)&&i.reverse()),this.pushStack(i)}});var dt=/\S+/g,ht={};Z.Callbacks=function(e){e="string"==typeof e?ht[e]||o(e):Z.extend({},e);var t,n,r,i,s,a,u=[],l=!e.once&&[],c=function(o){for(t=e.memory&&o,n=!0,a=i||0,i=0,s=u.length,r=!0;u&&s>a;a++)if(u[a].apply(o[0],o[1])===!1&&e.stopOnFalse){t=!1;break}r=!1,u&&(l?l.length&&c(l.shift()):t?u=[]:f.disable())},f={add:function(){if(u){var n=u.length;!function o(t){Z.each(t,function(t,n){var r=Z.type(n);"function"===r?e.unique&&f.has(n)||u.push(n):n&&n.length&&"string"!==r&&o(n)})}(arguments),r?s=u.length:t&&(i=n,c(t))}return this},remove:function(){return u&&Z.each(arguments,function(e,t){for(var n;(n=Z.inArray(t,u,n))>-1;)u.splice(n,1),r&&(s>=n&&s--,a>=n&&a--)}),this},has:function(e){return e?Z.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],s=0,this},disable:function(){return u=l=t=void 0,this},disabled:function(){return!u},lock:function(){return l=void 0,t||f.disable(),this},locked:function(){return!l},fireWith:function(e,t){return!u||n&&!l||(t=t||[],t=[e,t.slice?t.slice():t],r?l.push(t):c(t)),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!n}};return f},Z.extend({Deferred:function(e){var t=[["resolve","done",Z.Callbacks("once memory"),"resolved"],["reject","fail",Z.Callbacks("once memory"),"rejected"],["notify","progress",Z.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return Z.Deferred(function(n){Z.each(t,function(t,o){var s=Z.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&Z.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[o[0]+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?Z.extend(e,r):r}},i={};return r.pipe=r.then,Z.each(t,function(e,o){var s=o[2],a=o[3];r[o[1]]=s.add,a&&s.add(function(){n=a},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=s.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t,n,r,i=0,o=_.call(arguments),s=o.length,a=1!==s||e&&Z.isFunction(e.promise)?s:0,u=1===a?e:Z.Deferred(),l=function(e,n,r){return function(i){n[e]=this,r[e]=arguments.length>1?_.call(arguments):i,r===t?u.notifyWith(n,r):--a||u.resolveWith(n,r)}};if(s>1)for(t=new Array(s),n=new Array(s),r=new Array(s);s>i;i++)o[i]&&Z.isFunction(o[i].promise)?o[i].promise().done(l(i,r,o)).fail(u.reject).progress(l(i,n,t)):--a;return a||u.resolveWith(r,o),u.promise()}});var gt;Z.fn.ready=function(e){return Z.ready.promise().done(e),this},Z.extend({isReady:!1,readyWait:1,holdReady:function(e){e?Z.readyWait++:Z.ready(!0)},ready:function(e){(e===!0?--Z.readyWait:Z.isReady)||(Z.isReady=!0,e!==!0&&--Z.readyWait>0||(gt.resolveWith(J,[Z]),Z.fn.triggerHandler&&(Z(J).triggerHandler("ready"),Z(J).off("ready"))))}}),Z.ready.promise=function(t){return gt||(gt=Z.Deferred(),"complete"===J.readyState?setTimeout(Z.ready):(J.addEventListener("DOMContentLoaded",s,!1),e.addEventListener("load",s,!1))),gt.promise(t)},Z.ready.promise();var mt=Z.access=function(e,t,n,r,i,o,s){var a=0,u=e.length,l=null==n;if("object"===Z.type(n)){i=!0;for(a in n)Z.access(e,t,a,n[a],!0,o,s)}else if(void 0!==r&&(i=!0,Z.isFunction(r)||(s=!0),l&&(s?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(Z(e),n)})),t))for(;u>a;a++)t(e[a],n,s?r:r.call(e[a],a,t(e[a],n)));return i?e:l?t.call(e):u?t(e[0],n):o};Z.acceptData=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType},a.uid=1,a.accepts=Z.acceptData,a.prototype={key:function(e){if(!a.accepts(e))return 0;var t={},n=e[this.expando];if(!n){n=a.uid++;try{t[this.expando]={value:n},Object.defineProperties(e,t)}catch(r){t[this.expando]=n,Z.extend(e,t)}}return this.cache[n]||(this.cache[n]={}),n},set:function(e,t,n){var r,i=this.key(e),o=this.cache[i];if("string"==typeof t)o[t]=n;else if(Z.isEmptyObject(o))Z.extend(this.cache[i],t);else for(r in t)o[r]=t[r];return o},get:function(e,t){var n=this.cache[this.key(e)];return void 0===t?n:n[t]},access:function(e,t,n){var r;return void 0===t||t&&"string"==typeof t&&void 0===n?(r=this.get(e,t),void 0!==r?r:this.get(e,Z.camelCase(t))):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r,i,o=this.key(e),s=this.cache[o];if(void 0===t)this.cache[o]={};else{Z.isArray(t)?r=t.concat(t.map(Z.camelCase)):(i=Z.camelCase(t),t in s?r=[t,i]:(r=i,r=r in s?[r]:r.match(dt)||[])),n=r.length;for(;n--;)delete s[r[n]]}},hasData:function(e){return!Z.isEmptyObject(this.cache[e[this.expando]]||{})},discard:function(e){e[this.expando]&&delete this.cache[e[this.expando]]}};var vt=new a,yt=new a,xt=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,bt=/([A-Z])/g;Z.extend({hasData:function(e){return yt.hasData(e)||vt.hasData(e)},data:function(e,t,n){return yt.access(e,t,n)},removeData:function(e,t){yt.remove(e,t)},_data:function(e,t,n){return vt.access(e,t,n)},_removeData:function(e,t){vt.remove(e,t)}}),Z.fn.extend({data:function(e,t){var n,r,i,o=this[0],s=o&&o.attributes;if(void 0===e){if(this.length&&(i=yt.get(o),1===o.nodeType&&!vt.get(o,"hasDataAttrs"))){for(n=s.length;n--;)s[n]&&(r=s[n].name,0===r.indexOf("data-")&&(r=Z.camelCase(r.slice(5)),u(o,r,i[r])));vt.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each(function(){yt.set(this,e)}):mt(this,function(t){var n,r=Z.camelCase(e);if(o&&void 0===t){if(n=yt.get(o,e),void 0!==n)return n;if(n=yt.get(o,r),void 0!==n)return n;if(n=u(o,r,void 0),void 0!==n)return n}else this.each(function(){var n=yt.get(this,r);yt.set(this,r,t),-1!==e.indexOf("-")&&void 0!==n&&yt.set(this,e,t)})},null,t,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){yt.remove(this,e)})}}),Z.extend({queue:function(e,t,n){var r;return e?(t=(t||"fx")+"queue",r=vt.get(e,t),n&&(!r||Z.isArray(n)?r=vt.access(e,t,Z.makeArray(n)):r.push(n)),r||[]):void 0},dequeue:function(e,t){t=t||"fx";var n=Z.queue(e,t),r=n.length,i=n.shift(),o=Z._queueHooks(e,t),s=function(){Z.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,s,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return vt.get(e,n)||vt.access(e,n,{empty:Z.Callbacks("once memory").add(function(){vt.remove(e,[t+"queue",n])})})}}),Z.fn.extend({queue:function(e,t){var n=2;return"string"!=typeof e&&(t=e,e="fx",n--),arguments.length<n?Z.queue(this[0],e):void 0===t?this:this.each(function(){var n=Z.queue(this,e,t);Z._queueHooks(this,e),"fx"===e&&"inprogress"!==n[0]&&Z.dequeue(this,e)})},dequeue:function(e){return this.each(function(){Z.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=Z.Deferred(),o=this,s=this.length,a=function(){--r||i.resolveWith(o,[o])};for("string"!=typeof e&&(t=e,e=void 0),e=e||"fx";s--;)n=vt.get(o[s],e+"queueHooks"),n&&n.empty&&(r++,n.empty.add(a));return a(),i.promise(t)}});var wt=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,Tt=["Top","Right","Bottom","Left"],Ct=function(e,t){return e=t||e,"none"===Z.css(e,"display")||!Z.contains(e.ownerDocument,e)},Nt=/^(?:checkbox|radio)$/i;!function(){var e=J.createDocumentFragment(),t=e.appendChild(J.createElement("div")),n=J.createElement("input");n.setAttribute("type","radio"),n.setAttribute("checked","checked"),n.setAttribute("name","t"),t.appendChild(n),Q.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,t.innerHTML="<textarea>x</textarea>",Q.noCloneChecked=!!t.cloneNode(!0).lastChild.defaultValue}();var kt="undefined";Q.focusinBubbles="onfocusin"in e;var Et=/^key/,St=/^(?:mouse|pointer|contextmenu)|click/,jt=/^(?:focusinfocus|focusoutblur)$/,Dt=/^([^.]*)(?:\.(.+)|)$/;Z.event={global:{},add:function(e,t,n,r,i){var o,s,a,u,l,c,f,p,d,h,g,m=vt.get(e);if(m)for(n.handler&&(o=n,n=o.handler,i=o.selector),n.guid||(n.guid=Z.guid++),(u=m.events)||(u=m.events={}),(s=m.handle)||(s=m.handle=function(t){return typeof Z!==kt&&Z.event.triggered!==t.type?Z.event.dispatch.apply(e,arguments):void 0}),t=(t||"").match(dt)||[""],l=t.length;l--;)a=Dt.exec(t[l])||[],d=g=a[1],h=(a[2]||"").split(".").sort(),d&&(f=Z.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=Z.event.special[d]||{},c=Z.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&Z.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||(p=u[d]=[],p.delegateCount=0,f.setup&&f.setup.call(e,r,h,s)!==!1||e.addEventListener&&e.addEventListener(d,s,!1)),f.add&&(f.add.call(e,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),Z.event.global[d]=!0)},remove:function(e,t,n,r,i){var o,s,a,u,l,c,f,p,d,h,g,m=vt.hasData(e)&&vt.get(e);if(m&&(u=m.events)){for(t=(t||"").match(dt)||[""],l=t.length;l--;)if(a=Dt.exec(t[l])||[],d=g=a[1],h=(a[2]||"").split(".").sort(),d){for(f=Z.event.special[d]||{},d=(r?f.delegateType:f.bindType)||d,p=u[d]||[],a=a[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=o=p.length;o--;)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||a&&!a.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));s&&!p.length&&(f.teardown&&f.teardown.call(e,h,m.handle)!==!1||Z.removeEvent(e,d,m.handle),delete u[d])}else for(d in u)Z.event.remove(e,d+t[l],n,r,!0);Z.isEmptyObject(u)&&(delete m.handle,vt.remove(e,"events"))}},trigger:function(t,n,r,i){var o,s,a,u,l,c,f,p=[r||J],d=G.call(t,"type")?t.type:t,h=G.call(t,"namespace")?t.namespace.split("."):[];if(s=a=r=r||J,3!==r.nodeType&&8!==r.nodeType&&!jt.test(d+Z.event.triggered)&&(d.indexOf(".")>=0&&(h=d.split("."),d=h.shift(),h.sort()),l=d.indexOf(":")<0&&"on"+d,t=t[Z.expando]?t:new Z.Event(d,"object"==typeof t&&t),t.isTrigger=i?2:3,t.namespace=h.join("."),t.namespace_re=t.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,t.result=void 0,t.target||(t.target=r),n=null==n?[t]:Z.makeArray(n,[t]),f=Z.event.special[d]||{},i||!f.trigger||f.trigger.apply(r,n)!==!1)){if(!i&&!f.noBubble&&!Z.isWindow(r)){for(u=f.delegateType||d,jt.test(u+d)||(s=s.parentNode);s;s=s.parentNode)p.push(s),a=s;a===(r.ownerDocument||J)&&p.push(a.defaultView||a.parentWindow||e)}for(o=0;(s=p[o++])&&!t.isPropagationStopped();)t.type=o>1?u:f.bindType||d,c=(vt.get(s,"events")||{})[t.type]&&vt.get(s,"handle"),c&&c.apply(s,n),c=l&&s[l],c&&c.apply&&Z.acceptData(s)&&(t.result=c.apply(s,n),t.result===!1&&t.preventDefault());return t.type=d,i||t.isDefaultPrevented()||f._default&&f._default.apply(p.pop(),n)!==!1||!Z.acceptData(r)||l&&Z.isFunction(r[d])&&!Z.isWindow(r)&&(a=r[l],a&&(r[l]=null),Z.event.triggered=d,r[d](),Z.event.triggered=void 0,a&&(r[l]=a)),t.result}},dispatch:function(e){e=Z.event.fix(e);var t,n,r,i,o,s=[],a=_.call(arguments),u=(vt.get(this,"events")||{})[e.type]||[],l=Z.event.special[e.type]||{};if(a[0]=e,e.delegateTarget=this,!l.preDispatch||l.preDispatch.call(this,e)!==!1){for(s=Z.event.handlers.call(this,e,u),t=0;(i=s[t++])&&!e.isPropagationStopped();)for(e.currentTarget=i.elem,n=0;(o=i.handlers[n++])&&!e.isImmediatePropagationStopped();)(!e.namespace_re||e.namespace_re.test(o.namespace))&&(e.handleObj=o,e.data=o.data,r=((Z.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,a),void 0!==r&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()));return l.postDispatch&&l.postDispatch.call(this,e),e.result}},handlers:function(e,t){var n,r,i,o,s=[],a=t.delegateCount,u=e.target;if(a&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!==this;u=u.parentNode||this)if(u.disabled!==!0||"click"!==e.type){for(r=[],n=0;a>n;n++)o=t[n],i=o.selector+" ",void 0===r[i]&&(r[i]=o.needsContext?Z(i,this).index(u)>=0:Z.find(i,this,null,[u]).length),r[i]&&r.push(o);r.length&&s.push({elem:u,handlers:r})}return a<t.length&&s.push({elem:this,handlers:t.slice(a)}),s},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,t){var n,r,i,o=t.button;return null==e.pageX&&null!=t.clientX&&(n=e.target.ownerDocument||J,r=n.documentElement,i=n.body,e.pageX=t.clientX+(r&&r.scrollLeft||i&&i.scrollLeft||0)-(r&&r.clientLeft||i&&i.clientLeft||0),e.pageY=t.clientY+(r&&r.scrollTop||i&&i.scrollTop||0)-(r&&r.clientTop||i&&i.clientTop||0)),e.which||void 0===o||(e.which=1&o?1:2&o?3:4&o?2:0),e}},fix:function(e){if(e[Z.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];for(s||(this.fixHooks[i]=s=St.test(i)?this.mouseHooks:Et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new Z.Event(o),t=r.length;t--;)n=r[t],e[n]=o[n];return e.target||(e.target=J),3===e.target.nodeType&&(e.target=e.target.parentNode),s.filter?s.filter(e,o):e},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==f()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===f()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&Z.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(e){return Z.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=Z.extend(new Z.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?Z.event.trigger(i,null,t):Z.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},Z.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)},Z.Event=function(e,t){return this instanceof Z.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&e.returnValue===!1?l:c):this.type=e,t&&Z.extend(this,t),this.timeStamp=e&&e.timeStamp||Z.now(),void(this[Z.expando]=!0)):new Z.Event(e,t)},Z.Event.prototype={isDefaultPrevented:c,isPropagationStopped:c,isImmediatePropagationStopped:c,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=l,e&&e.preventDefault&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=l,e&&e.stopPropagation&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=l,e&&e.stopImmediatePropagation&&e.stopImmediatePropagation(),this.stopPropagation()}},Z.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,t){Z.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!Z.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),Q.focusinBubbles||Z.each({focus:"focusin",blur:"focusout"},function(e,t){var n=function(e){Z.event.simulate(t,e.target,Z.event.fix(e),!0)};Z.event.special[t]={setup:function(){var r=this.ownerDocument||this,i=vt.access(r,t);i||r.addEventListener(e,n,!0),vt.access(r,t,(i||0)+1)},teardown:function(){var r=this.ownerDocument||this,i=vt.access(r,t)-1;i?vt.access(r,t,i):(r.removeEventListener(e,n,!0),vt.remove(r,t))}}}),Z.fn.extend({on:function(e,t,n,r,i){var o,s;if("object"==typeof e){"string"!=typeof t&&(n=n||t,t=void 0);for(s in e)this.on(s,t,n,e[s],i);return this}if(null==n&&null==r?(r=t,n=t=void 0):null==r&&("string"==typeof t?(r=n,n=void 0):(r=n,n=t,t=void 0)),r===!1)r=c;else if(!r)return this;return 1===i&&(o=r,r=function(e){return Z().off(e),o.apply(this,arguments)},r.guid=o.guid||(o.guid=Z.guid++)),this.each(function(){Z.event.add(this,e,r,n,t)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,Z(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return(t===!1||"function"==typeof t)&&(n=t,t=void 0),n===!1&&(n=c),this.each(function(){Z.event.remove(this,e,n,t)})},trigger:function(e,t){return this.each(function(){Z.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];return n?Z.event.trigger(e,t,n,!0):void 0}});var At=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,Lt=/<([\w:]+)/,qt=/<|&#?\w+;/,Ht=/<(?:script|style|link)/i,Ot=/checked\s*(?:[^=]|=\s*.checked.)/i,Ft=/^$|\/(?:java|ecma)script/i,Pt=/^true\/(.*)/,Mt=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Rt={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};Rt.optgroup=Rt.option,Rt.tbody=Rt.tfoot=Rt.colgroup=Rt.caption=Rt.thead,Rt.th=Rt.td,Z.extend({clone:function(e,t,n){var r,i,o,s,a=e.cloneNode(!0),u=Z.contains(e.ownerDocument,e);if(!(Q.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||Z.isXMLDoc(e)))for(s=v(a),o=v(e),r=0,i=o.length;i>r;r++)y(o[r],s[r]);if(t)if(n)for(o=o||v(e),s=s||v(a),r=0,i=o.length;i>r;r++)m(o[r],s[r]);else m(e,a);return s=v(a,"script"),s.length>0&&g(s,!u&&v(e,"script")),a},buildFragment:function(e,t,n,r){for(var i,o,s,a,u,l,c=t.createDocumentFragment(),f=[],p=0,d=e.length;d>p;p++)if(i=e[p],i||0===i)if("object"===Z.type(i))Z.merge(f,i.nodeType?[i]:i);else if(qt.test(i)){for(o=o||c.appendChild(t.createElement("div")),s=(Lt.exec(i)||["",""])[1].toLowerCase(),a=Rt[s]||Rt._default,o.innerHTML=a[1]+i.replace(At,"<$1></$2>")+a[2],l=a[0];l--;)o=o.lastChild;Z.merge(f,o.childNodes),o=c.firstChild,o.textContent=""}else f.push(t.createTextNode(i));for(c.textContent="",p=0;i=f[p++];)if((!r||-1===Z.inArray(i,r))&&(u=Z.contains(i.ownerDocument,i),o=v(c.appendChild(i),"script"),u&&g(o),n))for(l=0;i=o[l++];)Ft.test(i.type||"")&&n.push(i);return c},cleanData:function(e){for(var t,n,r,i,o=Z.event.special,s=0;void 0!==(n=e[s]);s++){if(Z.acceptData(n)&&(i=n[vt.expando],i&&(t=vt.cache[i]))){if(t.events)for(r in t.events)o[r]?Z.event.remove(n,r):Z.removeEvent(n,r,t.handle);vt.cache[i]&&delete vt.cache[i]}delete yt.cache[n[yt.expando]]}}}),Z.fn.extend({text:function(e){return mt(this,function(e){return void 0===e?Z.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=e)})},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=p(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){for(var n,r=e?Z.filter(e,this):this,i=0;null!=(n=r[i]);i++)t||1!==n.nodeType||Z.cleanData(v(n)),n.parentNode&&(t&&Z.contains(n.ownerDocument,n)&&g(v(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(Z.cleanData(v(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return Z.clone(this,e,t)})},html:function(e){return mt(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!Ht.test(e)&&!Rt[(Lt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(At,"<$1></$2>");try{for(;r>n;n++)t=this[n]||{},1===t.nodeType&&(Z.cleanData(v(t,!1)),t.innerHTML=e);t=0}catch(i){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=arguments[0];return this.domManip(arguments,function(t){e=this.parentNode,Z.cleanData(v(this)),e&&e.replaceChild(t,this)}),e&&(e.length||e.nodeType)?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t){e=z.apply([],e);var n,r,i,o,s,a,u=0,l=this.length,c=this,f=l-1,p=e[0],g=Z.isFunction(p);if(g||l>1&&"string"==typeof p&&!Q.checkClone&&Ot.test(p))return this.each(function(n){var r=c.eq(n);g&&(e[0]=p.call(this,n,r.html())),r.domManip(e,t)});if(l&&(n=Z.buildFragment(e,this[0].ownerDocument,!1,this),r=n.firstChild,1===n.childNodes.length&&(n=r),r)){for(i=Z.map(v(n,"script"),d),o=i.length;l>u;u++)s=n,u!==f&&(s=Z.clone(s,!0,!0),o&&Z.merge(i,v(s,"script"))),t.call(this[u],s,u);if(o)for(a=i[i.length-1].ownerDocument,Z.map(i,h),u=0;o>u;u++)s=i[u],Ft.test(s.type||"")&&!vt.access(s,"globalEval")&&Z.contains(a,s)&&(s.src?Z._evalUrl&&Z._evalUrl(s.src):Z.globalEval(s.textContent.replace(Mt,"")))}return this}}),Z.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){Z.fn[e]=function(e){for(var n,r=[],i=Z(e),o=i.length-1,s=0;o>=s;s++)n=s===o?this:this.clone(!0),Z(i[s])[t](n),X.apply(r,n.get());return this.pushStack(r)}});var Wt,$t={},Bt=/^margin/,It=new RegExp("^("+wt+")(?!px)[a-z%]+$","i"),_t=function(e){return e.ownerDocument.defaultView.getComputedStyle(e,null)};!function(){function t(){s.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",s.innerHTML="",i.appendChild(o);var t=e.getComputedStyle(s,null);n="1%"!==t.top,r="4px"===t.width,i.removeChild(o)}var n,r,i=J.documentElement,o=J.createElement("div"),s=J.createElement("div");s.style&&(s.style.backgroundClip="content-box",s.cloneNode(!0).style.backgroundClip="",Q.clearCloneStyle="content-box"===s.style.backgroundClip,o.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",o.appendChild(s),e.getComputedStyle&&Z.extend(Q,{pixelPosition:function(){return t(),n},boxSizingReliable:function(){return null==r&&t(),r},reliableMarginRight:function(){var t,n=s.appendChild(J.createElement("div"));return n.style.cssText=s.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",n.style.marginRight=n.style.width="0",s.style.width="1px",i.appendChild(o),t=!parseFloat(e.getComputedStyle(n,null).marginRight),i.removeChild(o),t}}))}(),Z.swap=function(e,t,n,r){var i,o,s={};for(o in t)s[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=s[o];return i};var zt=/^(none|table(?!-c[ea]).+)/,Xt=new RegExp("^("+wt+")(.*)$","i"),Ut=new RegExp("^([+-])=("+wt+")","i"),Vt={position:"absolute",visibility:"hidden",display:"block"},Yt={letterSpacing:"0",fontWeight:"400"},Gt=["Webkit","O","Moz","ms"];Z.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=w(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,s,a=Z.camelCase(t),u=e.style;return t=Z.cssProps[a]||(Z.cssProps[a]=C(u,a)),s=Z.cssHooks[t]||Z.cssHooks[a],void 0===n?s&&"get"in s&&void 0!==(i=s.get(e,!1,r))?i:u[t]:(o=typeof n,"string"===o&&(i=Ut.exec(n))&&(n=(i[1]+1)*i[2]+parseFloat(Z.css(e,t)),o="number"),void(null!=n&&n===n&&("number"!==o||Z.cssNumber[a]||(n+="px"),Q.clearCloneStyle||""!==n||0!==t.indexOf("background")||(u[t]="inherit"),s&&"set"in s&&void 0===(n=s.set(e,n,r))||(u[t]=n))))}},css:function(e,t,n,r){var i,o,s,a=Z.camelCase(t);return t=Z.cssProps[a]||(Z.cssProps[a]=C(e.style,a)),s=Z.cssHooks[t]||Z.cssHooks[a],s&&"get"in s&&(i=s.get(e,!0,n)),void 0===i&&(i=w(e,t,r)),"normal"===i&&t in Yt&&(i=Yt[t]),""===n||n?(o=parseFloat(i),n===!0||Z.isNumeric(o)?o||0:i):i}}),Z.each(["height","width"],function(e,t){Z.cssHooks[t]={get:function(e,n,r){return n?zt.test(Z.css(e,"display"))&&0===e.offsetWidth?Z.swap(e,Vt,function(){return E(e,t,r)}):E(e,t,r):void 0},set:function(e,n,r){var i=r&&_t(e);return N(e,n,r?k(e,t,r,"border-box"===Z.css(e,"boxSizing",!1,i),i):0)}}}),Z.cssHooks.marginRight=T(Q.reliableMarginRight,function(e,t){return t?Z.swap(e,{display:"inline-block"},w,[e,"marginRight"]):void 0}),Z.each({margin:"",padding:"",border:"Width"},function(e,t){Z.cssHooks[e+t]={expand:function(n){for(var r=0,i={},o="string"==typeof n?n.split(" "):[n];4>r;r++)i[e+Tt[r]+t]=o[r]||o[r-2]||o[0];return i}},Bt.test(e)||(Z.cssHooks[e+t].set=N)}),Z.fn.extend({css:function(e,t){return mt(this,function(e,t,n){var r,i,o={},s=0;if(Z.isArray(t)){for(r=_t(e),i=t.length;i>s;s++)o[t[s]]=Z.css(e,t[s],!1,r);return o}return void 0!==n?Z.style(e,t,n):Z.css(e,t)},e,t,arguments.length>1)},show:function(){return S(this,!0)},hide:function(){return S(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){Ct(this)?Z(this).show():Z(this).hide()})}}),Z.Tween=j,j.prototype={constructor:j,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(Z.cssNumber[n]?"":"px")},cur:function(){var e=j.propHooks[this.prop];return e&&e.get?e.get(this):j.propHooks._default.get(this)},run:function(e){var t,n=j.propHooks[this.prop];return this.pos=t=this.options.duration?Z.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):j.propHooks._default.set(this),this}},j.prototype.init.prototype=j.prototype,j.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=Z.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){Z.fx.step[e.prop]?Z.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[Z.cssProps[e.prop]]||Z.cssHooks[e.prop])?Z.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},j.propHooks.scrollTop=j.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},Z.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},Z.fx=j.prototype.init,Z.fx.step={};var Qt,Jt,Kt=/^(?:toggle|show|hide)$/,Zt=new RegExp("^(?:([+-])=|)("+wt+")([a-z%]*)$","i"),en=/queueHooks$/,tn=[q],nn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Zt.exec(t),o=i&&i[3]||(Z.cssNumber[e]?"":"px"),s=(Z.cssNumber[e]||"px"!==o&&+r)&&Zt.exec(Z.css(n.elem,e)),a=1,u=20;if(s&&s[3]!==o){o=o||s[3],i=i||[],s=+r||1;do a=a||".5",s/=a,Z.style(n.elem,e,s+o);while(a!==(a=n.cur()/r)&&1!==a&&--u)}return i&&(s=n.start=+s||+r||0,n.unit=o,n.end=i[1]?s+(i[1]+1)*i[2]:+i[2]),n}]};Z.Animation=Z.extend(O,{tweener:function(e,t){Z.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");for(var n,r=0,i=e.length;i>r;r++)n=e[r],nn[n]=nn[n]||[],nn[n].unshift(t)},prefilter:function(e,t){t?tn.unshift(e):tn.push(e)}}),Z.speed=function(e,t,n){var r=e&&"object"==typeof e?Z.extend({},e):{complete:n||!n&&t||Z.isFunction(e)&&e,duration:e,easing:n&&t||t&&!Z.isFunction(t)&&t};return r.duration=Z.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in Z.fx.speeds?Z.fx.speeds[r.duration]:Z.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){Z.isFunction(r.old)&&r.old.call(this),r.queue&&Z.dequeue(this,r.queue)},r},Z.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Ct).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=Z.isEmptyObject(e),o=Z.speed(t,n,r),s=function(){var t=O(this,Z.extend({},e),o);(i||vt.get(this,"finish"))&&t.stop(!0)};return s.finish=s,i||o.queue===!1?this.each(s):this.queue(o.queue,s)},stop:function(e,t,n){var r=function(e){var t=e.stop;delete e.stop,t(n)};return"string"!=typeof e&&(n=t,t=e,e=void 0),t&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,i=null!=e&&e+"queueHooks",o=Z.timers,s=vt.get(this);if(i)s[i]&&s[i].stop&&r(s[i]);else for(i in s)s[i]&&s[i].stop&&en.test(i)&&r(s[i]);for(i=o.length;i--;)o[i].elem!==this||null!=e&&o[i].queue!==e||(o[i].anim.stop(n),t=!1,o.splice(i,1));(t||!n)&&Z.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=vt.get(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=Z.timers,s=r?r.length:0;for(n.finish=!0,Z.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;s>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}}),Z.each(["toggle","show","hide"],function(e,t){var n=Z.fn[t];
Z.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(A(t,!0),e,r,i)}}),Z.each({slideDown:A("show"),slideUp:A("hide"),slideToggle:A("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){Z.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),Z.timers=[],Z.fx.tick=function(){var e,t=0,n=Z.timers;for(Qt=Z.now();t<n.length;t++)e=n[t],e()||n[t]!==e||n.splice(t--,1);n.length||Z.fx.stop(),Qt=void 0},Z.fx.timer=function(e){Z.timers.push(e),e()?Z.fx.start():Z.timers.pop()},Z.fx.interval=13,Z.fx.start=function(){Jt||(Jt=setInterval(Z.fx.tick,Z.fx.interval))},Z.fx.stop=function(){clearInterval(Jt),Jt=null},Z.fx.speeds={slow:600,fast:200,_default:400},Z.fn.delay=function(e,t){return e=Z.fx?Z.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},function(){var e=J.createElement("input"),t=J.createElement("select"),n=t.appendChild(J.createElement("option"));e.type="checkbox",Q.checkOn=""!==e.value,Q.optSelected=n.selected,t.disabled=!0,Q.optDisabled=!n.disabled,e=J.createElement("input"),e.value="t",e.type="radio",Q.radioValue="t"===e.value}();var rn,on,sn=Z.expr.attrHandle;Z.fn.extend({attr:function(e,t){return mt(this,Z.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){Z.removeAttr(this,e)})}}),Z.extend({attr:function(e,t,n){var r,i,o=e.nodeType;return e&&3!==o&&8!==o&&2!==o?typeof e.getAttribute===kt?Z.prop(e,t,n):(1===o&&Z.isXMLDoc(e)||(t=t.toLowerCase(),r=Z.attrHooks[t]||(Z.expr.match.bool.test(t)?on:rn)),void 0===n?r&&"get"in r&&null!==(i=r.get(e,t))?i:(i=Z.find.attr(e,t),null==i?void 0:i):null!==n?r&&"set"in r&&void 0!==(i=r.set(e,n,t))?i:(e.setAttribute(t,n+""),n):void Z.removeAttr(e,t)):void 0},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(dt);if(o&&1===e.nodeType)for(;n=o[i++];)r=Z.propFix[n]||n,Z.expr.match.bool.test(n)&&(e[r]=!1),e.removeAttribute(n)},attrHooks:{type:{set:function(e,t){if(!Q.radioValue&&"radio"===t&&Z.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}}}),on={set:function(e,t,n){return t===!1?Z.removeAttr(e,n):e.setAttribute(n,n),n}},Z.each(Z.expr.match.bool.source.match(/\w+/g),function(e,t){var n=sn[t]||Z.find.attr;sn[t]=function(e,t,r){var i,o;return r||(o=sn[t],sn[t]=i,i=null!=n(e,t,r)?t.toLowerCase():null,sn[t]=o),i}});var an=/^(?:input|select|textarea|button)$/i;Z.fn.extend({prop:function(e,t){return mt(this,Z.prop,e,t,arguments.length>1)},removeProp:function(e){return this.each(function(){delete this[Z.propFix[e]||e]})}}),Z.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(e,t,n){var r,i,o,s=e.nodeType;return e&&3!==s&&8!==s&&2!==s?(o=1!==s||!Z.isXMLDoc(e),o&&(t=Z.propFix[t]||t,i=Z.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]):void 0},propHooks:{tabIndex:{get:function(e){return e.hasAttribute("tabindex")||an.test(e.nodeName)||e.href?e.tabIndex:-1}}}}),Q.optSelected||(Z.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null}}),Z.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){Z.propFix[this.toLowerCase()]=this});var un=/[\t\r\n\f]/g;Z.fn.extend({addClass:function(e){var t,n,r,i,o,s,a="string"==typeof e&&e,u=0,l=this.length;if(Z.isFunction(e))return this.each(function(t){Z(this).addClass(e.call(this,t,this.className))});if(a)for(t=(e||"").match(dt)||[];l>u;u++)if(n=this[u],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(un," "):" ")){for(o=0;i=t[o++];)r.indexOf(" "+i+" ")<0&&(r+=i+" ");s=Z.trim(r),n.className!==s&&(n.className=s)}return this},removeClass:function(e){var t,n,r,i,o,s,a=0===arguments.length||"string"==typeof e&&e,u=0,l=this.length;if(Z.isFunction(e))return this.each(function(t){Z(this).removeClass(e.call(this,t,this.className))});if(a)for(t=(e||"").match(dt)||[];l>u;u++)if(n=this[u],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(un," "):"")){for(o=0;i=t[o++];)for(;r.indexOf(" "+i+" ")>=0;)r=r.replace(" "+i+" "," ");s=e?Z.trim(r):"",n.className!==s&&(n.className=s)}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):this.each(Z.isFunction(e)?function(n){Z(this).toggleClass(e.call(this,n,this.className,t),t)}:function(){if("string"===n)for(var t,r=0,i=Z(this),o=e.match(dt)||[];t=o[r++];)i.hasClass(t)?i.removeClass(t):i.addClass(t);else(n===kt||"boolean"===n)&&(this.className&&vt.set(this,"__className__",this.className),this.className=this.className||e===!1?"":vt.get(this,"__className__")||"")})},hasClass:function(e){for(var t=" "+e+" ",n=0,r=this.length;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(un," ").indexOf(t)>=0)return!0;return!1}});var ln=/\r/g;Z.fn.extend({val:function(e){var t,n,r,i=this[0];return arguments.length?(r=Z.isFunction(e),this.each(function(n){var i;1===this.nodeType&&(i=r?e.call(this,n,Z(this).val()):e,null==i?i="":"number"==typeof i?i+="":Z.isArray(i)&&(i=Z.map(i,function(e){return null==e?"":e+""})),t=Z.valHooks[this.type]||Z.valHooks[this.nodeName.toLowerCase()],t&&"set"in t&&void 0!==t.set(this,i,"value")||(this.value=i))})):i?(t=Z.valHooks[i.type]||Z.valHooks[i.nodeName.toLowerCase()],t&&"get"in t&&void 0!==(n=t.get(i,"value"))?n:(n=i.value,"string"==typeof n?n.replace(ln,""):null==n?"":n)):void 0}}),Z.extend({valHooks:{option:{get:function(e){var t=Z.find.attr(e,"value");return null!=t?t:Z.trim(Z.text(e))}},select:{get:function(e){for(var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,s=o?null:[],a=o?i+1:r.length,u=0>i?a:o?i:0;a>u;u++)if(n=r[u],!(!n.selected&&u!==i||(Q.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&Z.nodeName(n.parentNode,"optgroup"))){if(t=Z(n).val(),o)return t;s.push(t)}return s},set:function(e,t){for(var n,r,i=e.options,o=Z.makeArray(t),s=i.length;s--;)r=i[s],(r.selected=Z.inArray(r.value,o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),Z.each(["radio","checkbox"],function(){Z.valHooks[this]={set:function(e,t){return Z.isArray(t)?e.checked=Z.inArray(Z(e).val(),t)>=0:void 0}},Q.checkOn||(Z.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),Z.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){Z.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),Z.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var cn=Z.now(),fn=/\?/;Z.parseJSON=function(e){return JSON.parse(e+"")},Z.parseXML=function(e){var t,n;if(!e||"string"!=typeof e)return null;try{n=new DOMParser,t=n.parseFromString(e,"text/xml")}catch(r){t=void 0}return(!t||t.getElementsByTagName("parsererror").length)&&Z.error("Invalid XML: "+e),t};var pn,dn,hn=/#.*$/,gn=/([?&])_=[^&]*/,mn=/^(.*?):[ \t]*([^\r\n]*)$/gm,vn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,yn=/^(?:GET|HEAD)$/,xn=/^\/\//,bn=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,wn={},Tn={},Cn="*/".concat("*");try{dn=location.href}catch(Nn){dn=J.createElement("a"),dn.href="",dn=dn.href}pn=bn.exec(dn.toLowerCase())||[],Z.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:dn,type:"GET",isLocal:vn.test(pn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Cn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":Z.parseJSON,"text xml":Z.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?M(M(e,Z.ajaxSettings),t):M(Z.ajaxSettings,e)},ajaxPrefilter:F(wn),ajaxTransport:F(Tn),ajax:function(e,t){function n(e,t,n,s){var u,c,v,y,b,T=t;2!==x&&(x=2,a&&clearTimeout(a),r=void 0,o=s||"",w.readyState=e>0?4:0,u=e>=200&&300>e||304===e,n&&(y=R(f,w,n)),y=W(f,y,w,u),u?(f.ifModified&&(b=w.getResponseHeader("Last-Modified"),b&&(Z.lastModified[i]=b),b=w.getResponseHeader("etag"),b&&(Z.etag[i]=b)),204===e||"HEAD"===f.type?T="nocontent":304===e?T="notmodified":(T=y.state,c=y.data,v=y.error,u=!v)):(v=T,(e||!T)&&(T="error",0>e&&(e=0))),w.status=e,w.statusText=(t||T)+"",u?h.resolveWith(p,[c,T,w]):h.rejectWith(p,[w,T,v]),w.statusCode(m),m=void 0,l&&d.trigger(u?"ajaxSuccess":"ajaxError",[w,f,u?c:v]),g.fireWith(p,[w,T]),l&&(d.trigger("ajaxComplete",[w,f]),--Z.active||Z.event.trigger("ajaxStop")))}"object"==typeof e&&(t=e,e=void 0),t=t||{};var r,i,o,s,a,u,l,c,f=Z.ajaxSetup({},t),p=f.context||f,d=f.context&&(p.nodeType||p.jquery)?Z(p):Z.event,h=Z.Deferred(),g=Z.Callbacks("once memory"),m=f.statusCode||{},v={},y={},x=0,b="canceled",w={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!s)for(s={};t=mn.exec(o);)s[t[1].toLowerCase()]=t[2];t=s[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?o:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=y[n]=y[n]||e,v[e]=t),this},overrideMimeType:function(e){return x||(f.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>x)for(t in e)m[t]=[m[t],e[t]];else w.always(e[w.status]);return this},abort:function(e){var t=e||b;return r&&r.abort(t),n(0,t),this}};if(h.promise(w).complete=g.add,w.success=w.done,w.error=w.fail,f.url=((e||f.url||dn)+"").replace(hn,"").replace(xn,pn[1]+"//"),f.type=t.method||t.type||f.method||f.type,f.dataTypes=Z.trim(f.dataType||"*").toLowerCase().match(dt)||[""],null==f.crossDomain&&(u=bn.exec(f.url.toLowerCase()),f.crossDomain=!(!u||u[1]===pn[1]&&u[2]===pn[2]&&(u[3]||("http:"===u[1]?"80":"443"))===(pn[3]||("http:"===pn[1]?"80":"443")))),f.data&&f.processData&&"string"!=typeof f.data&&(f.data=Z.param(f.data,f.traditional)),P(wn,f,t,w),2===x)return w;l=f.global,l&&0===Z.active++&&Z.event.trigger("ajaxStart"),f.type=f.type.toUpperCase(),f.hasContent=!yn.test(f.type),i=f.url,f.hasContent||(f.data&&(i=f.url+=(fn.test(i)?"&":"?")+f.data,delete f.data),f.cache===!1&&(f.url=gn.test(i)?i.replace(gn,"$1_="+cn++):i+(fn.test(i)?"&":"?")+"_="+cn++)),f.ifModified&&(Z.lastModified[i]&&w.setRequestHeader("If-Modified-Since",Z.lastModified[i]),Z.etag[i]&&w.setRequestHeader("If-None-Match",Z.etag[i])),(f.data&&f.hasContent&&f.contentType!==!1||t.contentType)&&w.setRequestHeader("Content-Type",f.contentType),w.setRequestHeader("Accept",f.dataTypes[0]&&f.accepts[f.dataTypes[0]]?f.accepts[f.dataTypes[0]]+("*"!==f.dataTypes[0]?", "+Cn+"; q=0.01":""):f.accepts["*"]);for(c in f.headers)w.setRequestHeader(c,f.headers[c]);if(f.beforeSend&&(f.beforeSend.call(p,w,f)===!1||2===x))return w.abort();b="abort";for(c in{success:1,error:1,complete:1})w[c](f[c]);if(r=P(Tn,f,t,w)){w.readyState=1,l&&d.trigger("ajaxSend",[w,f]),f.async&&f.timeout>0&&(a=setTimeout(function(){w.abort("timeout")},f.timeout));try{x=1,r.send(v,n)}catch(T){if(!(2>x))throw T;n(-1,T)}}else n(-1,"No Transport");return w},getJSON:function(e,t,n){return Z.get(e,t,n,"json")},getScript:function(e,t){return Z.get(e,void 0,t,"script")}}),Z.each(["get","post"],function(e,t){Z[t]=function(e,n,r,i){return Z.isFunction(n)&&(i=i||r,r=n,n=void 0),Z.ajax({url:e,type:t,dataType:i,data:n,success:r})}}),Z.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){Z.fn[t]=function(e){return this.on(t,e)}}),Z._evalUrl=function(e){return Z.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},Z.fn.extend({wrapAll:function(e){var t;return Z.isFunction(e)?this.each(function(t){Z(this).wrapAll(e.call(this,t))}):(this[0]&&(t=Z(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e}).append(this)),this)},wrapInner:function(e){return this.each(Z.isFunction(e)?function(t){Z(this).wrapInner(e.call(this,t))}:function(){var t=Z(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=Z.isFunction(e);return this.each(function(n){Z(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){Z.nodeName(this,"body")||Z(this).replaceWith(this.childNodes)}).end()}}),Z.expr.filters.hidden=function(e){return e.offsetWidth<=0&&e.offsetHeight<=0},Z.expr.filters.visible=function(e){return!Z.expr.filters.hidden(e)};var kn=/%20/g,En=/\[\]$/,Sn=/\r?\n/g,jn=/^(?:submit|button|image|reset|file)$/i,Dn=/^(?:input|select|textarea|keygen)/i;Z.param=function(e,t){var n,r=[],i=function(e,t){t=Z.isFunction(t)?t():null==t?"":t,r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(void 0===t&&(t=Z.ajaxSettings&&Z.ajaxSettings.traditional),Z.isArray(e)||e.jquery&&!Z.isPlainObject(e))Z.each(e,function(){i(this.name,this.value)});else for(n in e)$(n,e[n],t,i);return r.join("&").replace(kn,"+")},Z.fn.extend({serialize:function(){return Z.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=Z.prop(this,"elements");return e?Z.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!Z(this).is(":disabled")&&Dn.test(this.nodeName)&&!jn.test(e)&&(this.checked||!Nt.test(e))}).map(function(e,t){var n=Z(this).val();return null==n?null:Z.isArray(n)?Z.map(n,function(e){return{name:t.name,value:e.replace(Sn,"\r\n")}}):{name:t.name,value:n.replace(Sn,"\r\n")}}).get()}}),Z.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(e){}};var An=0,Ln={},qn={0:200,1223:204},Hn=Z.ajaxSettings.xhr();e.ActiveXObject&&Z(e).on("unload",function(){for(var e in Ln)Ln[e]()}),Q.cors=!!Hn&&"withCredentials"in Hn,Q.ajax=Hn=!!Hn,Z.ajaxTransport(function(e){var t;return Q.cors||Hn&&!e.crossDomain?{send:function(n,r){var i,o=e.xhr(),s=++An;if(o.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(i in e.xhrFields)o[i]=e.xhrFields[i];e.mimeType&&o.overrideMimeType&&o.overrideMimeType(e.mimeType),e.crossDomain||n["X-Requested-With"]||(n["X-Requested-With"]="XMLHttpRequest");for(i in n)o.setRequestHeader(i,n[i]);t=function(e){return function(){t&&(delete Ln[s],t=o.onload=o.onerror=null,"abort"===e?o.abort():"error"===e?r(o.status,o.statusText):r(qn[o.status]||o.status,o.statusText,"string"==typeof o.responseText?{text:o.responseText}:void 0,o.getAllResponseHeaders()))}},o.onload=t(),o.onerror=t("error"),t=Ln[s]=t("abort");try{o.send(e.hasContent&&e.data||null)}catch(a){if(t)throw a}},abort:function(){t&&t()}}:void 0}),Z.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return Z.globalEval(e),e}}}),Z.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),Z.ajaxTransport("script",function(e){if(e.crossDomain){var t,n;return{send:function(r,i){t=Z("<script>").prop({async:!0,charset:e.scriptCharset,src:e.url}).on("load error",n=function(e){t.remove(),n=null,e&&i("error"===e.type?404:200,e.type)}),J.head.appendChild(t[0])},abort:function(){n&&n()}}}});var On=[],Fn=/(=)\?(?=&|$)|\?\?/;Z.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=On.pop()||Z.expando+"_"+cn++;return this[e]=!0,e}}),Z.ajaxPrefilter("json jsonp",function(t,n,r){var i,o,s,a=t.jsonp!==!1&&(Fn.test(t.url)?"url":"string"==typeof t.data&&!(t.contentType||"").indexOf("application/x-www-form-urlencoded")&&Fn.test(t.data)&&"data");return a||"jsonp"===t.dataTypes[0]?(i=t.jsonpCallback=Z.isFunction(t.jsonpCallback)?t.jsonpCallback():t.jsonpCallback,a?t[a]=t[a].replace(Fn,"$1"+i):t.jsonp!==!1&&(t.url+=(fn.test(t.url)?"&":"?")+t.jsonp+"="+i),t.converters["script json"]=function(){return s||Z.error(i+" was not called"),s[0]},t.dataTypes[0]="json",o=e[i],e[i]=function(){s=arguments},r.always(function(){e[i]=o,t[i]&&(t.jsonpCallback=n.jsonpCallback,On.push(i)),s&&Z.isFunction(o)&&o(s[0]),s=o=void 0}),"script"):void 0}),Z.parseHTML=function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||J;var r=st.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=Z.buildFragment([e],t,i),i&&i.length&&Z(i).remove(),Z.merge([],r.childNodes))};var Pn=Z.fn.load;Z.fn.load=function(e,t,n){if("string"!=typeof e&&Pn)return Pn.apply(this,arguments);var r,i,o,s=this,a=e.indexOf(" ");return a>=0&&(r=Z.trim(e.slice(a)),e=e.slice(0,a)),Z.isFunction(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),s.length>0&&Z.ajax({url:e,type:i,dataType:"html",data:t}).done(function(e){o=arguments,s.html(r?Z("<div>").append(Z.parseHTML(e)).find(r):e)}).complete(n&&function(e,t){s.each(n,o||[e.responseText,t,e])}),this},Z.expr.filters.animated=function(e){return Z.grep(Z.timers,function(t){return e===t.elem}).length};var Mn=e.document.documentElement;Z.offset={setOffset:function(e,t,n){var r,i,o,s,a,u,l,c=Z.css(e,"position"),f=Z(e),p={};"static"===c&&(e.style.position="relative"),a=f.offset(),o=Z.css(e,"top"),u=Z.css(e,"left"),l=("absolute"===c||"fixed"===c)&&(o+u).indexOf("auto")>-1,l?(r=f.position(),s=r.top,i=r.left):(s=parseFloat(o)||0,i=parseFloat(u)||0),Z.isFunction(t)&&(t=t.call(e,n,a)),null!=t.top&&(p.top=t.top-a.top+s),null!=t.left&&(p.left=t.left-a.left+i),"using"in t?t.using.call(e,p):f.css(p)}},Z.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each(function(t){Z.offset.setOffset(this,e,t)});var t,n,r=this[0],i={top:0,left:0},o=r&&r.ownerDocument;return o?(t=o.documentElement,Z.contains(t,r)?(typeof r.getBoundingClientRect!==kt&&(i=r.getBoundingClientRect()),n=B(o),{top:i.top+n.pageYOffset-t.clientTop,left:i.left+n.pageXOffset-t.clientLeft}):i):void 0},position:function(){if(this[0]){var e,t,n=this[0],r={top:0,left:0};return"fixed"===Z.css(n,"position")?t=n.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),Z.nodeName(e[0],"html")||(r=e.offset()),r.top+=Z.css(e[0],"borderTopWidth",!0),r.left+=Z.css(e[0],"borderLeftWidth",!0)),{top:t.top-r.top-Z.css(n,"marginTop",!0),left:t.left-r.left-Z.css(n,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent||Mn;e&&!Z.nodeName(e,"html")&&"static"===Z.css(e,"position");)e=e.offsetParent;return e||Mn})}}),Z.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,n){var r="pageYOffset"===n;Z.fn[t]=function(i){return mt(this,function(t,i,o){var s=B(t);return void 0===o?s?s[n]:t[i]:void(s?s.scrollTo(r?e.pageXOffset:o,r?o:e.pageYOffset):t[i]=o)},t,i,arguments.length,null)}}),Z.each(["top","left"],function(e,t){Z.cssHooks[t]=T(Q.pixelPosition,function(e,n){return n?(n=w(e,t),It.test(n)?Z(e).position()[t]+"px":n):void 0})}),Z.each({Height:"height",Width:"width"},function(e,t){Z.each({padding:"inner"+e,content:t,"":"outer"+e},function(n,r){Z.fn[r]=function(r,i){var o=arguments.length&&(n||"boolean"!=typeof r),s=n||(r===!0||i===!0?"margin":"border");return mt(this,function(t,n,r){var i;return Z.isWindow(t)?t.document.documentElement["client"+e]:9===t.nodeType?(i=t.documentElement,Math.max(t.body["scroll"+e],i["scroll"+e],t.body["offset"+e],i["offset"+e],i["client"+e])):void 0===r?Z.css(t,n,s):Z.style(t,n,r,s)},t,o?r:void 0,o,null)}})}),Z.fn.size=function(){return this.length},Z.fn.andSelf=Z.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return Z});var Rn=e.jQuery,Wn=e.$;return Z.noConflict=function(t){return e.$===Z&&(e.$=Wn),t&&e.jQuery===Z&&(e.jQuery=Rn),Z},typeof t===kt&&(e.jQuery=e.$=Z),Z});
(function(){function n(t,r,e){if(t===r)return 0!==t||1/t==1/r;if(null==t||null==r)return t===r;if(t._chain&&(t=t._wrapped),r._chain&&(r=r._wrapped),t.isEqual&&j.isFunction(t.isEqual))return t.isEqual(r);if(r.isEqual&&j.isFunction(r.isEqual))return r.isEqual(t);var u=o.call(t);if(u!=o.call(r))return!1;switch(u){case"[object String]":return t==""+r;case"[object Number]":return t!=+t?r!=+r:0==t?1/t==1/r:t==+r;case"[object Date]":case"[object Boolean]":return+t==+r;case"[object RegExp]":return t.source==r.source&&t.global==r.global&&t.multiline==r.multiline&&t.ignoreCase==r.ignoreCase}if("object"!=typeof t||"object"!=typeof r)return!1;for(var i=e.length;i--;)if(e[i]==t)return!0;e.push(t);var i=0,a=!0;if("[object Array]"==u){if(i=t.length,a=i==r.length)for(;i--&&(a=i in t==i in r&&n(t[i],r[i],e)););}else{if("constructor"in t!="constructor"in r||t.constructor!=r.constructor)return!1;for(var c in t)if(j.has(t,c)&&(i++,!(a=j.has(r,c)&&n(t[c],r[c],e))))break;if(a){for(c in r)if(j.has(r,c)&&!i--)break;a=!i}}return e.pop(),a}var t=this,r=t._,e={},u=Array.prototype,i=Object.prototype,a=u.slice,c=u.unshift,o=i.toString,l=i.hasOwnProperty,f=u.forEach,s=u.map,p=u.reduce,h=u.reduceRight,g=u.filter,v=u.every,d=u.some,m=u.indexOf,y=u.lastIndexOf,i=Array.isArray,b=Object.keys,x=Function.prototype.bind,j=function(n){return new I(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=j),exports._=j):t._=j,j.VERSION="1.3.3";var _=j.each=j.forEach=function(n,t,r){if(null!=n)if(f&&n.forEach===f)n.forEach(t,r);else if(n.length===+n.length)for(var u=0,i=n.length;i>u&&!(u in n&&t.call(r,n[u],u,n)===e);u++);else for(u in n)if(j.has(n,u)&&t.call(r,n[u],u,n)===e)break};j.map=j.collect=function(n,t,r){var e=[];return null==n?e:s&&n.map===s?n.map(t,r):(_(n,function(n,u,i){e[e.length]=t.call(r,n,u,i)}),n.length===+n.length&&(e.length=n.length),e)},j.reduce=j.foldl=j.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),p&&n.reduce===p)return e&&(t=j.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(_(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError("Reduce of empty array with no initial value");return r},j.reduceRight=j.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduceRight===h)return e&&(t=j.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=j.toArray(n).reverse();return e&&!u&&(t=j.bind(t,e)),u?j.reduce(i,t,r,e):j.reduce(i,t)},j.find=j.detect=function(n,t,r){var e;return A(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},j.filter=j.select=function(n,t,r){var e=[];return null==n?e:g&&n.filter===g?n.filter(t,r):(_(n,function(n,u,i){t.call(r,n,u,i)&&(e[e.length]=n)}),e)},j.reject=function(n,t,r){var e=[];return null==n?e:(_(n,function(n,u,i){t.call(r,n,u,i)||(e[e.length]=n)}),e)},j.every=j.all=function(n,t,r){var u=!0;return null==n?u:v&&n.every===v?n.every(t,r):(_(n,function(n,i,a){return(u=u&&t.call(r,n,i,a))?void 0:e}),!!u)};var A=j.some=j.any=function(n,t,r){t||(t=j.identity);var u=!1;return null==n?u:d&&n.some===d?n.some(t,r):(_(n,function(n,i,a){return u||(u=t.call(r,n,i,a))?e:void 0}),!!u)};j.include=j.contains=function(n,t){var r=!1;return null==n?r:m&&n.indexOf===m?-1!=n.indexOf(t):r=A(n,function(n){return n===t})},j.invoke=function(n,t){var r=a.call(arguments,2);return j.map(n,function(n){return(j.isFunction(t)?t||n:n[t]).apply(n,r)})},j.pluck=function(n,t){return j.map(n,function(n){return n[t]})},j.max=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0])return Math.max.apply(Math,n);if(!t&&j.isEmpty(n))return-1/0;var e={computed:-1/0};return _(n,function(n,u,i){u=t?t.call(r,n,u,i):n,u>=e.computed&&(e={value:n,computed:u})}),e.value},j.min=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0])return Math.min.apply(Math,n);if(!t&&j.isEmpty(n))return 1/0;var e={computed:1/0};return _(n,function(n,u,i){u=t?t.call(r,n,u,i):n,u<e.computed&&(e={value:n,computed:u})}),e.value},j.shuffle=function(n){var t,r=[];return _(n,function(n,e){t=Math.floor(Math.random()*(e+1)),r[e]=r[t],r[t]=n}),r},j.sortBy=function(n,t,r){var e=j.isFunction(t)?t:function(n){return n[t]};return j.pluck(j.map(n,function(n,t,u){return{value:n,criteria:e.call(r,n,t,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;return void 0===r?1:void 0===e?-1:e>r?-1:r>e?1:0}),"value")},j.groupBy=function(n,t){var r={},e=j.isFunction(t)?t:function(n){return n[t]};return _(n,function(n,t){var u=e(n,t);(r[u]||(r[u]=[])).push(n)}),r},j.sortedIndex=function(n,t,r){r||(r=j.identity);for(var e=0,u=n.length;u>e;){var i=e+u>>1;r(n[i])<r(t)?e=i+1:u=i}return e},j.toArray=function(n){return n?j.isArray(n)||j.isArguments(n)?a.call(n):n.toArray&&j.isFunction(n.toArray)?n.toArray():j.values(n):[]},j.size=function(n){return j.isArray(n)?n.length:j.keys(n).length},j.first=j.head=j.take=function(n,t,r){return null==t||r?n[0]:a.call(n,0,t)},j.initial=function(n,t,r){return a.call(n,0,n.length-(null==t||r?1:t))},j.last=function(n,t,r){return null==t||r?n[n.length-1]:a.call(n,Math.max(n.length-t,0))},j.rest=j.tail=function(n,t,r){return a.call(n,null==t||r?1:t)},j.compact=function(n){return j.filter(n,function(n){return!!n})},j.flatten=function(n,t){return j.reduce(n,function(n,r){return j.isArray(r)?n.concat(t?r:j.flatten(r)):(n[n.length]=r,n)},[])},j.without=function(n){return j.difference(n,a.call(arguments,1))},j.uniq=j.unique=function(n,t,r){var r=r?j.map(n,r):n,e=[];return n.length<3&&(t=!0),j.reduce(r,function(r,u,i){return(t?j.last(r)===u&&r.length:j.include(r,u))||(r.push(u),e.push(n[i])),r},[]),e},j.union=function(){return j.uniq(j.flatten(arguments,!0))},j.intersection=j.intersect=function(n){var t=a.call(arguments,1);return j.filter(j.uniq(n),function(n){return j.every(t,function(t){return j.indexOf(t,n)>=0})})},j.difference=function(n){var t=j.flatten(a.call(arguments,1),!0);return j.filter(n,function(n){return!j.include(t,n)})},j.zip=function(){for(var n=a.call(arguments),t=j.max(j.pluck(n,"length")),r=Array(t),e=0;t>e;e++)r[e]=j.pluck(n,""+e);return r},j.indexOf=function(n,t,r){if(null==n)return-1;var e;if(r)return r=j.sortedIndex(n,t),n[r]===t?r:-1;if(m&&n.indexOf===m)return n.indexOf(t);for(r=0,e=n.length;e>r;r++)if(r in n&&n[r]===t)return r;return-1},j.lastIndexOf=function(n,t){if(null==n)return-1;if(y&&n.lastIndexOf===y)return n.lastIndexOf(t);for(var r=n.length;r--;)if(r in n&&n[r]===t)return r;return-1},j.range=function(n,t,r){arguments.length<=1&&(t=n||0,n=0);for(var r=arguments[2]||1,e=Math.max(Math.ceil((t-n)/r),0),u=0,i=Array(e);e>u;)i[u++]=n,n+=r;return i};var w=function(){};j.bind=function(n,t){var r,e;if(n.bind===x&&x)return x.apply(n,a.call(arguments,1));if(!j.isFunction(n))throw new TypeError;return e=a.call(arguments,2),r=function(){if(!(this instanceof r))return n.apply(t,e.concat(a.call(arguments)));w.prototype=n.prototype;var u=new w,i=n.apply(u,e.concat(a.call(arguments)));return Object(i)===i?i:u}},j.bindAll=function(n){var t=a.call(arguments,1);return 0==t.length&&(t=j.functions(n)),_(t,function(t){n[t]=j.bind(n[t],n)}),n},j.memoize=function(n,t){var r={};return t||(t=j.identity),function(){var e=t.apply(this,arguments);return j.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},j.delay=function(n,t){var r=a.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},j.defer=function(n){return j.delay.apply(j,[n,1].concat(a.call(arguments,1)))},j.throttle=function(n,t){var r,e,u,i,a,c,o=j.debounce(function(){a=i=!1},t);return function(){return r=this,e=arguments,u||(u=setTimeout(function(){u=null,a&&n.apply(r,e),o()},t)),i?a=!0:c=n.apply(r,e),o(),i=!0,c}},j.debounce=function(n,t,r){var e;return function(){var u=this,i=arguments;r&&!e&&n.apply(u,i),clearTimeout(e),e=setTimeout(function(){e=null,r||n.apply(u,i)},t)}},j.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments))}},j.wrap=function(n,t){return function(){var r=[n].concat(a.call(arguments,0));return t.apply(this,r)}},j.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},j.after=function(n,t){return 0>=n?t():function(){return--n<1?t.apply(this,arguments):void 0}},j.keys=b||function(n){if(n!==Object(n))throw new TypeError("Invalid object");var t,r=[];for(t in n)j.has(n,t)&&(r[r.length]=t);return r},j.values=function(n){return j.map(n,j.identity)},j.functions=j.methods=function(n){var t,r=[];for(t in n)j.isFunction(n[t])&&r.push(t);return r.sort()},j.extend=function(n){return _(a.call(arguments,1),function(t){for(var r in t)n[r]=t[r]}),n},j.pick=function(n){var t={};return _(j.flatten(a.call(arguments,1)),function(r){r in n&&(t[r]=n[r])}),t},j.defaults=function(n){return _(a.call(arguments,1),function(t){for(var r in t)null==n[r]&&(n[r]=t[r])}),n},j.clone=function(n){return j.isObject(n)?j.isArray(n)?n.slice():j.extend({},n):n},j.tap=function(n,t){return t(n),n},j.isEqual=function(t,r){return n(t,r,[])},j.isEmpty=function(n){if(null==n)return!0;if(j.isArray(n)||j.isString(n))return 0===n.length;for(var t in n)if(j.has(n,t))return!1;return!0},j.isElement=function(n){return!(!n||1!=n.nodeType)},j.isArray=i||function(n){return"[object Array]"==o.call(n)},j.isObject=function(n){return n===Object(n)},j.isArguments=function(n){return"[object Arguments]"==o.call(n)},j.isArguments(arguments)||(j.isArguments=function(n){return!(!n||!j.has(n,"callee"))}),j.isFunction=function(n){return"[object Function]"==o.call(n)},j.isString=function(n){return"[object String]"==o.call(n)},j.isNumber=function(n){return"[object Number]"==o.call(n)},j.isFinite=function(n){return j.isNumber(n)&&isFinite(n)},j.isNaN=function(n){return n!==n},j.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"==o.call(n)},j.isDate=function(n){return"[object Date]"==o.call(n)},j.isRegExp=function(n){return"[object RegExp]"==o.call(n)},j.isNull=function(n){return null===n},j.isUndefined=function(n){return void 0===n},j.has=function(n,t){return l.call(n,t)},j.noConflict=function(){return t._=r,this},j.identity=function(n){return n},j.times=function(n,t,r){for(var e=0;n>e;e++)t.call(r,e)},j.escape=function(n){return(""+n).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;").replace(/\//g,"&#x2F;")},j.result=function(n,t){if(null==n)return null;var r=n[t];return j.isFunction(r)?r.call(n):r},j.mixin=function(n){_(j.functions(n),function(t){N(t,j[t]=n[t])})};var E=0;j.uniqueId=function(n){var t=E++;return n?n+t:t},j.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var O,F=/.^/,k={"\\":"\\","'":"'",r:"\r",n:"\n",t:"	",u2028:"\u2028",u2029:"\u2029"};for(O in k)k[k[O]]=O;var q=/\\|'|\r|\n|\t|\u2028|\u2029/g,S=/\\(\\|'|r|n|t|u2028|u2029)/g,R=function(n){return n.replace(S,function(n,t){return k[t]})};j.template=function(n,t,r){r=j.defaults(r||{},j.templateSettings),n="__p+='"+n.replace(q,function(n){return"\\"+k[n]}).replace(r.escape||F,function(n,t){return"'+\n_.escape("+R(t)+")+\n'"}).replace(r.interpolate||F,function(n,t){return"'+\n("+R(t)+")+\n'"}).replace(r.evaluate||F,function(n,t){return"';\n"+R(t)+"\n;__p+='"})+"';\n",r.variable||(n="with(obj||{}){\n"+n+"}\n");var n="var __p='';var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n"+n+"return __p;\n",e=new Function(r.variable||"obj","_",n);return t?e(t,j):(t=function(n){return e.call(this,n,j)},t.source="function("+(r.variable||"obj")+"){\n"+n+"}",t)},j.chain=function(n){return j(n).chain()};var I=function(n){this._wrapped=n};j.prototype=I.prototype;var M=function(n,t){return t?j(n).chain():n},N=function(n,t){I.prototype[n]=function(){var n=a.call(arguments);return c.call(n,this._wrapped),M(t.apply(j,n),this._chain)}};j.mixin(j),_("pop,push,reverse,shift,sort,splice,unshift".split(","),function(n){var t=u[n];I.prototype[n]=function(){var r=this._wrapped;t.apply(r,arguments);var e=r.length;return("shift"==n||"splice"==n)&&0===e&&delete r[0],M(r,this._chain)}}),_(["concat","join","slice"],function(n){var t=u[n];I.prototype[n]=function(){return M(t.apply(this._wrapped,arguments),this._chain)}}),I.prototype.chain=function(){return this._chain=!0,this},I.prototype.value=function(){return this._wrapped}}).call(this);
var Cookies={get:function(e){return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*"+encodeURIComponent(e).replace(/[\-\.\+\*]/g,"\\$&")+"\\s*\\=\\s*([^;]*).*$)|^.*$"),"$1"))||null},set:function(e,n,o){var t,r,c,s;if(o||(o={}),t=null!=o.expires?o.expires:o.maxAge,r=o.path,c=o.domain,s=o.secure,!e||/^(?:expires|max\-age|path|domain|secure)$/i.test(e))return!1;var i="";if(t)switch(t.constructor){case Number:i=1/0===t?"; expires=Fri, 31 Dec 9999 23:59:59 GMT":"; max-age="+t;break;case String:i="; expires="+t;break;case Date:i="; expires="+t.toUTCString()}return document.cookie=encodeURIComponent(e)+"="+encodeURIComponent(n)+i+(c?"; domain="+c:"")+(r?"; path="+r:"")+(s?"; secure":""),!0},expire:function(e,n){var o,t;return n||(n={}),o=n.path,t=n.domain,e&&Cookies.exists(e)?(document.cookie=encodeURIComponent(e)+"=; expires=Thu, 01 Jan 1970 00:00:00 GMT"+(t?"; domain="+t:"")+(o?"; path="+o:""),!0):!1},exists:function(e){return new RegExp("(?:^|;\\s*)"+encodeURIComponent(e).replace(/[\-\.\+\*]/g,"\\$&")+"\\s*\\=").test(document.cookie)},keys:function(){for(var e=document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g,"").split(/\s*(?:\=[^;]*)?;\s*/),n=0;n<e.length;n++)e[n]=decodeURIComponent(e[n]);return e}};
!function(e){function t(){var t=r(this);return isNaN(t.datetime)||e(this).text(a(t.datetime)),this}function r(t){if(t=e(t),!t.data("timeago")){t.data("timeago",{datetime:i.datetime(t)});var r=e.trim(t.text());r.length>0&&t.attr("title",r)}return t.data("timeago")}function a(e){return i.inWords(n(e))}function n(e){return(new Date).getTime()-e.getTime()}e.timeago=function(t){return a(t instanceof Date?t:"string"==typeof t?e.timeago.parse(t):e.timeago.datetime(t))};var i=e.timeago;e.extend(e.timeago,{settings:{refreshMillis:6e4,allowFuture:!1,strings:{prefixAgo:null,prefixFromNow:null,suffixAgo:"ago",suffixFromNow:"from now",seconds:"less than a minute",minute:"a minute",minutes:"%d minutes",hour:"an hour",hours:"%d hours",day:"a day",days:"%d days",month:"a month",months:"%d months",year:"a year",years:"%d years",numbers:[]}},inWords:function(t){function r(r,n){var i=e.isFunction(r)?r(n,t):r,o=a.numbers&&a.numbers[n]||n;return i.replace(/%d/i,o)}var a=this.settings.strings,n=a.prefixAgo,i=a.suffixAgo;this.settings.allowFuture&&(0>t&&(n=a.prefixFromNow,i=a.suffixFromNow),t=Math.abs(t));var o=t/1e3,s=o/60,u=s/60,m=u/24,d=m/365,f=45>o&&r(a.seconds,Math.round(o))||90>o&&r(a.minute,1)||45>s&&r(a.minutes,Math.round(s))||90>s&&r(a.hour,1)||24>u&&r(a.hours,Math.round(u))||48>u&&r(a.day,1)||30>m&&r(a.days,Math.floor(m))||60>m&&r(a.month,1)||365>m&&r(a.months,Math.floor(m/30))||2>d&&r(a.year,1)||r(a.years,Math.floor(d));return e.trim([n,f,i].join(" "))},parse:function(t){var r=e.trim(t);return r=r.replace(/\.\d\d\d+/,""),r=r.replace(/-/,"/").replace(/-/,"/"),r=r.replace(/T/," ").replace(/Z/," UTC"),r=r.replace(/([\+\-]\d\d)\:?(\d\d)/," $1$2"),new Date(r)},datetime:function(t){var r="time"===e(t).get(0).tagName.toLowerCase(),a=e(t).attr(r?"datetime":"title");return i.parse(a)}}),e.fn.timeago=function(){var e=this;e.each(t);var r=i.settings;return r.refreshMillis>0&&setInterval(function(){e.each(t)},r.refreshMillis),e},document.createElement("abbr"),document.createElement("time")}(jQuery);
var dateFormat=function(){var t=/d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,e=/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,a=/[^-+\dA-Z]/g,m=function(t,e){for(t=String(t),e=e||2;t.length<e;)t="0"+t;return t};return function(d,n,r){var y=dateFormat;if(1!=arguments.length||"[object String]"!=Object.prototype.toString.call(d)||/\d/.test(d)||(n=d,d=void 0),d=d?new Date(d):new Date,isNaN(d))throw SyntaxError("invalid date");n=String(y.masks[n]||n||y.masks["default"]),"UTC:"==n.slice(0,4)&&(n=n.slice(4),r=!0);var s=r?"getUTC":"get",i=d[s+"Date"](),o=d[s+"Day"](),u=d[s+"Month"](),M=d[s+"FullYear"](),l=d[s+"Hours"](),T=d[s+"Minutes"](),h=d[s+"Seconds"](),c=d[s+"Milliseconds"](),g=r?0:d.getTimezoneOffset(),S={d:i,dd:m(i),ddd:y.i18n.dayNames[o],dddd:y.i18n.dayNames[o+7],m:u+1,mm:m(u+1),mmm:y.i18n.monthNames[u],mmmm:y.i18n.monthNames[u+12],yy:String(M).slice(2),yyyy:M,h:l%12||12,hh:m(l%12||12),H:l,HH:m(l),M:T,MM:m(T),s:h,ss:m(h),l:m(c,3),L:m(c>99?Math.round(c/10):c),t:12>l?"a":"p",tt:12>l?"am":"pm",T:12>l?"A":"P",TT:12>l?"AM":"PM",Z:r?"UTC":(String(d).match(e)||[""]).pop().replace(a,""),o:(g>0?"-":"+")+m(100*Math.floor(Math.abs(g)/60)+Math.abs(g)%60,4),S:["th","st","nd","rd"][i%10>3?0:(i%100-i%10!=10)*i%10]};return n.replace(t,function(t){return t in S?S[t]:t.slice(1,t.length-1)})}}();dateFormat.masks={"default":"ddd mmm dd yyyy HH:MM:ss",shortDate:"m/d/yy",mediumDate:"mmm d, yyyy",longDate:"mmmm d, yyyy",fullDate:"dddd, mmmm d, yyyy",shortTime:"h:MM TT",mediumTime:"h:MM:ss TT",longTime:"h:MM:ss TT Z",isoDate:"yyyy-mm-dd",isoTime:"HH:MM:ss",isoDateTime:"yyyy-mm-dd'T'HH:MM:ss",isoUtcDateTime:"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"},dateFormat.i18n={dayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],monthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec","January","February","March","April","May","June","July","August","September","October","November","December"]},Date.prototype.format=function(t,e){return dateFormat(this,t,e)};
var hljs=new function(){function e(e){return e.replace(/&/gm,"&amp;").replace(/</gm,"&lt;").replace(/>/gm,"&gt;")}function t(e){return e.nodeName.toLowerCase()}function r(e,t){var r=e&&e.exec(t);return r&&0==r.index}function i(e){return Array.prototype.map.call(e.childNodes,function(e){return 3==e.nodeType?f.useBR?e.nodeValue.replace(/\n/g,""):e.nodeValue:"br"==t(e)?"\n":i(e)}).join("")}function n(e){var t=(e.className+" "+(e.parentNode?e.parentNode.className:"")).split(/\s+/);return t=t.map(function(e){return e.replace(/^language-/,"")}),t.filter(function(e){return S(e)||"no-highlight"==e})[0]}function a(e,t){var r={};for(var i in e)r[i]=e[i];if(t)for(var i in t)r[i]=t[i];return r}function o(e){var r=[];return function i(e,n){for(var a=e.firstChild;a;a=a.nextSibling)3==a.nodeType?n+=a.nodeValue.length:"br"==t(a)?n+=1:1==a.nodeType&&(r.push({event:"start",offset:n,node:a}),n=i(a,n),r.push({event:"stop",offset:n,node:a}));return n}(e,0),r}function s(r,i,n){function a(){return r.length&&i.length?r[0].offset!=i[0].offset?r[0].offset<i[0].offset?r:i:"start"==i[0].event?r:i:r.length?r:i}function o(r){function i(t){return" "+t.nodeName+'="'+e(t.value)+'"'}u+="<"+t(r)+Array.prototype.map.call(r.attributes,i).join("")+">"}function s(e){u+="</"+t(e)+">"}function l(e){("start"==e.event?o:s)(e.node)}for(var c=0,u="",d=[];r.length||i.length;){var p=a();if(u+=e(n.substr(c,p[0].offset-c)),c=p[0].offset,p==r){d.reverse().forEach(s);do l(p.splice(0,1)[0]),p=a();while(p==r&&p.length&&p[0].offset==c);d.reverse().forEach(o)}else"start"==p[0].event?d.push(p[0].node):d.pop(),l(p.splice(0,1)[0])}return u+e(n.substr(c))}function l(e){function t(e){return e&&e.source||e}function r(r,i){return RegExp(t(r),"m"+(e.cI?"i":"")+(i?"g":""))}function i(n,o){function s(t,r){e.cI&&(r=r.toLowerCase()),r.split(" ").forEach(function(e){var r=e.split("|");l[r[0]]=[t,r[1]?Number(r[1]):1]})}if(!n.compiled){if(n.compiled=!0,n.k=n.k||n.bK,n.k){var l={};"string"==typeof n.k?s("keyword",n.k):Object.keys(n.k).forEach(function(e){s(e,n.k[e])}),n.k=l}n.lR=r(n.l||/\b[A-Za-z0-9_]+\b/,!0),o&&(n.bK&&(n.b=n.bK.split(" ").join("|")),n.b||(n.b=/\B|\b/),n.bR=r(n.b),n.e||n.eW||(n.e=/\B|\b/),n.e&&(n.eR=r(n.e)),n.tE=t(n.e)||"",n.eW&&o.tE&&(n.tE+=(n.e?"|":"")+o.tE)),n.i&&(n.iR=r(n.i)),void 0===n.r&&(n.r=1),n.c||(n.c=[]);var c=[];n.c.forEach(function(e){e.v?e.v.forEach(function(t){c.push(a(e,t))}):c.push("self"==e?n:e)}),n.c=c,n.c.forEach(function(e){i(e,n)}),n.starts&&i(n.starts,o);var u=n.c.map(function(e){return e.bK?"\\.?\\b("+e.b+")\\b\\.?":e.b}).concat([n.tE]).concat([n.i]).map(t).filter(Boolean);n.t=u.length?r(u.join("|"),!0):{exec:function(){return null}},n.continuation={}}}i(e)}function c(t,i,n,a){function o(e,t){for(var i=0;i<t.c.length;i++)if(r(t.c[i].bR,e))return t.c[i]}function s(e,t){return r(e.eR,t)?e:e.eW?s(e.parent,t):void 0}function d(e,t){return!n&&r(t.iR,e)}function p(e,t){var r=v.cI?t[0].toLowerCase():t[0];return e.k.hasOwnProperty(r)&&e.k[r]}function m(e,t,r,i){var n=i?"":f.classPrefix,a='<span class="'+n,o=r?"":"</span>";return a+=e+'">',a+t+o}function g(){var t=e(M);if(!N.k)return t;var r="",i=0;N.lR.lastIndex=0;for(var n=N.lR.exec(t);n;){r+=t.substr(i,n.index-i);var a=p(N,n);a?(F+=a[1],r+=m(a[0],n[0])):r+=n[0],i=N.lR.lastIndex,n=N.lR.exec(t)}return r+t.substr(i)}function b(){if(N.sL&&!y[N.sL])return e(M);var t=N.sL?c(N.sL,M,!0,N.continuation.top):u(M);return N.r>0&&(F+=t.r),"continuous"==N.subLanguageMode&&(N.continuation.top=t.top),m(t.language,t.value,!1,!0)}function h(){return void 0!==N.sL?b():g()}function C(t,r){var i=t.cN?m(t.cN,"",!0):"";t.rB?(x+=i,M=""):t.eB?(x+=e(r)+i,M=""):(x+=i,M=r),N=Object.create(t,{parent:{value:N}})}function D(t,r){if(M+=t,void 0===r)return x+=h(),0;var i=o(r,N);if(i)return x+=h(),C(i,r),i.rB?0:r.length;var n=s(N,r);if(n){var a=N;a.rE||a.eE||(M+=r),x+=h();do N.cN&&(x+="</span>"),F+=N.r,N=N.parent;while(N!=n.parent);return a.eE&&(x+=e(r)),M="",n.starts&&C(n.starts,""),a.rE?0:r.length}if(d(r,N))throw new Error('Illegal lexeme "'+r+'" for mode "'+(N.cN||"<unnamed>")+'"');return M+=r,r.length||1}var v=S(t);if(!v)throw new Error('Unknown language: "'+t+'"');l(v);for(var N=a||v,x="",P=N;P!=v;P=P.parent)P.cN&&(x=m(P.cN,x,!0));var M="",F=0;try{for(var L,k,B=0;;){if(N.t.lastIndex=B,L=N.t.exec(i),!L)break;k=D(i.substr(B,L.index-B),L[0]),B=L.index+k}D(i.substr(B));for(var P=N;P.parent;P=P.parent)P.cN&&(x+="</span>");return{r:F,value:x,language:t,top:N}}catch(T){if(-1!=T.message.indexOf("Illegal"))return{r:0,value:e(i)};throw T}}function u(t,r){r=r||f.languages||Object.keys(y);var i={r:0,value:e(t)},n=i;return r.forEach(function(e){if(S(e)){var r=c(e,t,!1);r.language=e,r.r>n.r&&(n=r),r.r>i.r&&(n=i,i=r)}}),n.language&&(i.second_best=n),i}function d(e){return f.tabReplace&&(e=e.replace(/^((<[^>]+>|\t)+)/gm,function(e,t){return t.replace(/\t/g,f.tabReplace)})),f.useBR&&(e=e.replace(/\n/g,"<br>")),e}function p(e){var t=i(e),r=n(e);if("no-highlight"!=r){var a=r?c(r,t,!0):u(t),l=o(e);if(l.length){var p=document.createElementNS("http://www.w3.org/1999/xhtml","pre");p.innerHTML=a.value,a.value=s(l,o(p),t)}a.value=d(a.value),e.innerHTML=a.value,e.className+=" hljs "+(!r&&a.language||""),e.result={language:a.language,re:a.r},a.second_best&&(e.second_best={language:a.second_best.language,re:a.second_best.r})}}function m(e){f=a(f,e)}function g(){if(!g.called){g.called=!0;var e=document.querySelectorAll("pre code");Array.prototype.forEach.call(e,p)}}function b(){addEventListener("DOMContentLoaded",g,!1),addEventListener("load",g,!1)}function h(e,t){var r=y[e]=t(this);r.aliases&&r.aliases.forEach(function(t){C[t]=e})}function S(e){return y[e]||y[C[e]]}var f={classPrefix:"hljs-",tabReplace:null,useBR:!1,languages:void 0},y={},C={};this.highlight=c,this.highlightAuto=u,this.fixMarkup=d,this.highlightBlock=p,this.configure=m,this.initHighlighting=g,this.initHighlightingOnLoad=b,this.registerLanguage=h,this.getLanguage=S,this.inherit=a,this.IR="[a-zA-Z][a-zA-Z0-9_]*",this.UIR="[a-zA-Z_][a-zA-Z0-9_]*",this.NR="\\b\\d+(\\.\\d+)?",this.CNR="(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",this.BNR="\\b(0b[01]+)",this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",this.BE={b:"\\\\[\\s\\S]",r:0},this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE]},this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE]},this.CLCM={cN:"comment",b:"//",e:"$"},this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"},this.HCM={cN:"comment",b:"#",e:"$"},this.NM={cN:"number",b:this.NR,r:0},this.CNM={cN:"number",b:this.CNR,r:0},this.BNM={cN:"number",b:this.BNR,r:0},this.REGEXP_MODE={cN:"regexp",b:/\//,e:/\/[gim]*/,i:/\n/,c:[this.BE,{b:/\[/,e:/\]/,r:0,c:[this.BE]}]},this.TM={cN:"title",b:this.IR,r:0},this.UTM={cN:"title",b:this.UIR,r:0}};hljs.registerLanguage("bash",function(e){var t={cN:"variable",v:[{b:/\$[\w\d#@][\w\d_]*/},{b:/\$\{(.*?)\}/}]},r={cN:"string",b:/"/,e:/"/,c:[e.BE,t,{cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]}]},i={cN:"string",b:/'/,e:/'/};return{l:/-?[a-z\.]+/,k:{keyword:"if then else elif fi for break continue while in do done exit return set declare case esac export exec",literal:"true false",built_in:"printf echo read cd pwd pushd popd dirs let eval unset typeset readonly getopts source shopt caller type hash bind help sudo",operator:"-ne -eq -lt -gt -f -d -e -s -l -a"},c:[{cN:"shebang",b:/^#![^\n]+sh\s*$/,r:10},{cN:"function",b:/\w[\w\d_]*\s*\(\s*\)\s*\{/,rB:!0,c:[e.inherit(e.TM,{b:/\w[\w\d_]*/})],r:0},e.HCM,e.NM,r,i,t]}}),hljs.registerLanguage("erlang",function(e){var t="[a-z'][a-zA-Z0-9_']*",r="("+t+":"+t+"|"+t+")",i={keyword:"after and andalso|10 band begin bnot bor bsl bzr bxor case catch cond div end fun let not of orelse|10 query receive rem try when xor",literal:"false true"},n={cN:"comment",b:"%",e:"$",r:0},a={cN:"number",b:"\\b(\\d+#[a-fA-F0-9]+|\\d+(\\.\\d+)?([eE][-+]?\\d+)?)",r:0},o={b:"fun\\s+"+t+"/\\d+"},s={b:r+"\\(",e:"\\)",rB:!0,r:0,c:[{cN:"function_name",b:r,r:0},{b:"\\(",e:"\\)",eW:!0,rE:!0,r:0}]},l={cN:"tuple",b:"{",e:"}",r:0},c={cN:"variable",b:"\\b_([A-Z][A-Za-z0-9_]*)?",r:0},u={cN:"variable",b:"[A-Z][a-zA-Z0-9_]*",r:0},d={b:"#"+e.UIR,r:0,rB:!0,c:[{cN:"record_name",b:"#"+e.UIR,r:0},{b:"{",e:"}",r:0}]},p={bK:"fun receive if try case",e:"end",k:i};p.c=[n,o,e.inherit(e.ASM,{cN:""}),p,s,e.QSM,a,l,c,u,d];var m=[n,o,p,s,e.QSM,a,l,c,u,d];s.c[1].c=m,l.c=m,d.c[1].c=m;var g={cN:"params",b:"\\(",e:"\\)",c:m};return{k:i,i:"(</|\\*=|\\+=|-=|/=|/\\*|\\*/|\\(\\*|\\*\\))",c:[{cN:"function",b:"^"+t+"\\s*\\(",e:"->",rB:!0,i:"\\(|#|//|/\\*|\\\\|:|;",c:[g,e.inherit(e.TM,{b:t})],starts:{e:";|\\.",k:i,c:m}},n,{cN:"pp",b:"^-",e:"\\.",r:0,eE:!0,rB:!0,l:"-"+e.IR,k:"-module -record -undef -export -ifdef -ifndef -author -copyright -doc -vsn -import -include -include_lib -compile -define -else -endif -file -behaviour -behavior",c:[g]},a,e.QSM,d,c,u,l]}}),hljs.registerLanguage("cs",function(e){var t="abstract as base bool break byte case catch char checked const continue decimal default delegate do double else enum event explicit extern false finally fixed float for foreach goto if implicit in int interface internal is lock long new null object operator out override params private protected public readonly ref return sbyte sealed short sizeof stackalloc static string struct switch this throw true try typeof uint ulong unchecked unsafe ushort using virtual volatile void while async await ascending descending from get group into join let orderby partial select set value var where yield";return{k:t,c:[{cN:"comment",b:"///",e:"$",rB:!0,c:[{cN:"xmlDocTag",b:"///|<!--|-->"},{cN:"xmlDocTag",b:"</?",e:">"}]},e.CLCM,e.CBLCLM,{cN:"preprocessor",b:"#",e:"$",k:"if else elif endif define undef warning error line region endregion pragma checksum"},{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},e.ASM,e.QSM,e.CNM,{bK:"protected public private internal",e:/[{;=]/,k:t,c:[{bK:"class namespace interface",starts:{c:[e.TM]}},{b:e.IR+"\\s*\\(",rB:!0,c:[e.TM]}]}]}}),hljs.registerLanguage("brainfuck",function(){var e={cN:"literal",b:"[\\+\\-]",r:0};return{c:[{cN:"comment",b:"[^\\[\\]\\.,\\+\\-<> \r\n]",rE:!0,e:"[\\[\\]\\.,\\+\\-<> \r\n]",r:0},{cN:"title",b:"[\\[\\]]",r:0},{cN:"string",b:"[\\.,]",r:0},{b:/\+\+|\-\-/,rB:!0,c:[e]},e]}}),hljs.registerLanguage("ruby",function(e){var t="[a-zA-Z_]\\w*[!?=]?|[-+~]\\@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?",r="and false then defined module in return redo if BEGIN retry end for true self when next until do begin unless END rescue nil else break undef not super class case require yield alias while ensure elsif or include attr_reader attr_writer attr_accessor",i={cN:"yardoctag",b:"@[A-Za-z]+"},n={cN:"comment",v:[{b:"#",e:"$",c:[i]},{b:"^\\=begin",e:"^\\=end",c:[i],r:10},{b:"^__END__",e:"\\n$"}]},a={cN:"subst",b:"#\\{",e:"}",k:r},o={cN:"string",c:[e.BE,a],v:[{b:/'/,e:/'/},{b:/"/,e:/"/},{b:"%[qw]?\\(",e:"\\)"},{b:"%[qw]?\\[",e:"\\]"},{b:"%[qw]?{",e:"}"},{b:"%[qw]?<",e:">",r:10},{b:"%[qw]?/",e:"/",r:10},{b:"%[qw]?%",e:"%",r:10},{b:"%[qw]?-",e:"-",r:10},{b:"%[qw]?\\|",e:"\\|",r:10},{b:/\B\?(\\\d{1,3}|\\x[A-Fa-f0-9]{1,2}|\\u[A-Fa-f0-9]{4}|\\?\S)\b/}]},s={cN:"params",b:"\\(",e:"\\)",k:r},l=[o,n,{cN:"class",bK:"class module",e:"$|;",i:/=/,c:[e.inherit(e.TM,{b:"[A-Za-z_]\\w*(::\\w+)*(\\?|\\!)?"}),{cN:"inheritance",b:"<\\s*",c:[{cN:"parent",b:"("+e.IR+"::)?"+e.IR}]},n]},{cN:"function",bK:"def",e:" |$|;",r:0,c:[e.inherit(e.TM,{b:t}),s,n]},{cN:"constant",b:"(::)?(\\b[A-Z]\\w*(::)?)+",r:0},{cN:"symbol",b:":",c:[o,{b:t}],r:0},{cN:"symbol",b:e.UIR+"(\\!|\\?)?:",r:0},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{cN:"variable",b:"(\\$\\W)|((\\$|\\@\\@?)(\\w+))"},{b:"("+e.RSR+")\\s*",c:[n,{cN:"regexp",c:[e.BE,a],i:/\n/,v:[{b:"/",e:"/[a-z]*"},{b:"%r{",e:"}[a-z]*"},{b:"%r\\(",e:"\\)[a-z]*"},{b:"%r!",e:"![a-z]*"},{b:"%r\\[",e:"\\][a-z]*"}]}],r:0}];return a.c=l,s.c=l,{k:r,c:l}}),hljs.registerLanguage("rust",function(e){var t={cN:"number",b:"\\b(0[xb][A-Za-z0-9_]+|[0-9_]+(\\.[0-9_]+)?([uif](8|16|32|64)?)?)",r:0},r="assert bool break char check claim comm const cont copy dir do drop else enum extern export f32 f64 fail false float fn for i16 i32 i64 i8 if impl int let log loop match mod move mut priv pub pure ref return self static str struct task true trait type u16 u32 u64 u8 uint unsafe use vec while";return{k:r,i:"</",c:[e.CLCM,e.CBLCLM,e.inherit(e.QSM,{i:null}),e.ASM,t,{cN:"function",bK:"fn",e:"(\\(|<)",c:[e.UTM]},{cN:"preprocessor",b:"#\\[",e:"\\]"},{bK:"type",e:"(=|<)",c:[e.UTM],i:"\\S"},{bK:"trait enum",e:"({|<)",c:[e.UTM],i:"\\S"}]}}),hljs.registerLanguage("diff",function(){return{c:[{cN:"chunk",r:10,v:[{b:/^\@\@ +\-\d+,\d+ +\+\d+,\d+ +\@\@$/},{b:/^\*\*\* +\d+,\d+ +\*\*\*\*$/},{b:/^\-\-\- +\d+,\d+ +\-\-\-\-$/}]},{cN:"header",v:[{b:/Index: /,e:/$/},{b:/=====/,e:/=====$/},{b:/^\-\-\-/,e:/$/},{b:/^\*{3} /,e:/$/},{b:/^\+\+\+/,e:/$/},{b:/\*{5}/,e:/\*{5}$/}]},{cN:"addition",b:"^\\+",e:"$"},{cN:"deletion",b:"^\\-",e:"$"},{cN:"change",b:"^\\!",e:"$"}]}}),hljs.registerLanguage("haml",function(){return{cI:!0,c:[{cN:"doctype",b:"^!!!( (5|1\\.1|Strict|Frameset|Basic|Mobile|RDFa|XML\\b.*))?$",r:10},{cN:"comment",b:"^\\s*(!=#|=#|-#|/).*$",r:0},{b:"^\\s*(-|=|!=)(?!#)",starts:{e:"\\n",sL:"ruby"}},{cN:"tag",b:"^\\s*%",c:[{cN:"title",b:"\\w+"},{cN:"value",b:"[#\\.]\\w+"},{b:"{\\s*",e:"\\s*}",eE:!0,c:[{b:":\\w+\\s*=>",e:",\\s+",rB:!0,eW:!0,c:[{cN:"symbol",b:":\\w+"},{cN:"string",b:'"',e:'"'},{cN:"string",b:"'",e:"'"},{b:"\\w+",r:0}]}]},{b:"\\(\\s*",e:"\\s*\\)",eE:!0,c:[{b:"\\w+\\s*=",e:"\\s+",rB:!0,eW:!0,c:[{cN:"attribute",b:"\\w+",r:0},{cN:"string",b:'"',e:'"'},{cN:"string",b:"'",e:"'"},{b:"\\w+",r:0}]}]}]},{cN:"bullet",b:"^\\s*[=~]\\s*",r:0},{b:"#{",starts:{e:"}",sL:"ruby"}}]}}),hljs.registerLanguage("javascript",function(e){return{aliases:["js"],k:{keyword:"in if for while finally var new function do return void else break catch instanceof with throw case default try this switch continue typeof delete let yield const class",literal:"true false null undefined NaN Infinity",built_in:"eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Error EvalError InternalError RangeError ReferenceError StopIteration SyntaxError TypeError URIError Number Math Date String RegExp Array Float32Array Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require"},c:[{cN:"pi",b:/^\s*('|")use strict('|")/,r:10},e.ASM,e.QSM,e.CLCM,e.CBLCLM,e.CNM,{b:"("+e.RSR+"|\\b(case|return|throw)\\b)\\s*",k:"return throw case",c:[e.CLCM,e.CBLCLM,e.REGEXP_MODE,{b:/</,e:/>;/,r:0,sL:"xml"}],r:0},{cN:"function",bK:"function",e:/\{/,c:[e.inherit(e.TM,{b:/[A-Za-z$_][0-9A-Za-z$_]*/}),{cN:"params",b:/\(/,e:/\)/,c:[e.CLCM,e.CBLCLM],i:/["'\(]/}],i:/\[|%/},{b:/\$[(.]/},{b:"\\."+e.IR,r:0}]}}),hljs.registerLanguage("lua",function(e){var t="\\[=*\\[",r="\\]=*\\]",i={b:t,e:r,c:["self"]},n=[{cN:"comment",b:"--(?!"+t+")",e:"$"},{cN:"comment",b:"--"+t,e:r,c:[i],r:10}];return{l:e.UIR,k:{keyword:"and break do else elseif end false for if in local nil not or repeat return then true until while",built_in:"_G _VERSION assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall coroutine debug io math os package string table"},c:n.concat([{cN:"function",bK:"function",e:"\\)",c:[e.inherit(e.TM,{b:"([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*"}),{cN:"params",b:"\\(",eW:!0,c:n}].concat(n)},e.CNM,e.ASM,e.QSM,{cN:"string",b:t,e:r,c:[i],r:10}])}}),hljs.registerLanguage("xml",function(){var e="[A-Za-z0-9\\._:-]+",t={b:/<\?(php)?(?!\w)/,e:/\?>/,sL:"php",subLanguageMode:"continuous"},r={eW:!0,i:/</,r:0,c:[t,{cN:"attribute",b:e,r:0},{b:"=",r:0,c:[{cN:"value",v:[{b:/"/,e:/"/},{b:/'/,e:/'/},{b:/[^\s\/>]+/}]}]}]};return{aliases:["html"],cI:!0,c:[{cN:"doctype",b:"<!DOCTYPE",e:">",r:10,c:[{b:"\\[",e:"\\]"}]},{cN:"comment",b:"<!--",e:"-->",r:10},{cN:"cdata",b:"<\\!\\[CDATA\\[",e:"\\]\\]>",r:10},{cN:"tag",b:"<style(?=\\s|>|$)",e:">",k:{title:"style"},c:[r],starts:{e:"</style>",rE:!0,sL:"css"}},{cN:"tag",b:"<script(?=\\s|>|$)",e:">",k:{title:"script"},c:[r],starts:{e:"</script>",rE:!0,sL:"javascript"}},{b:"<%",e:"%>",sL:"vbscript"},t,{cN:"pi",b:/<\?\w+/,e:/\?>/,r:10},{cN:"tag",b:"</?",e:"/?>",c:[{cN:"title",b:"[^ /><]+",r:0},r]}]}}),hljs.registerLanguage("markdown",function(){return{c:[{cN:"header",v:[{b:"^#{1,6}",e:"$"},{b:"^.+?\\n[=-]{2,}$"}]},{b:"<",e:">",sL:"xml",r:0},{cN:"bullet",b:"^([*+-]|(\\d+\\.))\\s+"},{cN:"strong",b:"[*_]{2}.+?[*_]{2}"},{cN:"emphasis",v:[{b:"\\*.+?\\*"},{b:"_.+?_",r:0}]},{cN:"blockquote",b:"^>\\s+",e:"$"},{cN:"code",v:[{b:"`.+?`"},{b:"^( {4}|	)",e:"$",r:0}]},{cN:"horizontal_rule",b:"^[-\\*]{3,}",e:"$"},{b:"\\[.+?\\][\\(\\[].+?[\\)\\]]",rB:!0,c:[{cN:"link_label",b:"\\[",e:"\\]",eB:!0,rE:!0,r:0},{cN:"link_url",b:"\\]\\(",e:"\\)",eB:!0,eE:!0},{cN:"link_reference",b:"\\]\\[",e:"\\]",eB:!0,eE:!0}],r:10},{b:"^\\[.+\\]:",e:"$",rB:!0,c:[{cN:"link_reference",b:"\\[",e:"\\]",eB:!0,eE:!0},{cN:"link_url",b:"\\s",e:"$"}]}]}}),hljs.registerLanguage("css",function(e){var t="[a-zA-Z-][a-zA-Z0-9_-]*",r={cN:"function",b:t+"\\(",e:"\\)",c:["self",e.NM,e.ASM,e.QSM]};return{cI:!0,i:"[=/|']",c:[e.CBLCLM,{cN:"id",b:"\\#[A-Za-z0-9_-]+"},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"pseudo",b:":(:)?[a-zA-Z0-9\\_\\-\\+\\(\\)\\\"\\']+"},{cN:"at_rule",b:"@(font-face|page)",l:"[a-z-]+",k:"font-face page"},{cN:"at_rule",b:"@",e:"[{;]",c:[{cN:"keyword",b:/\S+/},{b:/\s/,eW:!0,eE:!0,r:0,c:[r,e.ASM,e.QSM,e.NM]}]},{cN:"tag",b:t,r:0},{cN:"rules",b:"{",e:"}",i:"[^\\s]",r:0,c:[e.CBLCLM,{cN:"rule",b:"[^\\s]",rB:!0,e:";",eW:!0,c:[{cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:!0,i:"[^\\s]",starts:{cN:"value",eW:!0,eE:!0,c:[r,e.NM,e.QSM,e.ASM,e.CBLCLM,{cN:"hexcolor",b:"#[0-9A-Fa-f]+"},{cN:"important",b:"!important"}]}}]}]}]}}),hljs.registerLanguage("lisp",function(e){var t="[a-zA-Z_\\-\\+\\*\\/\\<\\=\\>\\&\\#][a-zA-Z0-9_\\-\\+\\*\\/\\<\\=\\>\\&\\#!]*",r="(\\-|\\+)?\\d+(\\.\\d+|\\/\\d+)?((d|e|f|l|s)(\\+|\\-)?\\d+)?",i={cN:"shebang",b:"^#!",e:"$"},n={cN:"literal",b:"\\b(t{1}|nil)\\b"},a={cN:"number",v:[{b:r,r:0},{b:"#b[0-1]+(/[0-1]+)?"},{b:"#o[0-7]+(/[0-7]+)?"},{b:"#x[0-9a-f]+(/[0-9a-f]+)?"},{b:"#c\\("+r+" +"+r,e:"\\)"}]},o=e.inherit(e.QSM,{i:null}),s={cN:"comment",b:";",e:"$"},l={cN:"variable",b:"\\*",e:"\\*"},c={cN:"keyword",b:"[:&]"+t},u={b:"\\(",e:"\\)",c:["self",n,o,a]},d={cN:"quoted",c:[a,o,l,c,u],v:[{b:"['`]\\(",e:"\\)"},{b:"\\(quote ",e:"\\)",k:{title:"quote"}}]},p={cN:"list",b:"\\(",e:"\\)"},m={eW:!0,r:0};return p.c=[{cN:"title",b:t},m],m.c=[d,p,n,a,o,s,l,c],{i:/\S/,c:[a,i,n,o,s,d,p]}}),hljs.registerLanguage("profile",function(e){return{c:[e.CNM,{cN:"built_in",b:"{",e:"}$",eB:!0,eE:!0,c:[e.ASM,e.QSM],r:0},{cN:"filename",b:"[a-zA-Z_][\\da-zA-Z_]+\\.[\\da-zA-Z_]{1,3}",e:":",eE:!0},{cN:"header",b:"(ncalls|tottime|cumtime)",e:"$",k:"ncalls tottime|10 cumtime|10 filename",r:10},{cN:"summary",b:"function calls",e:"$",c:[e.CNM],r:10},e.ASM,e.QSM,{cN:"function",b:"\\(",e:"\\)$",c:[e.UTM],r:0}]}}),hljs.registerLanguage("http",function(){return{i:"\\S",c:[{cN:"status",b:"^HTTP/[0-9\\.]+",e:"$",c:[{cN:"number",b:"\\b\\d{3}\\b"}]},{cN:"request",b:"^[A-Z]+ (.*?) HTTP/[0-9\\.]+$",rB:!0,e:"$",c:[{cN:"string",b:" ",e:" ",eB:!0,eE:!0}]},{cN:"attribute",b:"^\\w",e:": ",eE:!0,i:"\\n|\\s|=",starts:{cN:"string",e:"$"}},{b:"\\n\\n",starts:{sL:"",eW:!0}}]}}),hljs.registerLanguage("java",function(e){var t="false synchronized int abstract float private char boolean static null if const for true while long throw strictfp finally protected import native final return void enum else break transient new catch instanceof byte super volatile case assert short package default double public try this switch continue throws";return{k:t,i:/<\//,c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"(^|\\s)@[A-Za-z]+"}],r:10},e.CLCM,e.CBLCLM,e.ASM,e.QSM,{bK:"protected public private",e:/[{;=]/,k:t,c:[{cN:"class",bK:"class interface",eW:!0,i:/[:"<>]/,c:[{bK:"extends implements",r:10},e.UTM]},{b:e.UIR+"\\s*\\(",rB:!0,c:[e.UTM]}]},e.CNM,{cN:"annotation",b:"@[A-Za-z]+"}]}}),hljs.registerLanguage("fsharp",function(e){return{k:"abstract and as assert base begin class default delegate do done downcast downto elif else end exception extern false finally for fun function global if in inherit inline interface internal lazy let match member module mutable namespace new null of open or override private public rec return sig static struct then to true try type upcast use val void when while with yield",c:[{cN:"string",b:'@"',e:'"',c:[{b:'""'}]},{cN:"string",b:'"""',e:'"""'},{cN:"comment",b:"\\(\\*",e:"\\*\\)"},{cN:"class",bK:"type",e:"\\(|=|$",c:[e.UTM]},{cN:"annotation",b:"\\[<",e:">\\]"},{cN:"attribute",b:"\\B('[A-Za-z])\\b",c:[e.BE]},e.CLCM,e.inherit(e.QSM,{i:null}),e.CNM]}}),hljs.registerLanguage("mathematica",function(e){return{aliases:["mma"],l:"(\\$|\\b)"+e.IR+"\\b",k:"AbelianGroup Abort AbortKernels AbortProtect Above Abs Absolute AbsoluteCorrelation AbsoluteCorrelationFunction AbsoluteCurrentValue AbsoluteDashing AbsoluteFileName AbsoluteOptions AbsolutePointSize AbsoluteThickness AbsoluteTime AbsoluteTiming AccountingForm Accumulate Accuracy AccuracyGoal ActionDelay ActionMenu ActionMenuBox ActionMenuBoxOptions Active ActiveItem ActiveStyle AcyclicGraphQ AddOnHelpPath AddTo AdjacencyGraph AdjacencyList AdjacencyMatrix AdjustmentBox AdjustmentBoxOptions AdjustTimeSeriesForecast AffineTransform After AiryAi AiryAiPrime AiryAiZero AiryBi AiryBiPrime AiryBiZero AlgebraicIntegerQ AlgebraicNumber AlgebraicNumberDenominator AlgebraicNumberNorm AlgebraicNumberPolynomial AlgebraicNumberTrace AlgebraicRules AlgebraicRulesData Algebraics AlgebraicUnitQ Alignment AlignmentMarker AlignmentPoint All AllowedDimensions AllowGroupClose AllowInlineCells AllowKernelInitialization AllowReverseGroupClose AllowScriptLevelChange AlphaChannel AlternatingGroup AlternativeHypothesis Alternatives AmbientLight Analytic AnchoredSearch And AndersonDarlingTest AngerJ AngleBracket AngularGauge Animate AnimationCycleOffset AnimationCycleRepetitions AnimationDirection AnimationDisplayTime AnimationRate AnimationRepetitions AnimationRunning Animator AnimatorBox AnimatorBoxOptions AnimatorElements Annotation Annuity AnnuityDue Antialiasing Antisymmetric Apart ApartSquareFree Appearance AppearanceElements AppellF1 Append AppendTo Apply ArcCos ArcCosh ArcCot ArcCoth ArcCsc ArcCsch ArcSec ArcSech ArcSin ArcSinDistribution ArcSinh ArcTan ArcTanh Arg ArgMax ArgMin ArgumentCountQ ARIMAProcess ArithmeticGeometricMean ARMAProcess ARProcess Array ArrayComponents ArrayDepth ArrayFlatten ArrayPad ArrayPlot ArrayQ ArrayReshape ArrayRules Arrays Arrow Arrow3DBox ArrowBox Arrowheads AspectRatio AspectRatioFixed Assert Assuming Assumptions AstronomicalData Asynchronous AsynchronousTaskObject AsynchronousTasks AtomQ Attributes AugmentedSymmetricPolynomial AutoAction AutoDelete AutoEvaluateEvents AutoGeneratedPackage AutoIndent AutoIndentSpacings AutoItalicWords AutoloadPath AutoMatch Automatic AutomaticImageSize AutoMultiplicationSymbol AutoNumberFormatting AutoOpenNotebooks AutoOpenPalettes AutorunSequencing AutoScaling AutoScroll AutoSpacing AutoStyleOptions AutoStyleWords Axes AxesEdge AxesLabel AxesOrigin AxesStyle Axis BabyMonsterGroupB Back Background BackgroundTasksSettings Backslash Backsubstitution Backward Band BandpassFilter BandstopFilter BarabasiAlbertGraphDistribution BarChart BarChart3D BarLegend BarlowProschanImportance BarnesG BarOrigin BarSpacing BartlettHannWindow BartlettWindow BaseForm Baseline BaselinePosition BaseStyle BatesDistribution BattleLemarieWavelet Because BeckmannDistribution Beep Before Begin BeginDialogPacket BeginFrontEndInteractionPacket BeginPackage BellB BellY Below BenfordDistribution BeniniDistribution BenktanderGibratDistribution BenktanderWeibullDistribution BernoulliB BernoulliDistribution BernoulliGraphDistribution BernoulliProcess BernsteinBasis BesselFilterModel BesselI BesselJ BesselJZero BesselK BesselY BesselYZero Beta BetaBinomialDistribution BetaDistribution BetaNegativeBinomialDistribution BetaPrimeDistribution BetaRegularized BetweennessCentrality BezierCurve BezierCurve3DBox BezierCurve3DBoxOptions BezierCurveBox BezierCurveBoxOptions BezierFunction BilateralFilter Binarize BinaryFormat BinaryImageQ BinaryRead BinaryReadList BinaryWrite BinCounts BinLists Binomial BinomialDistribution BinomialProcess BinormalDistribution BiorthogonalSplineWavelet BipartiteGraphQ BirnbaumImportance BirnbaumSaundersDistribution BitAnd BitClear BitGet BitLength BitNot BitOr BitSet BitShiftLeft BitShiftRight BitXor Black BlackmanHarrisWindow BlackmanNuttallWindow BlackmanWindow Blank BlankForm BlankNullSequence BlankSequence Blend Block BlockRandom BlomqvistBeta BlomqvistBetaTest Blue Blur BodePlot BohmanWindow Bold Bookmarks Boole BooleanConsecutiveFunction BooleanConvert BooleanCountingFunction BooleanFunction BooleanGraph BooleanMaxterms BooleanMinimize BooleanMinterms Booleans BooleanTable BooleanVariables BorderDimensions BorelTannerDistribution Bottom BottomHatTransform BoundaryStyle Bounds Box BoxBaselineShift BoxData BoxDimensions Boxed Boxes BoxForm BoxFormFormatTypes BoxFrame BoxID BoxMargins BoxMatrix BoxRatios BoxRotation BoxRotationPoint BoxStyle BoxWhiskerChart Bra BracketingBar BraKet BrayCurtisDistance BreadthFirstScan Break Brown BrownForsytheTest BrownianBridgeProcess BrowserCategory BSplineBasis BSplineCurve BSplineCurve3DBox BSplineCurveBox BSplineCurveBoxOptions BSplineFunction BSplineSurface BSplineSurface3DBox BubbleChart BubbleChart3D BubbleScale BubbleSizes BulletGauge BusinessDayQ ButterflyGraph ButterworthFilterModel Button ButtonBar ButtonBox ButtonBoxOptions ButtonCell ButtonContents ButtonData ButtonEvaluator ButtonExpandable ButtonFrame ButtonFunction ButtonMargins ButtonMinHeight ButtonNote ButtonNotebook ButtonSource ButtonStyle ButtonStyleMenuListing Byte ByteCount ByteOrdering C CachedValue CacheGraphics CalendarData CalendarType CallPacket CanberraDistance Cancel CancelButton CandlestickChart Cap CapForm CapitalDifferentialD CardinalBSplineBasis CarmichaelLambda Cases Cashflow Casoratian Catalan CatalanNumber Catch CauchyDistribution CauchyWindow CayleyGraph CDF CDFDeploy CDFInformation CDFWavelet Ceiling Cell CellAutoOverwrite CellBaseline CellBoundingBox CellBracketOptions CellChangeTimes CellContents CellContext CellDingbat CellDynamicExpression CellEditDuplicate CellElementsBoundingBox CellElementSpacings CellEpilog CellEvaluationDuplicate CellEvaluationFunction CellEventActions CellFrame CellFrameColor CellFrameLabelMargins CellFrameLabels CellFrameMargins CellGroup CellGroupData CellGrouping CellGroupingRules CellHorizontalScrolling CellID CellLabel CellLabelAutoDelete CellLabelMargins CellLabelPositioning CellMargins CellObject CellOpen CellPrint CellProlog Cells CellSize CellStyle CellTags CellularAutomaton CensoredDistribution Censoring Center CenterDot CentralMoment CentralMomentGeneratingFunction CForm ChampernowneNumber ChanVeseBinarize Character CharacterEncoding CharacterEncodingsPath CharacteristicFunction CharacteristicPolynomial CharacterRange Characters ChartBaseStyle ChartElementData ChartElementDataFunction ChartElementFunction ChartElements ChartLabels ChartLayout ChartLegends ChartStyle Chebyshev1FilterModel Chebyshev2FilterModel ChebyshevDistance ChebyshevT ChebyshevU Check CheckAbort CheckAll Checkbox CheckboxBar CheckboxBox CheckboxBoxOptions ChemicalData ChessboardDistance ChiDistribution ChineseRemainder ChiSquareDistribution ChoiceButtons ChoiceDialog CholeskyDecomposition Chop Circle CircleBox CircleDot CircleMinus CirclePlus CircleTimes CirculantGraph CityData Clear ClearAll ClearAttributes ClearSystemCache ClebschGordan ClickPane Clip ClipboardNotebook ClipFill ClippingStyle ClipPlanes ClipRange Clock ClockGauge ClockwiseContourIntegral Close Closed CloseKernels ClosenessCentrality Closing ClosingAutoSave ClosingEvent ClusteringComponents CMYKColor Coarse Coefficient CoefficientArrays CoefficientDomain CoefficientList CoefficientRules CoifletWavelet Collect Colon ColonForm ColorCombine ColorConvert ColorData ColorDataFunction ColorFunction ColorFunctionScaling Colorize ColorNegate ColorOutput ColorProfileData ColorQuantize ColorReplace ColorRules ColorSelectorSettings ColorSeparate ColorSetter ColorSetterBox ColorSetterBoxOptions ColorSlider ColorSpace Column ColumnAlignments ColumnBackgrounds ColumnForm ColumnLines ColumnsEqual ColumnSpacings ColumnWidths CommonDefaultFormatTypes Commonest CommonestFilter CommonUnits CommunityBoundaryStyle CommunityGraphPlot CommunityLabels CommunityRegionStyle CompatibleUnitQ CompilationOptions CompilationTarget Compile Compiled CompiledFunction Complement CompleteGraph CompleteGraphQ CompleteKaryTree CompletionsListPacket Complex Complexes ComplexExpand ComplexInfinity ComplexityFunction ComponentMeasurements ComponentwiseContextMenu Compose ComposeList ComposeSeries Composition CompoundExpression CompoundPoissonDistribution CompoundPoissonProcess CompoundRenewalProcess Compress CompressedData Condition ConditionalExpression Conditioned Cone ConeBox ConfidenceLevel ConfidenceRange ConfidenceTransform ConfigurationPath Congruent Conjugate ConjugateTranspose Conjunction Connect ConnectedComponents ConnectedGraphQ ConnesWindow ConoverTest ConsoleMessage ConsoleMessagePacket ConsolePrint Constant ConstantArray Constants ConstrainedMax ConstrainedMin ContentPadding ContentsBoundingBox ContentSelectable ContentSize Context ContextMenu Contexts ContextToFilename ContextToFileName Continuation Continue ContinuedFraction ContinuedFractionK ContinuousAction ContinuousMarkovProcess ContinuousTimeModelQ ContinuousWaveletData ContinuousWaveletTransform ContourDetect ContourGraphics ContourIntegral ContourLabels ContourLines ContourPlot ContourPlot3D Contours ContourShading ContourSmoothing ContourStyle ContraharmonicMean Control ControlActive ControlAlignment ControllabilityGramian ControllabilityMatrix ControllableDecomposition ControllableModelQ ControllerDuration ControllerInformation ControllerInformationData ControllerLinking ControllerManipulate ControllerMethod ControllerPath ControllerState ControlPlacement ControlsRendering ControlType Convergents ConversionOptions ConversionRules ConvertToBitmapPacket ConvertToPostScript ConvertToPostScriptPacket Convolve ConwayGroupCo1 ConwayGroupCo2 ConwayGroupCo3 CoordinateChartData CoordinatesToolOptions CoordinateTransform CoordinateTransformData CoprimeQ Coproduct CopulaDistribution Copyable CopyDirectory CopyFile CopyTag CopyToClipboard CornerFilter CornerNeighbors Correlation CorrelationDistance CorrelationFunction CorrelationTest Cos Cosh CoshIntegral CosineDistance CosineWindow CosIntegral Cot Coth Count CounterAssignments CounterBox CounterBoxOptions CounterClockwiseContourIntegral CounterEvaluator CounterFunction CounterIncrements CounterStyle CounterStyleMenuListing CountRoots CountryData Covariance CovarianceEstimatorFunction CovarianceFunction CoxianDistribution CoxIngersollRossProcess CoxModel CoxModelFit CramerVonMisesTest CreateArchive CreateDialog CreateDirectory CreateDocument CreateIntermediateDirectories CreatePalette CreatePalettePacket CreateScheduledTask CreateTemporary CreateWindow CriticalityFailureImportance CriticalitySuccessImportance CriticalSection Cross CrossingDetect CrossMatrix Csc Csch CubeRoot Cubics Cuboid CuboidBox Cumulant CumulantGeneratingFunction Cup CupCap Curl CurlyDoubleQuote CurlyQuote CurrentImage CurrentlySpeakingPacket CurrentValue CurvatureFlowFilter CurveClosed Cyan CycleGraph CycleIndexPolynomial Cycles CyclicGroup Cyclotomic Cylinder CylinderBox CylindricalDecomposition D DagumDistribution DamerauLevenshteinDistance DampingFactor Darker Dashed Dashing DataCompression DataDistribution DataRange DataReversed Date DateDelimiters DateDifference DateFunction DateList DateListLogPlot DateListPlot DatePattern DatePlus DateRange DateString DateTicksFormat DaubechiesWavelet DavisDistribution DawsonF DayCount DayCountConvention DayMatchQ DayName DayPlus DayRange DayRound DeBruijnGraph Debug DebugTag Decimal DeclareKnownSymbols DeclarePackage Decompose Decrement DedekindEta Default DefaultAxesStyle DefaultBaseStyle DefaultBoxStyle DefaultButton DefaultColor DefaultControlPlacement DefaultDuplicateCellStyle DefaultDuration DefaultElement DefaultFaceGridsStyle DefaultFieldHintStyle DefaultFont DefaultFontProperties DefaultFormatType DefaultFormatTypeForStyle DefaultFrameStyle DefaultFrameTicksStyle DefaultGridLinesStyle DefaultInlineFormatType DefaultInputFormatType DefaultLabelStyle DefaultMenuStyle DefaultNaturalLanguage DefaultNewCellStyle DefaultNewInlineCellStyle DefaultNotebook DefaultOptions DefaultOutputFormatType DefaultStyle DefaultStyleDefinitions DefaultTextFormatType DefaultTextInlineFormatType DefaultTicksStyle DefaultTooltipStyle DefaultValues Defer DefineExternal DefineInputStreamMethod DefineOutputStreamMethod Definition Degree DegreeCentrality DegreeGraphDistribution DegreeLexicographic DegreeReverseLexicographic Deinitialization Del Deletable Delete DeleteBorderComponents DeleteCases DeleteContents DeleteDirectory DeleteDuplicates DeleteFile DeleteSmallComponents DeleteWithContents DeletionWarning Delimiter DelimiterFlashTime DelimiterMatching Delimiters Denominator DensityGraphics DensityHistogram DensityPlot DependentVariables Deploy Deployed Depth DepthFirstScan Derivative DerivativeFilter DescriptorStateSpace DesignMatrix Det DGaussianWavelet DiacriticalPositioning Diagonal DiagonalMatrix Dialog DialogIndent DialogInput DialogLevel DialogNotebook DialogProlog DialogReturn DialogSymbols Diamond DiamondMatrix DiceDissimilarity DictionaryLookup DifferenceDelta DifferenceOrder DifferenceRoot DifferenceRootReduce Differences DifferentialD DifferentialRoot DifferentialRootReduce DifferentiatorFilter DigitBlock DigitBlockMinimum DigitCharacter DigitCount DigitQ DihedralGroup Dilation Dimensions DiracComb DiracDelta DirectedEdge DirectedEdges DirectedGraph DirectedGraphQ DirectedInfinity Direction Directive Directory DirectoryName DirectoryQ DirectoryStack DirichletCharacter DirichletConvolve DirichletDistribution DirichletL DirichletTransform DirichletWindow DisableConsolePrintPacket DiscreteChirpZTransform DiscreteConvolve DiscreteDelta DiscreteHadamardTransform DiscreteIndicator DiscreteLQEstimatorGains DiscreteLQRegulatorGains DiscreteLyapunovSolve DiscreteMarkovProcess DiscretePlot DiscretePlot3D DiscreteRatio DiscreteRiccatiSolve DiscreteShift DiscreteTimeModelQ DiscreteUniformDistribution DiscreteVariables DiscreteWaveletData DiscreteWaveletPacketTransform DiscreteWaveletTransform Discriminant Disjunction Disk DiskBox DiskMatrix Dispatch DispersionEstimatorFunction Display DisplayAllSteps DisplayEndPacket DisplayFlushImagePacket DisplayForm DisplayFunction DisplayPacket DisplayRules DisplaySetSizePacket DisplayString DisplayTemporary DisplayWith DisplayWithRef DisplayWithVariable DistanceFunction DistanceTransform Distribute Distributed DistributedContexts DistributeDefinitions DistributionChart DistributionDomain DistributionFitTest DistributionParameterAssumptions DistributionParameterQ Dithering Div Divergence Divide DivideBy Dividers Divisible Divisors DivisorSigma DivisorSum DMSList DMSString Do DockedCells DocumentNotebook DominantColors DOSTextFormat Dot DotDashed DotEqual Dotted DoubleBracketingBar DoubleContourIntegral DoubleDownArrow DoubleLeftArrow DoubleLeftRightArrow DoubleLeftTee DoubleLongLeftArrow DoubleLongLeftRightArrow DoubleLongRightArrow DoubleRightArrow DoubleRightTee DoubleUpArrow DoubleUpDownArrow DoubleVerticalBar DoublyInfinite Down DownArrow DownArrowBar DownArrowUpArrow DownLeftRightVector DownLeftTeeVector DownLeftVector DownLeftVectorBar DownRightTeeVector DownRightVector DownRightVectorBar Downsample DownTee DownTeeArrow DownValues DragAndDrop DrawEdges DrawFrontFaces DrawHighlighted Drop DSolve Dt DualLinearProgramming DualSystemsModel DumpGet DumpSave DuplicateFreeQ Dynamic DynamicBox DynamicBoxOptions DynamicEvaluationTimeout DynamicLocation DynamicModule DynamicModuleBox DynamicModuleBoxOptions DynamicModuleParent DynamicModuleValues DynamicName DynamicNamespace DynamicReference DynamicSetting DynamicUpdating DynamicWrapper DynamicWrapperBox DynamicWrapperBoxOptions E EccentricityCentrality EdgeAdd EdgeBetweennessCentrality EdgeCapacity EdgeCapForm EdgeColor EdgeConnectivity EdgeCost EdgeCount EdgeCoverQ EdgeDashing EdgeDelete EdgeDetect EdgeForm EdgeIndex EdgeJoinForm EdgeLabeling EdgeLabels EdgeLabelStyle EdgeList EdgeOpacity EdgeQ EdgeRenderingFunction EdgeRules EdgeShapeFunction EdgeStyle EdgeThickness EdgeWeight Editable EditButtonSettings EditCellTagsSettings EditDistance EffectiveInterest Eigensystem Eigenvalues EigenvectorCentrality Eigenvectors Element ElementData Eliminate EliminationOrder EllipticE EllipticExp EllipticExpPrime EllipticF EllipticFilterModel EllipticK EllipticLog EllipticNomeQ EllipticPi EllipticReducedHalfPeriods EllipticTheta EllipticThetaPrime EmitSound EmphasizeSyntaxErrors EmpiricalDistribution Empty EmptyGraphQ EnableConsolePrintPacket Enabled Encode End EndAdd EndDialogPacket EndFrontEndInteractionPacket EndOfFile EndOfLine EndOfString EndPackage EngineeringForm Enter EnterExpressionPacket EnterTextPacket Entropy EntropyFilter Environment Epilog Equal EqualColumns EqualRows EqualTilde EquatedTo Equilibrium EquirippleFilterKernel Equivalent Erf Erfc Erfi ErlangB ErlangC ErlangDistribution Erosion ErrorBox ErrorBoxOptions ErrorNorm ErrorPacket ErrorsDialogSettings EstimatedDistribution EstimatedProcess EstimatorGains EstimatorRegulator EuclideanDistance EulerE EulerGamma EulerianGraphQ EulerPhi Evaluatable Evaluate Evaluated EvaluatePacket EvaluationCell EvaluationCompletionAction EvaluationElements EvaluationMode EvaluationMonitor EvaluationNotebook EvaluationObject EvaluationOrder Evaluator EvaluatorNames EvenQ EventData EventEvaluator EventHandler EventHandlerTag EventLabels ExactBlackmanWindow ExactNumberQ ExactRootIsolation ExampleData Except ExcludedForms ExcludePods Exclusions ExclusionsStyle Exists Exit ExitDialog Exp Expand ExpandAll ExpandDenominator ExpandFileName ExpandNumerator Expectation ExpectationE ExpectedValue ExpGammaDistribution ExpIntegralE ExpIntegralEi Exponent ExponentFunction ExponentialDistribution ExponentialFamily ExponentialGeneratingFunction ExponentialMovingAverage ExponentialPowerDistribution ExponentPosition ExponentStep Export ExportAutoReplacements ExportPacket ExportString Expression ExpressionCell ExpressionPacket ExpToTrig ExtendedGCD Extension ExtentElementFunction ExtentMarkers ExtentSize ExternalCall ExternalDataCharacterEncoding Extract ExtractArchive ExtremeValueDistribution FaceForm FaceGrids FaceGridsStyle Factor FactorComplete Factorial Factorial2 FactorialMoment FactorialMomentGeneratingFunction FactorialPower FactorInteger FactorList FactorSquareFree FactorSquareFreeList FactorTerms FactorTermsList Fail FailureDistribution False FARIMAProcess FEDisableConsolePrintPacket FeedbackSector FeedbackSectorStyle FeedbackType FEEnableConsolePrintPacket Fibonacci FieldHint FieldHintStyle FieldMasked FieldSize File FileBaseName FileByteCount FileDate FileExistsQ FileExtension FileFormat FileHash FileInformation FileName FileNameDepth FileNameDialogSettings FileNameDrop FileNameJoin FileNames FileNameSetter FileNameSplit FileNameTake FilePrint FileType FilledCurve FilledCurveBox Filling FillingStyle FillingTransform FilterRules FinancialBond FinancialData FinancialDerivative FinancialIndicator Find FindArgMax FindArgMin FindClique FindClusters FindCurvePath FindDistributionParameters FindDivisions FindEdgeCover FindEdgeCut FindEulerianCycle FindFaces FindFile FindFit FindGeneratingFunction FindGeoLocation FindGeometricTransform FindGraphCommunities FindGraphIsomorphism FindGraphPartition FindHamiltonianCycle FindIndependentEdgeSet FindIndependentVertexSet FindInstance FindIntegerNullVector FindKClan FindKClique FindKClub FindKPlex FindLibrary FindLinearRecurrence FindList FindMaximum FindMaximumFlow FindMaxValue FindMinimum FindMinimumCostFlow FindMinimumCut FindMinValue FindPermutation FindPostmanTour FindProcessParameters FindRoot FindSequenceFunction FindSettings FindShortestPath FindShortestTour FindThreshold FindVertexCover FindVertexCut Fine FinishDynamic FiniteAbelianGroupCount FiniteGroupCount FiniteGroupData First FirstPassageTimeDistribution FischerGroupFi22 FischerGroupFi23 FischerGroupFi24Prime FisherHypergeometricDistribution FisherRatioTest FisherZDistribution Fit FitAll FittedModel FixedPoint FixedPointList FlashSelection Flat Flatten FlattenAt FlatTopWindow FlipView Floor FlushPrintOutputPacket Fold FoldList Font FontColor FontFamily FontForm FontName FontOpacity FontPostScriptName FontProperties FontReencoding FontSize FontSlant FontSubstitutions FontTracking FontVariations FontWeight For ForAll Format FormatRules FormatType FormatTypeAutoConvert FormatValues FormBox FormBoxOptions FortranForm Forward ForwardBackward Fourier FourierCoefficient FourierCosCoefficient FourierCosSeries FourierCosTransform FourierDCT FourierDCTFilter FourierDCTMatrix FourierDST FourierDSTMatrix FourierMatrix FourierParameters FourierSequenceTransform FourierSeries FourierSinCoefficient FourierSinSeries FourierSinTransform FourierTransform FourierTrigSeries FractionalBrownianMotionProcess FractionalPart FractionBox FractionBoxOptions FractionLine Frame FrameBox FrameBoxOptions Framed FrameInset FrameLabel Frameless FrameMargins FrameStyle FrameTicks FrameTicksStyle FRatioDistribution FrechetDistribution FreeQ FrequencySamplingFilterKernel FresnelC FresnelS Friday FrobeniusNumber FrobeniusSolve FromCharacterCode FromCoefficientRules FromContinuedFraction FromDate FromDigits FromDMS Front FrontEndDynamicExpression FrontEndEventActions FrontEndExecute FrontEndObject FrontEndResource FrontEndResourceString FrontEndStackSize FrontEndToken FrontEndTokenExecute FrontEndValueCache FrontEndVersion FrontFaceColor FrontFaceOpacity Full FullAxes FullDefinition FullForm FullGraphics FullOptions FullSimplify Function FunctionExpand FunctionInterpolation FunctionSpace FussellVeselyImportance GaborFilter GaborMatrix GaborWavelet GainMargins GainPhaseMargins Gamma GammaDistribution GammaRegularized GapPenalty Gather GatherBy GaugeFaceElementFunction GaugeFaceStyle GaugeFrameElementFunction GaugeFrameSize GaugeFrameStyle GaugeLabels GaugeMarkers GaugeStyle GaussianFilter GaussianIntegers GaussianMatrix GaussianWindow GCD GegenbauerC General GeneralizedLinearModelFit GenerateConditions GeneratedCell GeneratedParameters GeneratingFunction Generic GenericCylindricalDecomposition GenomeData GenomeLookup GeodesicClosing GeodesicDilation GeodesicErosion GeodesicOpening GeoDestination GeodesyData GeoDirection GeoDistance GeoGridPosition GeometricBrownianMotionProcess GeometricDistribution GeometricMean GeometricMeanFilter GeometricTransformation GeometricTransformation3DBox GeometricTransformation3DBoxOptions GeometricTransformationBox GeometricTransformationBoxOptions GeoPosition GeoPositionENU GeoPositionXYZ GeoProjectionData GestureHandler GestureHandlerTag Get GetBoundingBoxSizePacket GetContext GetEnvironment GetFileName GetFrontEndOptionsDataPacket GetLinebreakInformationPacket GetMenusPacket GetPageBreakInformationPacket Glaisher GlobalClusteringCoefficient GlobalPreferences GlobalSession Glow GoldenRatio GompertzMakehamDistribution GoodmanKruskalGamma GoodmanKruskalGammaTest Goto Grad Gradient GradientFilter GradientOrientationFilter Graph GraphAssortativity GraphCenter GraphComplement GraphData GraphDensity GraphDiameter GraphDifference GraphDisjointUnion GraphDistance GraphDistanceMatrix GraphElementData GraphEmbedding GraphHighlight GraphHighlightStyle GraphHub Graphics Graphics3D Graphics3DBox Graphics3DBoxOptions GraphicsArray GraphicsBaseline GraphicsBox GraphicsBoxOptions GraphicsColor GraphicsColumn GraphicsComplex GraphicsComplex3DBox GraphicsComplex3DBoxOptions GraphicsComplexBox GraphicsComplexBoxOptions GraphicsContents GraphicsData GraphicsGrid GraphicsGridBox GraphicsGroup GraphicsGroup3DBox GraphicsGroup3DBoxOptions GraphicsGroupBox GraphicsGroupBoxOptions GraphicsGrouping GraphicsHighlightColor GraphicsRow GraphicsSpacing GraphicsStyle GraphIntersection GraphLayout GraphLinkEfficiency GraphPeriphery GraphPlot GraphPlot3D GraphPower GraphPropertyDistribution GraphQ GraphRadius GraphReciprocity GraphRoot GraphStyle GraphUnion Gray GrayLevel GreatCircleDistance Greater GreaterEqual GreaterEqualLess GreaterFullEqual GreaterGreater GreaterLess GreaterSlantEqual GreaterTilde Green Grid GridBaseline GridBox GridBoxAlignment GridBoxBackground GridBoxDividers GridBoxFrame GridBoxItemSize GridBoxItemStyle GridBoxOptions GridBoxSpacings GridCreationSettings GridDefaultElement GridElementStyleOptions GridFrame GridFrameMargins GridGraph GridLines GridLinesStyle GroebnerBasis GroupActionBase GroupCentralizer GroupElementFromWord GroupElementPosition GroupElementQ GroupElements GroupElementToWord GroupGenerators GroupMultiplicationTable GroupOrbits GroupOrder GroupPageBreakWithin GroupSetwiseStabilizer GroupStabilizer GroupStabilizerChain Gudermannian GumbelDistribution HaarWavelet HadamardMatrix HalfNormalDistribution HamiltonianGraphQ HammingDistance HammingWindow HankelH1 HankelH2 HankelMatrix HannPoissonWindow HannWindow HaradaNortonGroupHN HararyGraph HarmonicMean HarmonicMeanFilter HarmonicNumber Hash HashTable Haversine HazardFunction Head HeadCompose Heads HeavisideLambda HeavisidePi HeavisideTheta HeldGroupHe HeldPart HelpBrowserLookup HelpBrowserNotebook HelpBrowserSettings HermiteDecomposition HermiteH HermitianMatrixQ HessenbergDecomposition Hessian HexadecimalCharacter Hexahedron HexahedronBox HexahedronBoxOptions HiddenSurface HighlightGraph HighlightImage HighpassFilter HigmanSimsGroupHS HilbertFilter HilbertMatrix Histogram Histogram3D HistogramDistribution HistogramList HistogramTransform HistogramTransformInterpolation HitMissTransform HITSCentrality HodgeDual HoeffdingD HoeffdingDTest Hold HoldAll HoldAllComplete HoldComplete HoldFirst HoldForm HoldPattern HoldRest HolidayCalendar HomeDirectory HomePage Horizontal HorizontalForm HorizontalGauge HorizontalScrollPosition HornerForm HotellingTSquareDistribution HoytDistribution HTMLSave Hue HumpDownHump HumpEqual HurwitzLerchPhi HurwitzZeta HyperbolicDistribution HypercubeGraph HyperexponentialDistribution Hyperfactorial Hypergeometric0F1 Hypergeometric0F1Regularized Hypergeometric1F1 Hypergeometric1F1Regularized Hypergeometric2F1 Hypergeometric2F1Regularized HypergeometricDistribution HypergeometricPFQ HypergeometricPFQRegularized HypergeometricU Hyperlink HyperlinkCreationSettings Hyphenation HyphenationOptions HypoexponentialDistribution HypothesisTestData I Identity IdentityMatrix If IgnoreCase Im Image Image3D Image3DSlices ImageAccumulate ImageAdd ImageAdjust ImageAlign ImageApply ImageAspectRatio ImageAssemble ImageCache ImageCacheValid ImageCapture ImageChannels ImageClip ImageColorSpace ImageCompose ImageConvolve ImageCooccurrence ImageCorners ImageCorrelate ImageCorrespondingPoints ImageCrop ImageData ImageDataPacket ImageDeconvolve ImageDemosaic ImageDifference ImageDimensions ImageDistance ImageEffect ImageFeatureTrack ImageFileApply ImageFileFilter ImageFileScan ImageFilter ImageForestingComponents ImageForwardTransformation ImageHistogram ImageKeypoints ImageLevels ImageLines ImageMargins ImageMarkers ImageMeasurements ImageMultiply ImageOffset ImagePad ImagePadding ImagePartition ImagePeriodogram ImagePerspectiveTransformation ImageQ ImageRangeCache ImageReflect ImageRegion ImageResize ImageResolution ImageRotate ImageRotated ImageScaled ImageScan ImageSize ImageSizeAction ImageSizeCache ImageSizeMultipliers ImageSizeRaw ImageSubtract ImageTake ImageTransformation ImageTrim ImageType ImageValue ImageValuePositions Implies Import ImportAutoReplacements ImportString ImprovementImportance In IncidenceGraph IncidenceList IncidenceMatrix IncludeConstantBasis IncludeFileExtension IncludePods IncludeSingularTerm Increment Indent IndentingNewlineSpacings IndentMaxFraction IndependenceTest IndependentEdgeSetQ IndependentUnit IndependentVertexSetQ Indeterminate IndexCreationOptions Indexed IndexGraph IndexTag Inequality InexactNumberQ InexactNumbers Infinity Infix Information Inherited InheritScope Initialization InitializationCell InitializationCellEvaluation InitializationCellWarning InlineCounterAssignments InlineCounterIncrements InlineRules Inner Inpaint Input InputAliases InputAssumptions InputAutoReplacements InputField InputFieldBox InputFieldBoxOptions InputForm InputGrouping InputNamePacket InputNotebook InputPacket InputSettings InputStream InputString InputStringPacket InputToBoxFormPacket Insert InsertionPointObject InsertResults Inset Inset3DBox Inset3DBoxOptions InsetBox InsetBoxOptions Install InstallService InString Integer IntegerDigits IntegerExponent IntegerLength IntegerPart IntegerPartitions IntegerQ Integers IntegerString Integral Integrate Interactive InteractiveTradingChart Interlaced Interleaving InternallyBalancedDecomposition InterpolatingFunction InterpolatingPolynomial Interpolation InterpolationOrder InterpolationPoints InterpolationPrecision Interpretation InterpretationBox InterpretationBoxOptions InterpretationFunction InterpretTemplate InterquartileRange Interrupt InterruptSettings Intersection Interval IntervalIntersection IntervalMemberQ IntervalUnion Inverse InverseBetaRegularized InverseCDF InverseChiSquareDistribution InverseContinuousWaveletTransform InverseDistanceTransform InverseEllipticNomeQ InverseErf InverseErfc InverseFourier InverseFourierCosTransform InverseFourierSequenceTransform InverseFourierSinTransform InverseFourierTransform InverseFunction InverseFunctions InverseGammaDistribution InverseGammaRegularized InverseGaussianDistribution InverseGudermannian InverseHaversine InverseJacobiCD InverseJacobiCN InverseJacobiCS InverseJacobiDC InverseJacobiDN InverseJacobiDS InverseJacobiNC InverseJacobiND InverseJacobiNS InverseJacobiSC InverseJacobiSD InverseJacobiSN InverseLaplaceTransform InversePermutation InverseRadon InverseSeries InverseSurvivalFunction InverseWaveletTransform InverseWeierstrassP InverseZTransform Invisible InvisibleApplication InvisibleTimes IrreduciblePolynomialQ IsolatingInterval IsomorphicGraphQ IsotopeData Italic Item ItemBox ItemBoxOptions ItemSize ItemStyle ItoProcess JaccardDissimilarity JacobiAmplitude Jacobian JacobiCD JacobiCN JacobiCS JacobiDC JacobiDN JacobiDS JacobiNC JacobiND JacobiNS JacobiP JacobiSC JacobiSD JacobiSN JacobiSymbol JacobiZeta JankoGroupJ1 JankoGroupJ2 JankoGroupJ3 JankoGroupJ4 JarqueBeraALMTest JohnsonDistribution Join Joined JoinedCurve JoinedCurveBox JoinForm JordanDecomposition JordanModelDecomposition K KagiChart KaiserBesselWindow KaiserWindow KalmanEstimator KalmanFilter KarhunenLoeveDecomposition KaryTree KatzCentrality KCoreComponents KDistribution KelvinBei KelvinBer KelvinKei KelvinKer KendallTau KendallTauTest KernelExecute KernelMixtureDistribution KernelObject Kernels Ket Khinchin KirchhoffGraph KirchhoffMatrix KleinInvariantJ KnightTourGraph KnotData KnownUnitQ KolmogorovSmirnovTest KroneckerDelta KroneckerModelDecomposition KroneckerProduct KroneckerSymbol KuiperTest KumaraswamyDistribution Kurtosis KuwaharaFilter Label Labeled LabeledSlider LabelingFunction LabelStyle LaguerreL LambdaComponents LambertW LanczosWindow LandauDistribution Language LanguageCategory LaplaceDistribution LaplaceTransform Laplacian LaplacianFilter LaplacianGaussianFilter Large Larger Last Latitude LatitudeLongitude LatticeData LatticeReduce Launch LaunchKernels LayeredGraphPlot LayerSizeFunction LayoutInformation LCM LeafCount LeapYearQ LeastSquares LeastSquaresFilterKernel Left LeftArrow LeftArrowBar LeftArrowRightArrow LeftDownTeeVector LeftDownVector LeftDownVectorBar LeftRightArrow LeftRightVector LeftTee LeftTeeArrow LeftTeeVector LeftTriangle LeftTriangleBar LeftTriangleEqual LeftUpDownVector LeftUpTeeVector LeftUpVector LeftUpVectorBar LeftVector LeftVectorBar LegendAppearance Legended LegendFunction LegendLabel LegendLayout LegendMargins LegendMarkers LegendMarkerSize LegendreP LegendreQ LegendreType Length LengthWhile LerchPhi Less LessEqual LessEqualGreater LessFullEqual LessGreater LessLess LessSlantEqual LessTilde LetterCharacter LetterQ Level LeveneTest LeviCivitaTensor LevyDistribution Lexicographic LibraryFunction LibraryFunctionError LibraryFunctionInformation LibraryFunctionLoad LibraryFunctionUnload LibraryLoad LibraryUnload LicenseID LiftingFilterData LiftingWaveletTransform LightBlue LightBrown LightCyan Lighter LightGray LightGreen Lighting LightingAngle LightMagenta LightOrange LightPink LightPurple LightRed LightSources LightYellow Likelihood Limit LimitsPositioning LimitsPositioningTokens LindleyDistribution Line Line3DBox LinearFilter LinearFractionalTransform LinearModelFit LinearOffsetFunction LinearProgramming LinearRecurrence LinearSolve LinearSolveFunction LineBox LineBreak LinebreakAdjustments LineBreakChart LineBreakWithin LineColor LineForm LineGraph LineIndent LineIndentMaxFraction LineIntegralConvolutionPlot LineIntegralConvolutionScale LineLegend LineOpacity LineSpacing LineWrapParts LinkActivate LinkClose LinkConnect LinkConnectedQ LinkCreate LinkError LinkFlush LinkFunction LinkHost LinkInterrupt LinkLaunch LinkMode LinkObject LinkOpen LinkOptions LinkPatterns LinkProtocol LinkRead LinkReadHeld LinkReadyQ Links LinkWrite LinkWriteHeld LiouvilleLambda List Listable ListAnimate ListContourPlot ListContourPlot3D ListConvolve ListCorrelate ListCurvePathPlot ListDeconvolve ListDensityPlot Listen ListFourierSequenceTransform ListInterpolation ListLineIntegralConvolutionPlot ListLinePlot ListLogLinearPlot ListLogLogPlot ListLogPlot ListPicker ListPickerBox ListPickerBoxBackground ListPickerBoxOptions ListPlay ListPlot ListPlot3D ListPointPlot3D ListPolarPlot ListQ ListStreamDensityPlot ListStreamPlot ListSurfacePlot3D ListVectorDensityPlot ListVectorPlot ListVectorPlot3D ListZTransform Literal LiteralSearch LocalClusteringCoefficient LocalizeVariables LocationEquivalenceTest LocationTest Locator LocatorAutoCreate LocatorBox LocatorBoxOptions LocatorCentering LocatorPane LocatorPaneBox LocatorPaneBoxOptions LocatorRegion Locked Log Log10 Log2 LogBarnesG LogGamma LogGammaDistribution LogicalExpand LogIntegral LogisticDistribution LogitModelFit LogLikelihood LogLinearPlot LogLogisticDistribution LogLogPlot LogMultinormalDistribution LogNormalDistribution LogPlot LogRankTest LogSeriesDistribution LongEqual Longest LongestAscendingSequence LongestCommonSequence LongestCommonSequencePositions LongestCommonSubsequence LongestCommonSubsequencePositions LongestMatch LongForm Longitude LongLeftArrow LongLeftRightArrow LongRightArrow Loopback LoopFreeGraphQ LowerCaseQ LowerLeftArrow LowerRightArrow LowerTriangularize LowpassFilter LQEstimatorGains LQGRegulator LQOutputRegulatorGains LQRegulatorGains LUBackSubstitution LucasL LuccioSamiComponents LUDecomposition LyapunovSolve LyonsGroupLy MachineID MachineName MachineNumberQ MachinePrecision MacintoshSystemPageSetup Magenta Magnification Magnify MainSolve MaintainDynamicCaches Majority MakeBoxes MakeExpression MakeRules MangoldtLambda ManhattanDistance Manipulate Manipulator MannWhitneyTest MantissaExponent Manual Map MapAll MapAt MapIndexed MAProcess MapThread MarcumQ MardiaCombinedTest MardiaKurtosisTest MardiaSkewnessTest MarginalDistribution MarkovProcessProperties Masking MatchingDissimilarity MatchLocalNameQ MatchLocalNames MatchQ Material MathematicaNotation MathieuC MathieuCharacteristicA MathieuCharacteristicB MathieuCharacteristicExponent MathieuCPrime MathieuGroupM11 MathieuGroupM12 MathieuGroupM22 MathieuGroupM23 MathieuGroupM24 MathieuS MathieuSPrime MathMLForm MathMLText Matrices MatrixExp MatrixForm MatrixFunction MatrixLog MatrixPlot MatrixPower MatrixQ MatrixRank Max MaxBend MaxDetect MaxExtraBandwidths MaxExtraConditions MaxFeatures MaxFilter Maximize MaxIterations MaxMemoryUsed MaxMixtureKernels MaxPlotPoints MaxPoints MaxRecursion MaxStableDistribution MaxStepFraction MaxSteps MaxStepSize MaxValue MaxwellDistribution McLaughlinGroupMcL Mean MeanClusteringCoefficient MeanDegreeConnectivity MeanDeviation MeanFilter MeanGraphDistance MeanNeighborDegree MeanShift MeanShiftFilter Median MedianDeviation MedianFilter Medium MeijerG MeixnerDistribution MemberQ MemoryConstrained MemoryInUse Menu MenuAppearance MenuCommandKey MenuEvaluator MenuItem MenuPacket MenuSortingValue MenuStyle MenuView MergeDifferences Mesh MeshFunctions MeshRange MeshShading MeshStyle Message MessageDialog MessageList MessageName MessageOptions MessagePacket Messages MessagesNotebook MetaCharacters MetaInformation Method MethodOptions MexicanHatWavelet MeyerWavelet Min MinDetect MinFilter MinimalPolynomial MinimalStateSpaceModel Minimize Minors MinRecursion MinSize MinStableDistribution Minus MinusPlus MinValue Missing MissingDataMethod MittagLefflerE MixedRadix MixedRadixQuantity MixtureDistribution Mod Modal Mode Modular ModularLambda Module Modulus MoebiusMu Moment Momentary MomentConvert MomentEvaluate MomentGeneratingFunction Monday Monitor MonomialList MonomialOrder MonsterGroupM MorletWavelet MorphologicalBinarize MorphologicalBranchPoints MorphologicalComponents MorphologicalEulerNumber MorphologicalGraph MorphologicalPerimeter MorphologicalTransform Most MouseAnnotation MouseAppearance MouseAppearanceTag MouseButtons Mouseover MousePointerNote MousePosition MovingAverage MovingMedian MoyalDistribution MultiedgeStyle MultilaunchWarning MultiLetterItalics MultiLetterStyle MultilineFunction Multinomial MultinomialDistribution MultinormalDistribution MultiplicativeOrder Multiplicity Multiselection MultivariateHypergeometricDistribution MultivariatePoissonDistribution MultivariateTDistribution N NakagamiDistribution NameQ Names NamespaceBox Nand NArgMax NArgMin NBernoulliB NCache NDSolve NDSolveValue Nearest NearestFunction NeedCurrentFrontEndPackagePacket NeedCurrentFrontEndSymbolsPacket NeedlemanWunschSimilarity Needs Negative NegativeBinomialDistribution NegativeMultinomialDistribution NeighborhoodGraph Nest NestedGreaterGreater NestedLessLess NestedScriptRules NestList NestWhile NestWhileList NevilleThetaC NevilleThetaD NevilleThetaN NevilleThetaS NewPrimitiveStyle NExpectation Next NextPrime NHoldAll NHoldFirst NHoldRest NicholsGridLines NicholsPlot NIntegrate NMaximize NMaxValue NMinimize NMinValue NominalVariables NonAssociative NoncentralBetaDistribution NoncentralChiSquareDistribution NoncentralFRatioDistribution NoncentralStudentTDistribution NonCommutativeMultiply NonConstants None NonlinearModelFit NonlocalMeansFilter NonNegative NonPositive Nor NorlundB Norm Normal NormalDistribution NormalGrouping Normalize NormalizedSquaredEuclideanDistance NormalsFunction NormFunction Not NotCongruent NotCupCap NotDoubleVerticalBar Notebook NotebookApply NotebookAutoSave NotebookClose NotebookConvertSettings NotebookCreate NotebookCreateReturnObject NotebookDefault NotebookDelete NotebookDirectory NotebookDynamicExpression NotebookEvaluate NotebookEventActions NotebookFileName NotebookFind NotebookFindReturnObject NotebookGet NotebookGetLayoutInformationPacket NotebookGetMisspellingsPacket NotebookInformation NotebookInterfaceObject NotebookLocate NotebookObject NotebookOpen NotebookOpenReturnObject NotebookPath NotebookPrint NotebookPut NotebookPutReturnObject NotebookRead NotebookResetGeneratedCells Notebooks NotebookSave NotebookSaveAs NotebookSelection NotebookSetupLayoutInformationPacket NotebooksMenu NotebookWrite NotElement NotEqualTilde NotExists NotGreater NotGreaterEqual NotGreaterFullEqual NotGreaterGreater NotGreaterLess NotGreaterSlantEqual NotGreaterTilde NotHumpDownHump NotHumpEqual NotLeftTriangle NotLeftTriangleBar NotLeftTriangleEqual NotLess NotLessEqual NotLessFullEqual NotLessGreater NotLessLess NotLessSlantEqual NotLessTilde NotNestedGreaterGreater NotNestedLessLess NotPrecedes NotPrecedesEqual NotPrecedesSlantEqual NotPrecedesTilde NotReverseElement NotRightTriangle NotRightTriangleBar NotRightTriangleEqual NotSquareSubset NotSquareSubsetEqual NotSquareSuperset NotSquareSupersetEqual NotSubset NotSubsetEqual NotSucceeds NotSucceedsEqual NotSucceedsSlantEqual NotSucceedsTilde NotSuperset NotSupersetEqual NotTilde NotTildeEqual NotTildeFullEqual NotTildeTilde NotVerticalBar NProbability NProduct NProductFactors NRoots NSolve NSum NSumTerms Null NullRecords NullSpace NullWords Number NumberFieldClassNumber NumberFieldDiscriminant NumberFieldFundamentalUnits NumberFieldIntegralBasis NumberFieldNormRepresentatives NumberFieldRegulator NumberFieldRootsOfUnity NumberFieldSignature NumberForm NumberFormat NumberMarks NumberMultiplier NumberPadding NumberPoint NumberQ NumberSeparator NumberSigns NumberString Numerator NumericFunction NumericQ NuttallWindow NValues NyquistGridLines NyquistPlot O ObservabilityGramian ObservabilityMatrix ObservableDecomposition ObservableModelQ OddQ Off Offset OLEData On ONanGroupON OneIdentity Opacity Open OpenAppend Opener OpenerBox OpenerBoxOptions OpenerView OpenFunctionInspectorPacket Opening OpenRead OpenSpecialOptions OpenTemporary OpenWrite Operate OperatingSystem OptimumFlowData Optional OptionInspectorSettings OptionQ Options OptionsPacket OptionsPattern OptionValue OptionValueBox OptionValueBoxOptions Or Orange Order OrderDistribution OrderedQ Ordering Orderless OrnsteinUhlenbeckProcess Orthogonalize Out Outer OutputAutoOverwrite OutputControllabilityMatrix OutputControllableModelQ OutputForm OutputFormData OutputGrouping OutputMathEditExpression OutputNamePacket OutputResponse OutputSizeLimit OutputStream Over OverBar OverDot Overflow OverHat Overlaps Overlay OverlayBox OverlayBoxOptions Overscript OverscriptBox OverscriptBoxOptions OverTilde OverVector OwenT OwnValues PackingMethod PaddedForm Padding PadeApproximant PadLeft PadRight PageBreakAbove PageBreakBelow PageBreakWithin PageFooterLines PageFooters PageHeaderLines PageHeaders PageHeight PageRankCentrality PageWidth PairedBarChart PairedHistogram PairedSmoothHistogram PairedTTest PairedZTest PaletteNotebook PalettePath Pane PaneBox PaneBoxOptions Panel PanelBox PanelBoxOptions Paneled PaneSelector PaneSelectorBox PaneSelectorBoxOptions PaperWidth ParabolicCylinderD ParagraphIndent ParagraphSpacing ParallelArray ParallelCombine ParallelDo ParallelEvaluate Parallelization Parallelize ParallelMap ParallelNeeds ParallelProduct ParallelSubmit ParallelSum ParallelTable ParallelTry Parameter ParameterEstimator ParameterMixtureDistribution ParameterVariables ParametricFunction ParametricNDSolve ParametricNDSolveValue ParametricPlot ParametricPlot3D ParentConnect ParentDirectory ParentForm Parenthesize ParentList ParetoDistribution Part PartialCorrelationFunction PartialD ParticleData Partition PartitionsP PartitionsQ ParzenWindow PascalDistribution PassEventsDown PassEventsUp Paste PasteBoxFormInlineCells PasteButton Path PathGraph PathGraphQ Pattern PatternSequence PatternTest PauliMatrix PaulWavelet Pause PausedTime PDF PearsonChiSquareTest PearsonCorrelationTest PearsonDistribution PerformanceGoal PeriodicInterpolation Periodogram PeriodogramArray PermutationCycles PermutationCyclesQ PermutationGroup PermutationLength PermutationList PermutationListQ PermutationMax PermutationMin PermutationOrder PermutationPower PermutationProduct PermutationReplace Permutations PermutationSupport Permute PeronaMalikFilter Perpendicular PERTDistribution PetersenGraph PhaseMargins Pi Pick PIDData PIDDerivativeFilter PIDFeedforward PIDTune Piecewise PiecewiseExpand PieChart PieChart3D PillaiTrace PillaiTraceTest Pink Pivoting PixelConstrained PixelValue PixelValuePositions Placed Placeholder PlaceholderReplace Plain PlanarGraphQ Play PlayRange Plot Plot3D Plot3Matrix PlotDivision PlotJoined PlotLabel PlotLayout PlotLegends PlotMarkers PlotPoints PlotRange PlotRangeClipping PlotRangePadding PlotRegion PlotStyle Plus PlusMinus Pochhammer PodStates PodWidth Point Point3DBox PointBox PointFigureChart PointForm PointLegend PointSize PoissonConsulDistribution PoissonDistribution PoissonProcess PoissonWindow PolarAxes PolarAxesOrigin PolarGridLines PolarPlot PolarTicks PoleZeroMarkers PolyaAeppliDistribution PolyGamma Polygon Polygon3DBox Polygon3DBoxOptions PolygonBox PolygonBoxOptions PolygonHoleScale PolygonIntersections PolygonScale PolyhedronData PolyLog PolynomialExtendedGCD PolynomialForm PolynomialGCD PolynomialLCM PolynomialMod PolynomialQ PolynomialQuotient PolynomialQuotientRemainder PolynomialReduce PolynomialRemainder Polynomials PopupMenu PopupMenuBox PopupMenuBoxOptions PopupView PopupWindow Position Positive PositiveDefiniteMatrixQ PossibleZeroQ Postfix PostScript Power PowerDistribution PowerExpand PowerMod PowerModList PowerSpectralDensity PowersRepresentations PowerSymmetricPolynomial Precedence PrecedenceForm Precedes PrecedesEqual PrecedesSlantEqual PrecedesTilde Precision PrecisionGoal PreDecrement PredictionRoot PreemptProtect PreferencesPath Prefix PreIncrement Prepend PrependTo PreserveImageOptions Previous PriceGraphDistribution PrimaryPlaceholder Prime PrimeNu PrimeOmega PrimePi PrimePowerQ PrimeQ Primes PrimeZetaP PrimitiveRoot PrincipalComponents PrincipalValue Print PrintAction PrintForm PrintingCopies PrintingOptions PrintingPageRange PrintingStartingPageNumber PrintingStyleEnvironment PrintPrecision PrintTemporary Prism PrismBox PrismBoxOptions PrivateCellOptions PrivateEvaluationOptions PrivateFontOptions PrivateFrontEndOptions PrivateNotebookOptions PrivatePaths Probability ProbabilityDistribution ProbabilityPlot ProbabilityPr ProbabilityScalePlot ProbitModelFit ProcessEstimator ProcessParameterAssumptions ProcessParameterQ ProcessStateDomain ProcessTimeDomain Product ProductDistribution ProductLog ProgressIndicator ProgressIndicatorBox ProgressIndicatorBoxOptions Projection Prolog PromptForm Properties Property PropertyList PropertyValue Proportion Proportional Protect Protected ProteinData Pruning PseudoInverse Purple Put PutAppend Pyramid PyramidBox PyramidBoxOptions QBinomial QFactorial QGamma QHypergeometricPFQ QPochhammer QPolyGamma QRDecomposition QuadraticIrrationalQ Quantile QuantilePlot Quantity QuantityForm QuantityMagnitude QuantityQ QuantityUnit Quartics QuartileDeviation Quartiles QuartileSkewness QueueingNetworkProcess QueueingProcess QueueProperties Quiet Quit Quotient QuotientRemainder RadialityCentrality RadicalBox RadicalBoxOptions RadioButton RadioButtonBar RadioButtonBox RadioButtonBoxOptions Radon RamanujanTau RamanujanTauL RamanujanTauTheta RamanujanTauZ Random RandomChoice RandomComplex RandomFunction RandomGraph RandomImage RandomInteger RandomPermutation RandomPrime RandomReal RandomSample RandomSeed RandomVariate RandomWalkProcess Range RangeFilter RangeSpecification RankedMax RankedMin Raster Raster3D Raster3DBox Raster3DBoxOptions RasterArray RasterBox RasterBoxOptions Rasterize RasterSize Rational RationalFunctions Rationalize Rationals Ratios Raw RawArray RawBoxes RawData RawMedium RayleighDistribution Re Read ReadList ReadProtected Real RealBlockDiagonalForm RealDigits RealExponent Reals Reap Record RecordLists RecordSeparators Rectangle RectangleBox RectangleBoxOptions RectangleChart RectangleChart3D RecurrenceFilter RecurrenceTable RecurringDigitsForm Red Reduce RefBox ReferenceLineStyle ReferenceMarkers ReferenceMarkerStyle Refine ReflectionMatrix ReflectionTransform Refresh RefreshRate RegionBinarize RegionFunction RegionPlot RegionPlot3D RegularExpression Regularization Reinstall Release ReleaseHold ReliabilityDistribution ReliefImage ReliefPlot Remove RemoveAlphaChannel RemoveAsynchronousTask Removed RemoveInputStreamMethod RemoveOutputStreamMethod RemoveProperty RemoveScheduledTask RenameDirectory RenameFile RenderAll RenderingOptions RenewalProcess RenkoChart Repeated RepeatedNull RepeatedString Replace ReplaceAll ReplaceHeldPart ReplaceImageValue ReplaceList ReplacePart ReplacePixelValue ReplaceRepeated Resampling Rescale RescalingTransform ResetDirectory ResetMenusPacket ResetScheduledTask Residue Resolve Rest Resultant ResumePacket Return ReturnExpressionPacket ReturnInputFormPacket ReturnPacket ReturnTextPacket Reverse ReverseBiorthogonalSplineWavelet ReverseElement ReverseEquilibrium ReverseGraph ReverseUpEquilibrium RevolutionAxis RevolutionPlot3D RGBColor RiccatiSolve RiceDistribution RidgeFilter RiemannR RiemannSiegelTheta RiemannSiegelZ Riffle Right RightArrow RightArrowBar RightArrowLeftArrow RightCosetRepresentative RightDownTeeVector RightDownVector RightDownVectorBar RightTee RightTeeArrow RightTeeVector RightTriangle RightTriangleBar RightTriangleEqual RightUpDownVector RightUpTeeVector RightUpVector RightUpVectorBar RightVector RightVectorBar RiskAchievementImportance RiskReductionImportance RogersTanimotoDissimilarity Root RootApproximant RootIntervals RootLocusPlot RootMeanSquare RootOfUnityQ RootReduce Roots RootSum Rotate RotateLabel RotateLeft RotateRight RotationAction RotationBox RotationBoxOptions RotationMatrix RotationTransform Round RoundImplies RoundingRadius Row RowAlignments RowBackgrounds RowBox RowHeights RowLines RowMinHeight RowReduce RowsEqual RowSpacings RSolve RudvalisGroupRu Rule RuleCondition RuleDelayed RuleForm RulerUnits Run RunScheduledTask RunThrough RuntimeAttributes RuntimeOptions RussellRaoDissimilarity SameQ SameTest SampleDepth SampledSoundFunction SampledSoundList SampleRate SamplingPeriod SARIMAProcess SARMAProcess SatisfiabilityCount SatisfiabilityInstances SatisfiableQ Saturday Save Saveable SaveAutoDelete SaveDefinitions SawtoothWave Scale Scaled ScaleDivisions ScaledMousePosition ScaleOrigin ScalePadding ScaleRanges ScaleRangeStyle ScalingFunctions ScalingMatrix ScalingTransform Scan ScheduledTaskActiveQ ScheduledTaskData ScheduledTaskObject ScheduledTasks SchurDecomposition ScientificForm ScreenRectangle ScreenStyleEnvironment ScriptBaselineShifts ScriptLevel ScriptMinSize ScriptRules ScriptSizeMultipliers Scrollbars ScrollingOptions ScrollPosition Sec Sech SechDistribution SectionGrouping SectorChart SectorChart3D SectorOrigin SectorSpacing SeedRandom Select Selectable SelectComponents SelectedCells SelectedNotebook Selection SelectionAnimate SelectionCell SelectionCellCreateCell SelectionCellDefaultStyle SelectionCellParentStyle SelectionCreateCell SelectionDebuggerTag SelectionDuplicateCell SelectionEvaluate SelectionEvaluateCreateCell SelectionMove SelectionPlaceholder SelectionSetStyle SelectWithContents SelfLoops SelfLoopStyle SemialgebraicComponentInstances SendMail Sequence SequenceAlignment SequenceForm SequenceHold SequenceLimit Series SeriesCoefficient SeriesData SessionTime Set SetAccuracy SetAlphaChannel SetAttributes Setbacks SetBoxFormNamesPacket SetDelayed SetDirectory SetEnvironment SetEvaluationNotebook SetFileDate SetFileLoadingContext SetNotebookStatusLine SetOptions SetOptionsPacket SetPrecision SetProperty SetSelectedNotebook SetSharedFunction SetSharedVariable SetSpeechParametersPacket SetStreamPosition SetSystemOptions Setter SetterBar SetterBox SetterBoxOptions Setting SetValue Shading Shallow ShannonWavelet ShapiroWilkTest Share Sharpen ShearingMatrix ShearingTransform ShenCastanMatrix Short ShortDownArrow Shortest ShortestMatch ShortestPathFunction ShortLeftArrow ShortRightArrow ShortUpArrow Show ShowAutoStyles ShowCellBracket ShowCellLabel ShowCellTags ShowClosedCellArea ShowContents ShowControls ShowCursorTracker ShowGroupOpenCloseIcon ShowGroupOpener ShowInvisibleCharacters ShowPageBreaks ShowPredictiveInterface ShowSelection ShowShortBoxForm ShowSpecialCharacters ShowStringCharacters ShowSyntaxStyles ShrinkingDelay ShrinkWrapBoundingBox SiegelTheta SiegelTukeyTest Sign Signature SignedRankTest SignificanceLevel SignPadding SignTest SimilarityRules SimpleGraph SimpleGraphQ Simplify Sin Sinc SinghMaddalaDistribution SingleEvaluation SingleLetterItalics SingleLetterStyle SingularValueDecomposition SingularValueList SingularValuePlot SingularValues Sinh SinhIntegral SinIntegral SixJSymbol Skeleton SkeletonTransform SkellamDistribution Skewness SkewNormalDistribution Skip SliceDistribution Slider Slider2D Slider2DBox Slider2DBoxOptions SliderBox SliderBoxOptions SlideView Slot SlotSequence Small SmallCircle Smaller SmithDelayCompensator SmithWatermanSimilarity SmoothDensityHistogram SmoothHistogram SmoothHistogram3D SmoothKernelDistribution SocialMediaData Socket SokalSneathDissimilarity Solve SolveAlways SolveDelayed Sort SortBy Sound SoundAndGraphics SoundNote SoundVolume Sow Space SpaceForm Spacer Spacings Span SpanAdjustments SpanCharacterRounding SpanFromAbove SpanFromBoth SpanFromLeft SpanLineThickness SpanMaxSize SpanMinSize SpanningCharacters SpanSymmetric SparseArray SpatialGraphDistribution Speak SpeakTextPacket SpearmanRankTest SpearmanRho Spectrogram SpectrogramArray Specularity SpellingCorrection SpellingDictionaries SpellingDictionariesPath SpellingOptions SpellingSuggestionsPacket Sphere SphereBox SphericalBesselJ SphericalBesselY SphericalHankelH1 SphericalHankelH2 SphericalHarmonicY SphericalPlot3D SphericalRegion SpheroidalEigenvalue SpheroidalJoiningFactor SpheroidalPS SpheroidalPSPrime SpheroidalQS SpheroidalQSPrime SpheroidalRadialFactor SpheroidalS1 SpheroidalS1Prime SpheroidalS2 SpheroidalS2Prime Splice SplicedDistribution SplineClosed SplineDegree SplineKnots SplineWeights Split SplitBy SpokenString Sqrt SqrtBox SqrtBoxOptions Square SquaredEuclideanDistance SquareFreeQ SquareIntersection SquaresR SquareSubset SquareSubsetEqual SquareSuperset SquareSupersetEqual SquareUnion SquareWave StabilityMargins StabilityMarginsStyle StableDistribution Stack StackBegin StackComplete StackInhibit StandardDeviation StandardDeviationFilter StandardForm Standardize StandbyDistribution Star StarGraph StartAsynchronousTask StartingStepSize StartOfLine StartOfString StartScheduledTask StartupSound StateDimensions StateFeedbackGains StateOutputEstimator StateResponse StateSpaceModel StateSpaceRealization StateSpaceTransform StationaryDistribution StationaryWaveletPacketTransform StationaryWaveletTransform StatusArea StatusCentrality StepMonitor StieltjesGamma StirlingS1 StirlingS2 StopAsynchronousTask StopScheduledTask StrataVariables StratonovichProcess StreamColorFunction StreamColorFunctionScaling StreamDensityPlot StreamPlot StreamPoints StreamPosition Streams StreamScale StreamStyle String StringBreak StringByteCount StringCases StringCount StringDrop StringExpression StringForm StringFormat StringFreeQ StringInsert StringJoin StringLength StringMatchQ StringPosition StringQ StringReplace StringReplaceList StringReplacePart StringReverse StringRotateLeft StringRotateRight StringSkeleton StringSplit StringTake StringToStream StringTrim StripBoxes StripOnInput StripWrapperBoxes StrokeForm StructuralImportance StructuredArray StructuredSelection StruveH StruveL Stub StudentTDistribution Style StyleBox StyleBoxAutoDelete StyleBoxOptions StyleData StyleDefinitions StyleForm StyleKeyMapping StyleMenuListing StyleNameDialogSettings StyleNames StylePrint StyleSheetPath Subfactorial Subgraph SubMinus SubPlus SubresultantPolynomialRemainders SubresultantPolynomials Subresultants Subscript SubscriptBox SubscriptBoxOptions Subscripted Subset SubsetEqual Subsets SubStar Subsuperscript SubsuperscriptBox SubsuperscriptBoxOptions Subtract SubtractFrom SubValues Succeeds SucceedsEqual SucceedsSlantEqual SucceedsTilde SuchThat Sum SumConvergence Sunday SuperDagger SuperMinus SuperPlus Superscript SuperscriptBox SuperscriptBoxOptions Superset SupersetEqual SuperStar Surd SurdForm SurfaceColor SurfaceGraphics SurvivalDistribution SurvivalFunction SurvivalModel SurvivalModelFit SuspendPacket SuzukiDistribution SuzukiGroupSuz SwatchLegend Switch Symbol SymbolName SymletWavelet Symmetric SymmetricGroup SymmetricMatrixQ SymmetricPolynomial SymmetricReduction Symmetrize SymmetrizedArray SymmetrizedArrayRules SymmetrizedDependentComponents SymmetrizedIndependentComponents SymmetrizedReplacePart SynchronousInitialization SynchronousUpdating Syntax SyntaxForm SyntaxInformation SyntaxLength SyntaxPacket SyntaxQ SystemDialogInput SystemException SystemHelpPath SystemInformation SystemInformationData SystemOpen SystemOptions SystemsModelDelay SystemsModelDelayApproximate SystemsModelDelete SystemsModelDimensions SystemsModelExtract SystemsModelFeedbackConnect SystemsModelLabels SystemsModelOrder SystemsModelParallelConnect SystemsModelSeriesConnect SystemsModelStateFeedbackConnect SystemStub Tab TabFilling Table TableAlignments TableDepth TableDirections TableForm TableHeadings TableSpacing TableView TableViewBox TabSpacings TabView TabViewBox TabViewBoxOptions TagBox TagBoxNote TagBoxOptions TaggingRules TagSet TagSetDelayed TagStyle TagUnset Take TakeWhile Tally Tan Tanh TargetFunctions TargetUnits TautologyQ TelegraphProcess TemplateBox TemplateBoxOptions TemplateSlotSequence TemporalData Temporary TemporaryVariable TensorContract TensorDimensions TensorExpand TensorProduct TensorQ TensorRank TensorReduce TensorSymmetry TensorTranspose TensorWedge Tetrahedron TetrahedronBox TetrahedronBoxOptions TeXForm TeXSave Text Text3DBox Text3DBoxOptions TextAlignment TextBand TextBoundingBox TextBox TextCell TextClipboardType TextData TextForm TextJustification TextLine TextPacket TextParagraph TextRecognize TextRendering TextStyle Texture TextureCoordinateFunction TextureCoordinateScaling Therefore ThermometerGauge Thick Thickness Thin Thinning ThisLink ThompsonGroupTh Thread ThreeJSymbol Threshold Through Throw Thumbnail Thursday Ticks TicksStyle Tilde TildeEqual TildeFullEqual TildeTilde TimeConstrained TimeConstraint Times TimesBy TimeSeriesForecast TimeSeriesInvertibility TimeUsed TimeValue TimeZone Timing Tiny TitleGrouping TitsGroupT ToBoxes ToCharacterCode ToColor ToContinuousTimeModel ToDate ToDiscreteTimeModel ToeplitzMatrix ToExpression ToFileName Together Toggle ToggleFalse Toggler TogglerBar TogglerBox TogglerBoxOptions ToHeldExpression ToInvertibleTimeSeries TokenWords Tolerance ToLowerCase ToNumberField TooBig Tooltip TooltipBox TooltipBoxOptions TooltipDelay TooltipStyle Top TopHatTransform TopologicalSort ToRadicals ToRules ToString Total TotalHeight TotalVariationFilter TotalWidth TouchscreenAutoZoom TouchscreenControlPlacement ToUpperCase Tr Trace TraceAbove TraceAction TraceBackward TraceDepth TraceDialog TraceForward TraceInternal TraceLevel TraceOff TraceOn TraceOriginal TracePrint TraceScan TrackedSymbols TradingChart TraditionalForm TraditionalFunctionNotation TraditionalNotation TraditionalOrder TransferFunctionCancel TransferFunctionExpand TransferFunctionFactor TransferFunctionModel TransferFunctionPoles TransferFunctionTransform TransferFunctionZeros TransformationFunction TransformationFunctions TransformationMatrix TransformedDistribution TransformedField Translate TranslationTransform TransparentColor Transpose TreeForm TreeGraph TreeGraphQ TreePlot TrendStyle TriangleWave TriangularDistribution Trig TrigExpand TrigFactor TrigFactorList Trigger TrigReduce TrigToExp TrimmedMean True TrueQ TruncatedDistribution TsallisQExponentialDistribution TsallisQGaussianDistribution TTest Tube TubeBezierCurveBox TubeBezierCurveBoxOptions TubeBox TubeBSplineCurveBox TubeBSplineCurveBoxOptions Tuesday TukeyLambdaDistribution TukeyWindow Tuples TuranGraph TuringMachine Transparent UnateQ Uncompress Undefined UnderBar Underflow Underlined Underoverscript UnderoverscriptBox UnderoverscriptBoxOptions Underscript UnderscriptBox UnderscriptBoxOptions UndirectedEdge UndirectedGraph UndirectedGraphQ UndocumentedTestFEParserPacket UndocumentedTestGetSelectionPacket Unequal Unevaluated UniformDistribution UniformGraphDistribution UniformSumDistribution Uninstall Union UnionPlus Unique UnitBox UnitConvert UnitDimensions Unitize UnitRootTest UnitSimplify UnitStep UnitTriangle UnitVector Unprotect UnsameQ UnsavedVariables Unset UnsetShared UntrackedVariables Up UpArrow UpArrowBar UpArrowDownArrow Update UpdateDynamicObjects UpdateDynamicObjectsSynchronous UpdateInterval UpDownArrow UpEquilibrium UpperCaseQ UpperLeftArrow UpperRightArrow UpperTriangularize Upsample UpSet UpSetDelayed UpTee UpTeeArrow UpValues URL URLFetch URLFetchAsynchronous URLSave URLSaveAsynchronous UseGraphicsRange Using UsingFrontEnd V2Get ValidationLength Value ValueBox ValueBoxOptions ValueForm ValueQ ValuesData Variables Variance VarianceEquivalenceTest VarianceEstimatorFunction VarianceGammaDistribution VarianceTest VectorAngle VectorColorFunction VectorColorFunctionScaling VectorDensityPlot VectorGlyphData VectorPlot VectorPlot3D VectorPoints VectorQ Vectors VectorScale VectorStyle Vee Verbatim Verbose VerboseConvertToPostScriptPacket VerifyConvergence VerifySolutions VerifyTestAssumptions Version VersionNumber VertexAdd VertexCapacity VertexColors VertexComponent VertexConnectivity VertexCoordinateRules VertexCoordinates VertexCorrelationSimilarity VertexCosineSimilarity VertexCount VertexCoverQ VertexDataCoordinates VertexDegree VertexDelete VertexDiceSimilarity VertexEccentricity VertexInComponent VertexInDegree VertexIndex VertexJaccardSimilarity VertexLabeling VertexLabels VertexLabelStyle VertexList VertexNormals VertexOutComponent VertexOutDegree VertexQ VertexRenderingFunction VertexReplace VertexShape VertexShapeFunction VertexSize VertexStyle VertexTextureCoordinates VertexWeight Vertical VerticalBar VerticalForm VerticalGauge VerticalSeparator VerticalSlider VerticalTilde ViewAngle ViewCenter ViewMatrix ViewPoint ViewPointSelectorSettings ViewPort ViewRange ViewVector ViewVertical VirtualGroupData Visible VisibleCell VoigtDistribution VonMisesDistribution WaitAll WaitAsynchronousTask WaitNext WaitUntil WakebyDistribution WalleniusHypergeometricDistribution WaringYuleDistribution WatershedComponents WatsonUSquareTest WattsStrogatzGraphDistribution WaveletBestBasis WaveletFilterCoefficients WaveletImagePlot WaveletListPlot WaveletMapIndexed WaveletMatrixPlot WaveletPhi WaveletPsi WaveletScale WaveletScalogram WaveletThreshold WeaklyConnectedComponents WeaklyConnectedGraphQ WeakStationarity WeatherData WeberE Wedge Wednesday WeibullDistribution WeierstrassHalfPeriods WeierstrassInvariants WeierstrassP WeierstrassPPrime WeierstrassSigma WeierstrassZeta WeightedAdjacencyGraph WeightedAdjacencyMatrix WeightedData WeightedGraphQ Weights WelchWindow WheelGraph WhenEvent Which While White Whitespace WhitespaceCharacter WhittakerM WhittakerW WienerFilter WienerProcess WignerD WignerSemicircleDistribution WilksW WilksWTest WindowClickSelect WindowElements WindowFloating WindowFrame WindowFrameElements WindowMargins WindowMovable WindowOpacity WindowSelected WindowSize WindowStatusArea WindowTitle WindowToolbars WindowWidth With WolframAlpha WolframAlphaDate WolframAlphaQuantity WolframAlphaResult Word WordBoundary WordCharacter WordData WordSearch WordSeparators WorkingPrecision Write WriteString Wronskian XMLElement XMLObject Xnor Xor Yellow YuleDissimilarity ZernikeR ZeroSymmetric ZeroTest ZeroWidthTimes Zeta ZetaZero ZipfDistribution ZTest ZTransform $Aborted $ActivationGroupID $ActivationKey $ActivationUserRegistered $AddOnsDirectory $AssertFunction $Assumptions $AsynchronousTask $BaseDirectory $BatchInput $BatchOutput $BoxForms $ByteOrdering $Canceled $CharacterEncoding $CharacterEncodings $CommandLine $CompilationTarget $ConditionHold $ConfiguredKernels $Context $ContextPath $ControlActiveSetting $CreationDate $CurrentLink $DateStringFormat $DefaultFont $DefaultFrontEnd $DefaultImagingDevice $DefaultPath $Display $DisplayFunction $DistributedContexts $DynamicEvaluation $Echo $Epilog $ExportFormats $Failed $FinancialDataSource $FormatType $FrontEnd $FrontEndSession $GeoLocation $HistoryLength $HomeDirectory $HTTPCookies $IgnoreEOF $ImagingDevices $ImportFormats $InitialDirectory $Input $InputFileName $InputStreamMethods $Inspector $InstallationDate $InstallationDirectory $InterfaceEnvironment $IterationLimit $KernelCount $KernelID $Language $LaunchDirectory $LibraryPath $LicenseExpirationDate $LicenseID $LicenseProcesses $LicenseServer $LicenseSubprocesses $LicenseType $Line $Linked $LinkSupported $LoadedFiles $MachineAddresses $MachineDomain $MachineDomains $MachineEpsilon $MachineID $MachineName $MachinePrecision $MachineType $MaxExtraPrecision $MaxLicenseProcesses $MaxLicenseSubprocesses $MaxMachineNumber $MaxNumber $MaxPiecewiseCases $MaxPrecision $MaxRootDegree $MessageGroups $MessageList $MessagePrePrint $Messages $MinMachineNumber $MinNumber $MinorReleaseNumber $MinPrecision $ModuleNumber $NetworkLicense $NewMessage $NewSymbol $Notebooks $NumberMarks $Off $OperatingSystem $Output $OutputForms $OutputSizeLimit $OutputStreamMethods $Packages $ParentLink $ParentProcessID $PasswordFile $PatchLevelID $Path $PathnameSeparator $PerformanceGoal $PipeSupported $Post $Pre $PreferencesDirectory $PrePrint $PreRead $PrintForms $PrintLiteral $ProcessID $ProcessorCount $ProcessorType $ProductInformation $ProgramName $RandomState $RecursionLimit $ReleaseNumber $RootDirectory $ScheduledTask $ScriptCommandLine $SessionID $SetParentLink $SharedFunctions $SharedVariables $SoundDisplay $SoundDisplayFunction $SuppressInputFormHeads $SynchronousEvaluation $SyntaxHandler $System $SystemCharacterEncoding $SystemID $SystemWordLength $TemporaryDirectory $TemporaryPrefix $TextStyle $TimedOut $TimeUnit $TimeZone $TopDirectory $TraceOff $TraceOn $TracePattern $TracePostAction $TracePreAction $Urgent $UserAddOnsDirectory $UserBaseDirectory $UserDocumentsDirectory $UserName $Version $VersionNumber",c:[{cN:"comment",b:/\(\*/,e:/\*\)/},e.ASM,e.QSM,e.CNM,{cN:"list",b:/\{/,e:/\}/,i:/:/}]}
}),hljs.registerLanguage("php",function(e){var t={cN:"variable",b:"\\$+[a-zA-Z_-ÿ][a-zA-Z0-9_-ÿ]*"},r={cN:"preprocessor",b:/<\?(php)?|\?>/},i={cN:"string",c:[e.BE,r],v:[{b:'b"',e:'"'},{b:"b'",e:"'"},e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null})]},n={v:[e.BNM,e.CNM]};return{cI:!0,k:"and include_once list abstract global private echo interface as static endswitch array null if endwhile or const for endforeach self var while isset public protected exit foreach throw elseif include __FILE__ empty require_once do xor return parent clone use __CLASS__ __LINE__ else break print eval new catch __METHOD__ case exception default die require __FUNCTION__ enddeclare final try switch continue endfor endif declare unset true false trait goto instanceof insteadof __DIR__ __NAMESPACE__ yield finally",c:[e.CLCM,e.HCM,{cN:"comment",b:"/\\*",e:"\\*/",c:[{cN:"phpdoc",b:"\\s@[A-Za-z]+"},r]},{cN:"comment",b:"__halt_compiler.+?;",eW:!0,k:"__halt_compiler",l:e.UIR},{cN:"string",b:"<<<['\"]?\\w+['\"]?$",e:"^\\w+;",c:[e.BE]},r,t,{cN:"function",bK:"function",e:/[;{]/,i:"\\$|\\[|%",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)",c:["self",t,e.CBLCLM,i,n]}]},{cN:"class",bK:"class interface",e:"{",i:/[:\(\$"]/,c:[{bK:"extends implements",r:10},e.UTM]},{bK:"namespace",e:";",i:/[\.']/,c:[e.UTM]},{bK:"use",e:";",c:[e.UTM]},{b:"=>"},i,n]}}),hljs.registerLanguage("haskell",function(e){var t={cN:"comment",v:[{b:"--",e:"$"},{b:"{-",e:"-}",c:["self"]}]},r={cN:"pragma",b:"{-#",e:"#-}"},i={cN:"preprocessor",b:"^#",e:"$"},n={cN:"type",b:"\\b[A-Z][\\w']*",r:0},a={cN:"container",b:"\\(",e:"\\)",i:'"',c:[r,t,i,{cN:"type",b:"\\b[A-Z][\\w]*(\\((\\.\\.|,|\\w+)\\))?"},e.inherit(e.TM,{b:"[_a-z][\\w']*"})]},o={cN:"container",b:"{",e:"}",c:a.c};return{k:"let in if then else case of where do module import hiding qualified type data newtype deriving class instance as default infix infixl infixr foreign export ccall stdcall cplusplus jvm dotnet safe unsafe family forall mdo proc rec",c:[{cN:"module",b:"\\bmodule\\b",e:"where",k:"module where",c:[a,t],i:"\\W\\.|;"},{cN:"import",b:"\\bimport\\b",e:"$",k:"import|0 qualified as hiding",c:[a,t],i:"\\W\\.|;"},{cN:"class",b:"^(\\s*)?(class|instance)\\b",e:"where",k:"class family instance where",c:[n,a,t]},{cN:"typedef",b:"\\b(data|(new)?type)\\b",e:"$",k:"data family type newtype deriving",c:[r,t,n,a,o]},{cN:"default",bK:"default",e:"$",c:[n,a,t]},{cN:"infix",bK:"infix infixl infixr",e:"$",c:[e.CNM,t]},{cN:"foreign",b:"\\bforeign\\b",e:"$",k:"foreign import export ccall stdcall cplusplus jvm dotnet safe unsafe",c:[n,e.QSM,t]},{cN:"shebang",b:"#!\\/usr\\/bin\\/env runhaskell",e:"$"},r,t,i,e.QSM,e.CNM,n,e.inherit(e.TM,{b:"^[_a-z][\\w']*"}),{b:"->|<-"}]}}),hljs.registerLanguage("python",function(e){var t={cN:"prompt",b:/^(>>>|\.\.\.) /},r={cN:"string",c:[e.BE],v:[{b:/(u|b)?r?'''/,e:/'''/,c:[t],r:10},{b:/(u|b)?r?"""/,e:/"""/,c:[t],r:10},{b:/(u|r|ur)'/,e:/'/,r:10},{b:/(u|r|ur)"/,e:/"/,r:10},{b:/(b|br)'/,e:/'/},{b:/(b|br)"/,e:/"/},e.ASM,e.QSM]},i={cN:"number",r:0,v:[{b:e.BNR+"[lLjJ]?"},{b:"\\b(0o[0-7]+)[lLjJ]?"},{b:e.CNR+"[lLjJ]?"}]},n={cN:"params",b:/\(/,e:/\)/,c:["self",t,i,r]},a={e:/:/,i:/[${=;\n]/,c:[e.UTM,n]};return{k:{keyword:"and elif is global as in if from raise for except finally print import pass return exec else break not with class assert yield try while continue del or def lambda nonlocal|10 None True False",built_in:"Ellipsis NotImplemented"},i:/(<\/|->|\?)/,c:[t,i,r,e.HCM,e.inherit(a,{cN:"function",bK:"def",r:10}),e.inherit(a,{cN:"class",bK:"class"}),{cN:"decorator",b:/@/,e:/$/},{b:/\b(print|exec)\(/}]}}),hljs.registerLanguage("smalltalk",function(e){var t="[a-z][a-zA-Z0-9_]*",r={cN:"char",b:"\\$.{1}"},i={cN:"symbol",b:"#"+e.UIR};return{k:"self super nil true false thisContext",c:[{cN:"comment",b:'"',e:'"'},e.ASM,{cN:"class",b:"\\b[A-Z][A-Za-z0-9_]*",r:0},{cN:"method",b:t+":",r:0},e.CNM,i,r,{cN:"localvars",b:"\\|[ ]*"+t+"([ ]+"+t+")*[ ]*\\|",rB:!0,e:/\|/,i:/\S/,c:[{b:"(\\|[ ]*)?"+t}]},{cN:"array",b:"\\#\\(",e:"\\)",c:[e.ASM,r,e.CNM,i]}]}}),hljs.registerLanguage("tex",function(){var e={cN:"command",b:"\\\\[a-zA-Zа-яА-я]+[\\*]?"},t={cN:"command",b:"\\\\[^a-zA-Zа-яА-я0-9]"},r={cN:"special",b:"[{}\\[\\]\\&#~]",r:0};return{c:[{b:"\\\\[a-zA-Zа-яА-я]+[\\*]? *= *-?\\d*\\.?\\d+(pt|pc|mm|cm|in|dd|cc|ex|em)?",rB:!0,c:[e,t,{cN:"number",b:" *=",e:"-?\\d*\\.?\\d+(pt|pc|mm|cm|in|dd|cc|ex|em)?",eB:!0}],r:10},e,t,r,{cN:"formula",b:"\\$\\$",e:"\\$\\$",c:[e,t,r],r:0},{cN:"formula",b:"\\$",e:"\\$",c:[e,t,r],r:0},{cN:"comment",b:"%",e:"$",r:0}]}}),hljs.registerLanguage("sql",function(e){return{cI:!0,i:/[<>]/,c:[{cN:"operator",b:"\\b(begin|end|start|commit|rollback|savepoint|lock|alter|create|drop|rename|call|delete|do|handler|insert|load|replace|select|truncate|update|set|show|pragma|grant|merge)\\b(?!:)",e:";",eW:!0,k:{keyword:"all partial global month current_timestamp using go revoke smallint indicator end-exec disconnect zone with character assertion to add current_user usage input local alter match collate real then rollback get read timestamp session_user not integer bit unique day minute desc insert execute like ilike|2 level decimal drop continue isolation found where constraints domain right national some module transaction relative second connect escape close system_user for deferred section cast current sqlstate allocate intersect deallocate numeric public preserve full goto initially asc no key output collation group by union session both last language constraint column of space foreign deferrable prior connection unknown action commit view or first into float year primary cascaded except restrict set references names table outer open select size are rows from prepare distinct leading create only next inner authorization schema corresponding option declare precision immediate else timezone_minute external varying translation true case exception join hour default double scroll value cursor descriptor values dec fetch procedure delete and false int is describe char as at in varchar null trailing any absolute current_time end grant privileges when cross check write current_date pad begin temporary exec time update catalog user sql date on identity timezone_hour natural whenever interval work order cascade diagnostics nchar having left call do handler load replace truncate start lock show pragma exists number trigger if before after each row merge matched database",aggregate:"count sum min max avg"},c:[{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]},{cN:"string",b:'"',e:'"',c:[e.BE,{b:'""'}]},{cN:"string",b:"`",e:"`",c:[e.BE]},e.CNM]},e.CBLCLM,{cN:"comment",b:"--",e:"$"}]}}),hljs.registerLanguage("handlebars",function(){var e="each in with if else unless bindattr action collection debugger log outlet template unbound view yield";return{cI:!0,sL:"xml",subLanguageMode:"continuous",c:[{cN:"expression",b:"{{",e:"}}",c:[{cN:"begin-block",b:"#[a-zA-Z- .]+",k:e},{cN:"string",b:'"',e:'"'},{cN:"end-block",b:"\\/[a-zA-Z- .]+",k:e},{cN:"variable",b:"[a-zA-Z-.]+",k:e}]}]}}),hljs.registerLanguage("ini",function(e){return{cI:!0,i:/\S/,c:[{cN:"comment",b:";",e:"$"},{cN:"title",b:"^\\[",e:"\\]"},{cN:"setting",b:"^[a-z0-9\\[\\]_-]+[ \\t]*=[ \\t]*",e:"$",c:[{cN:"value",eW:!0,k:"on off true false yes no",c:[e.QSM,e.NM],r:0}]}]}}),hljs.registerLanguage("perl",function(e){var t="getpwent getservent quotemeta msgrcv scalar kill dbmclose undef lc ma syswrite tr send umask sysopen shmwrite vec qx utime local oct semctl localtime readpipe do return format read sprintf dbmopen pop getpgrp not getpwnam rewinddir qqfileno qw endprotoent wait sethostent bless s|0 opendir continue each sleep endgrent shutdown dump chomp connect getsockname die socketpair close flock exists index shmgetsub for endpwent redo lstat msgctl setpgrp abs exit select print ref gethostbyaddr unshift fcntl syscall goto getnetbyaddr join gmtime symlink semget splice x|0 getpeername recv log setsockopt cos last reverse gethostbyname getgrnam study formline endhostent times chop length gethostent getnetent pack getprotoent getservbyname rand mkdir pos chmod y|0 substr endnetent printf next open msgsnd readdir use unlink getsockopt getpriority rindex wantarray hex system getservbyport endservent int chr untie rmdir prototype tell listen fork shmread ucfirst setprotoent else sysseek link getgrgid shmctl waitpid unpack getnetbyname reset chdir grep split require caller lcfirst until warn while values shift telldir getpwuid my getprotobynumber delete and sort uc defined srand accept package seekdir getprotobyname semop our rename seek if q|0 chroot sysread setpwent no crypt getc chown sqrt write setnetent setpriority foreach tie sin msgget map stat getlogin unless elsif truncate exec keys glob tied closedirioctl socket readlink eval xor readline binmode setservent eof ord bind alarm pipe atan2 getgrent exp time push setgrent gt lt or ne m|0 break given say state when",r={cN:"subst",b:"[$@]\\{",e:"\\}",k:t},i={b:"->{",e:"}"},n={cN:"variable",v:[{b:/\$\d/},{b:/[\$\%\@\*](\^\w\b|#\w+(\:\:\w+)*|{\w+}|\w+(\:\:\w*)*)/},{b:/[\$\%\@\*][^\s\w{]/,r:0}]},a={cN:"comment",b:"^(__END__|__DATA__)",e:"\\n$",r:5},o=[e.BE,r,n],s=[n,e.HCM,a,{cN:"comment",b:"^\\=\\w",e:"\\=cut",eW:!0},i,{cN:"string",c:o,v:[{b:"q[qwxr]?\\s*\\(",e:"\\)",r:5},{b:"q[qwxr]?\\s*\\[",e:"\\]",r:5},{b:"q[qwxr]?\\s*\\{",e:"\\}",r:5},{b:"q[qwxr]?\\s*\\|",e:"\\|",r:5},{b:"q[qwxr]?\\s*\\<",e:"\\>",r:5},{b:"qw\\s+q",e:"q",r:5},{b:"'",e:"'",c:[e.BE]},{b:'"',e:'"'},{b:"`",e:"`",c:[e.BE]},{b:"{\\w+}",c:[],r:0},{b:"-?\\w+\\s*\\=\\>",c:[],r:0}]},{cN:"number",b:"(\\b0[0-7_]+)|(\\b0x[0-9a-fA-F_]+)|(\\b[1-9][0-9_]*(\\.[0-9_]+)?)|[0_]\\b",r:0},{b:"(\\/\\/|"+e.RSR+"|\\b(split|return|print|reverse|grep)\\b)\\s*",k:"split return print reverse grep",r:0,c:[e.HCM,a,{cN:"regexp",b:"(s|tr|y)/(\\\\.|[^/])*/(\\\\.|[^/])*/[a-z]*",r:10},{cN:"regexp",b:"(m|qr)?/",e:"/[a-z]*",c:[e.BE],r:0}]},{cN:"sub",bK:"sub",e:"(\\s*\\(.*?\\))?[;{]",r:5},{cN:"operator",b:"-\\w\\b",r:0}];return r.c=s,i.c=s,{k:t,c:s}}),hljs.registerLanguage("scala",function(e){var t={cN:"annotation",b:"@[A-Za-z]+"},r={cN:"string",b:'u?r?"""',e:'"""',r:10};return{k:"type yield lazy override def with val var false true sealed abstract private trait object null if for while throw finally protected extends import final return else break new catch super class case package default try this match continue throws",c:[{cN:"javadoc",b:"/\\*\\*",e:"\\*/",c:[{cN:"javadoctag",b:"@[A-Za-z]+"}],r:10},e.CLCM,e.CBLCLM,r,e.ASM,e.QSM,{cN:"class",b:"((case )?class |object |trait )",e:"({|$)",i:":",k:"case class trait object",c:[{bK:"extends with",r:10},e.UTM,{cN:"params",b:"\\(",e:"\\)",c:[e.ASM,e.QSM,r,t]}]},e.CNM,t]}}),hljs.registerLanguage("cmake",function(e){return{cI:!0,k:{keyword:"add_custom_command add_custom_target add_definitions add_dependencies add_executable add_library add_subdirectory add_test aux_source_directory break build_command cmake_minimum_required cmake_policy configure_file create_test_sourcelist define_property else elseif enable_language enable_testing endforeach endfunction endif endmacro endwhile execute_process export find_file find_library find_package find_path find_program fltk_wrap_ui foreach function get_cmake_property get_directory_property get_filename_component get_property get_source_file_property get_target_property get_test_property if include include_directories include_external_msproject include_regular_expression install link_directories load_cache load_command macro mark_as_advanced message option output_required_files project qt_wrap_cpp qt_wrap_ui remove_definitions return separate_arguments set set_directory_properties set_property set_source_files_properties set_target_properties set_tests_properties site_name source_group string target_link_libraries try_compile try_run unset variable_watch while build_name exec_program export_library_dependencies install_files install_programs install_targets link_libraries make_directory remove subdir_depends subdirs use_mangled_mesa utility_source variable_requires write_file qt5_use_modules qt5_use_package qt5_wrap_cpp on off true false and or",operator:"equal less greater strless strgreater strequal matches"},c:[{cN:"envvar",b:"\\${",e:"}"},e.HCM,e.QSM,e.NM]}}),hljs.registerLanguage("ocaml",function(e){return{k:{keyword:"and as assert asr begin class constraint do done downto else end exception external false for fun function functor if in include inherit initializer land lazy let lor lsl lsr lxor match method mod module mutable new object of open or private rec ref sig struct then to true try type val virtual when while with parser value",built_in:"bool char float int list unit array exn option int32 int64 nativeint format4 format6 lazy_t in_channel out_channel string"},i:/\/\//,c:[{cN:"string",b:'"""',e:'"""'},{cN:"comment",b:"\\(\\*",e:"\\*\\)",c:["self"]},{cN:"class",bK:"type",e:"\\(|=|$",c:[e.UTM]},{cN:"annotation",b:"\\[<",e:">\\]"},e.CBLCLM,e.inherit(e.ASM,{i:null}),e.inherit(e.QSM,{i:null}),e.CNM]}}),hljs.registerLanguage("objectivec",function(e){var t={keyword:"int float while char export sizeof typedef const struct for union unsigned long volatile static bool mutable if do return goto void enum else break extern asm case short default double register explicit signed typename this switch continue wchar_t inline readonly assign self synchronized id nonatomic super unichar IBOutlet IBAction strong weak @private @protected @public @try @property @end @throw @catch @finally @synthesize @dynamic @selector @optional @required",literal:"false true FALSE TRUE nil YES NO NULL",built_in:"NSString NSDictionary CGRect CGPoint UIButton UILabel UITextView UIWebView MKMapView UISegmentedControl NSObject UITableViewDelegate UITableViewDataSource NSThread UIActivityIndicator UITabbar UIToolBar UIBarButtonItem UIImageView NSAutoreleasePool UITableView BOOL NSInteger CGFloat NSException NSLog NSMutableString NSMutableArray NSMutableDictionary NSURL NSIndexPath CGSize UITableViewCell UIView UIViewController UINavigationBar UINavigationController UITabBarController UIPopoverController UIPopoverControllerDelegate UIImage NSNumber UISearchBar NSFetchedResultsController NSFetchedResultsChangeType UIScrollView UIScrollViewDelegate UIEdgeInsets UIColor UIFont UIApplication NSNotFound NSNotificationCenter NSNotification UILocalNotification NSBundle NSFileManager NSTimeInterval NSDate NSCalendar NSUserDefaults UIWindow NSRange NSArray NSError NSURLRequest NSURLConnection UIInterfaceOrientation MPMoviePlayerController dispatch_once_t dispatch_queue_t dispatch_sync dispatch_async dispatch_once"},r=/[a-zA-Z@][a-zA-Z0-9_]*/,i="@interface @class @protocol @implementation";return{k:t,l:r,i:"</",c:[e.CLCM,e.CBLCLM,e.CNM,e.QSM,{cN:"string",b:"'",e:"[^\\\\]'",i:"[^\\\\][^']"},{cN:"preprocessor",b:"#import",e:"$",c:[{cN:"title",b:'"',e:'"'},{cN:"title",b:"<",e:">"}]},{cN:"preprocessor",b:"#",e:"$"},{cN:"class",b:"("+i.split(" ").join("|")+")\\b",e:"({|$)",k:i,l:r,c:[e.UTM]},{cN:"variable",b:"\\."+e.UIR,r:0}]}}),hljs.registerLanguage("coffeescript",function(e){var t={keyword:"in if for while finally new do return else break catch instanceof throw try this switch continue typeof delete debugger super then unless until loop of by when and or is isnt not",literal:"true false null undefined yes no on off",reserved:"case default function var void with const let enum export import native __hasProp __extends __slice __bind __indexOf",built_in:"npm require console print module exports global window document"},r="[A-Za-z$_][0-9A-Za-z$_]*",i=e.inherit(e.TM,{b:r}),n={cN:"subst",b:/#\{/,e:/}/,k:t},a=[e.BNM,e.inherit(e.CNM,{starts:{e:"(\\s*/)?",r:0}}),{cN:"string",v:[{b:/'''/,e:/'''/,c:[e.BE]},{b:/'/,e:/'/,c:[e.BE]},{b:/"""/,e:/"""/,c:[e.BE,n]},{b:/"/,e:/"/,c:[e.BE,n]}]},{cN:"regexp",v:[{b:"///",e:"///",c:[n,e.HCM]},{b:"//[gim]*",r:0},{b:"/\\S(\\\\.|[^\\n])*?/[gim]*(?=\\s|\\W|$)"}]},{cN:"property",b:"@"+r},{b:"`",e:"`",eB:!0,eE:!0,sL:"javascript"}];return n.c=a,{k:t,c:a.concat([{cN:"comment",b:"###",e:"###"},e.HCM,{cN:"function",b:"("+r+"\\s*=\\s*)?(\\(.*\\))?\\s*\\B[-=]>",e:"[-=]>",rB:!0,c:[i,{cN:"params",b:"\\(",rB:!0,c:[{b:/\(/,e:/\)/,k:t,c:["self"].concat(a)}]}]},{cN:"class",bK:"class",e:"$",i:/[:="\[\]]/,c:[{bK:"extends",eW:!0,i:/[:="\[\]]/,c:[i]},i]},{cN:"attribute",b:r+":",e:":",rB:!0,eE:!0,r:0}])}}),hljs.registerLanguage("nginx",function(e){var t={cN:"variable",v:[{b:/\$\d+/},{b:/\$\{/,e:/}/},{b:"[\\$\\@]"+e.UIR}]},r={eW:!0,l:"[a-z/_]+",k:{built_in:"on off yes no true false none blocked debug info notice warn error crit select break last permanent redirect kqueue rtsig epoll poll /dev/poll"},r:0,i:"=>",c:[e.HCM,{cN:"string",c:[e.BE,t],v:[{b:/"/,e:/"/},{b:/'/,e:/'/}]},{cN:"url",b:"([a-z]+):/",e:"\\s",eW:!0,eE:!0},{cN:"regexp",c:[e.BE,t],v:[{b:"\\s\\^",e:"\\s|{|;",rE:!0},{b:"~\\*?\\s+",e:"\\s|{|;",rE:!0},{b:"\\*(\\.[a-z\\-]+)+"},{b:"([a-z\\-]+\\.)+\\*"}]},{cN:"number",b:"\\b\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}(:\\d{1,5})?\\b"},{cN:"number",b:"\\b\\d+[kKmMgGdshdwy]*\\b",r:0},t]};return{c:[e.HCM,{b:e.UIR+"\\s",e:";|{",rB:!0,c:[e.inherit(e.UTM,{starts:r})],r:0}],i:"[^\\s\\}]"}}),hljs.registerLanguage("erlang-repl",function(e){return{k:{special_functions:"spawn spawn_link self",reserved:"after and andalso|10 band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse|10 query receive rem try when xor"},c:[{cN:"prompt",b:"^[0-9]+> ",r:10},{cN:"comment",b:"%",e:"$"},{cN:"number",b:"\\b(\\d+#[a-fA-F0-9]+|\\d+(\\.\\d+)?([eE][-+]?\\d+)?)",r:0},e.ASM,e.QSM,{cN:"constant",b:"\\?(::)?([A-Z]\\w*(::)?)+"},{cN:"arrow",b:"->"},{cN:"ok",b:"ok"},{cN:"exclamation_mark",b:"!"},{cN:"function_or_atom",b:"(\\b[a-z'][a-zA-Z0-9_']*:[a-z'][a-zA-Z0-9_']*)|(\\b[a-z'][a-zA-Z0-9_']*)",r:0},{cN:"variable",b:"[A-Z][a-zA-Z0-9_']*",r:0}]}}),hljs.registerLanguage("r",function(e){var t="([a-zA-Z]|\\.[a-zA-Z.])[a-zA-Z0-9._]*";return{c:[e.HCM,{b:t,l:t,k:{keyword:"function if in break next repeat else for return switch while try tryCatch|10 stop warning require library attach detach source setMethod setGeneric setGroupGeneric setClass ...|10",literal:"NULL NA TRUE FALSE T F Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10"},r:0},{cN:"number",b:"0[xX][0-9a-fA-F]+[Li]?\\b",r:0},{cN:"number",b:"\\d+(?:[eE][+\\-]?\\d*)?L\\b",r:0},{cN:"number",b:"\\d+\\.(?!\\d)(?:i\\b)?",r:0},{cN:"number",b:"\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",r:0},{b:"`",e:"`",r:0},{cN:"string",c:[e.BE],v:[{b:'"',e:'"'},{b:"'",e:"'"}]}]}}),hljs.registerLanguage("json",function(e){var t={literal:"true false null"},r=[e.QSM,e.CNM],i={cN:"value",e:",",eW:!0,eE:!0,c:r,k:t},n={b:"{",e:"}",c:[{cN:"attribute",b:'\\s*"',e:'"\\s*:\\s*',eB:!0,eE:!0,c:[e.BE],i:"\\n",starts:i}],i:"\\S"},a={b:"\\[",e:"\\]",c:[e.inherit(i,{cN:null})],i:"\\S"};return r.splice(r.length,0,n,a),{c:r,k:t,i:"\\S"}}),hljs.registerLanguage("django",function(){var e={cN:"filter",b:/\|[A-Za-z]+\:?/,k:"truncatewords removetags linebreaksbr yesno get_digit timesince random striptags filesizeformat escape linebreaks length_is ljust rjust cut urlize fix_ampersands title floatformat capfirst pprint divisibleby add make_list unordered_list urlencode timeuntil urlizetrunc wordcount stringformat linenumbers slice date dictsort dictsortreversed default_if_none pluralize lower join center default truncatewords_html upper length phone2numeric wordwrap time addslashes slugify first escapejs force_escape iriencode last safe safeseq truncatechars localize unlocalize localtime utc timezone",c:[{cN:"argument",b:/"/,e:/"/},{cN:"argument",b:/'/,e:/'/}]};return{cI:!0,sL:"xml",subLanguageMode:"continuous",c:[{cN:"template_comment",b:/\{%\s*comment\s*%}/,e:/\{%\s*endcomment\s*%}/},{cN:"template_comment",b:/\{#/,e:/#}/},{cN:"template_tag",b:/\{%/,e:/%}/,k:"comment endcomment load templatetag ifchanged endifchanged if endif firstof for endfor in ifnotequal endifnotequal widthratio extends include spaceless endspaceless regroup by as ifequal endifequal ssi now with cycle url filter endfilter debug block endblock else autoescape endautoescape csrf_token empty elif endwith static trans blocktrans endblocktrans get_static_prefix get_media_prefix plural get_current_language language get_available_languages get_current_language_bidi get_language_info get_language_info_list localize endlocalize localtime endlocaltime timezone endtimezone get_current_timezone verbatim",c:[e]},{cN:"variable",b:/\{\{/,e:/}}/,c:[e]}]}}),hljs.registerLanguage("apache",function(e){var t={cN:"number",b:"[\\$%]\\d+"};return{cI:!0,c:[e.HCM,{cN:"tag",b:"</?",e:">"},{cN:"keyword",b:/\w+/,r:0,k:{common:"order deny allow setenv rewriterule rewriteengine rewritecond documentroot sethandler errordocument loadmodule options header listen serverroot servername"},starts:{e:/$/,r:0,k:{literal:"on off all"},c:[{cN:"sqbracket",b:"\\s\\[",e:"\\]$"},{cN:"cbracket",b:"[\\$%]\\{",e:"\\}",c:["self",t]},t,e.QSM]}}],i:/\S/}}),hljs.registerLanguage("scss",function(e){{var t="[a-zA-Z-][a-zA-Z0-9_-]*",r={cN:"function",b:t+"\\(",e:"\\)",c:["self",e.NM,e.ASM,e.QSM]},i={cN:"hexcolor",b:"#[0-9A-Fa-f]+"};({cN:"attribute",b:"[A-Z\\_\\.\\-]+",e:":",eE:!0,i:"[^\\s]",starts:{cN:"value",eW:!0,eE:!0,c:[r,i,e.NM,e.QSM,e.ASM,e.CBLCLM,{cN:"important",b:"!important"}]}})}return{cI:!0,i:"[=/|']",c:[e.CLCM,e.CBLCLM,{cN:"function",b:t+"\\(",e:"\\)",c:["self",e.NM,e.ASM,e.QSM]},{cN:"id",b:"\\#[A-Za-z0-9_-]+",r:0},{cN:"class",b:"\\.[A-Za-z0-9_-]+",r:0},{cN:"attr_selector",b:"\\[",e:"\\]",i:"$"},{cN:"tag",b:"\\b(a|abbr|acronym|address|area|article|aside|audio|b|base|big|blockquote|body|br|button|canvas|caption|cite|code|col|colgroup|command|datalist|dd|del|details|dfn|div|dl|dt|em|embed|fieldset|figcaption|figure|footer|form|frame|frameset|(h[1-6])|head|header|hgroup|hr|html|i|iframe|img|input|ins|kbd|keygen|label|legend|li|link|map|mark|meta|meter|nav|noframes|noscript|object|ol|optgroup|option|output|p|param|pre|progress|q|rp|rt|ruby|samp|script|section|select|small|span|strike|strong|style|sub|sup|table|tbody|td|textarea|tfoot|th|thead|time|title|tr|tt|ul|var|video)\\b",r:0},{cN:"pseudo",b:":(visited|valid|root|right|required|read-write|read-only|out-range|optional|only-of-type|only-child|nth-of-type|nth-last-of-type|nth-last-child|nth-child|not|link|left|last-of-type|last-child|lang|invalid|indeterminate|in-range|hover|focus|first-of-type|first-line|first-letter|first-child|first|enabled|empty|disabled|default|checked|before|after|active)"},{cN:"pseudo",b:"::(after|before|choices|first-letter|first-line|repeat-index|repeat-item|selection|value)"},{cN:"attribute",b:"\\b(z-index|word-wrap|word-spacing|word-break|width|widows|white-space|visibility|vertical-align|unicode-bidi|transition-timing-function|transition-property|transition-duration|transition-delay|transition|transform-style|transform-origin|transform|top|text-underline-position|text-transform|text-shadow|text-rendering|text-overflow|text-indent|text-decoration-style|text-decoration-line|text-decoration-color|text-decoration|text-align-last|text-align|tab-size|table-layout|right|resize|quotes|position|pointer-events|perspective-origin|perspective|page-break-inside|page-break-before|page-break-after|padding-top|padding-right|padding-left|padding-bottom|padding|overflow-y|overflow-x|overflow-wrap|overflow|outline-width|outline-style|outline-offset|outline-color|outline|orphans|order|opacity|object-position|object-fit|normal|none|nav-up|nav-right|nav-left|nav-index|nav-down|min-width|min-height|max-width|max-height|mask|marks|margin-top|margin-right|margin-left|margin-bottom|margin|list-style-type|list-style-position|list-style-image|list-style|line-height|letter-spacing|left|justify-content|initial|inherit|ime-mode|image-orientation|image-resolution|image-rendering|icon|hyphens|height|font-weight|font-variant-ligatures|font-variant|font-style|font-stretch|font-size-adjust|font-size|font-language-override|font-kerning|font-feature-settings|font-family|font|float|flex-wrap|flex-shrink|flex-grow|flex-flow|flex-direction|flex-basis|flex|filter|empty-cells|display|direction|cursor|counter-reset|counter-increment|content|column-width|column-span|column-rule-width|column-rule-style|column-rule-color|column-rule|column-gap|column-fill|column-count|columns|color|clip-path|clip|clear|caption-side|break-inside|break-before|break-after|box-sizing|box-shadow|box-decoration-break|bottom|border-width|border-top-width|border-top-style|border-top-right-radius|border-top-left-radius|border-top-color|border-top|border-style|border-spacing|border-right-width|border-right-style|border-right-color|border-right|border-radius|border-left-width|border-left-style|border-left-color|border-left|border-image-width|border-image-source|border-image-slice|border-image-repeat|border-image-outset|border-image|border-color|border-collapse|border-bottom-width|border-bottom-style|border-bottom-right-radius|border-bottom-left-radius|border-bottom-color|border-bottom|border|background-size|background-repeat|background-position|background-origin|background-image|background-color|background-clip|background-attachment|background|backface-visibility|auto|animation-timing-function|animation-play-state|animation-name|animation-iteration-count|animation-fill-mode|animation-duration|animation-direction|animation-delay|animation|align-self|align-items|align-content)\\b",i:"[^\\s]"},{cN:"value",b:"\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b"},{cN:"value",b:":",e:";",c:[i,e.NM,e.QSM,e.ASM,{cN:"important",b:"!important"}]},{cN:"at_rule",b:"@",e:"[{;]",k:"mixin include extend for if else each while charset import debug media page content font-face namespace warn",c:[r,e.QSM,e.ASM,i,e.NM,{cN:"preprocessor",b:"\\s[A-Za-z0-9_.-]+",r:0}]}]}}),hljs.registerLanguage("applescript",function(e){var t=e.inherit(e.QSM,{i:""}),r={cN:"params",b:"\\(",e:"\\)",c:["self",e.CNM,t]},i=[{cN:"comment",b:"--",e:"$"},{cN:"comment",b:"\\(\\*",e:"\\*\\)",c:["self",{b:"--",e:"$"}]},e.HCM];return{k:{keyword:"about above after against and around as at back before beginning behind below beneath beside between but by considering contain contains continue copy div does eighth else end equal equals error every exit fifth first for fourth from front get given global if ignoring in into is it its last local me middle mod my ninth not of on onto or over prop property put ref reference repeat returning script second set seventh since sixth some tell tenth that the then third through thru timeout times to transaction try until where while whose with without",constant:"AppleScript false linefeed return pi quote result space tab true",type:"alias application boolean class constant date file integer list number real record string text",command:"activate beep count delay launch log offset read round run say summarize write",property:"character characters contents day frontmost id item length month name paragraph paragraphs rest reverse running time version weekday word words year"},c:[t,e.CNM,{cN:"type",b:"\\bPOSIX file\\b"},{cN:"command",b:"\\b(clipboard info|the clipboard|info for|list (disks|folder)|mount volume|path to|(close|open for) access|(get|set) eof|current date|do shell script|get volume settings|random number|set volume|system attribute|system info|time to GMT|(load|run|store) script|scripting components|ASCII (character|number)|localized string|choose (application|color|file|file name|folder|from list|remote application|URL)|display (alert|dialog))\\b|^\\s*return\\b"},{cN:"constant",b:"\\b(text item delimiters|current application|missing value)\\b"},{cN:"keyword",b:"\\b(apart from|aside from|instead of|out of|greater than|isn't|(doesn't|does not) (equal|come before|come after|contain)|(greater|less) than( or equal)?|(starts?|ends|begins?) with|contained by|comes (before|after)|a (ref|reference))\\b"},{cN:"property",b:"\\b(POSIX path|(date|time) string|quoted form)\\b"},{cN:"function_start",bK:"on",i:"[${=;\\n]",c:[e.UTM,r]}].concat(i),i:"//"}}),hljs.registerLanguage("cpp",function(e){var t={keyword:"false int float while private char catch export virtual operator sizeof dynamic_cast|10 typedef const_cast|10 const struct for static_cast|10 union namespace unsigned long throw volatile static protected bool template mutable if public friend do return goto auto void enum else break new extern using true class asm case typeid short reinterpret_cast|10 default double register explicit signed typename try this switch continue wchar_t inline delete alignof char16_t char32_t constexpr decltype noexcept nullptr static_assert thread_local restrict _Bool complex _Complex _Imaginary",built_in:"std string cin cout cerr clog stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap array shared_ptr abort abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf"};return{aliases:["c"],k:t,i:"</",c:[e.CLCM,e.CBLCLM,e.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},e.CNM,{cN:"preprocessor",b:"#",e:"$",c:[{b:"include\\s*<",e:">",i:"\\n"},e.CLCM]},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:t,r:10,c:["self"]}]}}),hljs.registerLanguage("matlab",function(e){var t=[e.CNM,{cN:"string",b:"'",e:"'",c:[e.BE,{b:"''"}]}];return{k:{keyword:"break case catch classdef continue else elseif end enumerated events for function global if methods otherwise parfor persistent properties return spmd switch try while",built_in:"sin sind sinh asin asind asinh cos cosd cosh acos acosd acosh tan tand tanh atan atand atan2 atanh sec secd sech asec asecd asech csc cscd csch acsc acscd acsch cot cotd coth acot acotd acoth hypot exp expm1 log log1p log10 log2 pow2 realpow reallog realsqrt sqrt nthroot nextpow2 abs angle complex conj imag real unwrap isreal cplxpair fix floor ceil round mod rem sign airy besselj bessely besselh besseli besselk beta betainc betaln ellipj ellipke erf erfc erfcx erfinv expint gamma gammainc gammaln psi legendre cross dot factor isprime primes gcd lcm rat rats perms nchoosek factorial cart2sph cart2pol pol2cart sph2cart hsv2rgb rgb2hsv zeros ones eye repmat rand randn linspace logspace freqspace meshgrid accumarray size length ndims numel disp isempty isequal isequalwithequalnans cat reshape diag blkdiag tril triu fliplr flipud flipdim rot90 find sub2ind ind2sub bsxfun ndgrid permute ipermute shiftdim circshift squeeze isscalar isvector ans eps realmax realmin pi i inf nan isnan isinf isfinite j why compan gallery hadamard hankel hilb invhilb magic pascal rosser toeplitz vander wilkinson"},i:'(//|"|#|/\\*|\\s+/\\w+)',c:[{cN:"function",bK:"function",e:"$",c:[e.UTM,{cN:"params",b:"\\(",e:"\\)"},{cN:"params",b:"\\[",e:"\\]"}]},{cN:"transposed_variable",b:"[a-zA-Z_][a-zA-Z_0-9]*('+[\\.']*|[\\.']+)",e:"",r:0},{cN:"matrix",b:"\\[",e:"\\]'*[\\.']*",c:t,r:0},{cN:"cell",b:"\\{",e:"\\}'*[\\.']*",c:t,i:/:/},{cN:"comment",b:"\\%",e:"$"}].concat(t)}
}),hljs.registerLanguage("makefile",function(e){var t={cN:"variable",b:/\$\(/,e:/\)/,c:[e.BE]};return{c:[e.HCM,{b:/^\w+\s*\W*=/,rB:!0,r:0,starts:{cN:"constant",e:/\s*\W*=/,eE:!0,starts:{e:/$/,r:0,c:[t]}}},{cN:"title",b:/^[\w]+:\s*$/},{cN:"phony",b:/^\.PHONY:/,e:/$/,k:".PHONY",l:/[\.\w]+/},{b:/^\t+/,e:/$/,c:[e.QSM,t]}]}}),hljs.registerLanguage("clojure",function(e){var t={built_in:"def cond apply if-not if-let if not not= = &lt; < > &lt;= <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="[a-zA-Z_0-9\\!\\.\\?\\-\\+\\*\\/\\<\\=\\>\\&\\#\\$';]+",i="[\\s:\\(\\{]+\\d+(\\.\\d+)?",n={cN:"number",b:i,r:0},a=e.inherit(e.QSM,{i:null}),o={cN:"comment",b:";",e:"$",r:0},s={cN:"collection",b:"[\\[\\{]",e:"[\\]\\}]"},l={cN:"comment",b:"\\^"+r},c={cN:"comment",b:"\\^\\{",e:"\\}"},u={cN:"attribute",b:"[:]"+r},d={cN:"list",b:"\\(",e:"\\)"},p={eW:!0,k:{literal:"true false nil"},r:0},m={k:t,l:r,cN:"title",b:r,starts:p};return d.c=[{cN:"comment",b:"comment"},m,p],p.c=[d,a,l,c,o,u,s,n],s.c=[d,a,l,o,u,s,n],{i:/\S/,c:[o,d,{cN:"prompt",b:/^=> /,starts:{e:/\n\n|\Z/}}]}}),hljs.registerLanguage("go",function(e){var t={keyword:"break default func interface select case map struct chan else goto package switch const fallthrough if range type continue for import return var go defer",constant:"true false iota nil",typename:"bool byte complex64 complex128 float32 float64 int8 int16 int32 int64 string uint8 uint16 uint32 uint64 int uint uintptr rune",built_in:"append cap close complex copy imag len make new panic print println real recover delete"};return{aliases:["golang"],k:t,i:"</",c:[e.CLCM,e.CBLCLM,e.QSM,{cN:"string",b:"'",e:"[^\\\\]'"},{cN:"string",b:"`",e:"`"},{cN:"number",b:"[^a-zA-Z_0-9](\\-|\\+)?\\d+(\\.\\d+|\\/\\d+)?((d|e|f|l|s)(\\+|\\-)?\\d+)?",r:0},e.CNM]}});
var Inflector;Inflector=function(){function e(i){return this instanceof e?void(this.value=i):new e(i)}var i,n,t=Array.prototype.slice;return n={uncountable_words:["equipment","information","rice","money","species","series","fish","sheep","moose","deer","news"],plural_rules:[[new RegExp("(m)an$","gi"),"$1en"],[new RegExp("(pe)rson$","gi"),"$1ople"],[new RegExp("(child)$","gi"),"$1ren"],[new RegExp("^(ox)$","gi"),"$1en"],[new RegExp("(ax|test)is$","gi"),"$1es"],[new RegExp("(octop|vir)us$","gi"),"$1i"],[new RegExp("(alias|status|by)$","gi"),"$1es"],[new RegExp("(bu)s$","gi"),"$1ses"],[new RegExp("(buffal|tomat|potat)o$","gi"),"$1oes"],[new RegExp("([ti])um$","gi"),"$1a"],[new RegExp("sis$","gi"),"ses"],[new RegExp("(?:([^f])fe|([lr])f)$","gi"),"$1$2ves"],[new RegExp("(hive)$","gi"),"$1s"],[new RegExp("([^aeiouy]|qu)y$","gi"),"$1ies"],[new RegExp("(x|ch|ss|sh)$","gi"),"$1es"],[new RegExp("(matr|vert|ind)ix|ex$","gi"),"$1ices"],[new RegExp("([m|l])ouse$","gi"),"$1ice"],[new RegExp("(quiz)$","gi"),"$1zes"],[new RegExp("s$","gi"),"s"],[new RegExp("$","gi"),"s"]],singular_rules:[[new RegExp("(m)en$","gi"),"$1an"],[new RegExp("(pe)ople$","gi"),"$1rson"],[new RegExp("(child)ren$","gi"),"$1"],[new RegExp("([ti])a$","gi"),"$1um"],[new RegExp("((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$","gi"),"$1$2sis"],[new RegExp("(hive)s$","gi"),"$1"],[new RegExp("(tive)s$","gi"),"$1"],[new RegExp("(curve)s$","gi"),"$1"],[new RegExp("([lr])ves$","gi"),"$1f"],[new RegExp("([^fo])ves$","gi"),"$1fe"],[new RegExp("([^aeiouy]|qu)ies$","gi"),"$1y"],[new RegExp("(s)eries$","gi"),"$1eries"],[new RegExp("(m)ovies$","gi"),"$1ovie"],[new RegExp("(x|ch|ss|sh)es$","gi"),"$1"],[new RegExp("([m|l])ice$","gi"),"$1ouse"],[new RegExp("(bus)es$","gi"),"$1"],[new RegExp("(o)es$","gi"),"$1"],[new RegExp("(shoe)s$","gi"),"$1"],[new RegExp("(cris|ax|test)es$","gi"),"$1is"],[new RegExp("(octop|vir)i$","gi"),"$1us"],[new RegExp("(alias|status)es$","gi"),"$1"],[new RegExp("^(ox)en","gi"),"$1"],[new RegExp("(vert|ind)ices$","gi"),"$1ex"],[new RegExp("(matr)ices$","gi"),"$1ix"],[new RegExp("(quiz)zes$","gi"),"$1"],[new RegExp("s$","gi"),""]],non_titlecased_words:["and","or","nor","a","an","the","so","but","to","of","at","by","from","into","on","onto","off","out","in","over","with","for"],id_suffix:new RegExp("(_ids|_id)$","g"),underbar:new RegExp("_","g"),space_or_underbar:new RegExp("[ _]","g"),uppercase:new RegExp("([A-Z])","g"),underbar_prefix:new RegExp("^_"),apply_rules:function(e,i,n,t){if(t)e=t;else{var r=n.indexOf(e.toLowerCase())>-1;if(!r)for(var s=0;s<i.length;s++)if(e.match(i[s][0])){e=e.replace(i[s][0],i[s][1]);break}}return e}},n.pluralize=function(e,i){return this.apply_rules(e,this.plural_rules,this.uncountable_words,i)},n.singularize=function(e,i){return this.apply_rules(e,this.singular_rules,this.uncountable_words,i)},n.camelize=function(e,i,n){n||(e=e.toLowerCase());for(var t=e.split("/"),r=0;r<t.length;r++){for(var s=t[r].split("_"),o=i&&r+1===t.length?1:0,g=o;g<s.length;g++)s[g]=s[g].charAt(0).toUpperCase()+s[g].substring(1);t[r]=s.join("")}return e=t.join("::")},n.underscore=function(e){for(var i=e.split("::"),n=0;n<i.length;n++)i[n]=i[n].replace(this.uppercase,"_$1"),i[n]=i[n].replace(this.underbar_prefix,"");return e=i.join("/").toLowerCase()},n.humanize=function(e,i){return e=e.toLowerCase(),e=e.replace(this.id_suffix,""),e=e.replace(this.underbar," "),i||(e=this.capitalize(e)),e},n.capitalize=function(e,i){return i||(e=e.toLowerCase()),e=e.substring(0,1).toUpperCase()+e.substring(1)},n.decapitalize=function(e){return e=e.substring(0,1).toLowerCase()+e.substring(1)},n.dasherize=function(e){return e=e.replace(this.space_or_underbar,"-")},n.titleize=function(e){e=e.toLowerCase(),e=e.replace(this.underbar," ");for(var i=e.split(" "),n=0;n<i.length;n++){for(var t=i[n].split("-"),r=0;r<t.length;r++)this.non_titlecased_words.indexOf(t[r].toLowerCase())<0&&(t[r]=this.capitalize(t[r]));i[n]=t.join("-")}return e=i.join(" "),e=e.substring(0,1).toUpperCase()+e.substring(1)},n.demodulize=function(e){var i=e.split("::");return e=i[i.length-1]},n.tableize=function(e){return e=this.pluralize(this.underscore(e))},n.classify=function(e){return e=this.singularize(this.camelize(e))},n.foreign_key=function(e,i){return e=this.underscore(this.demodulize(e))+(i?"":"_")+"id"},n.ordinalize=function(e){for(var i=e.split(" "),n=0;n<i.length;n++){var t=parseInt(i[n]);if(0/0===t){var r=i[n].substring(i[n].length-2),s=i[n].substring(i[n].length-1),o="th";"11"!=r&&"12"!=r&&"13"!=r&&("1"===s?o="st":"2"===s?o="nd":"3"===s&&(o="rd")),i[n]+=o}}return e=i.join(" ")},i=n,Object.keys(i).forEach(function(n){return e[n]=i[n],e.prototype[n]=function(){return this.value=e[n].apply(e,[this.value].concat(t.call(arguments))),this}}),e.prototype.tap=function(e){return e(this.value),this},e.prototype.inspect=function(){return this+""},e.prototype.toString=function(){return this.value},e.prototype.valueOf=function(){return this.value},e}();
!function(t){"use strict";var e,i=function(t,e){"undefined"==typeof e&&(e={}),this.init(t,e)},s=i.prototype,n=["canvas","vml"],a=["oval","spiral","square","rect","roundRect"],h=/^\#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/,r=-1!==navigator.appVersion.indexOf("MSIE")&&8===parseFloat(navigator.appVersion.split("MSIE")[1])?!0:!1,o=!!document.createElement("canvas").getContext,c=40,d=!0,u=function(t,e,i){var s,n=document.createElement(t);for(s in i)n[s]=i[s];return"undefined"!=typeof e&&e.appendChild(n),n},l=function(t,e){for(var i in e)t.style[i]=e[i];return t},f=function(t,e){for(var i in e)t.setAttribute(i,e[i]);return t},p=function(t,e,i,s){t.save(),t.translate(e,i),t.rotate(s),t.translate(-e,-i),t.beginPath()};s.init=function(t,s){"boolean"==typeof s.safeVML&&(d=s.safeVML);try{this.mum=void 0!==t?t:document.body}catch(a){this.mum=document.body}if(s.id="undefined"!=typeof s.id?s.id:"canvasLoader",this.cont=u("span",this.mum,{id:s.id}),this.cont.setAttribute("class","canvas-loader"),o)e=n[0],this.can=u("canvas",this.cont),this.con=this.can.getContext("2d"),this.cCan=l(u("canvas",this.cont),{display:"none"}),this.cCon=this.cCan.getContext("2d");else{if(e=n[1],"undefined"==typeof i.vmlSheet){document.getElementsByTagName("head")[0].appendChild(u("style")),i.vmlSheet=document.styleSheets[document.styleSheets.length-1];var h,r=["group","oval","roundrect","fill"];for(h in r)i.vmlSheet.addRule(r[h],"behavior:url(#default#VML); position:absolute;")}this.vml=u("group",this.cont)}this.setColor(this.color),this.draw(),l(this.cont,{display:"none"})},s.cont={},s.can={},s.con={},s.cCan={},s.cCon={},s.timer={},s.activeId=0,s.diameter=40,s.setDiameter=function(t){this.diameter=Math.round(Math.abs(t)),this.redraw()},s.getDiameter=function(){return this.diameter},s.cRGB={},s.color="#000000",s.setColor=function(t){this.color=h.test(t)?t:"#000000",this.cRGB=this.getRGB(this.color),this.redraw()},s.getColor=function(){return this.color},s.shape=a[0],s.setShape=function(t){var e;for(e in a)if(t===a[e]){this.shape=t,this.redraw();break}},s.getShape=function(){return this.shape},s.density=40,s.setDensity=function(t){this.density=d&&e===n[1]?Math.round(Math.abs(t))<=c?Math.round(Math.abs(t)):c:Math.round(Math.abs(t)),this.density>360&&(this.density=360),this.activeId=0,this.redraw()},s.getDensity=function(){return this.density},s.range=1.3,s.setRange=function(t){this.range=Math.abs(t),this.redraw()},s.getRange=function(){return this.range},s.speed=2,s.setSpeed=function(t){this.speed=Math.round(Math.abs(t))},s.getSpeed=function(){return this.speed},s.fps=24,s.setFPS=function(t){this.fps=Math.round(Math.abs(t)),this.reset()},s.getFPS=function(){return this.fps},s.getRGB=function(t){return t="#"===t.charAt(0)?t.substring(1,7):t,{r:parseInt(t.substring(0,2),16),g:parseInt(t.substring(2,4),16),b:parseInt(t.substring(4,6),16)}},s.draw=function(){var t,i,s,h,o,c,d,v,m,g,b,y,M,C=0,w=this.density,I=Math.round(w*this.range),R=0,S=1e3,k=0,T=this.cCon,P=this.diameter,B=.47;if(e===n[0])for(T.clearRect(0,0,S,S),f(this.can,{width:P,height:P}),f(this.cCan,{width:P,height:P});w>C;){switch(m=I>=C?1-(1-R)/I*C:m=R,c=270-360/w*C,d=c/180*Math.PI,T.fillStyle="rgba("+this.cRGB.r+","+this.cRGB.g+","+this.cRGB.b+","+m.toString()+")",this.shape){case a[0]:case a[1]:t=.07*P,h=P*B+Math.cos(d)*(P*B-t)-P*B,o=P*B+Math.sin(d)*(P*B-t)-P*B,T.beginPath(),this.shape===a[1]?T.arc(.5*P+h,.5*P+o,t*m,0,2*Math.PI,!1):T.arc(.5*P+h,.5*P+o,t,0,2*Math.PI,!1);break;case a[2]:t=.12*P,h=Math.cos(d)*(P*B-t)+.5*P,o=Math.sin(d)*(P*B-t)+.5*P,p(T,h,o,d),T.fillRect(h,o-.5*t,t,t);break;case a[3]:case a[4]:i=.3*P,s=.27*i,h=Math.cos(d)*(s+.13*(P-s))+.5*P,o=Math.sin(d)*(s+.13*(P-s))+.5*P,p(T,h,o,d),this.shape===a[3]?T.fillRect(h,o-.5*s,i,s):(v=.55*s,T.moveTo(h+v,o-.5*s),T.lineTo(h+i-v,o-.5*s),T.quadraticCurveTo(h+i,o-.5*s,h+i,o-.5*s+v),T.lineTo(h+i,o-.5*s+s-v),T.quadraticCurveTo(h+i,o-.5*s+s,h+i-v,o-.5*s+s),T.lineTo(h+v,o-.5*s+s),T.quadraticCurveTo(h,o-.5*s+s,h,o-.5*s+s-v),T.lineTo(h,o-.5*s+v),T.quadraticCurveTo(h,o-.5*s,h+v,o-.5*s))}T.closePath(),T.fill(),T.restore(),++C}else{switch(l(this.cont,{width:P,height:P}),l(this.vml,{width:P,height:P}),this.shape){case a[0]:case a[1]:y="oval",t=.14*S;break;case a[2]:y="roundrect",t=.12*S;break;case a[3]:case a[4]:y="roundrect",t=.3*S}for(i=s=t,h=.5*S-s,o=.5*-s;w>C;){switch(m=I>=C?1-(1-R)/I*C:m=R,c=270-360/w*C,this.shape){case a[1]:i=s=t*m,h=.5*S-.5*t-t*m*.5,o=.5*(t-t*m);break;case a[0]:case a[2]:r&&(o=0,this.shape===a[2]&&(h=.5*S-.5*s));break;case a[3]:case a[4]:i=.95*t,s=.28*i,r?(h=0,o=.5*S-.5*s):(h=.5*S-i,o=.5*-s),k=this.shape===a[4]?.6:0}b=f(l(u("group",this.vml),{width:S,height:S,rotation:c}),{coordsize:S+","+S,coordorigin:.5*-S+","+.5*-S}),g=l(u(y,b,{stroked:!1,arcSize:k}),{width:i,height:s,top:o,left:h}),M=u("fill",g,{color:this.color,opacity:m}),++C}}this.tick(!0)},s.clean=function(){if(e===n[0])this.con.clearRect(0,0,1e3,1e3);else{var t=this.vml;if(t.hasChildNodes())for(;t.childNodes.length>=1;)t.removeChild(t.firstChild)}},s.redraw=function(){this.clean(),this.draw()},s.reset=function(){"number"==typeof this.timer&&(this.hide(),this.show())},s.tick=function(t){var i=this.con,s=this.diameter;t||(this.activeId+=360/this.density*this.speed),e===n[0]?(i.clearRect(0,0,s,s),p(i,.5*s,.5*s,this.activeId/180*Math.PI),i.drawImage(this.cCan,0,0,s,s),i.restore()):(this.activeId>=360&&(this.activeId-=360),l(this.vml,{rotation:this.activeId}))},s.show=function(){if("number"!=typeof this.timer){var t=this;this.timer=self.setInterval(function(){t.tick()},Math.round(1e3/this.fps)),l(this.cont,{display:"block"})}},s.hide=function(){"number"==typeof this.timer&&(clearInterval(this.timer),delete this.timer,l(this.cont,{display:"none"}))},s.kill=function(){var t=this.cont;"number"==typeof this.timer&&this.hide(),e===n[0]?(t.removeChild(this.can),t.removeChild(this.cCan)):t.removeChild(this.vml);var i;for(i in this)delete this[i]},t.CanvasLoader=i}(window);
!function(e,t){function n(e,t,n){return e.addEventListener?void e.addEventListener(t,n,!1):void e.attachEvent("on"+t,n)}function r(e){if("keypress"==e.type){var t=String.fromCharCode(e.which);return e.shiftKey||(t=t.toLowerCase()),t}return K[e.which]?K[e.which]:q[e.which]?q[e.which]:String.fromCharCode(e.which).toLowerCase()}function o(e,t){return e.sort().join(",")===t.sort().join(",")}function i(e){e=e||{};var t,n=!1;for(t in M)e[t]?n=!0:M[t]=0;n||(j=!1)}function a(e,t,n,r,i,a){var c,u,s=[],f=n.type;if(!L[e])return[];for("keyup"==f&&h(e)&&(t=[e]),c=0;c<L[e].length;++c)if(u=L[e][c],(r||!u.seq||M[u.seq]==u.level)&&f==u.action&&("keypress"==f&&!n.metaKey&&!n.ctrlKey||o(t,u.modifiers))){var l=!r&&u.combo==i,p=r&&u.seq==r&&u.level==a;(l||p)&&L[e].splice(c,1),s.push(u)}return s}function c(e){var t=[];return e.shiftKey&&t.push("shift"),e.altKey&&t.push("alt"),e.ctrlKey&&t.push("ctrl"),e.metaKey&&t.push("meta"),t}function u(e){return e.preventDefault?void e.preventDefault():void(e.returnValue=!1)}function s(e){return e.stopPropagation?void e.stopPropagation():void(e.cancelBubble=!0)}function f(e,t,n,r){D.stopCallback(t,t.target||t.srcElement,n,r)||e(t,n)===!1&&(u(t),s(t))}function l(e,t,n){var r,o=a(e,t,n),c={},u=0,s=!1;for(r=0;r<o.length;++r)o[r].seq&&(u=Math.max(u,o[r].level));for(r=0;r<o.length;++r)if(o[r].seq){if(o[r].level!=u)continue;s=!0,c[o[r].seq]=1,f(o[r].callback,n,o[r].combo,o[r].seq)}else s||f(o[r].callback,n,o[r].combo);var l="keypress"==n.type&&S;n.type!=j||h(e)||l||i(c),S=s&&"keydown"==n.type}function p(e){"number"!=typeof e.which&&(e.which=e.keyCode);var t=r(e);if(t)return"keyup"==e.type&&N===t?void(N=!1):void D.handleKey(t,c(e),e)}function h(e){return"shift"==e||"ctrl"==e||"alt"==e||"meta"==e}function d(){clearTimeout(E),E=setTimeout(i,1e3)}function y(){if(!C){C={};for(var e in K)e>95&&112>e||K.hasOwnProperty(e)&&(C[K[e]]=e)}return C}function v(e,t,n){return n||(n=y()[e]?"keydown":"keypress"),"keypress"==n&&t.length&&(n="keydown"),n}function m(e,t,n,o){function a(t){return function(){j=t,++M[e],d()}}function c(t){f(n,t,e),"keyup"!==o&&(N=r(t)),setTimeout(i,10)}M[e]=0;for(var u=0;u<t.length;++u){var s=u+1===t.length,l=s?c:a(o||g(t[u+1]).action);b(t[u],l,o,e,u)}}function k(e){return"+"===e?["+"]:e.split("+")}function g(e,t){var n,r,o,i=[];for(n=k(e),o=0;o<n.length;++o)r=n[o],T[r]&&(r=T[r]),t&&"keypress"!=t&&P[r]&&(r=P[r],i.push("shift")),h(r)&&i.push(r);return t=v(r,i,t),{key:r,modifiers:i,action:t}}function b(e,t,n,r,o){A[e+":"+n]=t,e=e.replace(/\s+/g," ");var i,c=e.split(" ");return c.length>1?void m(e,c,t,n):(i=g(e,n),L[i.key]=L[i.key]||[],a(i.key,i.modifiers,{type:i.action},r,e,o),void L[i.key][r?"unshift":"push"]({callback:t,modifiers:i.modifiers,action:i.action,seq:r,level:o,combo:e}))}function w(e,t,n){for(var r=0;r<e.length;++r)b(e[r],t,n)}for(var C,E,K={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},q={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},P={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},T={option:"alt",command:"meta","return":"enter",escape:"esc",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},L={},A={},M={},N=!1,S=!1,j=!1,x=1;20>x;++x)K[111+x]="f"+x;for(x=0;9>=x;++x)K[x+96]=x;n(t,"keypress",p),n(t,"keydown",p),n(t,"keyup",p);var D={bindings:function(){return L},bind:function(e,t,n){return e=e instanceof Array?e:[e],w(e,t,n),this},unbind:function(e,t){return D.bind(e,function(){},t)},trigger:function(e,t){return A[e+":"+t]&&A[e+":"+t]({},e),this},reset:function(){return L={},A={},this},stopCallback:function(e,t){var n=t.tagName.toUpperCase();return(" "+t.className+" ").indexOf(" mousetrap ")>-1?!1:"INPUT"==n||"SELECT"==n||"TEXTAREA"==n||t.isContentEditable},handleKey:l};e.Mousetrap=D,"function"==typeof define&&define.amd&&define(D)}(window,document);
Mousetrap=function(n){var a={},r=n.stopCallback;return n.stopCallback=function(n,t,o,e){return a[o]||a[e]?!1:r(n,t,o)},n.bindGlobal=function(r,t,o){if(n.bind(r,t,o),r instanceof Array)for(var e=0;e<r.length;e++)a[r[e]]=!0;else a[r]=!0},n}(Mousetrap);
(function(){function e(e){this.tokens=[],this.tokens.links={},this.options=e||a.defaults,this.rules=p.normal,this.options.gfm&&(this.rules=this.options.tables?p.tables:p.gfm)}function t(e,t){if(this.options=t||a.defaults,this.links=e,this.rules=u.normal,this.renderer=this.options.renderer||new n,this.renderer.options=this.options,!this.links)throw new Error("Tokens array requires a `links` property.");this.options.gfm?this.rules=this.options.breaks?u.breaks:u.gfm:this.options.pedantic&&(this.rules=u.pedantic)}function n(e){this.options=e||{}}function r(e){this.tokens=[],this.token=null,this.options=e||a.defaults,this.options.renderer=this.options.renderer||new n,this.renderer=this.options.renderer,this.renderer.options=this.options}function s(e,t){return e.replace(t?/&/g:/&(?!#?\w+;)/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function i(e){return e.replace(/&([#\w]+);/g,function(e,t){return t=t.toLowerCase(),"colon"===t?":":"#"===t.charAt(0)?String.fromCharCode("x"===t.charAt(1)?parseInt(t.substring(2),16):+t.substring(1)):""})}function l(e,t){return e=e.source,t=t||"",function n(r,s){return r?(s=s.source||s,s=s.replace(/(^|[^\[])\^/g,"$1"),e=e.replace(r,s),n):new RegExp(e,t)}}function o(){}function h(e){for(var t,n,r=1;r<arguments.length;r++){t=arguments[r];for(n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}function a(t,n,i){if(i||"function"==typeof n){i||(i=n,n=null),n=h({},a.defaults,n||{});var l,o,p=n.highlight,u=0;try{l=e.lex(t,n)}catch(c){return i(c)}o=l.length;var g=function(){var e,t;try{e=r.parse(l,n)}catch(s){t=s}return n.highlight=p,t?i(t):i(null,e)};if(!p||p.length<3)return g();if(delete n.highlight,!o)return g();for(;u<l.length;u++)!function(e){return"code"!==e.type?--o||g():p(e.text,e.lang,function(t,n){return null==n||n===e.text?--o||g():(e.text=n,e.escaped=!0,void(--o||g()))})}(l[u])}else try{return n&&(n=h({},a.defaults,n)),r.parse(e.lex(t,n),n)}catch(c){if(c.message+="\nPlease report this to https://github.com/chjj/marked.",(n||a.defaults).silent)return"<p>An error occured:</p><pre>"+s(c.message+"",!0)+"</pre>";throw c}}var p={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:o,hr:/^( *[-*_]){3,} *(?:\n+|$)/,heading:/^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,nptable:o,lheading:/^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,blockquote:/^( *>[^\n]+(\n[^\n]+)*\n*)+/,list:/^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,html:/^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/,def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,table:o,paragraph:/^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,text:/^[^\n]+/};p.bullet=/(?:[*+-]|\d+\.)/,p.item=/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/,p.item=l(p.item,"gm")(/bull/g,p.bullet)(),p.list=l(p.list)(/bull/g,p.bullet)("hr",/\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)(),p._tag="(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b",p.html=l(p.html)("comment",/<!--[\s\S]*?-->/)("closed",/<(tag)[\s\S]+?<\/\1>/)("closing",/<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g,p._tag)(),p.paragraph=l(p.paragraph)("hr",p.hr)("heading",p.heading)("lheading",p.lheading)("blockquote",p.blockquote)("tag","<"+p._tag)("def",p.def)(),p.normal=h({},p),p.gfm=h({},p.normal,{fences:/^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,paragraph:/^/}),p.gfm.paragraph=l(p.paragraph)("(?!","(?!"+p.gfm.fences.source.replace("\\1","\\2")+"|"+p.list.source.replace("\\1","\\3")+"|")(),p.tables=h({},p.gfm,{nptable:/^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,table:/^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/}),e.rules=p,e.lex=function(t,n){var r=new e(n);return r.lex(t)},e.prototype.lex=function(e){return e=e.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g,"\n"),this.token(e,!0)},e.prototype.token=function(e,t){for(var n,r,s,i,l,o,h,a,u,e=e.replace(/^ +$/gm,"");e;)if((s=this.rules.newline.exec(e))&&(e=e.substring(s[0].length),s[0].length>1&&this.tokens.push({type:"space"})),s=this.rules.code.exec(e))e=e.substring(s[0].length),s=s[0].replace(/^ {4}/gm,""),this.tokens.push({type:"code",text:this.options.pedantic?s:s.replace(/\n+$/,"")});else if(s=this.rules.fences.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"code",lang:s[2],text:s[3]});else if(s=this.rules.heading.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"heading",depth:s[1].length,text:s[2]});else if(t&&(s=this.rules.nptable.exec(e))){for(e=e.substring(s[0].length),o={type:"table",header:s[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:s[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:s[3].replace(/\n$/,"").split("\n")},a=0;a<o.align.length;a++)o.align[a]=/^ *-+: *$/.test(o.align[a])?"right":/^ *:-+: *$/.test(o.align[a])?"center":/^ *:-+ *$/.test(o.align[a])?"left":null;for(a=0;a<o.cells.length;a++)o.cells[a]=o.cells[a].split(/ *\| */);this.tokens.push(o)}else if(s=this.rules.lheading.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"heading",depth:"="===s[2]?1:2,text:s[1]});else if(s=this.rules.hr.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"hr"});else if(s=this.rules.blockquote.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"blockquote_start"}),s=s[0].replace(/^ *> ?/gm,""),this.token(s,t),this.tokens.push({type:"blockquote_end"});else if(s=this.rules.list.exec(e)){for(e=e.substring(s[0].length),i=s[2],this.tokens.push({type:"list_start",ordered:i.length>1}),s=s[0].match(this.rules.item),n=!1,u=s.length,a=0;u>a;a++)o=s[a],h=o.length,o=o.replace(/^ *([*+-]|\d+\.) +/,""),~o.indexOf("\n ")&&(h-=o.length,o=this.options.pedantic?o.replace(/^ {1,4}/gm,""):o.replace(new RegExp("^ {1,"+h+"}","gm"),"")),this.options.smartLists&&a!==u-1&&(l=p.bullet.exec(s[a+1])[0],i===l||i.length>1&&l.length>1||(e=s.slice(a+1).join("\n")+e,a=u-1)),r=n||/\n\n(?!\s*$)/.test(o),a!==u-1&&(n="\n"===o.charAt(o.length-1),r||(r=n)),this.tokens.push({type:r?"loose_item_start":"list_item_start"}),this.token(o,!1),this.tokens.push({type:"list_item_end"});this.tokens.push({type:"list_end"})}else if(s=this.rules.html.exec(e))e=e.substring(s[0].length),this.tokens.push({type:this.options.sanitize?"paragraph":"html",pre:"pre"===s[1]||"script"===s[1]||"style"===s[1],text:s[0]});else if(t&&(s=this.rules.def.exec(e)))e=e.substring(s[0].length),this.tokens.links[s[1].toLowerCase()]={href:s[2],title:s[3]};else if(t&&(s=this.rules.table.exec(e))){for(e=e.substring(s[0].length),o={type:"table",header:s[1].replace(/^ *| *\| *$/g,"").split(/ *\| */),align:s[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:s[3].replace(/(?: *\| *)?\n$/,"").split("\n")},a=0;a<o.align.length;a++)o.align[a]=/^ *-+: *$/.test(o.align[a])?"right":/^ *:-+: *$/.test(o.align[a])?"center":/^ *:-+ *$/.test(o.align[a])?"left":null;for(a=0;a<o.cells.length;a++)o.cells[a]=o.cells[a].replace(/^ *\| *| *\| *$/g,"").split(/ *\| */);this.tokens.push(o)}else if(t&&(s=this.rules.paragraph.exec(e)))e=e.substring(s[0].length),this.tokens.push({type:"paragraph",text:"\n"===s[1].charAt(s[1].length-1)?s[1].slice(0,-1):s[1]});else if(s=this.rules.text.exec(e))e=e.substring(s[0].length),this.tokens.push({type:"text",text:s[0]});else if(e)throw new Error("Infinite loop on byte: "+e.charCodeAt(0));return this.tokens};var u={escape:/^\\([\\`*{}\[\]()#+\-.!_>])/,autolink:/^<([^ >]+(@|:\/)[^ >]+)>/,url:o,tag:/^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,link:/^!?\[(inside)\]\(href\)/,reflink:/^!?\[(inside)\]\s*\[([^\]]*)\]/,nolink:/^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,strong:/^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,em:/^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,code:/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,br:/^ {2,}\n(?!\s*$)/,del:o,text:/^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/};u._inside=/(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/,u._href=/\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/,u.link=l(u.link)("inside",u._inside)("href",u._href)(),u.reflink=l(u.reflink)("inside",u._inside)(),u.normal=h({},u),u.pedantic=h({},u.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/}),u.gfm=h({},u.normal,{escape:l(u.escape)("])","~|])")(),url:/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,del:/^~~(?=\S)([\s\S]*?\S)~~/,text:l(u.text)("]|","~]|")("|","|https?://|")()}),u.breaks=h({},u.gfm,{br:l(u.br)("{2,}","*")(),text:l(u.gfm.text)("{2,}","*")()}),t.rules=u,t.output=function(e,n,r){var s=new t(n,r);return s.output(e)},t.prototype.output=function(e){for(var t,n,r,i,l="";e;)if(i=this.rules.escape.exec(e))e=e.substring(i[0].length),l+=i[1];else if(i=this.rules.autolink.exec(e))e=e.substring(i[0].length),"@"===i[2]?(n=this.mangle(":"===i[1].charAt(6)?i[1].substring(7):i[1]),r=this.mangle("mailto:")+n):(n=s(i[1]),r=n),l+=this.renderer.link(r,null,n);else if(i=this.rules.url.exec(e))e=e.substring(i[0].length),n=s(i[1]),r=n,l+=this.renderer.link(r,null,n);else if(i=this.rules.tag.exec(e))e=e.substring(i[0].length),l+=this.options.sanitize?s(i[0]):i[0];else if(i=this.rules.link.exec(e))e=e.substring(i[0].length),l+=this.outputLink(i,{href:i[2],title:i[3]});else if((i=this.rules.reflink.exec(e))||(i=this.rules.nolink.exec(e))){if(e=e.substring(i[0].length),t=(i[2]||i[1]).replace(/\s+/g," "),t=this.links[t.toLowerCase()],!t||!t.href){l+=i[0].charAt(0),e=i[0].substring(1)+e;continue}l+=this.outputLink(i,t)}else if(i=this.rules.strong.exec(e))e=e.substring(i[0].length),l+=this.renderer.strong(this.output(i[2]||i[1]));else if(i=this.rules.em.exec(e))e=e.substring(i[0].length),l+=this.renderer.em(this.output(i[2]||i[1]));else if(i=this.rules.code.exec(e))e=e.substring(i[0].length),l+=this.renderer.codespan(s(i[2],!0));else if(i=this.rules.br.exec(e))e=e.substring(i[0].length),l+=this.renderer.br();else if(i=this.rules.del.exec(e))e=e.substring(i[0].length),l+=this.renderer.del(this.output(i[1]));else if(i=this.rules.text.exec(e))e=e.substring(i[0].length),l+=s(this.smartypants(i[0]));else if(e)throw new Error("Infinite loop on byte: "+e.charCodeAt(0));return l},t.prototype.outputLink=function(e,t){var n=s(t.href),r=t.title?s(t.title):null;return"!"!==e[0].charAt(0)?this.renderer.link(n,r,this.output(e[1])):this.renderer.image(n,r,s(e[1]))},t.prototype.smartypants=function(e){return this.options.smartypants?e.replace(/--/g,"—").replace(/(^|[-\u2014/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…"):e},t.prototype.mangle=function(e){for(var t,n="",r=e.length,s=0;r>s;s++)t=e.charCodeAt(s),Math.random()>.5&&(t="x"+t.toString(16)),n+="&#"+t+";";return n},n.prototype.code=function(e,t,n){if(this.options.highlight){var r=this.options.highlight(e,t);null!=r&&r!==e&&(n=!0,e=r)}return t?'<pre><code class="'+this.options.langPrefix+s(t,!0)+'">'+(n?e:s(e,!0))+"\n</code></pre>\n":"<pre><code>"+(n?e:s(e,!0))+"\n</code></pre>"},n.prototype.blockquote=function(e){return"<blockquote>\n"+e+"</blockquote>\n"},n.prototype.html=function(e){return e},n.prototype.heading=function(e,t,n){return"<h"+t+' id="'+this.options.headerPrefix+n.toLowerCase().replace(/[^\w]+/g,"-")+'">'+e+"</h"+t+">\n"},n.prototype.hr=function(){return"<hr>\n"},n.prototype.list=function(e,t){var n=t?"ol":"ul";return"<"+n+">\n"+e+"</"+n+">\n"},n.prototype.listitem=function(e){return"<li>"+e+"</li>\n"},n.prototype.paragraph=function(e){return"<p>"+e+"</p>\n"},n.prototype.table=function(e,t){return"<table>\n<thead>\n"+e+"</thead>\n<tbody>\n"+t+"</tbody>\n</table>\n"},n.prototype.tablerow=function(e){return"<tr>\n"+e+"</tr>\n"},n.prototype.tablecell=function(e,t){var n=t.header?"th":"td",r=t.align?"<"+n+' style="text-align:'+t.align+'">':"<"+n+">";return r+e+"</"+n+">\n"},n.prototype.strong=function(e){return"<strong>"+e+"</strong>"},n.prototype.em=function(e){return"<em>"+e+"</em>"},n.prototype.codespan=function(e){return"<code>"+e+"</code>"},n.prototype.br=function(){return"<br>"},n.prototype.del=function(e){return"<del>"+e+"</del>"},n.prototype.link=function(e,t,n){if(this.options.sanitize){try{var r=decodeURIComponent(i(e)).replace(/[^\w:]/g,"").toLowerCase()}catch(s){return""}if(0===r.indexOf("javascript:"))return""}var l='<a href="'+e+'"';return t&&(l+=' title="'+t+'"'),l+=">"+n+"</a>"},n.prototype.image=function(e,t,n){var r='<img src="'+e+'" alt="'+n+'"';return t&&(r+=' title="'+t+'"'),r+=">"},r.parse=function(e,t,n){var s=new r(t,n);return s.parse(e)},r.prototype.parse=function(e){this.inline=new t(e.links,this.options,this.renderer),this.tokens=e.reverse();for(var n="";this.next();)n+=this.tok();return n},r.prototype.next=function(){return this.token=this.tokens.pop()},r.prototype.peek=function(){return this.tokens[this.tokens.length-1]||0},r.prototype.parseText=function(){for(var e=this.token.text;"text"===this.peek().type;)e+="\n"+this.next().text;return this.inline.output(e)},r.prototype.tok=function(){switch(this.token.type){case"space":return"";case"hr":return this.renderer.hr();case"heading":return this.renderer.heading(this.inline.output(this.token.text),this.token.depth,this.token.text);case"code":return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case"table":var e,t,n,r,s,i="",l="";for(n="",e=0;e<this.token.header.length;e++)r={header:!0,align:this.token.align[e]},n+=this.renderer.tablecell(this.inline.output(this.token.header[e]),{header:!0,align:this.token.align[e]});for(i+=this.renderer.tablerow(n),e=0;e<this.token.cells.length;e++){for(t=this.token.cells[e],n="",s=0;s<t.length;s++)n+=this.renderer.tablecell(this.inline.output(t[s]),{header:!1,align:this.token.align[s]});l+=this.renderer.tablerow(n)}return this.renderer.table(i,l);case"blockquote_start":for(var l="";"blockquote_end"!==this.next().type;)l+=this.tok();return this.renderer.blockquote(l);case"list_start":for(var l="",o=this.token.ordered;"list_end"!==this.next().type;)l+=this.tok();return this.renderer.list(l,o);case"list_item_start":for(var l="";"list_item_end"!==this.next().type;)l+="text"===this.token.type?this.parseText():this.tok();return this.renderer.listitem(l);case"loose_item_start":for(var l="";"list_item_end"!==this.next().type;)l+=this.tok();return this.renderer.listitem(l);case"html":var h=this.token.pre||this.options.pedantic?this.token.text:this.inline.output(this.token.text);return this.renderer.html(h);case"paragraph":return this.renderer.paragraph(this.inline.output(this.token.text));case"text":return this.renderer.paragraph(this.parseText())}},o.exec=o,a.options=a.setOptions=function(e){return h(a.defaults,e),a},a.defaults={gfm:!0,tables:!0,breaks:!1,pedantic:!1,sanitize:!1,smartLists:!1,silent:!1,highlight:null,langPrefix:"lang-",smartypants:!1,headerPrefix:"",renderer:new n},a.Parser=r,a.parser=r.parse,a.Renderer=n,a.Lexer=e,a.lexer=e.lex,a.InlineLexer=t,a.inlineLexer=t.output,a.parse=a,"object"==typeof exports?module.exports=a:"function"==typeof define&&define.amd?define(function(){return a}):this.marked=a}).call(function(){return this||("undefined"!=typeof window?window:global)}());
(function(){var t=Array.prototype.slice;this.JsPath=function(){function n(t,e){return n.setAt({},t,e||{})}var e;return e=/^(string|number|boolean)$/,["forEach","indexOf","join","pop","reverse","shift","sort","splice","unshift","push"].forEach(function(e){return n[e+"At"]=function(){var r,i,o,s;if(r=arguments[0],i=arguments[1],o=3<=arguments.length?t.call(arguments,2):[],s=n.getAt(r,i),"function"==typeof(null!=s?s[e]:void 0))return s[e].apply(s,o);throw new Error("Does not implement method "+e+" at "+i)}}),n.getAt=function(t,n){var e;for(n="function"==typeof n.split?n.split("."):n.slice();null!=t&&(e=n.shift());)t=t[e];return t},n.setAt=function(t,n,r){var i,o,s,f;for(n="function"==typeof n.split?n.split("."):n.slice(),o=n.pop(),s=[],f=t;i=n.shift();){if(e.test(typeof f[i]))throw new Error(""+s.concat(i).join(".")+" is\nprimitive, and cannot be extended.");f=f[i]||(f[i]={}),s.push(i)}return f[o]=r,t},n.assureAt=function(t,n,e){var r;return(r=this.getAt(t,n))?r:(this.setAt(t,n,e),e)},n.deleteAt=function(t,n){var r,i,o;for(n="function"==typeof n.split?n.split("."):n.slice(),o=[],i=n.pop();r=n.shift();){if(e.test(typeof t[r]))throw new Error(""+o.concat(r).join(".")+" is\nprimitive; cannot drill any deeper.");if(!(t=t[r]))return!1;o.push(r)}return delete t[i]},n}.call(this)}).call(this);
!function(t,e){"use strict";function n(){if(!i.READY){i.event.determineEventTypes();for(var t in i.gestures)i.gestures.hasOwnProperty(t)&&i.detection.register(i.gestures[t]);i.event.onTouch(i.DOCUMENT,i.EVENT_MOVE,i.detection.detect),i.event.onTouch(i.DOCUMENT,i.EVENT_END,i.detection.detect),i.READY=!0}}var i=function(t,e){return new i.Instance(t,e||{})};i.defaults={stop_browser_behavior:{userSelect:"none",touchAction:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},i.HAS_POINTEREVENTS=navigator.pointerEnabled||navigator.msPointerEnabled,i.HAS_TOUCHEVENTS="ontouchstart"in t,i.MOBILE_REGEX=/mobile|tablet|ip(ad|hone|od)|android/i,i.NO_MOUSEEVENTS=i.HAS_TOUCHEVENTS&&navigator.userAgent.match(i.MOBILE_REGEX),i.EVENT_TYPES={},i.DIRECTION_DOWN="down",i.DIRECTION_LEFT="left",i.DIRECTION_UP="up",i.DIRECTION_RIGHT="right",i.POINTER_MOUSE="mouse",i.POINTER_TOUCH="touch",i.POINTER_PEN="pen",i.EVENT_START="start",i.EVENT_MOVE="move",i.EVENT_END="end",i.DOCUMENT=document,i.plugins={},i.READY=!1,i.Instance=function(t,e){var r=this;return n(),this.element=t,this.enabled=!0,this.options=i.utils.extend(i.utils.extend({},i.defaults),e||{}),this.options.stop_browser_behavior&&i.utils.stopDefaultBrowserBehavior(this.element,this.options.stop_browser_behavior),i.event.onTouch(t,i.EVENT_START,function(t){r.enabled&&i.detection.startDetect(r,t)}),this},i.Instance.prototype={on:function(t,e){for(var n=t.split(" "),i=0;i<n.length;i++)this.element.addEventListener(n[i],e,!1);return this},off:function(t,e){for(var n=t.split(" "),i=0;i<n.length;i++)this.element.removeEventListener(n[i],e,!1);return this},trigger:function(t,e){var n=i.DOCUMENT.createEvent("Event");n.initEvent(t,!0,!0),n.gesture=e;var r=this.element;return i.utils.hasParent(e.target,r)&&(r=e.target),r.dispatchEvent(n),this},enable:function(t){return this.enabled=t,this}};var r=null,o=!1,s=!1;i.event={bindDom:function(t,e,n){for(var i=e.split(" "),r=0;r<i.length;r++)t.addEventListener(i[r],n,!1)},onTouch:function(t,e,n){var a=this;this.bindDom(t,i.EVENT_TYPES[e],function(c){var u=c.type.toLowerCase();if(!u.match(/mouse/)||!s){(u.match(/touch/)||u.match(/pointerdown/)||u.match(/mouse/)&&1===c.which)&&(o=!0),u.match(/touch|pointer/)&&(s=!0);var h=0;o&&(i.HAS_POINTEREVENTS&&e!=i.EVENT_END?h=i.PointerEvent.updatePointer(e,c):u.match(/touch/)?h=c.touches.length:s||(h=u.match(/up/)?0:1),h>0&&e==i.EVENT_END?e=i.EVENT_MOVE:h||(e=i.EVENT_END),h||null===r?r=c:c=r,n.call(i.detection,a.collectEventData(t,e,c)),i.HAS_POINTEREVENTS&&e==i.EVENT_END&&(h=i.PointerEvent.updatePointer(e,c))),h||(r=null,o=!1,s=!1,i.PointerEvent.reset())}})},determineEventTypes:function(){var t;t=i.HAS_POINTEREVENTS?i.PointerEvent.getEvents():i.NO_MOUSEEVENTS?["touchstart","touchmove","touchend touchcancel"]:["touchstart mousedown","touchmove mousemove","touchend touchcancel mouseup"],i.EVENT_TYPES[i.EVENT_START]=t[0],i.EVENT_TYPES[i.EVENT_MOVE]=t[1],i.EVENT_TYPES[i.EVENT_END]=t[2]},getTouchList:function(t){return i.HAS_POINTEREVENTS?i.PointerEvent.getTouchList():t.touches?t.touches:[{identifier:1,pageX:t.pageX,pageY:t.pageY,target:t.target}]},collectEventData:function(t,e,n){var r=this.getTouchList(n,e),o=i.POINTER_TOUCH;return(n.type.match(/mouse/)||i.PointerEvent.matchType(i.POINTER_MOUSE,n))&&(o=i.POINTER_MOUSE),{center:i.utils.getCenter(r),timeStamp:(new Date).getTime(),target:n.target,touches:r,eventType:e,pointerType:o,srcEvent:n,preventDefault:function(){this.srcEvent.preventManipulation&&this.srcEvent.preventManipulation(),this.srcEvent.preventDefault&&this.srcEvent.preventDefault()},stopPropagation:function(){this.srcEvent.stopPropagation()},stopDetect:function(){return i.detection.stopDetect()}}}},i.PointerEvent={pointers:{},getTouchList:function(){var t=this,e=[];return Object.keys(t.pointers).sort().forEach(function(n){e.push(t.pointers[n])}),e},updatePointer:function(t,e){return t==i.EVENT_END?this.pointers={}:(e.identifier=e.pointerId,this.pointers[e.pointerId]=e),Object.keys(this.pointers).length},matchType:function(t,e){if(!e.pointerType)return!1;var n={};return n[i.POINTER_MOUSE]=e.pointerType==e.MSPOINTER_TYPE_MOUSE||e.pointerType==i.POINTER_MOUSE,n[i.POINTER_TOUCH]=e.pointerType==e.MSPOINTER_TYPE_TOUCH||e.pointerType==i.POINTER_TOUCH,n[i.POINTER_PEN]=e.pointerType==e.MSPOINTER_TYPE_PEN||e.pointerType==i.POINTER_PEN,n[t]},getEvents:function(){return["pointerdown MSPointerDown","pointermove MSPointerMove","pointerup pointercancel MSPointerUp MSPointerCancel"]},reset:function(){this.pointers={}}},i.utils={extend:function(t,n,i){for(var r in n)t[r]!==e&&i||(t[r]=n[r]);return t},hasParent:function(t,e){for(;t;){if(t==e)return!0;t=t.parentNode}return!1},getCenter:function(t){for(var e=[],n=[],i=0,r=t.length;r>i;i++)e.push(t[i].pageX),n.push(t[i].pageY);return{pageX:(Math.min.apply(Math,e)+Math.max.apply(Math,e))/2,pageY:(Math.min.apply(Math,n)+Math.max.apply(Math,n))/2}},getVelocity:function(t,e,n){return{x:Math.abs(e/t)||0,y:Math.abs(n/t)||0}},getAngle:function(t,e){var n=e.pageY-t.pageY,i=e.pageX-t.pageX;return 180*Math.atan2(n,i)/Math.PI},getDirection:function(t,e){var n=Math.abs(t.pageX-e.pageX),r=Math.abs(t.pageY-e.pageY);return n>=r?t.pageX-e.pageX>0?i.DIRECTION_LEFT:i.DIRECTION_RIGHT:t.pageY-e.pageY>0?i.DIRECTION_UP:i.DIRECTION_DOWN},getDistance:function(t,e){var n=e.pageX-t.pageX,i=e.pageY-t.pageY;return Math.sqrt(n*n+i*i)},getScale:function(t,e){return t.length>=2&&e.length>=2?this.getDistance(e[0],e[1])/this.getDistance(t[0],t[1]):1},getRotation:function(t,e){return t.length>=2&&e.length>=2?this.getAngle(e[1],e[0])-this.getAngle(t[1],t[0]):0},isVertical:function(t){return t==i.DIRECTION_UP||t==i.DIRECTION_DOWN},stopDefaultBrowserBehavior:function(t,e){var n,i=["webkit","khtml","moz","ms","o",""];if(e&&t.style){for(var r=0;r<i.length;r++)for(var o in e)e.hasOwnProperty(o)&&(n=o,i[r]&&(n=i[r]+n.substring(0,1).toUpperCase()+n.substring(1)),t.style[n]=e[o]);"none"==e.userSelect&&(t.onselectstart=function(){return!1})}}},i.detection={gestures:[],current:null,previous:null,stopped:!1,startDetect:function(t,e){this.current||(this.stopped=!1,this.current={inst:t,startEvent:i.utils.extend({},e),lastEvent:!1,name:""},this.detect(e))},detect:function(t){if(this.current&&!this.stopped){t=this.extendEventData(t);for(var e=this.current.inst.options,n=0,r=this.gestures.length;r>n;n++){var o=this.gestures[n];if(!this.stopped&&e[o.name]!==!1&&o.handler.call(o,t,this.current.inst)===!1){this.stopDetect();break}}return this.current&&(this.current.lastEvent=t),t.eventType==i.EVENT_END&&!t.touches.length-1&&this.stopDetect(),t}},stopDetect:function(){this.previous=i.utils.extend({},this.current),this.current=null,this.stopped=!0},extendEventData:function(t){var e=this.current.startEvent;if(e&&(t.touches.length!=e.touches.length||t.touches===e.touches)){e.touches=[];for(var n=0,r=t.touches.length;r>n;n++)e.touches.push(i.utils.extend({},t.touches[n]))}var o=t.timeStamp-e.timeStamp,s=t.center.pageX-e.center.pageX,a=t.center.pageY-e.center.pageY,c=i.utils.getVelocity(o,s,a);return i.utils.extend(t,{deltaTime:o,deltaX:s,deltaY:a,velocityX:c.x,velocityY:c.y,distance:i.utils.getDistance(e.center,t.center),angle:i.utils.getAngle(e.center,t.center),direction:i.utils.getDirection(e.center,t.center),scale:i.utils.getScale(e.touches,t.touches),rotation:i.utils.getRotation(e.touches,t.touches),startEvent:e}),t},register:function(t){var n=t.defaults||{};return n[t.name]===e&&(n[t.name]=!0),i.utils.extend(i.defaults,n,!0),t.index=t.index||1e3,this.gestures.push(t),this.gestures.sort(function(t,e){return t.index<e.index?-1:t.index>e.index?1:0}),this.gestures}},i.gestures=i.gestures||{},i.gestures.Hold={name:"hold",index:10,defaults:{hold_timeout:500,hold_threshold:1},timer:null,handler:function(t,e){switch(t.eventType){case i.EVENT_START:clearTimeout(this.timer),i.detection.current.name=this.name,this.timer=setTimeout(function(){"hold"==i.detection.current.name&&e.trigger("hold",t)},e.options.hold_timeout);break;case i.EVENT_MOVE:t.distance>e.options.hold_threshold&&clearTimeout(this.timer);break;case i.EVENT_END:clearTimeout(this.timer)}}},i.gestures.Tap={name:"tap",index:100,defaults:{tap_max_touchtime:250,tap_max_distance:10,tap_always:!0,doubletap_distance:20,doubletap_interval:300},handler:function(t,e){if(t.eventType==i.EVENT_END){var n=i.detection.previous,r=!1;if(t.deltaTime>e.options.tap_max_touchtime||t.distance>e.options.tap_max_distance)return;n&&"tap"==n.name&&t.timeStamp-n.lastEvent.timeStamp<e.options.doubletap_interval&&t.distance<e.options.doubletap_distance&&(e.trigger("doubletap",t),r=!0),(!r||e.options.tap_always)&&(i.detection.current.name="tap",e.trigger(i.detection.current.name,t))}}},i.gestures.Swipe={name:"swipe",index:40,defaults:{swipe_max_touches:1,swipe_velocity:.7},handler:function(t,e){if(t.eventType==i.EVENT_END){if(e.options.swipe_max_touches>0&&t.touches.length>e.options.swipe_max_touches)return;(t.velocityX>e.options.swipe_velocity||t.velocityY>e.options.swipe_velocity)&&(e.trigger(this.name,t),e.trigger(this.name+t.direction,t))}}},i.gestures.Drag={name:"drag",index:50,defaults:{drag_min_distance:10,drag_max_touches:1,drag_block_horizontal:!1,drag_block_vertical:!1,drag_lock_to_axis:!1,drag_lock_min_distance:25},triggered:!1,handler:function(t,e){if(i.detection.current.name!=this.name&&this.triggered)return e.trigger(this.name+"end",t),void(this.triggered=!1);if(!(e.options.drag_max_touches>0&&t.touches.length>e.options.drag_max_touches))switch(t.eventType){case i.EVENT_START:this.triggered=!1;break;case i.EVENT_MOVE:if(t.distance<e.options.drag_min_distance&&i.detection.current.name!=this.name)return;i.detection.current.name=this.name,(i.detection.current.lastEvent.drag_locked_to_axis||e.options.drag_lock_to_axis&&e.options.drag_lock_min_distance<=t.distance)&&(t.drag_locked_to_axis=!0);var n=i.detection.current.lastEvent.direction;t.drag_locked_to_axis&&n!==t.direction&&(t.direction=i.utils.isVertical(n)?t.deltaY<0?i.DIRECTION_UP:i.DIRECTION_DOWN:t.deltaX<0?i.DIRECTION_LEFT:i.DIRECTION_RIGHT),this.triggered||(e.trigger(this.name+"start",t),this.triggered=!0),e.trigger(this.name,t),e.trigger(this.name+t.direction,t),(e.options.drag_block_vertical&&i.utils.isVertical(t.direction)||e.options.drag_block_horizontal&&!i.utils.isVertical(t.direction))&&t.preventDefault();break;case i.EVENT_END:this.triggered&&e.trigger(this.name+"end",t),this.triggered=!1}}},i.gestures.Transform={name:"transform",index:45,defaults:{transform_min_scale:.01,transform_min_rotation:1,transform_always_block:!1},triggered:!1,handler:function(t,e){if(i.detection.current.name!=this.name&&this.triggered)return e.trigger(this.name+"end",t),void(this.triggered=!1);if(!(t.touches.length<2))switch(e.options.transform_always_block&&t.preventDefault(),t.eventType){case i.EVENT_START:this.triggered=!1;break;case i.EVENT_MOVE:var n=Math.abs(1-t.scale),r=Math.abs(t.rotation);if(n<e.options.transform_min_scale&&r<e.options.transform_min_rotation)return;i.detection.current.name=this.name,this.triggered||(e.trigger(this.name+"start",t),this.triggered=!0),e.trigger(this.name,t),r>e.options.transform_min_rotation&&e.trigger("rotate",t),n>e.options.transform_min_scale&&(e.trigger("pinch",t),e.trigger("pinch"+(t.scale<1?"in":"out"),t));break;case i.EVENT_END:this.triggered&&e.trigger(this.name+"end",t),this.triggered=!1}}},i.gestures.Touch={name:"touch",index:-1/0,defaults:{prevent_default:!1,prevent_mouseevents:!1},handler:function(t,e){return e.options.prevent_mouseevents&&t.pointerType==i.POINTER_MOUSE?void t.stopDetect():(e.options.prevent_default&&t.preventDefault(),void(t.eventType==i.EVENT_START&&e.trigger(this.name,t)))}},i.gestures.Release={name:"release",index:1/0,handler:function(t,e){t.eventType==i.EVENT_END&&e.trigger(this.name,t)}},"object"==typeof module&&"object"==typeof module.exports?module.exports=i:(t.Hammer=i,"function"==typeof t.define&&t.define.amd&&t.define("hammer",[],function(){return i}))}(this);
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var MutationObserverCtor;
if (typeof WebKitMutationObserver !== 'undefined')
    MutationObserverCtor = WebKitMutationObserver;
else
    MutationObserverCtor = MutationObserver;

if (MutationObserverCtor === undefined) {
    console.error('DOM Mutation Observers are required.');
    console.error('https://developer.mozilla.org/en-US/docs/DOM/MutationObserver');
    throw Error('DOM Mutation Observers are required');
}

var NodeMap = (function () {
    function NodeMap() {
        this.nodes = [];
        this.values = [];
    }
    NodeMap.prototype.isIndex = function (s) {
        return +s === s >>> 0;
    };

    NodeMap.prototype.nodeId = function (node) {
        var id = node[NodeMap.ID_PROP];
        if (!id)
            id = node[NodeMap.ID_PROP] = NodeMap.nextId_++;
        return id;
    };

    NodeMap.prototype.set = function (node, value) {
        var id = this.nodeId(node);
        this.nodes[id] = node;
        this.values[id] = value;
    };

    NodeMap.prototype.get = function (node) {
        var id = this.nodeId(node);
        return this.values[id];
    };

    NodeMap.prototype.has = function (node) {
        return this.nodeId(node) in this.nodes;
    };

    NodeMap.prototype.delete = function (node) {
        var id = this.nodeId(node);
        delete this.nodes[id];
        this.values[id] = undefined;
    };

    NodeMap.prototype.keys = function () {
        var nodes = [];
        for (var id in this.nodes) {
            if (!this.isIndex(id))
                continue;
            nodes.push(this.nodes[id]);
        }

        return nodes;
    };
    NodeMap.ID_PROP = '__mutation_summary_node_map_id__';
    NodeMap.nextId_ = 1;
    return NodeMap;
})();

/**
*  var reachableMatchableProduct = [
*  //  STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED
*    [ STAYED_OUT,  STAYED_OUT,  STAYED_OUT,  STAYED_OUT ], // STAYED_OUT
*    [ STAYED_OUT,  ENTERED,     ENTERED,     STAYED_OUT ], // ENTERED
*    [ STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED     ], // STAYED_IN
*    [ STAYED_OUT,  STAYED_OUT,  EXITED,      EXITED     ]  // EXITED
*  ];
*/
var Movement;
(function (Movement) {
    Movement[Movement["STAYED_OUT"] = 0] = "STAYED_OUT";
    Movement[Movement["ENTERED"] = 1] = "ENTERED";
    Movement[Movement["STAYED_IN"] = 2] = "STAYED_IN";
    Movement[Movement["REPARENTED"] = 3] = "REPARENTED";
    Movement[Movement["REORDERED"] = 4] = "REORDERED";
    Movement[Movement["EXITED"] = 5] = "EXITED";
})(Movement || (Movement = {}));

function enteredOrExited(changeType) {
    return changeType === 1 /* ENTERED */ || changeType === 5 /* EXITED */;
}

var NodeChange = (function () {
    function NodeChange(node, childList, attributes, characterData, oldParentNode, added, attributeOldValues, characterDataOldValue) {
        if (typeof childList === "undefined") { childList = false; }
        if (typeof attributes === "undefined") { attributes = false; }
        if (typeof characterData === "undefined") { characterData = false; }
        if (typeof oldParentNode === "undefined") { oldParentNode = null; }
        if (typeof added === "undefined") { added = false; }
        if (typeof attributeOldValues === "undefined") { attributeOldValues = null; }
        if (typeof characterDataOldValue === "undefined") { characterDataOldValue = null; }
        this.node = node;
        this.childList = childList;
        this.attributes = attributes;
        this.characterData = characterData;
        this.oldParentNode = oldParentNode;
        this.added = added;
        this.attributeOldValues = attributeOldValues;
        this.characterDataOldValue = characterDataOldValue;
        this.isCaseInsensitive = this.node.nodeType === Node.ELEMENT_NODE && this.node instanceof HTMLElement && this.node.ownerDocument instanceof HTMLDocument;
    }
    NodeChange.prototype.getAttributeOldValue = function (name) {
        if (!this.attributeOldValues)
            return undefined;
        if (this.isCaseInsensitive)
            name = name.toLowerCase();
        return this.attributeOldValues[name];
    };

    NodeChange.prototype.getAttributeNamesMutated = function () {
        var names = [];
        if (!this.attributeOldValues)
            return names;
        for (var name in this.attributeOldValues) {
            names.push(name);
        }
        return names;
    };

    NodeChange.prototype.attributeMutated = function (name, oldValue) {
        this.attributes = true;
        this.attributeOldValues = this.attributeOldValues || {};

        if (name in this.attributeOldValues)
            return;

        this.attributeOldValues[name] = oldValue;
    };

    NodeChange.prototype.characterDataMutated = function (oldValue) {
        if (this.characterData)
            return;
        this.characterData = true;
        this.characterDataOldValue = oldValue;
    };

    // Note: is it possible to receive a removal followed by a removal. This
    // can occur if the removed node is added to an non-observed node, that
    // node is added to the observed area, and then the node removed from
    // it.
    NodeChange.prototype.removedFromParent = function (parent) {
        this.childList = true;
        if (this.added || this.oldParentNode)
            this.added = false;
        else
            this.oldParentNode = parent;
    };

    NodeChange.prototype.insertedIntoParent = function () {
        this.childList = true;
        this.added = true;
    };

    // An node's oldParent is
    //   -its present parent, if its parentNode was not changed.
    //   -null if the first thing that happened to it was an add.
    //   -the node it was removed from if the first thing that happened to it
    //      was a remove.
    NodeChange.prototype.getOldParent = function () {
        if (this.childList) {
            if (this.oldParentNode)
                return this.oldParentNode;
            if (this.added)
                return null;
        }

        return this.node.parentNode;
    };
    return NodeChange;
})();

var ChildListChange = (function () {
    function ChildListChange() {
        this.added = new NodeMap();
        this.removed = new NodeMap();
        this.maybeMoved = new NodeMap();
        this.oldPrevious = new NodeMap();
        this.moved = undefined;
    }
    return ChildListChange;
})();

var TreeChanges = (function (_super) {
    __extends(TreeChanges, _super);
    function TreeChanges(rootNode, mutations) {
        _super.call(this);

        this.rootNode = rootNode;
        this.reachableCache = undefined;
        this.wasReachableCache = undefined;
        this.anyParentsChanged = false;
        this.anyAttributesChanged = false;
        this.anyCharacterDataChanged = false;

        for (var m = 0; m < mutations.length; m++) {
            var mutation = mutations[m];
            switch (mutation.type) {
                case 'childList':
                    this.anyParentsChanged = true;
                    for (var i = 0; i < mutation.removedNodes.length; i++) {
                        var node = mutation.removedNodes[i];
                        this.getChange(node).removedFromParent(mutation.target);
                    }
                    for (var i = 0; i < mutation.addedNodes.length; i++) {
                        var node = mutation.addedNodes[i];
                        this.getChange(node).insertedIntoParent();
                    }
                    break;

                case 'attributes':
                    this.anyAttributesChanged = true;
                    var change = this.getChange(mutation.target);
                    change.attributeMutated(mutation.attributeName, mutation.oldValue);
                    break;

                case 'characterData':
                    this.anyCharacterDataChanged = true;
                    var change = this.getChange(mutation.target);
                    change.characterDataMutated(mutation.oldValue);
                    break;
            }
        }
    }
    TreeChanges.prototype.getChange = function (node) {
        var change = this.get(node);
        if (!change) {
            change = new NodeChange(node);
            this.set(node, change);
        }
        return change;
    };

    TreeChanges.prototype.getOldParent = function (node) {
        var change = this.get(node);
        return change ? change.getOldParent() : node.parentNode;
    };

    TreeChanges.prototype.getIsReachable = function (node) {
        if (node === this.rootNode)
            return true;
        if (!node)
            return false;

        this.reachableCache = this.reachableCache || new NodeMap();
        var isReachable = this.reachableCache.get(node);
        if (isReachable === undefined) {
            isReachable = this.getIsReachable(node.parentNode);
            this.reachableCache.set(node, isReachable);
        }
        return isReachable;
    };

    // A node wasReachable if its oldParent wasReachable.
    TreeChanges.prototype.getWasReachable = function (node) {
        if (node === this.rootNode)
            return true;
        if (!node)
            return false;

        this.wasReachableCache = this.wasReachableCache || new NodeMap();
        var wasReachable = this.wasReachableCache.get(node);
        if (wasReachable === undefined) {
            wasReachable = this.getWasReachable(this.getOldParent(node));
            this.wasReachableCache.set(node, wasReachable);
        }
        return wasReachable;
    };

    TreeChanges.prototype.reachabilityChange = function (node) {
        if (this.getIsReachable(node)) {
            return this.getWasReachable(node) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;
        }

        return this.getWasReachable(node) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;
    };
    return TreeChanges;
})(NodeMap);

var MutationProjection = (function () {
    // TOOD(any)
    function MutationProjection(rootNode, mutations, selectors, calcReordered, calcOldPreviousSibling) {
        this.rootNode = rootNode;
        this.mutations = mutations;
        this.selectors = selectors;
        this.calcReordered = calcReordered;
        this.calcOldPreviousSibling = calcOldPreviousSibling;
        this.treeChanges = new TreeChanges(rootNode, mutations);
        this.entered = [];
        this.exited = [];
        this.stayedIn = new NodeMap();
        this.visited = new NodeMap();
        this.childListChangeMap = undefined;
        this.characterDataOnly = undefined;
        this.matchCache = undefined;

        this.processMutations();
    }
    MutationProjection.prototype.processMutations = function () {
        if (!this.treeChanges.anyParentsChanged && !this.treeChanges.anyAttributesChanged)
            return;

        var changedNodes = this.treeChanges.keys();
        for (var i = 0; i < changedNodes.length; i++) {
            this.visitNode(changedNodes[i], undefined);
        }
    };

    MutationProjection.prototype.visitNode = function (node, parentReachable) {
        if (this.visited.has(node))
            return;

        this.visited.set(node, true);

        var change = this.treeChanges.get(node);
        var reachable = parentReachable;

        // node inherits its parent's reachability change unless
        // its parentNode was mutated.
        if ((change && change.childList) || reachable == undefined)
            reachable = this.treeChanges.reachabilityChange(node);

        if (reachable === 0 /* STAYED_OUT */)
            return;

        // Cache match results for sub-patterns.
        this.matchabilityChange(node);

        if (reachable === 1 /* ENTERED */) {
            this.entered.push(node);
        } else if (reachable === 5 /* EXITED */) {
            this.exited.push(node);
            this.ensureHasOldPreviousSiblingIfNeeded(node);
        } else if (reachable === 2 /* STAYED_IN */) {
            var movement = 2 /* STAYED_IN */;

            if (change && change.childList) {
                if (change.oldParentNode !== node.parentNode) {
                    movement = 3 /* REPARENTED */;
                    this.ensureHasOldPreviousSiblingIfNeeded(node);
                } else if (this.calcReordered && this.wasReordered(node)) {
                    movement = 4 /* REORDERED */;
                }
            }

            this.stayedIn.set(node, movement);
        }

        if (reachable === 2 /* STAYED_IN */)
            return;

        for (var child = node.firstChild; child; child = child.nextSibling) {
            this.visitNode(child, reachable);
        }
    };

    MutationProjection.prototype.ensureHasOldPreviousSiblingIfNeeded = function (node) {
        if (!this.calcOldPreviousSibling)
            return;

        this.processChildlistChanges();

        var parentNode = node.parentNode;
        var nodeChange = this.treeChanges.get(node);
        if (nodeChange && nodeChange.oldParentNode)
            parentNode = nodeChange.oldParentNode;

        var change = this.childListChangeMap.get(parentNode);
        if (!change) {
            change = new ChildListChange();
            this.childListChangeMap.set(parentNode, change);
        }

        if (!change.oldPrevious.has(node)) {
            change.oldPrevious.set(node, node.previousSibling);
        }
    };

    MutationProjection.prototype.getChanged = function (summary, selectors, characterDataOnly) {
        this.selectors = selectors;
        this.characterDataOnly = characterDataOnly;

        for (var i = 0; i < this.entered.length; i++) {
            var node = this.entered[i];
            var matchable = this.matchabilityChange(node);
            if (matchable === 1 /* ENTERED */ || matchable === 2 /* STAYED_IN */)
                summary.added.push(node);
        }

        var stayedInNodes = this.stayedIn.keys();
        for (var i = 0; i < stayedInNodes.length; i++) {
            var node = stayedInNodes[i];
            var matchable = this.matchabilityChange(node);

            if (matchable === 1 /* ENTERED */) {
                summary.added.push(node);
            } else if (matchable === 5 /* EXITED */) {
                summary.removed.push(node);
            } else if (matchable === 2 /* STAYED_IN */ && (summary.reparented || summary.reordered)) {
                var movement = this.stayedIn.get(node);
                if (summary.reparented && movement === 3 /* REPARENTED */)
                    summary.reparented.push(node);
                else if (summary.reordered && movement === 4 /* REORDERED */)
                    summary.reordered.push(node);
            }
        }

        for (var i = 0; i < this.exited.length; i++) {
            var node = this.exited[i];
            var matchable = this.matchabilityChange(node);
            if (matchable === 5 /* EXITED */ || matchable === 2 /* STAYED_IN */)
                summary.removed.push(node);
        }
    };

    MutationProjection.prototype.getOldParentNode = function (node) {
        var change = this.treeChanges.get(node);
        if (change && change.childList)
            return change.oldParentNode ? change.oldParentNode : null;

        var reachabilityChange = this.treeChanges.reachabilityChange(node);
        if (reachabilityChange === 0 /* STAYED_OUT */ || reachabilityChange === 1 /* ENTERED */)
            throw Error('getOldParentNode requested on invalid node.');

        return node.parentNode;
    };

    MutationProjection.prototype.getOldPreviousSibling = function (node) {
        var parentNode = node.parentNode;
        var nodeChange = this.treeChanges.get(node);
        if (nodeChange && nodeChange.oldParentNode)
            parentNode = nodeChange.oldParentNode;

        var change = this.childListChangeMap.get(parentNode);
        if (!change)
            throw Error('getOldPreviousSibling requested on invalid node.');

        return change.oldPrevious.get(node);
    };

    MutationProjection.prototype.getOldAttribute = function (element, attrName) {
        var change = this.treeChanges.get(element);
        if (!change || !change.attributes)
            throw Error('getOldAttribute requested on invalid node.');

        var value = change.getAttributeOldValue(attrName);
        if (value === undefined)
            throw Error('getOldAttribute requested for unchanged attribute name.');

        return value;
    };

    MutationProjection.prototype.attributeChangedNodes = function (includeAttributes) {
        if (!this.treeChanges.anyAttributesChanged)
            return {};

        var attributeFilter;
        var caseInsensitiveFilter;
        if (includeAttributes) {
            attributeFilter = {};
            caseInsensitiveFilter = {};
            for (var i = 0; i < includeAttributes.length; i++) {
                var attrName = includeAttributes[i];
                attributeFilter[attrName] = true;
                caseInsensitiveFilter[attrName.toLowerCase()] = attrName;
            }
        }

        var result = {};
        var nodes = this.treeChanges.keys();

        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            var change = this.treeChanges.get(node);
            if (!change.attributes)
                continue;

            if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(node) || 2 /* STAYED_IN */ !== this.matchabilityChange(node)) {
                continue;
            }

            var element = node;
            var changedAttrNames = change.getAttributeNamesMutated();
            for (var j = 0; j < changedAttrNames.length; j++) {
                var attrName = changedAttrNames[j];

                if (attributeFilter && !attributeFilter[attrName] && !(change.isCaseInsensitive && caseInsensitiveFilter[attrName])) {
                    continue;
                }

                var oldValue = change.getAttributeOldValue(attrName);
                if (oldValue === element.getAttribute(attrName))
                    continue;

                if (caseInsensitiveFilter && change.isCaseInsensitive)
                    attrName = caseInsensitiveFilter[attrName];

                result[attrName] = result[attrName] || [];
                result[attrName].push(element);
            }
        }

        return result;
    };

    MutationProjection.prototype.getOldCharacterData = function (node) {
        var change = this.treeChanges.get(node);
        if (!change || !change.characterData)
            throw Error('getOldCharacterData requested on invalid node.');

        return change.characterDataOldValue;
    };

    MutationProjection.prototype.getCharacterDataChanged = function () {
        if (!this.treeChanges.anyCharacterDataChanged)
            return [];

        var nodes = this.treeChanges.keys();
        var result = [];
        for (var i = 0; i < nodes.length; i++) {
            var target = nodes[i];
            if (2 /* STAYED_IN */ !== this.treeChanges.reachabilityChange(target))
                continue;

            var change = this.treeChanges.get(target);
            if (!change.characterData || target.textContent == change.characterDataOldValue)
                continue;

            result.push(target);
        }

        return result;
    };

    MutationProjection.prototype.computeMatchabilityChange = function (selector, el) {
        if (!this.matchCache)
            this.matchCache = [];
        if (!this.matchCache[selector.uid])
            this.matchCache[selector.uid] = new NodeMap();

        var cache = this.matchCache[selector.uid];
        var result = cache.get(el);
        if (result === undefined) {
            result = selector.matchabilityChange(el, this.treeChanges.get(el));
            cache.set(el, result);
        }
        return result;
    };

    MutationProjection.prototype.matchabilityChange = function (node) {
        var _this = this;
        // TODO(rafaelw): Include PI, CDATA?
        // Only include text nodes.
        if (this.characterDataOnly) {
            switch (node.nodeType) {
                case Node.COMMENT_NODE:
                case Node.TEXT_NODE:
                    return 2 /* STAYED_IN */;
                default:
                    return 0 /* STAYED_OUT */;
            }
        }

        // No element filter. Include all nodes.
        if (!this.selectors)
            return 2 /* STAYED_IN */;

        // Element filter. Exclude non-elements.
        if (node.nodeType !== Node.ELEMENT_NODE)
            return 0 /* STAYED_OUT */;

        var el = node;

        var matchChanges = this.selectors.map(function (selector) {
            return _this.computeMatchabilityChange(selector, el);
        });

        var accum = 0 /* STAYED_OUT */;
        var i = 0;

        while (accum !== 2 /* STAYED_IN */ && i < matchChanges.length) {
            switch (matchChanges[i]) {
                case 2 /* STAYED_IN */:
                    accum = 2 /* STAYED_IN */;
                    break;
                case 1 /* ENTERED */:
                    if (accum === 5 /* EXITED */)
                        accum = 2 /* STAYED_IN */;
                    else
                        accum = 1 /* ENTERED */;
                    break;
                case 5 /* EXITED */:
                    if (accum === 1 /* ENTERED */)
                        accum = 2 /* STAYED_IN */;
                    else
                        accum = 5 /* EXITED */;
                    break;
            }

            i++;
        }

        return accum;
    };

    MutationProjection.prototype.getChildlistChange = function (el) {
        var change = this.childListChangeMap.get(el);
        if (!change) {
            change = new ChildListChange();
            this.childListChangeMap.set(el, change);
        }

        return change;
    };

    MutationProjection.prototype.processChildlistChanges = function () {
        if (this.childListChangeMap)
            return;

        this.childListChangeMap = new NodeMap();

        for (var i = 0; i < this.mutations.length; i++) {
            var mutation = this.mutations[i];
            if (mutation.type != 'childList')
                continue;

            if (this.treeChanges.reachabilityChange(mutation.target) !== 2 /* STAYED_IN */ && !this.calcOldPreviousSibling)
                continue;

            var change = this.getChildlistChange(mutation.target);

            var oldPrevious = mutation.previousSibling;

            function recordOldPrevious(node, previous) {
                if (!node || change.oldPrevious.has(node) || change.added.has(node) || change.maybeMoved.has(node))
                    return;

                if (previous && (change.added.has(previous) || change.maybeMoved.has(previous)))
                    return;

                change.oldPrevious.set(node, previous);
            }

            for (var j = 0; j < mutation.removedNodes.length; j++) {
                var node = mutation.removedNodes[j];
                recordOldPrevious(node, oldPrevious);

                if (change.added.has(node)) {
                    change.added.delete(node);
                } else {
                    change.removed.set(node, true);
                    change.maybeMoved.delete(node);
                }

                oldPrevious = node;
            }

            recordOldPrevious(mutation.nextSibling, oldPrevious);

            for (var j = 0; j < mutation.addedNodes.length; j++) {
                var node = mutation.addedNodes[j];
                if (change.removed.has(node)) {
                    change.removed.delete(node);
                    change.maybeMoved.set(node, true);
                } else {
                    change.added.set(node, true);
                }
            }
        }
    };

    MutationProjection.prototype.wasReordered = function (node) {
        if (!this.treeChanges.anyParentsChanged)
            return false;

        this.processChildlistChanges();

        var parentNode = node.parentNode;
        var nodeChange = this.treeChanges.get(node);
        if (nodeChange && nodeChange.oldParentNode)
            parentNode = nodeChange.oldParentNode;

        var change = this.childListChangeMap.get(parentNode);
        if (!change)
            return false;

        if (change.moved)
            return change.moved.get(node);

        change.moved = new NodeMap();
        var pendingMoveDecision = new NodeMap();

        function isMoved(node) {
            if (!node)
                return false;
            if (!change.maybeMoved.has(node))
                return false;

            var didMove = change.moved.get(node);
            if (didMove !== undefined)
                return didMove;

            if (pendingMoveDecision.has(node)) {
                didMove = true;
            } else {
                pendingMoveDecision.set(node, true);
                didMove = getPrevious(node) !== getOldPrevious(node);
            }

            if (pendingMoveDecision.has(node)) {
                pendingMoveDecision.delete(node);
                change.moved.set(node, didMove);
            } else {
                didMove = change.moved.get(node);
            }

            return didMove;
        }

        var oldPreviousCache = new NodeMap();
        function getOldPrevious(node) {
            var oldPrevious = oldPreviousCache.get(node);
            if (oldPrevious !== undefined)
                return oldPrevious;

            oldPrevious = change.oldPrevious.get(node);
            while (oldPrevious && (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {
                oldPrevious = getOldPrevious(oldPrevious);
            }

            if (oldPrevious === undefined)
                oldPrevious = node.previousSibling;
            oldPreviousCache.set(node, oldPrevious);

            return oldPrevious;
        }

        var previousCache = new NodeMap();
        function getPrevious(node) {
            if (previousCache.has(node))
                return previousCache.get(node);

            var previous = node.previousSibling;
            while (previous && (change.added.has(previous) || isMoved(previous)))
                previous = previous.previousSibling;

            previousCache.set(node, previous);
            return previous;
        }

        change.maybeMoved.keys().forEach(isMoved);
        return change.moved.get(node);
    };
    return MutationProjection;
})();

var Summary = (function () {
    function Summary(projection, query) {
        var _this = this;
        this.projection = projection;
        this.added = [];
        this.removed = [];
        this.reparented = query.all || query.element ? [] : undefined;
        this.reordered = query.all ? [] : undefined;

        projection.getChanged(this, query.elementFilter, query.characterData);

        if (query.all || query.attribute || query.attributeList) {
            var filter = query.attribute ? [query.attribute] : query.attributeList;
            var attributeChanged = projection.attributeChangedNodes(filter);

            if (query.attribute) {
                this.valueChanged = attributeChanged[query.attribute] || [];
            } else {
                this.attributeChanged = attributeChanged;
                if (query.attributeList) {
                    query.attributeList.forEach(function (attrName) {
                        if (!_this.attributeChanged.hasOwnProperty(attrName))
                            _this.attributeChanged[attrName] = [];
                    });
                }
            }
        }

        if (query.all || query.characterData) {
            var characterDataChanged = projection.getCharacterDataChanged();

            if (query.characterData)
                this.valueChanged = characterDataChanged;
            else
                this.characterDataChanged = characterDataChanged;
        }

        if (this.reordered)
            this.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);
    }
    Summary.prototype.getOldParentNode = function (node) {
        return this.projection.getOldParentNode(node);
    };

    Summary.prototype.getOldAttribute = function (node, name) {
        return this.projection.getOldAttribute(node, name);
    };

    Summary.prototype.getOldCharacterData = function (node) {
        return this.projection.getOldCharacterData(node);
    };

    Summary.prototype.getOldPreviousSibling = function (node) {
        return this.projection.getOldPreviousSibling(node);
    };
    return Summary;
})();

// TODO(rafaelw): Allow ':' and '.' as valid name characters.
var validNameInitialChar = /[a-zA-Z_]+/;
var validNameNonInitialChar = /[a-zA-Z0-9_\-]+/;

// TODO(rafaelw): Consider allowing backslash in the attrValue.
// TODO(rafaelw): There's got a to be way to represent this state machine
// more compactly???
function escapeQuotes(value) {
    return '"' + value.replace(/"/, '\\\"') + '"';
}

var Qualifier = (function () {
    function Qualifier() {
    }
    Qualifier.prototype.matches = function (oldValue) {
        if (oldValue === null)
            return false;

        if (this.attrValue === undefined)
            return true;

        if (!this.contains)
            return this.attrValue == oldValue;

        var tokens = oldValue.split(' ');
        for (var i = 0; i < tokens.length; i++) {
            if (this.attrValue === tokens[i])
                return true;
        }

        return false;
    };

    Qualifier.prototype.toString = function () {
        if (this.attrName === 'class' && this.contains)
            return '.' + this.attrValue;

        if (this.attrName === 'id' && !this.contains)
            return '#' + this.attrValue;

        if (this.contains)
            return '[' + this.attrName + '~=' + escapeQuotes(this.attrValue) + ']';

        if ('attrValue' in this)
            return '[' + this.attrName + '=' + escapeQuotes(this.attrValue) + ']';

        return '[' + this.attrName + ']';
    };
    return Qualifier;
})();

var Selector = (function () {
    function Selector() {
        this.uid = Selector.nextUid++;
        this.qualifiers = [];
    }
    Object.defineProperty(Selector.prototype, "caseInsensitiveTagName", {
        get: function () {
            return this.tagName.toUpperCase();
        },
        enumerable: true,
        configurable: true
    });

    Object.defineProperty(Selector.prototype, "selectorString", {
        get: function () {
            return this.tagName + this.qualifiers.join('');
        },
        enumerable: true,
        configurable: true
    });

    Selector.prototype.isMatching = function (el) {
        return el[Selector.matchesSelector](this.selectorString);
    };

    Selector.prototype.wasMatching = function (el, change, isMatching) {
        if (!change || !change.attributes)
            return isMatching;

        var tagName = change.isCaseInsensitive ? this.caseInsensitiveTagName : this.tagName;
        if (tagName !== '*' && tagName !== el.tagName)
            return false;

        var attributeOldValues = [];
        var anyChanged = false;
        for (var i = 0; i < this.qualifiers.length; i++) {
            var qualifier = this.qualifiers[i];
            var oldValue = change.getAttributeOldValue(qualifier.attrName);
            attributeOldValues.push(oldValue);
            anyChanged = anyChanged || (oldValue !== undefined);
        }

        if (!anyChanged)
            return isMatching;

        for (var i = 0; i < this.qualifiers.length; i++) {
            var qualifier = this.qualifiers[i];
            var oldValue = attributeOldValues[i];
            if (oldValue === undefined)
                oldValue = el.getAttribute(qualifier.attrName);
            if (!qualifier.matches(oldValue))
                return false;
        }

        return true;
    };

    Selector.prototype.matchabilityChange = function (el, change) {
        var isMatching = this.isMatching(el);
        if (isMatching)
            return this.wasMatching(el, change, isMatching) ? 2 /* STAYED_IN */ : 1 /* ENTERED */;
        else
            return this.wasMatching(el, change, isMatching) ? 5 /* EXITED */ : 0 /* STAYED_OUT */;
    };

    Selector.parseSelectors = function (input) {
        var selectors = [];
        var currentSelector;
        var currentQualifier;

        function newSelector() {
            if (currentSelector) {
                if (currentQualifier) {
                    currentSelector.qualifiers.push(currentQualifier);
                    currentQualifier = undefined;
                }

                selectors.push(currentSelector);
            }
            currentSelector = new Selector();
        }

        function newQualifier() {
            if (currentQualifier)
                currentSelector.qualifiers.push(currentQualifier);

            currentQualifier = new Qualifier();
        }

        var WHITESPACE = /\s/;
        var valueQuoteChar;
        var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';

        var SELECTOR = 1;
        var TAG_NAME = 2;
        var QUALIFIER = 3;
        var QUALIFIER_NAME_FIRST_CHAR = 4;
        var QUALIFIER_NAME = 5;
        var ATTR_NAME_FIRST_CHAR = 6;
        var ATTR_NAME = 7;
        var EQUIV_OR_ATTR_QUAL_END = 8;
        var EQUAL = 9;
        var ATTR_QUAL_END = 10;
        var VALUE_FIRST_CHAR = 11;
        var VALUE = 12;
        var QUOTED_VALUE = 13;
        var SELECTOR_SEPARATOR = 14;

        var state = SELECTOR;
        var i = 0;
        while (i < input.length) {
            var c = input[i++];

            switch (state) {
                case SELECTOR:
                    if (c.match(validNameInitialChar)) {
                        newSelector();
                        currentSelector.tagName = c;
                        state = TAG_NAME;
                        break;
                    }

                    if (c == '*') {
                        newSelector();
                        currentSelector.tagName = '*';
                        state = QUALIFIER;
                        break;
                    }

                    if (c == '.') {
                        newSelector();
                        newQualifier();
                        currentSelector.tagName = '*';
                        currentQualifier.attrName = 'class';
                        currentQualifier.contains = true;
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '#') {
                        newSelector();
                        newQualifier();
                        currentSelector.tagName = '*';
                        currentQualifier.attrName = 'id';
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '[') {
                        newSelector();
                        newQualifier();
                        currentSelector.tagName = '*';
                        currentQualifier.attrName = '';
                        state = ATTR_NAME_FIRST_CHAR;
                        break;
                    }

                    if (c.match(WHITESPACE))
                        break;

                    throw Error(SYNTAX_ERROR);

                case TAG_NAME:
                    if (c.match(validNameNonInitialChar)) {
                        currentSelector.tagName += c;
                        break;
                    }

                    if (c == '.') {
                        newQualifier();
                        currentQualifier.attrName = 'class';
                        currentQualifier.contains = true;
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '#') {
                        newQualifier();
                        currentQualifier.attrName = 'id';
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '[') {
                        newQualifier();
                        currentQualifier.attrName = '';
                        state = ATTR_NAME_FIRST_CHAR;
                        break;
                    }

                    if (c.match(WHITESPACE)) {
                        state = SELECTOR_SEPARATOR;
                        break;
                    }

                    if (c == ',') {
                        state = SELECTOR;
                        break;
                    }

                    throw Error(SYNTAX_ERROR);

                case QUALIFIER:
                    if (c == '.') {
                        newQualifier();
                        currentQualifier.attrName = 'class';
                        currentQualifier.contains = true;
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '#') {
                        newQualifier();
                        currentQualifier.attrName = 'id';
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '[') {
                        newQualifier();
                        currentQualifier.attrName = '';
                        state = ATTR_NAME_FIRST_CHAR;
                        break;
                    }

                    if (c.match(WHITESPACE)) {
                        state = SELECTOR_SEPARATOR;
                        break;
                    }

                    if (c == ',') {
                        state = SELECTOR;
                        break;
                    }

                    throw Error(SYNTAX_ERROR);

                case QUALIFIER_NAME_FIRST_CHAR:
                    if (c.match(validNameInitialChar)) {
                        currentQualifier.attrValue = c;
                        state = QUALIFIER_NAME;
                        break;
                    }

                    throw Error(SYNTAX_ERROR);

                case QUALIFIER_NAME:
                    if (c.match(validNameNonInitialChar)) {
                        currentQualifier.attrValue += c;
                        break;
                    }

                    if (c == '.') {
                        newQualifier();
                        currentQualifier.attrName = 'class';
                        currentQualifier.contains = true;
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '#') {
                        newQualifier();
                        currentQualifier.attrName = 'id';
                        state = QUALIFIER_NAME_FIRST_CHAR;
                        break;
                    }
                    if (c == '[') {
                        newQualifier();
                        state = ATTR_NAME_FIRST_CHAR;
                        break;
                    }

                    if (c.match(WHITESPACE)) {
                        state = SELECTOR_SEPARATOR;
                        break;
                    }
                    if (c == ',') {
                        state = SELECTOR;
                        break;
                    }

                    throw Error(SYNTAX_ERROR);

                case ATTR_NAME_FIRST_CHAR:
                    if (c.match(validNameInitialChar)) {
                        currentQualifier.attrName = c;
                        state = ATTR_NAME;
                        break;
                    }

                    if (c.match(WHITESPACE))
                        break;

                    throw Error(SYNTAX_ERROR);

                case ATTR_NAME:
                    if (c.match(validNameNonInitialChar)) {
                        currentQualifier.attrName += c;
                        break;
                    }

                    if (c.match(WHITESPACE)) {
                        state = EQUIV_OR_ATTR_QUAL_END;
                        break;
                    }

                    if (c == '~') {
                        currentQualifier.contains = true;
                        state = EQUAL;
                        break;
                    }

                    if (c == '=') {
                        currentQualifier.attrValue = '';
                        state = VALUE_FIRST_CHAR;
                        break;
                    }

                    if (c == ']') {
                        state = QUALIFIER;
                        break;
                    }

                    throw Error(SYNTAX_ERROR);

                case EQUIV_OR_ATTR_QUAL_END:
                    if (c == '~') {
                        currentQualifier.contains = true;
                        state = EQUAL;
                        break;
                    }

                    if (c == '=') {
                        currentQualifier.attrValue = '';
                        state = VALUE_FIRST_CHAR;
                        break;
                    }

                    if (c == ']') {
                        state = QUALIFIER;
                        break;
                    }

                    if (c.match(WHITESPACE))
                        break;

                    throw Error(SYNTAX_ERROR);

                case EQUAL:
                    if (c == '=') {
                        currentQualifier.attrValue = '';
                        state = VALUE_FIRST_CHAR;
                        break;
                    }

                    throw Error(SYNTAX_ERROR);

                case ATTR_QUAL_END:
                    if (c == ']') {
                        state = QUALIFIER;
                        break;
                    }

                    if (c.match(WHITESPACE))
                        break;

                    throw Error(SYNTAX_ERROR);

                case VALUE_FIRST_CHAR:
                    if (c.match(WHITESPACE))
                        break;

                    if (c == '"' || c == "'") {
                        valueQuoteChar = c;
                        state = QUOTED_VALUE;
                        break;
                    }

                    currentQualifier.attrValue += c;
                    state = VALUE;
                    break;

                case VALUE:
                    if (c.match(WHITESPACE)) {
                        state = ATTR_QUAL_END;
                        break;
                    }
                    if (c == ']') {
                        state = QUALIFIER;
                        break;
                    }
                    if (c == "'" || c == '"')
                        throw Error(SYNTAX_ERROR);

                    currentQualifier.attrValue += c;
                    break;

                case QUOTED_VALUE:
                    if (c == valueQuoteChar) {
                        state = ATTR_QUAL_END;
                        break;
                    }

                    currentQualifier.attrValue += c;
                    break;

                case SELECTOR_SEPARATOR:
                    if (c.match(WHITESPACE))
                        break;

                    if (c == ',') {
                        state = SELECTOR;
                        break;
                    }

                    throw Error(SYNTAX_ERROR);
            }
        }

        switch (state) {
            case SELECTOR:
            case TAG_NAME:
            case QUALIFIER:
            case QUALIFIER_NAME:
            case SELECTOR_SEPARATOR:
                // Valid end states.
                newSelector();
                break;
            default:
                throw Error(SYNTAX_ERROR);
        }

        if (!selectors.length)
            throw Error(SYNTAX_ERROR);

        return selectors;
    };
    Selector.nextUid = 1;
    Selector.matchesSelector = (function () {
        var element = document.createElement('div');
        if (typeof element['webkitMatchesSelector'] === 'function')
            return 'webkitMatchesSelector';
        if (typeof element['mozMatchesSelector'] === 'function')
            return 'mozMatchesSelector';
        if (typeof element['msMatchesSelector'] === 'function')
            return 'msMatchesSelector';

        return 'matchesSelector';
    })();
    return Selector;
})();

var attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\-:\.]*)$/;

function validateAttribute(attribute) {
    if (typeof attribute != 'string')
        throw Error('Invalid request opion. attribute must be a non-zero length string.');

    attribute = attribute.trim();

    if (!attribute)
        throw Error('Invalid request opion. attribute must be a non-zero length string.');

    if (!attribute.match(attributeFilterPattern))
        throw Error('Invalid request option. invalid attribute name: ' + attribute);

    return attribute;
}

function validateElementAttributes(attribs) {
    if (!attribs.trim().length)
        throw Error('Invalid request option: elementAttributes must contain at least one attribute.');

    var lowerAttributes = {};
    var attributes = {};

    var tokens = attribs.split(/\s+/);
    for (var i = 0; i < tokens.length; i++) {
        var name = tokens[i];
        if (!name)
            continue;

        var name = validateAttribute(name);
        var nameLower = name.toLowerCase();
        if (lowerAttributes[nameLower])
            throw Error('Invalid request option: observing multiple case variations of the same attribute is not supported.');

        attributes[name] = true;
        lowerAttributes[nameLower] = true;
    }

    return Object.keys(attributes);
}

function elementFilterAttributes(selectors) {
    var attributes = {};

    selectors.forEach(function (selector) {
        selector.qualifiers.forEach(function (qualifier) {
            attributes[qualifier.attrName] = true;
        });
    });

    return Object.keys(attributes);
}

var MutationSummary = (function () {
    function MutationSummary(opts) {
        var _this = this;
        this.connected = false;
        this.options = MutationSummary.validateOptions(opts);
        this.observerOptions = MutationSummary.createObserverOptions(this.options.queries);
        this.root = this.options.rootNode;
        this.callback = this.options.callback;

        this.elementFilter = Array.prototype.concat.apply([], this.options.queries.map(function (query) {
            return query.elementFilter ? query.elementFilter : [];
        }));
        if (!this.elementFilter.length)
            this.elementFilter = undefined;

        this.calcReordered = this.options.queries.some(function (query) {
            return query.all;
        });

        this.queryValidators = []; // TODO(rafaelw): Shouldn't always define this.
        if (MutationSummary.createQueryValidator) {
            this.queryValidators = this.options.queries.map(function (query) {
                return MutationSummary.createQueryValidator(_this.root, query);
            });
        }

        this.observer = new MutationObserverCtor(function (mutations) {
            _this.observerCallback(mutations);
        });

        this.reconnect();
    }
    MutationSummary.createObserverOptions = function (queries) {
        var observerOptions = {
            childList: true,
            subtree: true
        };

        var attributeFilter;
        function observeAttributes(attributes) {
            if (observerOptions.attributes && !attributeFilter)
                return;

            observerOptions.attributes = true;
            observerOptions.attributeOldValue = true;

            if (!attributes) {
                // observe all.
                attributeFilter = undefined;
                return;
            }

            // add to observed.
            attributeFilter = attributeFilter || {};
            attributes.forEach(function (attribute) {
                attributeFilter[attribute] = true;
                attributeFilter[attribute.toLowerCase()] = true;
            });
        }

        queries.forEach(function (query) {
            if (query.characterData) {
                observerOptions.characterData = true;
                observerOptions.characterDataOldValue = true;
                return;
            }

            if (query.all) {
                observeAttributes();
                observerOptions.characterData = true;
                observerOptions.characterDataOldValue = true;
                return;
            }

            if (query.attribute) {
                observeAttributes([query.attribute.trim()]);
                return;
            }

            var attributes = elementFilterAttributes(query.elementFilter).concat(query.attributeList || []);
            if (attributes.length)
                observeAttributes(attributes);
        });

        if (attributeFilter)
            observerOptions.attributeFilter = Object.keys(attributeFilter);

        return observerOptions;
    };

    MutationSummary.validateOptions = function (options) {
        for (var prop in options) {
            if (!(prop in MutationSummary.optionKeys))
                throw Error('Invalid option: ' + prop);
        }

        if (typeof options.callback !== 'function')
            throw Error('Invalid options: callback is required and must be a function');

        if (!options.queries || !options.queries.length)
            throw Error('Invalid options: queries must contain at least one query request object.');

        var opts = {
            callback: options.callback,
            rootNode: options.rootNode || document,
            observeOwnChanges: !!options.observeOwnChanges,
            oldPreviousSibling: !!options.oldPreviousSibling,
            queries: []
        };

        for (var i = 0; i < options.queries.length; i++) {
            var request = options.queries[i];

            // all
            if (request.all) {
                if (Object.keys(request).length > 1)
                    throw Error('Invalid request option. all has no options.');

                opts.queries.push({ all: true });
                continue;
            }

            // attribute
            if ('attribute' in request) {
                var query = {
                    attribute: validateAttribute(request.attribute)
                };

                query.elementFilter = Selector.parseSelectors('*[' + query.attribute + ']');

                if (Object.keys(request).length > 1)
                    throw Error('Invalid request option. attribute has no options.');

                opts.queries.push(query);
                continue;
            }

            // element
            if ('element' in request) {
                var requestOptionCount = Object.keys(request).length;
                var query = {
                    element: request.element,
                    elementFilter: Selector.parseSelectors(request.element)
                };

                if (request.hasOwnProperty('elementAttributes')) {
                    query.attributeList = validateElementAttributes(request.elementAttributes);
                    requestOptionCount--;
                }

                if (requestOptionCount > 1)
                    throw Error('Invalid request option. element only allows elementAttributes option.');

                opts.queries.push(query);
                continue;
            }

            // characterData
            if (request.characterData) {
                if (Object.keys(request).length > 1)
                    throw Error('Invalid request option. characterData has no options.');

                opts.queries.push({ characterData: true });
                continue;
            }

            throw Error('Invalid request option. Unknown query request.');
        }

        return opts;
    };

    MutationSummary.prototype.createSummaries = function (mutations) {
        if (!mutations || !mutations.length)
            return [];

        var projection = new MutationProjection(this.root, mutations, this.elementFilter, this.calcReordered, this.options.oldPreviousSibling);

        var summaries = [];
        for (var i = 0; i < this.options.queries.length; i++) {
            summaries.push(new Summary(projection, this.options.queries[i]));
        }

        return summaries;
    };

    MutationSummary.prototype.checkpointQueryValidators = function () {
        this.queryValidators.forEach(function (validator) {
            if (validator)
                validator.recordPreviousState();
        });
    };

    MutationSummary.prototype.runQueryValidators = function (summaries) {
        this.queryValidators.forEach(function (validator, index) {
            if (validator)
                validator.validate(summaries[index]);
        });
    };

    MutationSummary.prototype.changesToReport = function (summaries) {
        return summaries.some(function (summary) {
            var summaryProps = [
                'added', 'removed', 'reordered', 'reparented',
                'valueChanged', 'characterDataChanged'];
            if (summaryProps.some(function (prop) {
                return summary[prop] && summary[prop].length;
            }))
                return true;

            if (summary.attributeChanged) {
                var attrNames = Object.keys(summary.attributeChanged);
                var attrsChanged = attrNames.some(function (attrName) {
                    return !!summary.attributeChanged[attrName].length;
                });
                if (attrsChanged)
                    return true;
            }
            return false;
        });
    };

    MutationSummary.prototype.observerCallback = function (mutations) {
        if (!this.options.observeOwnChanges)
            this.observer.disconnect();

        var summaries = this.createSummaries(mutations);
        this.runQueryValidators(summaries);

        if (this.options.observeOwnChanges)
            this.checkpointQueryValidators();

        if (this.changesToReport(summaries))
            this.callback(summaries);

        // disconnect() may have been called during the callback.
        if (!this.options.observeOwnChanges && this.connected) {
            this.checkpointQueryValidators();
            this.observer.observe(this.root, this.observerOptions);
        }
    };

    MutationSummary.prototype.reconnect = function () {
        if (this.connected)
            throw Error('Already connected');

        this.observer.observe(this.root, this.observerOptions);
        this.connected = true;
        this.checkpointQueryValidators();
    };

    MutationSummary.prototype.takeSummaries = function () {
        if (!this.connected)
            throw Error('Not connected');

        var summaries = this.createSummaries(this.observer.takeRecords());
        return this.changesToReport(summaries) ? summaries : undefined;
    };

    MutationSummary.prototype.disconnect = function () {
        var summaries = this.takeSummaries();
        this.observer.disconnect();
        this.connected = false;
        return summaries;
    };
    MutationSummary.NodeMap = NodeMap;
    MutationSummary.parseElementFilter = Selector.parseSelectors;

    MutationSummary.optionKeys = {
        'callback': true,
        'queries': true,
        'rootNode': true,
        'oldPreviousSibling': true,
        'observeOwnChanges': true
    };
    return MutationSummary;
})();

module.exports = MutationSummary

},{}],2:[function(require,module,exports){
/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.11
 *
 * Requires: jQuery 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.11',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $parent = $(elem)['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10);
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

},{}],3:[function(require,module,exports){
var KDAutoComplete, KDInputView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./../inputs/inputview.coffee');

module.exports = KDAutoComplete = (function(_super) {
  __extends(KDAutoComplete, _super);

  function KDAutoComplete() {
    return KDAutoComplete.__super__.constructor.apply(this, arguments);
  }

  KDAutoComplete.prototype.mouseDown = function() {
    return this.focus();
  };

  KDAutoComplete.prototype.setDomElement = function() {
    return this.domElement = $("<div class='kdautocompletewrapper clearfix'><input type='text' placeholder='" + (this.getOptions().placeholder) + "' class='kdinput text'/></div>");
  };

  KDAutoComplete.prototype.setDomId = function() {
    this.$input().attr("id", this.getDomId());
    this.$input().attr("name", this.getName());
    return this.$input().data("data-id", this.getId());
  };

  KDAutoComplete.prototype.setDefaultValue = function(value) {
    this.inputDefaultValue = value;
    return this.setValue(value);
  };

  KDAutoComplete.prototype.$input = function() {
    return this.$("input").eq(0);
  };

  KDAutoComplete.prototype.getValue = function() {
    return this.$input().val();
  };

  KDAutoComplete.prototype.setValue = function(value) {
    return this.$input().val(value);
  };

  KDAutoComplete.prototype.bindEvents = function() {
    return KDAutoComplete.__super__.bindEvents.call(this, this.$input());
  };

  KDAutoComplete.prototype.blur = function(pubInst, event) {
    this.unsetClass("focus");
    return true;
  };

  KDAutoComplete.prototype.focus = function(pubInst, event) {
    this.setClass("focus");
    return KDAutoComplete.__super__.focus.apply(this, arguments);
  };

  KDAutoComplete.prototype.keyDown = function(event) {
    (KD.getSingleton("windowController")).setKeyView(this);
    return true;
  };

  KDAutoComplete.prototype.getLeftOffset = function() {
    return this.$input().prev().width();
  };

  KDAutoComplete.prototype.destroyDropdown = function() {
    if (this.dropdown != null) {
      this.dropdown.destroy();
    }
    this.dropdownPrefix = "";
    return this.dropdown = null;
  };

  KDAutoComplete.prototype.setPlaceHolder = function(value) {
    return this.$input()[0].setAttribute("placeholder", value);
  };

  KDAutoComplete.prototype.setFocus = function() {
    KDAutoComplete.__super__.setFocus.apply(this, arguments);
    return this.$input().trigger("focus");
  };

  KDAutoComplete.prototype.setBlur = function() {
    KDAutoComplete.__super__.setBlur.apply(this, arguments);
    return this.$input().trigger("blur");
  };

  return KDAutoComplete;

})(KDInputView);


},{"./../inputs/inputview.coffee":46}],4:[function(require,module,exports){
var KDAutoComplete, KDAutoCompleteController, KDAutoCompleteFetchingItem, KDAutoCompleteListView, KDLabelView, KDListViewController, KDNotificationView, KDViewController,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

KDViewController = require('./../../core/viewcontroller.coffee');

KDListViewController = require('./../list/listviewcontroller.coffee');

KDLabelView = require('./../inputs/labelview.coffee');

KDNotificationView = require('./../notifications/notificationview.coffee');

KDAutoComplete = require('./autocomplete.coffee');

KDAutoCompleteListView = require('./autocompletelist.coffee');

KDAutoCompleteFetchingItem = require('./autocompletefetchingitem.coffee');

module.exports = KDAutoCompleteController = (function(_super) {
  __extends(KDAutoCompleteController, _super);

  function KDAutoCompleteController(options, data) {
    var mainView;
    if (options == null) {
      options = {};
    }
    options = $.extend({
      view: mainView = options.view || new KDAutoComplete({
        name: options.name,
        placeholder: options.placeholder || "",
        label: options.label || new KDLabelView({
          title: options.name
        })
      }),
      itemClass: KDAutoCompleteListItemView,
      selectedItemClass: KDAutoCompletedItem,
      nothingFoundItemClass: KDAutoCompleteNothingFoundItem,
      fetchingItemClass: KDAutoCompleteFetchingItem,
      listWrapperCssClass: '',
      minSuggestionLength: 2,
      selectedItemsLimit: null,
      itemDataPath: '',
      separator: ',',
      wrapper: 'parent',
      submitValuesAsText: false,
      defaultValue: []
    }, options);
    KDAutoCompleteController.__super__.constructor.call(this, options, data);
    mainView.on('focus', this.bound("updateDropdownContents"));
    this.lastPrefix = null;
    this.selectedItemData = [];
    this.hiddenInputs = {};
    this.selectedItemCounter = 0;
    this.readyToShowDropDown = true;
  }

  KDAutoCompleteController.prototype.reset = function() {
    var item, subViews, _i, _len, _results;
    subViews = this.itemWrapper.getSubViews().slice();
    _results = [];
    for (_i = 0, _len = subViews.length; _i < _len; _i++) {
      item = subViews[_i];
      _results.push(this.removeFromSubmitQueue(item));
    }
    return _results;
  };

  KDAutoCompleteController.prototype.loadView = function(mainView) {
    this.createDropDown();
    this.getAutoCompletedItemParent();
    this.setDefaultValue();
    mainView.on('keyup', this.utils.debounce(300, this.bound("keyUpOnInputView")));
    return mainView.on('keydown', (function(_this) {
      return function(event) {
        return _this.keyDownOnInputView(event);
      };
    })(this));
  };

  KDAutoCompleteController.prototype.setDefaultValue = function(defaultItems) {
    var defaultValue, item, itemDataPath, _i, _len, _ref, _results;
    _ref = this.getOptions(), defaultValue = _ref.defaultValue, itemDataPath = _ref.itemDataPath;
    defaultItems || (defaultItems = defaultValue);
    _results = [];
    for (_i = 0, _len = defaultItems.length; _i < _len; _i++) {
      item = defaultItems[_i];
      _results.push(this.addItemToSubmitQueue(this.getView(), item));
    }
    return _results;
  };

  KDAutoCompleteController.prototype.keyDownOnInputView = function(event) {
    var autoCompleteView;
    autoCompleteView = this.getView();
    switch (event.which) {
      case 13:
      case 9:
        if (autoCompleteView.getValue() !== "" && event.shiftKey !== true) {
          this.submitAutoComplete(autoCompleteView.getValue());
          event.stopPropagation();
          event.preventDefault();
          this.readyToShowDropDown = false;
          return false;
        } else {
          return true;
        }
        break;
      case 27:
        this.hideDropdown();
        break;
      case 38:
        if (this.dropdown.getView().$().is(":visible")) {
          this.dropdown.getListView().goUp();
          event.stopPropagation();
          event.preventDefault();
          return false;
        } else {

        }
        break;
      case 40:
        if (this.dropdown.getView().$().is(":visible")) {
          this.dropdown.getListView().goDown();
          event.stopPropagation();
          event.preventDefault();
          return false;
        }
        break;
      default:
        this.readyToShowDropDown = true;
    }
    return false;
  };

  KDAutoCompleteController.prototype.getPrefix = function() {
    var items, prefix, separator;
    separator = this.getOptions().separator;
    items = this.getView().getValue().split(separator);
    prefix = items[items.length - 1];
    return prefix;
  };

  KDAutoCompleteController.prototype.createDropDown = function(data) {
    var dropdownListView, dropdownWrapper, windowController;
    if (data == null) {
      data = [];
    }
    this.dropdownPrefix = "";
    this.dropdownListView = dropdownListView = new KDAutoCompleteListView({
      itemClass: this.getOptions().itemClass
    }, {
      items: data
    });
    dropdownListView.on('ItemsDeselected', (function(_this) {
      return function() {
        var view;
        view = _this.getView();
        return view.$input().trigger('focus');
      };
    })(this));
    dropdownListView.on('KDAutoCompleteSubmit', this.bound("submitAutoComplete"));
    windowController = KD.getSingleton('windowController');
    this.dropdown = new KDListViewController({
      view: dropdownListView
    });
    dropdownWrapper = this.dropdown.getView();
    dropdownWrapper.on('ReceivedClickElsewhere', (function(_this) {
      return function() {
        return _this.hideDropdown();
      };
    })(this));
    dropdownWrapper.setClass("kdautocomplete hidden " + (this.getOptions().listWrapperCssClass));
    return dropdownWrapper.appendToDomBody();
  };

  KDAutoCompleteController.prototype.hideDropdown = function() {
    var dropdownWrapper;
    dropdownWrapper = this.dropdown.getView();
    return dropdownWrapper.$().fadeOut(75);
  };

  KDAutoCompleteController.prototype.showDropdown = function() {
    var dropdownWrapper, input, offset, windowController;
    if (!this.readyToShowDropDown) {
      return;
    }
    windowController = KD.getSingleton('windowController');
    dropdownWrapper = this.dropdown.getView();
    dropdownWrapper.unsetClass("hidden");
    input = this.getView();
    offset = input.$().offset();
    offset.top += input.getHeight();
    dropdownWrapper.$().css(offset);
    dropdownWrapper.$().fadeIn(75);
    return windowController.addLayer(dropdownWrapper);
  };

  KDAutoCompleteController.prototype.refreshDropDown = function(data) {
    var allowNewSuggestions, exactMatches, exactPattern, inexactMatches, itemDataPath, listView, minSuggestionLength, _ref;
    if (data == null) {
      data = [];
    }
    listView = this.dropdown.getListView();
    this.dropdown.removeAllItems();
    listView.userInput = this.dropdownPrefix;
    exactPattern = RegExp('^' + this.dropdownPrefix.replace(/[^\s\w]/, '') + '$', 'i');
    exactMatches = [];
    inexactMatches = [];
    _ref = this.getOptions(), itemDataPath = _ref.itemDataPath, allowNewSuggestions = _ref.allowNewSuggestions, minSuggestionLength = _ref.minSuggestionLength;
    data.forEach((function(_this) {
      return function(datum) {
        var match;
        if (!_this.isItemAlreadySelected(datum)) {
          match = JsPath.getAt(datum, itemDataPath);
          if (exactPattern.test(match)) {
            return exactMatches.push(datum);
          } else {
            return inexactMatches.push(datum);
          }
        }
      };
    })(this));
    if ((this.dropdownPrefix.length >= minSuggestionLength) && allowNewSuggestions && !exactMatches.length) {
      this.dropdown.getListView().addItemView(this.getNoItemFoundView());
    }
    data = exactMatches.concat(inexactMatches);
    this.dropdown.instantiateListItems(data);
    return this.dropdown.getListView().goDown();
  };

  KDAutoCompleteController.prototype.submitAutoComplete = function(item, data) {
    var activeItem, inputView;
    inputView = this.getView();
    if (this.getOptions().selectedItemsLimit === null || this.getOptions().selectedItemsLimit > this.selectedItemCounter) {
      activeItem = this.dropdown.getListView().getActiveItem();
      if (activeItem.item) {
        this.appendAutoCompletedItem();
      }
      this.addItemToSubmitQueue(activeItem.item);
      this.emit('ItemListChanged', this.selectedItemCounter);
    } else {
      inputView.setValue('');
      KD.getSingleton("windowController").setKeyView(null);
      new KDNotificationView({
        type: "mini",
        title: "You can add up to " + (this.getOptions().selectedItemsLimit) + " items!",
        duration: 4000
      });
    }
    return this.hideDropdown();
  };

  KDAutoCompleteController.prototype.getAutoCompletedItemParent = function() {
    var outputWrapper;
    outputWrapper = this.getOptions().outputWrapper;
    if (outputWrapper instanceof KDView) {
      return this.itemWrapper = outputWrapper;
    } else {
      return this.itemWrapper = this.getView();
    }
  };

  KDAutoCompleteController.prototype.isItemAlreadySelected = function(data) {
    var alreadySelected, customCompare, isCaseSensitive, itemDataPath, selected, selectedData, suggested, _i, _len, _ref, _ref1;
    _ref = this.getOptions(), itemDataPath = _ref.itemDataPath, customCompare = _ref.customCompare, isCaseSensitive = _ref.isCaseSensitive;
    suggested = JsPath.getAt(data, itemDataPath);
    _ref1 = this.getSelectedItemData();
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      selectedData = _ref1[_i];
      if (customCompare != null) {
        alreadySelected = customCompare(data, selectedData);
        if (alreadySelected) {
          return true;
        }
      } else {
        selected = JsPath.getAt(selectedData, itemDataPath);
        if (!isCaseSensitive) {
          suggested = suggested.toLowerCase();
          selected = selected.toLowerCase();
        }
        if (suggested === selected) {
          return true;
        }
      }
    }
    return false;
  };

  KDAutoCompleteController.prototype.addHiddenInputItem = function(name, value) {
    return this.itemWrapper.addSubView(this.hiddenInputs[name] = new KDInputView({
      type: "hidden",
      name: name,
      defaultValue: value
    }));
  };

  KDAutoCompleteController.prototype.removeHiddenInputItem = function(name) {
    return delete this.hiddenInputs[name];
  };

  KDAutoCompleteController.prototype.addSelectedItem = function(name, data) {
    var itemView, selectedItemClass;
    selectedItemClass = this.getOptions().selectedItemClass;
    this.itemWrapper.addSubView(itemView = new selectedItemClass({
      cssClass: "kdautocompletedlistitem",
      delegate: this,
      name: name
    }, data));
    return itemView.setPartial("<span class='close-icon'></span>");
  };

  KDAutoCompleteController.prototype.getSelectedItemData = function() {
    return this.selectedItemData;
  };

  KDAutoCompleteController.prototype.addSelectedItemData = function(data) {
    return this.getSelectedItemData().push(data);
  };

  KDAutoCompleteController.prototype.removeSelectedItemData = function(data) {
    var i, selectedData, selectedItemData, _i, _len;
    selectedItemData = this.getSelectedItemData();
    for (i = _i = 0, _len = selectedItemData.length; _i < _len; i = ++_i) {
      selectedData = selectedItemData[i];
      if (selectedData === data) {
        selectedItemData.splice(i, 1);
        return;
      }
    }
  };

  KDAutoCompleteController.prototype.getCollectionPath = function() {
    var collectionName, leaf, name, path, _i, _ref;
    name = this.getOptions().name;
    if (!name) {
      throw new Error('No name!');
    }
    _ref = name.split('.'), path = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), leaf = _ref[_i++];
    collectionName = Inflector.pluralize(leaf);
    path.push(collectionName);
    return path.join('.');
  };

  KDAutoCompleteController.prototype.addSuggestion = function(title) {
    return this.emit('AutocompleteSuggestionWasAdded', title);
  };

  KDAutoCompleteController.prototype.addItemToSubmitQueue = function(item, data) {
    var collection, form, itemDataPath, itemName, itemValue, name, path, submitValuesAsText, _ref;
    data || (data = item != null ? item.getData() : void 0);
    if (!(data || (item != null ? item.getOptions().userInput : void 0))) {
      return;
    }
    _ref = this.getOptions(), name = _ref.name, itemDataPath = _ref.itemDataPath, form = _ref.form, submitValuesAsText = _ref.submitValuesAsText;
    if (data) {
      itemValue = submitValuesAsText ? JsPath.getAt(data, itemDataPath) : data;
    } else {
      itemValue = item.getOptions().userInput;
      data = JsPath(itemDataPath, itemValue);
    }
    if (this.isItemAlreadySelected(data)) {
      return false;
    }
    path = this.getCollectionPath();
    itemName = "" + name + "-" + (this.selectedItemCounter++);
    if (form) {
      collection = form.getCustomData(path) || [];
      collection.push(submitValuesAsText ? itemValue : (typeof itemValue.getId === "function" ? itemValue.getId() : void 0) ? {
        constructorName: itemValue.constructor.name,
        id: itemValue.getId(),
        title: itemValue.title
      } : {
        $suggest: itemValue
      });
      form.addCustomData(path, collection);
      if (item.getOptions().userInput === !"") {
        this.selectedItemCounter++;
      }
    } else {
      this.addHiddenInputItem(path, itemValue);
    }
    this.addSelectedItemData(data);
    this.addSelectedItem(itemName, data);
    return this.getView().setValue(this.dropdownPrefix = "");
  };

  KDAutoCompleteController.prototype.removeFromSubmitQueue = function(item, data) {
    var collection, form, itemDataPath, path, _ref;
    _ref = this.getOptions(), itemDataPath = _ref.itemDataPath, form = _ref.form;
    data || (data = item.getData());
    path = this.getCollectionPath();
    if (form) {
      collection = JsPath.getAt(form.getCustomData(), path);
      collection = collection.filter(function(sibling) {
        var id;
        id = typeof data.getId === "function" ? data.getId() : void 0;
        if (id == null) {
          return sibling.$suggest !== data.title;
        } else {
          return sibling.id !== id;
        }
      });
      JsPath.setAt(form.getCustomData(), path, collection);
    } else {
      this.removeHiddenInputItem(path);
    }
    this.removeSelectedItemData(data);
    this.selectedItemCounter--;
    item.destroy();
    return this.emit('ItemListChanged', this.selectedItemCounter);
  };

  KDAutoCompleteController.prototype.appendAutoCompletedItem = function() {
    this.getView().setValue("");
    return this.getView().$input().trigger("focus");
  };

  KDAutoCompleteController.prototype.updateDropdownContents = function() {
    var inputView;
    inputView = this.getView();
    if (inputView.getValue() === "") {
      this.hideDropdown();
    }
    if (inputView.getValue() !== "" && this.dropdownPrefix !== inputView.getValue() && this.dropdown.getView().$().not(":visible")) {
      this.dropdownPrefix = inputView.getValue();
      return this.fetch((function(_this) {
        return function(data) {
          _this.refreshDropDown(data);
          return _this.showDropdown();
        };
      })(this));
    }
  };

  KDAutoCompleteController.prototype.keyUpOnInputView = function(event) {
    var _ref;
    if ((_ref = event.keyCode) === 9 || _ref === 38 || _ref === 40) {
      return;
    }
    this.updateDropdownContents();
    return false;
  };

  KDAutoCompleteController.prototype.fetch = function(callback) {
    var args, source;
    args = {};
    if (this.getOptions().fetchInputName) {
      args[this.getOptions().fetchInputName] = this.getView().getValue();
    } else {
      args = {
        inputValue: this.getView().getValue()
      };
    }
    this.dropdownPrefix = this.getView().getValue();
    source = this.getOptions().dataSource;
    return source(args, callback);
  };

  KDAutoCompleteController.prototype.showFetching = function() {
    var fetchingItemClass, view, _ref;
    fetchingItemClass = this.getOptions().fetchingItemClass;
    if (!(((_ref = this.dropdown.getListView().items) != null ? _ref[0] : void 0) instanceof KDAutoCompleteFetchingItem)) {
      view = new fetchingItemClass;
      if (this.dropdown.getListView().items.length) {
        return this.dropdown.getListView().addItemView(view, 0);
      } else {
        return this.dropdown.getListView().addItemView(view);
      }
    }
  };

  KDAutoCompleteController.prototype.getNoItemFoundView = function(suggestion) {
    var nothingFoundItemClass, view;
    nothingFoundItemClass = this.getOptions().nothingFoundItemClass;
    return view = new nothingFoundItemClass({
      delegate: this.dropdown.getListView(),
      userInput: suggestion || this.getView().getValue()
    });
  };

  KDAutoCompleteController.prototype.showNoDataFound = function() {
    var noItemFoundView;
    noItemFoundView = this.getNoItemFoundView();
    this.dropdown.removeAllItems();
    this.dropdown.getListView().addItemView(noItemFoundView);
    return this.showDropdown();
  };

  KDAutoCompleteController.prototype.destroy = function() {
    this.dropdown.getView().destroy();
    return KDAutoCompleteController.__super__.destroy.apply(this, arguments);
  };

  return KDAutoCompleteController;

})(KDViewController);


},{"./../../core/viewcontroller.coffee":107,"./../inputs/labelview.coffee":47,"./../list/listviewcontroller.coffee":55,"./../notifications/notificationview.coffee":61,"./autocomplete.coffee":3,"./autocompletefetchingitem.coffee":6,"./autocompletelist.coffee":7}],5:[function(require,module,exports){
var KDAutoCompletedItem, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDAutoCompletedItem = (function(_super) {
  __extends(KDAutoCompletedItem, _super);

  function KDAutoCompletedItem(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = this.utils.curry("kdautocompletedlistitem", options.cssClass);
    KDAutoCompletedItem.__super__.constructor.apply(this, arguments);
  }

  KDAutoCompletedItem.prototype.click = function(event) {
    if ($(event.target).is('span.close-icon')) {
      this.getDelegate().removeFromSubmitQueue(this);
    }
    return this.getDelegate().getView().$input().trigger("focus");
  };

  KDAutoCompletedItem.prototype.viewAppended = function() {
    return this.setPartial(this.partial());
  };

  KDAutoCompletedItem.prototype.partial = function(data) {
    return this.getDelegate().getOptions().itemClass.prototype.partial(this.getData());
  };

  return KDAutoCompletedItem;

})(KDView);


},{"./../../core/view.coffee":106}],6:[function(require,module,exports){
var KDAutoCompleteFetchingItem, KDAutocompleteUnselecteableItem,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDAutocompleteUnselecteableItem = require('./autocompleteunselecteableitem.coffee');

module.exports = KDAutoCompleteFetchingItem = (function(_super) {
  __extends(KDAutoCompleteFetchingItem, _super);

  function KDAutoCompleteFetchingItem(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = this.utils.curry("kdautocompletelistitem fetching", options.cssClass);
    KDAutoCompleteFetchingItem.__super__.constructor.apply(this, arguments);
  }

  KDAutoCompleteFetchingItem.prototype.partial = function() {
    return "Fetching in process...";
  };

  return KDAutoCompleteFetchingItem;

})(KDAutocompleteUnselecteableItem);


},{"./autocompleteunselecteableitem.coffee":10}],7:[function(require,module,exports){
var KDAutoCompleteListView, KDListView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListView = require('./../list/listview.coffee');

module.exports = KDAutoCompleteListView = (function(_super) {
  __extends(KDAutoCompleteListView, _super);

  function KDAutoCompleteListView(options, data) {
    KDAutoCompleteListView.__super__.constructor.call(this, options, data);
    this.setClass("kdautocompletelist");
  }

  KDAutoCompleteListView.prototype.goDown = function() {
    var activeItem, nextItem, _ref;
    activeItem = this.getActiveItem();
    if (activeItem.index != null) {
      nextItem = this.items[activeItem.index + 1];
      if (nextItem != null) {
        return nextItem.makeItemActive();
      }
    } else {
      return (_ref = this.items[0]) != null ? _ref.makeItemActive() : void 0;
    }
  };

  KDAutoCompleteListView.prototype.goUp = function() {
    var activeItem;
    activeItem = this.getActiveItem();
    if (activeItem.index != null) {
      if (this.items[activeItem.index - 1] != null) {
        return this.items[activeItem.index - 1].makeItemActive();
      } else {
        return this.emit('ItemsDeselected');
      }
    } else {
      return this.items[0].makeItemActive();
    }
  };

  KDAutoCompleteListView.prototype.getActiveItem = function() {
    var active, i, item, _i, _len, _ref;
    active = {
      index: null,
      item: null
    };
    _ref = this.items;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (item.active) {
        active.item = item;
        active.index = i;
        break;
      }
    }
    return active;
  };

  return KDAutoCompleteListView;

})(KDListView);


},{"./../list/listview.coffee":54}],8:[function(require,module,exports){
var KDAutoCompleteListItemView, KDListItemView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListItemView = require('./../list/listitemview.coffee');

module.exports = KDAutoCompleteListItemView = (function(_super) {
  __extends(KDAutoCompleteListItemView, _super);

  function KDAutoCompleteListItemView(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry("kdautocompletelistitem", options.cssClass);
    options.bind = "mouseenter mouseleave";
    KDAutoCompleteListItemView.__super__.constructor.call(this, options, data);
    this.active = false;
  }

  KDAutoCompleteListItemView.prototype.viewAppended = function() {
    return this.updatePartial(this.partial(this.data));
  };

  KDAutoCompleteListItemView.prototype.mouseEnter = function() {
    return this.makeItemActive();
  };

  KDAutoCompleteListItemView.prototype.mouseLeave = function() {
    return this.makeItemInactive();
  };

  KDAutoCompleteListItemView.prototype.makeItemActive = function() {
    var item, _i, _len, _ref;
    _ref = this.getDelegate().items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      item.makeItemInactive();
    }
    this.active = true;
    return this.setClass("active");
  };

  KDAutoCompleteListItemView.prototype.makeItemInactive = function() {
    this.active = false;
    return this.unsetClass("active");
  };

  KDAutoCompleteListItemView.prototype.click = function() {
    var list;
    list = this.getDelegate();
    list.emit('KDAutoCompleteSubmit', this, this.data);
    return false;
  };

  KDAutoCompleteListItemView.prototype.partial = function() {
    return "<div class='autocomplete-item clearfix'>Default item</div>";
  };

  return KDAutoCompleteListItemView;

})(KDListItemView);


},{"./../list/listitemview.coffee":53}],9:[function(require,module,exports){
var KDAutoCompleteNothingFoundItem, KDAutocompleteUnselecteableItem,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDAutocompleteUnselecteableItem = require('./autocompleteunselecteableitem.coffee');

module.exports = KDAutoCompleteNothingFoundItem = (function(_super) {
  __extends(KDAutoCompleteNothingFoundItem, _super);

  function KDAutoCompleteNothingFoundItem(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = this.utils.curry("kdautocompletelistitem no-result", options.cssClass);
    KDAutoCompleteNothingFoundItem.__super__.constructor.apply(this, arguments);
  }

  KDAutoCompleteNothingFoundItem.prototype.partial = function(data) {
    return "Nothing found";
  };

  return KDAutoCompleteNothingFoundItem;

})(KDAutocompleteUnselecteableItem);


},{"./autocompleteunselecteableitem.coffee":10}],10:[function(require,module,exports){
var KDAutocompleteUnselecteableItem, KDListItemView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListItemView = require('./../list/listitemview.coffee');

module.exports = KDAutocompleteUnselecteableItem = (function(_super) {
  __extends(KDAutocompleteUnselecteableItem, _super);

  function KDAutocompleteUnselecteableItem() {
    return KDAutocompleteUnselecteableItem.__super__.constructor.apply(this, arguments);
  }

  KDAutocompleteUnselecteableItem.prototype.click = function() {
    return false;
  };

  KDAutocompleteUnselecteableItem.prototype.keyUp = function() {
    return false;
  };

  KDAutocompleteUnselecteableItem.prototype.keyDown = function() {
    return false;
  };

  KDAutocompleteUnselecteableItem.prototype.makeItemActive = function() {};

  KDAutocompleteUnselecteableItem.prototype.destroy = function() {
    return KDAutocompleteUnselecteableItem.__super__.destroy.call(this, false);
  };

  return KDAutocompleteUnselecteableItem;

})(KDListItemView);


},{"./../list/listitemview.coffee":53}],11:[function(require,module,exports){
var KDListView, MultipleInputListView, MultipleListItemView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListView = require('./../list/listview.coffee');

MultipleListItemView = require('./multiplelistitemview.coffee');

module.exports = MultipleInputListView = (function(_super) {
  __extends(MultipleInputListView, _super);

  function MultipleInputListView() {
    return MultipleInputListView.__super__.constructor.apply(this, arguments);
  }

  MultipleInputListView.prototype.setDomElement = function() {
    return this.domElement = $("<p class='search-tags clearfix'></p>");
  };

  MultipleInputListView.prototype.addItems = function(items) {
    var item, newItem, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      newItem = new MultipleListItemView({
        delegate: this
      }, item);
      _results.push(this.addItemView(newItem));
    }
    return _results;
  };

  MultipleInputListView.prototype.removeListItem = function(instance) {
    MultipleInputListView.__super__.removeListItem.call(this, instance);
    return this.getDelegate().inputRemoveValue(instance.getData());
  };

  return MultipleInputListView;

})(KDListView);


},{"./../list/listview.coffee":54,"./multiplelistitemview.coffee":13}],12:[function(require,module,exports){
var KDInputView, KDMultipleInputView, KDSimpleAutocomplete, MultipleInputListView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDSimpleAutocomplete = require('./simpleautocomplete.coffee');

MultipleInputListView = require('./multipleinputlistview.coffee');

KDInputView = require('./../inputs/inputview.coffee');

module.exports = KDMultipleInputView = (function(_super) {
  __extends(KDMultipleInputView, _super);

  function KDMultipleInputView(options) {
    this._values = [];
    options = $.extend({
      icon: 'noicon',
      title: ''
    }, options);
    KDMultipleInputView.__super__.constructor.call(this, options);
  }

  KDMultipleInputView.prototype.focus = function(pubInst, event) {
    return (KD.getSingleton("windowController")).setKeyView(this);
  };

  KDMultipleInputView.prototype.viewAppended = function() {
    this.list = new MultipleInputListView({
      delegate: this
    });
    return this.addSubView(this.list);
  };

  KDMultipleInputView.prototype.$input = function() {
    return this.$().find("input.main").eq(0);
  };

  KDMultipleInputView.prototype.getValues = function() {
    return this._values;
  };

  KDMultipleInputView.prototype.addItemToSubmitQueue = function() {
    KDMultipleInputView.__super__.addItemToSubmitQueue.apply(this, arguments);
    return this.inputAddCurrentValue();
  };

  KDMultipleInputView.prototype.keyUp = function(event) {
    if (event.keyCode === 13) {
      this.inputAddCurrentValue();
    }
    return KDMultipleInputView.__super__.keyUp.apply(this, arguments);
  };

  KDMultipleInputView.prototype.inputRemoveValue = function(value) {
    var index;
    index = this._values.indexOf(value);
    if (index > -1) {
      this._values.splice(index, 1);
    }
    return this._inputChanged();
  };

  KDMultipleInputView.prototype.clear = function() {
    this._values = [];
    this.removeAllItems();
    return this._inputChanged();
  };

  KDMultipleInputView.prototype.inputAddCurrentValue = function() {
    var value;
    value = this.$input().val();
    value = $.trim(value);
    if (__indexOf.call(this._values, value) >= 0 || value === '') {
      return;
    }
    this._values.push(value);
    this.$input().val('');
    this.list.addItems([value]);
    return this._inputChanged();
  };

  KDMultipleInputView.prototype._inputChanged = function() {
    var index, input, inputName, newInput, value, _i, _j, _len, _len1, _ref, _ref1;
    if (!this._hiddenInputs) {
      this._hiddenInputs = [];
    }
    _ref = this._hiddenInputs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      input = _ref[_i];
      input.destroy();
    }
    inputName = this.getOptions().name;
    _ref1 = this._values;
    for (index = _j = 0, _len1 = _ref1.length; _j < _len1; index = ++_j) {
      value = _ref1[index];
      newInput = new KDInputView({
        type: 'hidden',
        name: inputName + ("[" + index + "]"),
        defaultValue: value
      });
      this._hiddenInputs.push(newInput);
      this.addSubView(newInput);
    }
    return this.emit('MultipleInputChanged', {
      values: this.getValue()
    });
  };

  KDMultipleInputView.prototype.click = function(event) {
    if ($(event.target).hasClass('addNewItem')) {
      return this.inputAddCurrentValue();
    }
  };

  KDMultipleInputView.prototype.setDomId = function() {
    this.$input().attr("id", this.getDomId());
    return this.$input().data("data-id", this.getId());
  };

  KDMultipleInputView.prototype.setDomElement = function() {
    return this.domElement = $("<div class='filter kdview'> <h2>" + (this.getOptions().title) + "</h2> <div class='clearfix'> <span class='" + (this.getOptions().icon) + "'></span> <input type='text' class='main'> <a href='#' class='addNewItem'>+</a> </div> </div>");
  };

  return KDMultipleInputView;

})(KDSimpleAutocomplete);


},{"./../inputs/inputview.coffee":46,"./multipleinputlistview.coffee":11,"./simpleautocomplete.coffee":16}],13:[function(require,module,exports){
var KDListItemView, MultipleListItemView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListItemView = require('./../list/listitemview.coffee');

module.exports = MultipleListItemView = (function(_super) {
  __extends(MultipleListItemView, _super);

  function MultipleListItemView() {
    return MultipleListItemView.__super__.constructor.apply(this, arguments);
  }

  MultipleListItemView.prototype.click = function(event) {
    if ($(event.target).hasClass('removeIcon')) {
      return this.getDelegate().removeListItem(this);
    }
  };

  MultipleListItemView.prototype.setDomElement = function() {
    return this.domElement = $('<span />');
  };

  MultipleListItemView.prototype.partial = function() {
    return "" + (this.getData()) + " <cite class='removeIcon'>x</cite>";
  };

  return MultipleListItemView;

})(KDListItemView);


},{"./../list/listitemview.coffee":53}],14:[function(require,module,exports){
var KDMultipleInputView, NoAutocompleteInputView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDMultipleInputView = require('./multipleinputview.coffee');

module.exports = NoAutocompleteInputView = (function(_super) {
  __extends(NoAutocompleteInputView, _super);

  function NoAutocompleteInputView() {
    return NoAutocompleteInputView.__super__.constructor.apply(this, arguments);
  }

  NoAutocompleteInputView.prototype.keyUp = function(event) {
    if (event.keyCode === 13) {
      return this.inputAddCurrentValue();
    }
  };

  NoAutocompleteInputView.prototype.setDomElement = function(cssClass) {
    var placeholder;
    placeholder = this.getOptions().placeholder;
    return this.domElement = $("<div class='" + cssClass + "'><input type='text' class='main' placeholder='" + (placeholder || '') + "' /></div>");
  };

  NoAutocompleteInputView.prototype.addItemToSubmitQueue = function(item) {
    return false;
  };

  return NoAutocompleteInputView;

})(KDMultipleInputView);


},{"./multipleinputview.coffee":12}],15:[function(require,module,exports){
var KDView, NoAutocompleteMultipleListView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = NoAutocompleteMultipleListView = (function(_super) {
  __extends(NoAutocompleteMultipleListView, _super);

  function NoAutocompleteMultipleListView(options, data) {
    var defaults;
    if (options == null) {
      options = {};
    }
    defaults = {
      cssClass: 'common-view input-with-extras'
    };
    options = $.extend(defaults, options);
    NoAutocompleteMultipleListView.__super__.constructor.call(this, options, data);
  }

  NoAutocompleteMultipleListView.prototype.viewAppended = function() {
    var button, defaults, icon, input, options, _ref;
    _ref = this.options, icon = _ref.icon, input = _ref.input, button = _ref.button;
    if (icon) {
      this.setClass("with-icon");
      options = {
        tagName: "span",
        cssClass: "icon " + icon
      };
      this.addSubView(this.icon = new KDCustomHTMLView(options));
    }
    if (input) {
      this.addSubView(this.input = new KDNoAutocompleteInputView(input));
    }
    if (button) {
      defaults = {
        callback: (function(_this) {
          return function(event) {
            event.preventDefault();
            event.stopPropagation();
            return _this.input.inputAddCurrentValue();
          };
        })(this)
      };
      button = $.extend(defaults, button);
      return this.addSubView(this.button = new KDButtonView(button));
    }
  };

  return NoAutocompleteMultipleListView;

})(KDView);


},{"./../../core/view.coffee":106}],16:[function(require,module,exports){
var KDAutoComplete, KDSimpleAutocomplete,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDAutoComplete = require('./autocomplete.coffee');

module.exports = KDSimpleAutocomplete = (function(_super) {
  __extends(KDSimpleAutocomplete, _super);

  function KDSimpleAutocomplete() {
    return KDSimpleAutocomplete.__super__.constructor.apply(this, arguments);
  }

  KDSimpleAutocomplete.prototype.addItemToSubmitQueue = function(item) {
    var itemValue;
    itemValue = JsPath.getAt(item.getData(), this.getOptions().itemDataPath);
    return this.setValue(itemValue);
  };

  KDSimpleAutocomplete.prototype.keyUp = function(event) {
    if (event.keyCode === 13) {
      return;
    }
    return KDSimpleAutocomplete.__super__.keyUp.apply(this, arguments);
  };

  KDSimpleAutocomplete.prototype.showNoDataFound = function() {
    this.dropdown.removeAllItems();
    return this.hideDropdown();
  };

  return KDSimpleAutocomplete;

})(KDAutoComplete);


},{"./autocomplete.coffee":3}],17:[function(require,module,exports){
var KDButtonBar, KDButtonView, KDFormView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDButtonView = require('./buttonview');

KDFormView = require('../forms/formview.coffee');

module.exports = KDButtonBar = (function(_super) {
  __extends(KDButtonBar, _super);

  function KDButtonBar(options, data) {
    var button, buttonOptions, buttons, _i, _len, _ref;
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry("formline button-field clearfix", options.cssClass);
    KDButtonBar.__super__.constructor.call(this, options, data);
    this.buttons = {};
    buttons = options.buttons;
    _ref = KDFormView.sanitizeFormOptions(buttons);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      buttonOptions = _ref[_i];
      button = this.createButton(buttonOptions);
      this.addSubView(button);
      this.buttons[buttonOptions.key] = button;
    }
  }

  KDButtonBar.prototype._itemClass = KDButtonView;

  KDButtonBar.prototype.createButton = function(options) {
    var button, o;
    options || (options = {});
    options.itemClass || (options.itemClass = this._itemClass);
    o = $.extend({}, options);
    delete o.itemClass;
    return button = new options.itemClass(o);
  };

  return KDButtonBar;

})(KDView);


},{"../forms/formview.coffee":34,"./../../core/view.coffee":106,"./buttonview":20}],18:[function(require,module,exports){
var KDButtonGroupView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDButtonGroupView = (function(_super) {
  __extends(KDButtonGroupView, _super);

  function KDButtonGroupView(options, data) {
    var cssClass;
    if (options == null) {
      options = {};
    }
    cssClass = options.cssClass;
    cssClass = cssClass ? " " + cssClass : "";
    options.cssClass = "kdbuttongroup" + cssClass;
    options.buttons || (options.buttons = {});
    KDButtonGroupView.__super__.constructor.call(this, options, data);
    this.buttons = {};
    this.createButtons(options.buttons);
  }

  KDButtonGroupView.prototype.createButtons = function(allButtonOptions) {
    var buttonClass, buttonOptions, buttonTitle, _results;
    _results = [];
    for (buttonTitle in allButtonOptions) {
      if (!__hasProp.call(allButtonOptions, buttonTitle)) continue;
      buttonOptions = allButtonOptions[buttonTitle];
      buttonClass = buttonOptions.buttonClass || KDButtonView;
      buttonOptions.title = buttonTitle;
      buttonOptions.style = "";
      this.addSubView(this.buttons[buttonTitle] = new buttonClass(buttonOptions));
      _results.push(this.buttons[buttonTitle].on("click", (function(_this) {
        return function(event) {
          return _this.buttonReceivedClick(_this.buttons[buttonTitle], event);
        };
      })(this)));
    }
    return _results;
  };

  KDButtonGroupView.prototype.buttonReceivedClick = function(button, event) {
    var otherButton, title, _ref;
    _ref = this.buttons;
    for (title in _ref) {
      if (!__hasProp.call(_ref, title)) continue;
      otherButton = _ref[title];
      otherButton.unsetClass("toggle");
    }
    return button.setClass("toggle");
  };

  return KDButtonGroupView;

})(KDView);


},{"./../../core/view.coffee":106}],19:[function(require,module,exports){
var JButtonMenu, KDContextMenu,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDContextMenu = require('./../contextmenu/contextmenu.coffee');

module.exports = JButtonMenu = (function(_super) {
  __extends(JButtonMenu, _super);

  function JButtonMenu(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = this.utils.curry("kdbuttonmenu", options.cssClass);
    options.listViewClass || (options.listViewClass = JContextMenuTreeView);
    JButtonMenu.__super__.constructor.call(this, options, data);
  }

  JButtonMenu.prototype.viewAppended = function() {
    JButtonMenu.__super__.viewAppended.apply(this, arguments);
    this.setPartial("<div class='chevron-ghost-wrapper'><span class='chevron-ghost'></span></div>");
    return this.positionContextMenu();
  };

  JButtonMenu.prototype.positionContextMenu = KD.utils.debounce(10, function() {
    var button, buttonHeight, buttonWidth, ghostCss, mainHeight, mainScroll, menuHeight, menuWidth, top;
    button = this.getDelegate();
    mainHeight = $(window).height();
    mainScroll = $(window).scrollTop();
    buttonHeight = button.getHeight();
    buttonWidth = button.getWidth();
    top = button.getY() + buttonHeight;
    menuHeight = this.getHeight();
    menuWidth = this.getWidth();
    ghostCss = top + menuHeight > mainHeight + mainScroll ? (top = button.getY() - menuHeight, this.setClass("top-menu"), {
      top: "100%",
      height: buttonHeight
    }) : {
      top: -(buttonHeight + 1),
      height: buttonHeight
    };
    this.$(".chevron-ghost-wrapper").css(ghostCss);
    return this.$().css({
      top: top,
      left: button.getX() + buttonWidth - menuWidth
    });
  });

  return JButtonMenu;

})(KDContextMenu);


},{"./../contextmenu/contextmenu.coffee":23}],20:[function(require,module,exports){
var KDButtonView, KDLoaderView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDLoaderView = require('./../loader/loaderview.coffee');

module.exports = KDButtonView = (function(_super) {
  __extends(KDButtonView, _super);

  function KDButtonView(options, data) {
    if (options == null) {
      options = {};
    }
    options.callback || (options.callback = noop);
    options.title || (options.title = "");
    options.type || (options.type = "button");
    options.cssClass || (options.cssClass = options.style || (options.style = "clean-gray"));
    if (options.icon == null) {
      options.icon = false;
    }
    if (options.iconOnly == null) {
      options.iconOnly = false;
    }
    options.iconClass || (options.iconClass = "");
    if (options.disabled == null) {
      options.disabled = false;
    }
    options.hint || (options.hint = null);
    if (options.loader == null) {
      options.loader = false;
    }
    KDButtonView.__super__.constructor.call(this, options, data);
    this.setClass(options.style);
    this.setCallback(options.callback);
    this.setTitle(options.title);
    if (options.iconClass) {
      this.setIconClass(options.iconClass);
    }
    if (options.icon || options.iconOnly) {
      this.showIcon();
    }
    if (options.iconOnly) {
      this.setIconOnly(options.iconOnly);
    }
    if (options.disabled) {
      this.disable();
    }
    if (options.focus) {
      this.once("viewAppended", this.bound("setFocus"));
    }
    if (options.loader) {
      this.once("viewAppended", this.bound("setLoader"));
    }
  }

  KDButtonView.prototype.setFocus = function() {
    return this.$().trigger('focus');
  };

  KDButtonView.prototype.setDomElement = function(cssClass) {
    var el, klass, lazyDomId, tagName, _i, _len, _ref, _ref1;
    _ref = this.getOptions(), lazyDomId = _ref.lazyDomId, tagName = _ref.tagName;
    if (lazyDomId) {
      el = document.getElementById(lazyDomId);
      _ref1 = ("kdview " + cssClass).split(' ');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        klass = _ref1[_i];
        if (klass.length) {
          el.classList.add(klass);
        }
      }
    }
    if (el == null) {
      if (lazyDomId) {
        warn("No lazy DOM Element found with given id " + lazyDomId + ".");
      }
      el = "<button type='" + (this.getOptions().type) + "' class='kdbutton " + cssClass + "' id='" + (this.getId()) + "'>\n  <span class='icon hidden'></span>\n  <span class='button-title'>Title</span>\n</button>";
    }
    return this.domElement = $(el);
  };

  KDButtonView.prototype.setTitle = function(title) {
    this.buttonTitle = title;
    return this.$('.button-title').html(title);
  };

  KDButtonView.prototype.getTitle = function() {
    return this.buttonTitle;
  };

  KDButtonView.prototype.setCallback = function(callback) {
    return this.buttonCallback = callback;
  };

  KDButtonView.prototype.getCallback = function() {
    return this.buttonCallback;
  };

  KDButtonView.prototype.showIcon = function() {
    this.setClass("with-icon");
    return this.$('span.icon').removeClass('hidden');
  };

  KDButtonView.prototype.hideIcon = function() {
    this.unsetClass("with-icon");
    return this.$('span.icon').addClass('hidden');
  };

  KDButtonView.prototype.setIconClass = function(iconClass) {
    this.$('.icon').attr('class', 'icon');
    return this.$('.icon').addClass(iconClass);
  };

  KDButtonView.prototype.setIconOnly = function() {
    var $icon;
    this.unsetClass("with-icon");
    this.$().addClass('icon-only');
    $icon = this.$('span.icon');
    return this.$().html($icon);
  };

  KDButtonView.prototype.setLoader = function() {
    var loader, loaderSize, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    this.setClass("w-loader");
    loader = this.getOptions().loader;
    loaderSize = this.getHeight() / 2;
    this.loader = new KDLoaderView({
      size: {
        width: (_ref = loader.diameter) != null ? _ref : loaderSize
      },
      loaderOptions: {
        color: loader.color || "#ffffff",
        shape: loader.shape || "spiral",
        diameter: (_ref1 = loader.diameter) != null ? _ref1 : loaderSize,
        density: (_ref2 = loader.density) != null ? _ref2 : 30,
        range: (_ref3 = loader.range) != null ? _ref3 : 0.4,
        speed: (_ref4 = loader.speed) != null ? _ref4 : 1.5,
        FPS: (_ref5 = loader.FPS) != null ? _ref5 : 24
      }
    });
    this.addSubView(this.loader, null, true);
    this.loader.$().css({
      position: "absolute",
      left: loader.left || "50%",
      top: loader.top || "50%",
      marginTop: -(loader.diameter / 2),
      marginLeft: -(loader.diameter / 2)
    });
    return this.loader.hide();
  };

  KDButtonView.prototype.showLoader = function() {
    var icon, iconOnly, _ref;
    _ref = this.getOptions(), icon = _ref.icon, iconOnly = _ref.iconOnly;
    this.setClass("loading");
    this.loader.show();
    if (icon && !iconOnly) {
      return this.hideIcon();
    }
  };

  KDButtonView.prototype.hideLoader = function() {
    var icon, iconOnly, _ref, _ref1;
    _ref = this.getOptions(), icon = _ref.icon, iconOnly = _ref.iconOnly;
    this.unsetClass("loading");
    if ((_ref1 = this.loader) != null) {
      _ref1.hide();
    }
    if (icon && !iconOnly) {
      return this.showIcon();
    }
  };

  KDButtonView.prototype.disable = function() {
    return this.$().attr("disabled", true);
  };

  KDButtonView.prototype.enable = function() {
    return this.$().attr("disabled", false);
  };

  KDButtonView.prototype.focus = function() {
    return this.$().trigger("focus");
  };

  KDButtonView.prototype.blur = function() {
    return this.$().trigger("blur");
  };

  KDButtonView.prototype.click = function(event) {
    var _ref;
    if ((_ref = this.loader) != null ? _ref.active : void 0) {
      return this.utils.stopDOMEvent();
    }
    if (this.loader && !this.loader.active) {
      this.showLoader();
    }
    if (this.getOption('type') === "button") {
      this.utils.stopDOMEvent();
    }
    this.getCallback().call(this, event);
    return false;
  };

  KDButtonView.prototype.triggerClick = function() {
    return this.doOnSubmit();
  };

  return KDButtonView;

})(KDView);


},{"./../../core/view.coffee":106,"./../loader/loaderview.coffee":56}],21:[function(require,module,exports){
var KDButtonView, KDButtonViewWithMenu,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDButtonView = require('./buttonview.coffee');

module.exports = KDButtonViewWithMenu = (function(_super) {
  __extends(KDButtonViewWithMenu, _super);

  function KDButtonViewWithMenu() {
    return KDButtonViewWithMenu.__super__.constructor.apply(this, arguments);
  }

  KDButtonViewWithMenu.prototype.setDomElement = function(cssClass) {
    if (cssClass == null) {
      cssClass = '';
    }
    this.domElement = $("<div class='kdbuttonwithmenu-wrapper " + cssClass + "'>\n  <button class='kdbutton " + cssClass + " with-icon with-menu' id='" + (this.getId()) + "'>\n    <span class='icon hidden'></span>\n  </button>\n  <span class='chevron-separator'></span>\n  <span class='chevron'></span>\n</div>");
    this.$button = this.$('button').first();
    return this.domElement;
  };

  KDButtonViewWithMenu.prototype.setIconOnly = function() {
    var $icons;
    this.$().addClass('icon-only').removeClass('with-icon');
    $icons = this.$('span.icon,span.chevron');
    return this.$().html($icons);
  };

  KDButtonViewWithMenu.prototype.click = function(event) {
    if ($(event.target).is(".chevron")) {
      this.contextMenu(event);
      return false;
    }
    return this.getCallback().call(this, event);
  };

  KDButtonViewWithMenu.prototype.contextMenu = function(event) {
    this.createContextMenu(event);
    return false;
  };

  KDButtonViewWithMenu.prototype.createContextMenu = function(event) {
    var menuArrayToObj, menuObject, menuObjectProperty, menuObjectValue, o;
    o = this.getOptions();
    this.buttonMenu = new (o.buttonMenuClass || JButtonMenu)({
      cssClass: o.style,
      ghost: this.$('.chevron').clone(),
      event: event,
      delegate: this,
      treeItemClass: o.treeItemClass,
      itemChildClass: o.itemChildClass,
      itemChildOptions: o.itemChildOptions
    }, (function() {
      var _i, _len, _ref;
      if ("function" === typeof o.menu) {
        return o.menu();
      } else {
        if (o.menu instanceof Array) {
          menuArrayToObj = {};
          _ref = o.menu;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            menuObject = _ref[_i];
            for (menuObjectProperty in menuObject) {
              if (!__hasProp.call(menuObject, menuObjectProperty)) continue;
              menuObjectValue = menuObject[menuObjectProperty];
              if ((menuObjectProperty != null) && (menuObjectValue != null)) {
                menuArrayToObj[menuObjectProperty] = menuObjectValue;
              }
            }
          }
          return menuArrayToObj;
        } else {
          return o.menu;
        }
      }
    })());
    return this.buttonMenu.on("ContextMenuItemReceivedClick", (function(_this) {
      return function() {
        return _this.buttonMenu.destroy();
      };
    })(this));
  };

  KDButtonViewWithMenu.prototype.setTitle = function(title) {
    return this.$button.append(title);
  };

  KDButtonViewWithMenu.prototype.setButtonStyle = function(newStyle) {
    var style, styles, _i, _len;
    styles = this.constructor.styles;
    for (_i = 0, _len = styles.length; _i < _len; _i++) {
      style = styles[_i];
      this.$().removeClass(style);
      this.$button.removeClass(style);
    }
    this.$button.addClass(newStyle);
    return this.$().addClass(newStyle);
  };

  KDButtonViewWithMenu.prototype.setIconOnly = function() {
    var $icon;
    this.$button.addClass('icon-only').removeClass('with-icon');
    $icon = this.$('span.icon');
    return this.$button.html($icon);
  };

  KDButtonViewWithMenu.prototype.disable = function() {
    return this.$button.attr("disabled", true);
  };

  KDButtonViewWithMenu.prototype.enable = function() {
    return this.$button.attr("disabled", false);
  };

  return KDButtonViewWithMenu;

})(KDButtonView);


},{"./buttonview.coffee":20}],22:[function(require,module,exports){
var KDButtonView, KDToggleButton,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDButtonView = require('./buttonview.coffee');

module.exports = KDToggleButton = (function(_super) {
  __extends(KDToggleButton, _super);

  function KDToggleButton(options, data) {
    if (options == null) {
      options = {};
    }
    options = $.extend({
      dataPath: null,
      defaultState: null,
      states: []
    }, options);
    KDToggleButton.__super__.constructor.call(this, options, data);
    this.setState(options.defaultState);
  }

  KDToggleButton.prototype.getStateIndex = function(name) {
    var index, state, states, _i, _len;
    states = this.getOptions().states;
    if (!name) {
      return 0;
    } else {
      for (index = _i = 0, _len = states.length; _i < _len; index = ++_i) {
        state = states[index];
        if (name === state.title) {
          return index;
        }
      }
    }
  };

  KDToggleButton.prototype.decorateState = function(name) {
    this.setTitle(this.state.title);
    if (this.state.iconClass != null) {
      this.setIconClass(this.state.iconClass);
    }
    if ((this.state.cssClass != null) || (this.lastUsedCssClass != null)) {
      if (this.lastUsedCssClass != null) {
        this.unsetClass(this.lastUsedCssClass);
      }
      this.setClass(this.state.cssClass);
      return this.lastUsedCssClass = this.state.cssClass;
    } else {
      return delete this.lastUsedCssClass;
    }
  };

  KDToggleButton.prototype.getState = function() {
    return this.state;
  };

  KDToggleButton.prototype.setState = function(name) {
    var index, states;
    states = this.getOptions().states;
    this.stateIndex = index = this.getStateIndex(name);
    this.state = states[index];
    this.decorateState(name);
    return this.setCallback(states[index].callback.bind(this, this.toggleState.bind(this)));
  };

  KDToggleButton.prototype.toggleState = function(err) {
    var nextState, states;
    states = this.getOptions().states;
    nextState = states[this.stateIndex + 1] || states[0];
    if (!err) {
      this.setState(nextState.title);
    } else {
      if (err.name !== 'AccessDenied') {
        warn(err.message || ("There was an error, couldn't switch to " + nextState.title + " state!"));
      }
    }
    return typeof this.hideLoader === "function" ? this.hideLoader() : void 0;
  };

  return KDToggleButton;

})(KDButtonView);


},{"./buttonview.coffee":20}],23:[function(require,module,exports){
var JContextMenuTreeViewController, KDContextMenu, KDCustomHTMLView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

JContextMenuTreeViewController = require('./contextmenutreeviewcontroller.coffee');

module.exports = KDContextMenu = (function(_super) {
  __extends(KDContextMenu, _super);

  function KDContextMenu(options, data) {
    var o, _base, _base1, _ref;
    if (options == null) {
      options = {};
    }
    options.cssClass = this.utils.curry("kdcontextmenu", options.cssClass);
    options.menuMaxWidth || (options.menuMaxWidth = "auto");
    options.menuMinWidth || (options.menuMinWidth = "auto");
    options.menuWidth || (options.menuWidth = 172);
    options.offset || (options.offset = {});
    (_base = options.offset).left || (_base.left = 0);
    (_base1 = options.offset).top || (_base1.top = 0);
    if (options.arrow == null) {
      options.arrow = false;
    }
    if (options.sticky == null) {
      options.sticky = false;
    }
    KDContextMenu.__super__.constructor.call(this, options, data);
    this.topMargin = 0;
    this.leftMargin = 0;
    o = this.getOptions();
    this.sticky = o.sticky;
    KD.getSingleton("windowController").addLayer(this);
    this.on('ReceivedClickElsewhere', (function(_this) {
      return function() {
        if (!_this.sticky) {
          return _this.destroy();
        }
      };
    })(this));
    if (data) {
      this.treeController = new JContextMenuTreeViewController({
        type: o.type,
        view: o.view,
        delegate: this,
        treeItemClass: o.treeItemClass,
        listViewClass: o.listViewClass,
        itemChildClass: o.itemChildClass,
        itemChildOptions: o.itemChildOptions,
        addListsCollapsed: o.addListsCollapsed,
        putDepthInfo: o.putDepthInfo,
        lazyLoad: (_ref = o.lazyLoad) != null ? _ref : false
      }, data);
      this.addSubView(this.treeController.getView());
      this.treeController.getView().on('ReceivedClickElsewhere', (function(_this) {
        return function() {
          if (!_this.sticky) {
            return _this.destroy();
          }
        };
      })(this));
      this.treeController.on("NodeExpanded", this.bound("positionSubMenu"));
    }
    if (options.arrow) {
      this.on("viewAppended", this.bound("addArrow"));
    }
    this.appendToDomBody();
  }

  KDContextMenu.prototype.changeStickyState = function(state) {
    return this.sticky = state;
  };

  KDContextMenu.prototype.childAppended = function() {
    KDContextMenu.__super__.childAppended.apply(this, arguments);
    this.positionContextMenu();
    if (this.getOption("deferPositioning")) {
      return KD.utils.defer((function(_this) {
        return function() {
          return _this.positionContextMenu();
        };
      })(this));
    } else {
      return this.positionContextMenu();
    }
  };

  KDContextMenu.prototype.addArrow = function() {
    var o, rule, _ref;
    o = this.getOptions().arrow;
    o.placement || (o.placement = "top");
    if (o.margin == null) {
      o.margin = 0;
    }
    if ((_ref = o.placement) === 'top' || _ref === 'bottom') {
      o.margin += this.leftMargin;
    } else {
      o.margin += this.topMargin;
    }
    this.arrow = new KDCustomHTMLView({
      tagName: "span",
      cssClass: "arrow " + o.placement
    });
    this.arrow.$().css((function() {
      switch (o.placement) {
        case "top":
          rule = {};
          if (o.margin > 0) {
            rule.left = o.margin;
          } else {
            rule.right = -o.margin;
          }
          return rule;
        case "bottom":
          rule = {};
          if (o.margin > 0) {
            rule.left = o.margin;
          } else {
            rule.right = -o.margin;
          }
          return rule;
        case "right":
          rule = {};
          if (o.margin > 0) {
            rule.top = o.margin;
          } else {
            rule.bottom = -o.margin;
          }
          return rule;
        case "left":
          rule = {};
          if (o.margin > 0) {
            rule.top = o.margin;
          } else {
            rule.bottom = -o.margin;
          }
          return rule;
        default:
          return {};
      }
    })());
    return this.addSubView(this.arrow);
  };

  KDContextMenu.prototype.positionContextMenu = KD.utils.debounce(10, function() {
    var event, expectedLeft, expectedTop, left, mainHeight, mainWidth, menuHeight, menuMaxWidth, menuMinWidth, menuWidth, options, style, top;
    options = this.getOptions();
    event = options.event || {};
    mainHeight = window.innerHeight;
    mainWidth = window.innerWidth;
    menuWidth = options.menuWidth, menuHeight = options.menuHeight, menuMaxWidth = options.menuMaxWidth, menuMinWidth = options.menuMinWidth;
    if (menuHeight == null) {
      menuHeight = this.getHeight();
    }
    if (menuWidth == null) {
      menuWidth = this.getWidth();
    }
    top = (options.y || event.pageY || 0) + options.offset.top;
    left = (options.x || event.pageX || 0) + options.offset.left;
    expectedTop = top;
    expectedLeft = left;
    if (top + menuHeight > mainHeight) {
      top = mainHeight - menuHeight + options.offset.top;
    }
    if (left + menuWidth > mainWidth) {
      left = mainWidth - menuWidth + options.offset.left;
    }
    this.topMargin = expectedTop - top;
    this.leftMargin = expectedLeft - left;
    style = {
      width: "" + menuWidth + "px",
      top: top,
      left: left
    };
    if (menuMaxWidth) {
      style.maxWidth = "" + menuMaxWidth + "px";
    }
    if (menuMinWidth) {
      style.minWidth = "" + menuMinWidth + "px";
    }
    return this.getDomElement().css(style);
  });

  KDContextMenu.prototype.positionSubMenu = function(nodeView) {
    var children, expandView, fullViewHeight, fullViewWidth, id, _ref;
    _ref = nodeView.getData(), children = _ref.children, id = _ref.id;
    if (children) {
      expandView = this.treeController.listControllers[id].getView();
      fullViewHeight = expandView.getY() + expandView.getHeight();
      if (fullViewHeight > window.innerHeight) {
        expandView.$().css("bottom", 0);
      }
      fullViewWidth = expandView.getX() + expandView.getWidth();
      if (fullViewWidth > window.innerWidth) {
        expandView.$().css("left", -expandView.getWidth());
        return expandView.setClass("left-aligned");
      }
    }
  };

  return KDContextMenu;

})(KDView);


},{"./../../core/customhtmlview.coffee":97,"./../../core/view.coffee":106,"./contextmenutreeviewcontroller.coffee":26}],24:[function(require,module,exports){
var JContextMenuItem, JTreeItemView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

JTreeItemView = require('./../tree/treeitemview.coffee');

module.exports = JContextMenuItem = (function(_super) {
  __extends(JContextMenuItem, _super);

  function JContextMenuItem(options, data) {
    if (options == null) {
      options = {};
    }
    if (data == null) {
      data = {};
    }
    options.type = "contextitem";
    options.cssClass || (options.cssClass = "default");
    JContextMenuItem.__super__.constructor.call(this, options, data);
    this.unsetClass("jtreeitem");
    if (data) {
      if (data.type === "divider" || data.type === "separator") {
        this.setClass("separator");
      }
      if (data.cssClass) {
        this.setClass(data.cssClass);
      }
      if (data.type === "customView") {
        this.addCustomView(data);
      }
      if (data.disabled) {
        this.setClass("disabled");
      }
    }
  }

  JContextMenuItem.prototype.viewAppended = function() {
    if (!this.customView) {
      return JContextMenuItem.__super__.viewAppended.call(this);
    }
  };

  JContextMenuItem.prototype.mouseDown = function() {
    return true;
  };

  JContextMenuItem.prototype.addCustomView = function(data) {
    this.setClass("custom-view");
    this.unsetClass("default");
    this.customView = data.view || new KDView;
    delete data.view;
    return this.addSubView(this.customView);
  };

  return JContextMenuItem;

})(JTreeItemView);


},{"./../../core/view.coffee":106,"./../tree/treeitemview.coffee":86}],25:[function(require,module,exports){
var JContextMenuTreeView, JTreeView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

JTreeView = require('./../tree/treeview.coffee');

module.exports = JContextMenuTreeView = (function(_super) {
  __extends(JContextMenuTreeView, _super);

  function JContextMenuTreeView(options, data) {
    if (options == null) {
      options = {};
    }
    if (data == null) {
      data = {};
    }
    options.type || (options.type = "contextmenu");
    if (options.animated == null) {
      options.animated = false;
    }
    options.cssClass || (options.cssClass = "default");
    JContextMenuTreeView.__super__.constructor.call(this, options, data);
    this.unsetClass("jtreeview");
  }

  return JContextMenuTreeView;

})(JTreeView);


},{"./../tree/treeview.coffee":87}],26:[function(require,module,exports){
var JContextMenuItem, JContextMenuTreeView, JContextMenuTreeViewController, JTreeViewController, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

JTreeViewController = require('./../tree/treeviewcontroller.coffee');

JContextMenuItem = require('./contextmenuitem.coffee');

JContextMenuTreeView = require('./contextmenutreeview.coffee');

module.exports = JContextMenuTreeViewController = (function(_super) {

  /*
  STATIC CONTEXT
   */
  var convertToArray, getUId, uId;

  __extends(JContextMenuTreeViewController, _super);

  uId = 0;

  getUId = function() {
    return ++uId;
  };

  convertToArray = JContextMenuTreeViewController.convertToArray = function(items, pId) {
    var childrenArr, divider, id, newItem, options, results, title;
    if (pId == null) {
      pId = null;
    }
    results = [];
    for (title in items) {
      if (!__hasProp.call(items, title)) continue;
      options = items[title];
      id = null;
      if ((title.indexOf("customView")) === 0) {
        newItem = {
          type: 'customView',
          parentId: pId,
          view: options
        };
        results.push(newItem);
        continue;
      }
      if (options.children) {
        id = getUId();
        options.title = title;
        options.id = id;
        options.parentId = pId;
        results.push(options);
        childrenArr = convertToArray(options.children, id);
        results = results.concat(childrenArr);
        if (options.separator) {
          divider = {
            type: 'separator',
            parentId: pId
          };
          results.push(divider);
        }
        continue;
      }
      options.title = title;
      options.parentId = pId;
      results.push(options);
      if (options.separator) {
        divider = {
          type: 'separator',
          parentId: pId
        };
        results.push(divider);
      }
    }
    return results;
  };


  /*
  INSTANCE LEVEL
   */

  function JContextMenuTreeViewController(options, data) {
    var o;
    if (options == null) {
      options = {};
    }
    o = options;
    o.view || (o.view = new KDView({
      cssClass: "context-list-wrapper"
    }));
    o.type || (o.type = "contextmenu");
    o.treeItemClass || (o.treeItemClass = JContextMenuItem);
    o.listViewClass || (o.listViewClass = JContextMenuTreeView);
    if (o.addListsCollapsed == null) {
      o.addListsCollapsed = true;
    }
    if (o.putDepthInfo == null) {
      o.putDepthInfo = true;
    }
    JContextMenuTreeViewController.__super__.constructor.call(this, o, data);
    this.expandedNodes = [];
  }

  JContextMenuTreeViewController.prototype.loadView = function() {
    JContextMenuTreeViewController.__super__.loadView.apply(this, arguments);
    if (!this.getOptions().lazyLoad) {
      return this.selectFirstNode();
    }
  };

  JContextMenuTreeViewController.prototype.initTree = function(nodes) {
    if (!nodes.length) {
      this.setData(nodes = convertToArray(nodes));
    }
    return JContextMenuTreeViewController.__super__.initTree.call(this, nodes);
  };


  /*
  Helpers
   */

  JContextMenuTreeViewController.prototype.repairIds = function(nodeData) {
    if (nodeData.type === "divider") {
      nodeData.type = "separator";
    }
    return JContextMenuTreeViewController.__super__.repairIds.apply(this, arguments);
  };


  /*
  EXPAND / COLLAPSE
   */

  JContextMenuTreeViewController.prototype.expand = function(nodeView) {
    JContextMenuTreeViewController.__super__.expand.apply(this, arguments);
    this.emit("NodeExpanded", nodeView);
    if (nodeView.expanded) {
      return this.expandedNodes.push(nodeView);
    }
  };


  /*
  NODE SELECTION
   */

  JContextMenuTreeViewController.prototype.organizeSelectedNodes = function(listController, nodes, event) {
    var depth1, nodeView;
    if (event == null) {
      event = {};
    }
    nodeView = nodes[0];
    if (this.expandedNodes.length) {
      depth1 = nodeView.getData().depth;
      this.expandedNodes.forEach((function(_this) {
        return function(expandedNode) {
          var depth2;
          depth2 = expandedNode.getData().depth;
          if (depth1 <= depth2) {
            return _this.collapse(expandedNode);
          }
        };
      })(this));
    }
    return JContextMenuTreeViewController.__super__.organizeSelectedNodes.apply(this, arguments);
  };


  /*
  re-HANDLING MOUSE EVENTS
   */

  JContextMenuTreeViewController.prototype.dblClick = function(nodeView, event) {};

  JContextMenuTreeViewController.prototype.mouseEnter = function(nodeView, event) {
    var nodeData;
    if (this.mouseEnterTimeOut) {
      clearTimeout(this.mouseEnterTimeOut);
    }
    nodeData = nodeView.getData();
    if (nodeData.type !== "separator") {
      this.selectNode(nodeView, event);
      return this.mouseEnterTimeOut = setTimeout((function(_this) {
        return function() {
          return _this.expand(nodeView);
        };
      })(this), 150);
    }
  };

  JContextMenuTreeViewController.prototype.click = function(nodeView, event) {
    var contextMenu, nodeData;
    nodeData = nodeView.getData();
    if (nodeData.type === "separator" || nodeData.disabled) {
      return;
    }
    this.toggle(nodeView);
    contextMenu = this.getDelegate();
    if (nodeData.callback && "function" === typeof nodeData.callback) {
      nodeData.callback.call(contextMenu, nodeView, event);
    }
    contextMenu.emit("ContextMenuItemReceivedClick", nodeView);
    event.stopPropagation();
    return false;
  };


  /*
  re-HANDLING KEY EVENTS
   */

  JContextMenuTreeViewController.prototype.performDownKey = function(nodeView, event) {
    var nextNode, nodeData;
    nextNode = JContextMenuTreeViewController.__super__.performDownKey.call(this, nodeView, event);
    if (nextNode) {
      nodeData = nextNode.getData();
      if (nodeData.type === "separator") {
        return this.performDownKey(nextNode, event);
      }
    }
  };

  JContextMenuTreeViewController.prototype.performUpKey = function(nodeView, event) {
    var nextNode, nodeData;
    nextNode = JContextMenuTreeViewController.__super__.performUpKey.call(this, nodeView, event);
    if (nextNode) {
      nodeData = nextNode.getData();
      if (nodeData.type === "separator") {
        this.performUpKey(nextNode, event);
      }
    }
    return nextNode;
  };

  JContextMenuTreeViewController.prototype.performRightKey = function(nodeView, event) {
    JContextMenuTreeViewController.__super__.performRightKey.apply(this, arguments);
    return this.performDownKey(nodeView, event);
  };

  JContextMenuTreeViewController.prototype.performLeftKey = function(nodeView, event) {
    var parentNode;
    parentNode = JContextMenuTreeViewController.__super__.performLeftKey.call(this, nodeView, event);
    if (parentNode) {
      this.collapse(parentNode);
    }
    return parentNode;
    return nextNode;
  };

  JContextMenuTreeViewController.prototype.performEscapeKey = function(nodeView, event) {
    KD.getSingleton("windowController").revertKeyView();
    return this.getDelegate().destroy();
  };

  JContextMenuTreeViewController.prototype.performEnterKey = function(nodeView, event) {
    var contextMenu;
    KD.getSingleton("windowController").revertKeyView();
    contextMenu = this.getDelegate();
    contextMenu.emit("ContextMenuItemReceivedClick", nodeView);
    contextMenu.destroy();
    event.stopPropagation();
    event.preventDefault();
    return false;
  };

  return JContextMenuTreeViewController;

})(JTreeViewController);


},{"./../../core/view.coffee":106,"./../tree/treeviewcontroller.coffee":88,"./contextmenuitem.coffee":24,"./contextmenutreeview.coffee":25}],27:[function(require,module,exports){
var KDCounterDigitView, KDCustomHTMLView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

module.exports = KDCounterDigitView = (function(_super) {
  __extends(KDCounterDigitView, _super);

  function KDCounterDigitView(options, data) {
    if (options == null) {
      options = {};
    }
    if (data == null) {
      data = {};
    }
    options.tagName = "ul";
    if (options.initialValue == null) {
      options.initialValue = 0;
    }
    KDCounterDigitView.__super__.constructor.call(this, options, data);
    this.currentValue = options.initialValue;
    this.createDigit();
  }

  KDCounterDigitView.prototype.createDigit = function() {
    this.addSubView(this.digit = new KDCustomHTMLView({
      tagName: "li",
      cssClass: "real",
      partial: "<span class=\"top\">" + (this.getOption('initialValue')) + "</span>\n<span class=\"bottom\">" + (this.getOption('initialValue')) + "</span>"
    }));
    this.addSubView(this.fakeDigit = new KDCustomHTMLView({
      tagName: "li",
      cssClass: "fake",
      partial: "<span class=\"top\">" + (this.getOption('initialValue')) + "</span>\n<span class=\"bottom\">" + (this.getOption('initialValue')) + "</span>"
    }));
    return this.setValue(this.getOption("initialValue"));
  };

  KDCounterDigitView.prototype.setValue = function(value) {
    if (value === this.currentValue) {
      return;
    }
    this.currentValue = value;
    this.digit.updatePartial("<span class=\"top\">" + value + "</span>\n<span class=\"bottom\">" + value + "</span>");
    this.setClass("animate");
    return KD.utils.wait(500, (function(_this) {
      return function() {
        _this.fakeDigit.updatePartial("<span class=\"top\">" + value + "</span>\n<span class=\"bottom\">" + value + "</span>");
        return _this.unsetClass("animate");
      };
    })(this));
  };

  return KDCounterDigitView;

})(KDCustomHTMLView);


},{"./../../core/customhtmlview.coffee":97}],28:[function(require,module,exports){
var KDCounterDigitView, KDCounterView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDCounterDigitView = require('./counterdigitview.coffee');

module.exports = KDCounterView = (function(_super) {
  __extends(KDCounterView, _super);

  function KDCounterView(options, data) {
    if (options == null) {
      options = {};
    }
    if (data == null) {
      data = {};
    }
    if (options.style == null) {
      options.style = "dark";
    }
    if (options.from == null) {
      options.from = 5000;
    }
    if (options.to == null) {
      options.to = 10000;
    }
    if (options.interval == null) {
      options.interval = 1000;
    }
    if (options.step == null) {
      options.step = 1;
    }
    if (options.autoStart == null) {
      options.autoStart = true;
    }
    options.direction = options.from < options.to ? "up" : "down";
    if (options.digits == null) {
      options.digits = options.direction === "up" ? options.to.toString().length : options.from.toString().length;
    }
    options.cssClass = KD.utils.curry("" + options.style + " " + options.direction + " kd-counter", options.cssClass);
    KDCounterView.__super__.constructor.call(this, options, data);
    this.digitsList = [];
    this.currentValue = options.from;
    this.createCounter();
    if (options.autoStart) {
      this.start();
    }
  }

  KDCounterView.prototype.createCounter = function() {
    var digits, from, i, _i, _ref, _results;
    _ref = this.getOptions(), from = _ref.from, digits = _ref.digits;
    _results = [];
    for (i = _i = 0; 0 <= digits ? _i < digits : _i > digits; i = 0 <= digits ? ++_i : --_i) {
      _results.push(this.digitsList.push(this.addSubView(new KDCounterDigitView({
        initialValue: from.toString()[i]
      }))));
    }
    return _results;
  };

  KDCounterView.prototype.setValue = function(value) {
    var i, _i, _ref, _results;
    if (value === this.currentValue) {
      return;
    }
    this.currentValue = value;
    value = value.toString();
    _results = [];
    for (i = _i = 0, _ref = value.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      _results.push(this.digitsList[i].setValue(value[i]));
    }
    return _results;
  };

  KDCounterView.prototype.start = function() {
    var timer;
    timer = this.getOption("interval");
    return this.counterInterval = KD.utils.repeat(timer, (function(_this) {
      return function() {
        var newValue;
        if (_this.getOption("direction") === "up") {
          newValue = _this.currentValue + _this.getOption("step");
        } else {
          newValue = _this.currentValue - _this.getOption("step");
        }
        _this.setValue(newValue);
        return _this.currentValue = newValue;
      };
    })(this));
  };

  return KDCounterView;

})(KDView);


},{"./../../core/view.coffee":106,"./counterdigitview.coffee":27}],29:[function(require,module,exports){
var KDDiaContainer, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDDiaContainer = (function(_super) {
  __extends(KDDiaContainer, _super);

  function KDDiaContainer(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry('kddia-container', options.cssClass);
    if (options.draggable) {
      if ('object' !== typeof options.draggable) {
        options.draggable = {};
      }
    }
    if (options.itemClass == null) {
      options.itemClass = KDDiaObject;
    }
    KDDiaContainer.__super__.constructor.call(this, options, data);
    this.scale = 1;
    this.dias = {};
  }

  KDDiaContainer.prototype.mouseDown = function() {
    var dia, key;
    KDDiaContainer.__super__.mouseDown.apply(this, arguments);
    return this.emit("HighlightDia", (function() {
      var _ref, _results;
      _ref = this.dias;
      _results = [];
      for (key in _ref) {
        dia = _ref[key];
        _results.push(dia);
      }
      return _results;
    }).call(this));
  };

  KDDiaContainer.prototype.addDia = function(diaObj, pos) {
    if (pos == null) {
      pos = {};
    }
    this.addSubView(diaObj);
    diaObj.on("DiaObjectClicked", (function(_this) {
      return function() {
        return _this.emit("HighlightDia", diaObj);
      };
    })(this));
    diaObj.on("RemoveMyConnections", (function(_this) {
      return function() {
        return delete _this.dias[diaObj.getId()];
      };
    })(this));
    this.dias[diaObj.getId()] = diaObj;
    this.emit("NewDiaObjectAdded", this, diaObj);
    if (pos.x != null) {
      diaObj.setX(pos.x);
    }
    if (pos.y != null) {
      diaObj.setY(pos.y);
    }
    return diaObj;
  };

  KDDiaContainer.prototype.addItem = function(data, options) {
    var itemClass;
    if (options == null) {
      options = {};
    }
    itemClass = this.getOption('itemClass');
    return this.addDia(new itemClass(options, data));
  };

  KDDiaContainer.prototype.removeAllItems = function() {
    var dia, _key, _ref, _results;
    _ref = this.dias;
    _results = [];
    for (_key in _ref) {
      dia = _ref[_key];
      _results.push(typeof dia.destroy === "function" ? dia.destroy() : void 0);
    }
    return _results;
  };

  KDDiaContainer.prototype.setScale = function(scale) {
    var css, prop, props, _i, _len;
    if (scale == null) {
      scale = 1;
    }
    if (scale === this.scale) {
      return;
    }
    props = ['webkitTransform', 'MozTransform', 'transform'];
    css = {};
    for (_i = 0, _len = props.length; _i < _len; _i++) {
      prop = props[_i];
      css[prop] = "scale(" + scale + ")";
    }
    this.setStyle(css);
    return this.scale = scale;
  };

  return KDDiaContainer;

})(KDView);


},{"./../../core/view.coffee":106}],30:[function(require,module,exports){
var KDDiaJoint, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDView = require('./../../core/view.coffee');

module.exports = KDDiaJoint = (function(_super) {
  var types;

  __extends(KDDiaJoint, _super);

  types = ['left', 'right', 'top', 'bottom'];

  function KDDiaJoint(options, data) {
    var _ref;
    if (options == null) {
      options = {};
    }
    options.type || (options.type = 'left');
    if (_ref = options.type, __indexOf.call(types, _ref) < 0) {
      warn("Unknown joint type '" + options.type + "', falling back to 'left'");
      options.type = 'left';
    }
    if (options["static"] == null) {
      options["static"] = false;
    }
    if (options.size == null) {
      options.size = 10;
    }
    options.cssClass = KD.utils.curry("kddia-joint " + options.type, options.cssClass);
    KDDiaJoint.__super__.constructor.call(this, options, data);
    this.connections = {};
    this.type = this.getOption('type');
    this.size = this.getOption('size');
  }

  KDDiaJoint.prototype.viewAppended = function() {
    KDDiaJoint.__super__.viewAppended.apply(this, arguments);
    return this.domElement.attr("dia-id", this.getDiaId());
  };

  KDDiaJoint.prototype.getDiaId = function() {
    return "dia-" + (this.parent.getId()) + "-joint-" + this.type;
  };

  KDDiaJoint.prototype.getPos = function() {
    return this.parent.getJointPos(this);
  };

  KDDiaJoint.prototype.click = function(e) {
    if (this.inDeleteMode()) {
      this.emit('DeleteRequested', this.parent, this.type);
    }
    return this.utils.stopDOMEvent(e);
  };

  KDDiaJoint.prototype.mouseDown = function(e) {
    if (this.inDeleteMode()) {
      return;
    }
    this.utils.stopDOMEvent(e);
    this.parent.emit("JointRequestsLine", this);
    return false;
  };

  KDDiaJoint.prototype.inDeleteMode = function() {
    return this.hasClass('deleteMode');
  };

  KDDiaJoint.prototype.showDeleteButton = function() {
    if (!this.isStatic()) {
      return this.setClass('deleteMode');
    }
  };

  KDDiaJoint.prototype.hideDeleteButton = function() {
    return this.unsetClass('deleteMode');
  };

  KDDiaJoint.prototype.isStatic = function() {
    return this.getOption('static');
  };

  return KDDiaJoint;

})(KDView);


},{"./../../core/view.coffee":106}],31:[function(require,module,exports){
var KDDiaObject, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDView = require('./../../core/view.coffee');

module.exports = KDDiaObject = (function(_super) {
  __extends(KDDiaObject, _super);

  function KDDiaObject(options, data) {
    var _base, _base1, _base2;
    options.cssClass = KD.utils.curry('kddia-object', options.cssClass);
    if (options.draggable == null) {
      if ('object' !== typeof options.draggable) {
        options.draggable = {};
      }
      (_base = options.draggable).containment || (_base.containment = {});
      (_base1 = options.draggable.containment).view || (_base1.view = 'parent');
      if ((_base2 = options.draggable.containment).padding == null) {
        _base2.padding = {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1
        };
      }
    }
    options.bind = KD.utils.curry('mouseleave', options.bind);
    if (options.joints == null) {
      options.joints = ['left', 'right'];
    }
    if (options.jointItemClass == null) {
      options.jointItemClass = KDDiaJoint;
    }
    options.allowedConnections || (options.allowedConnections = {});
    options.staticJoints || (options.staticJoints = []);
    KDDiaObject.__super__.constructor.call(this, options, data);
    this.joints = {};
    this.allowedConnections = this.getOption('allowedConnections');
    this.domElement.attr("dia-id", "dia-" + (this.getId()));
    this.wc = KD.getSingleton('windowController');
    this.on("KDObjectWillBeDestroyed", (function(_this) {
      return function() {
        return _this.emit('RemoveMyConnections');
      };
    })(this));
    this.once('viewAppended', (function(_this) {
      return function() {
        var joint, _i, _len, _ref;
        _ref = _this.getOption('joints');
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          joint = _ref[_i];
          _this.addJoint(joint);
        }
        return _this.parent.on('UnhighlightDias', function() {
          var key, _ref1, _results;
          _this.unsetClass('highlight');
          _ref1 = _this.joints;
          _results = [];
          for (key in _ref1) {
            joint = _ref1[key];
            _results.push(joint.hideDeleteButton());
          }
          return _results;
        });
      };
    })(this));
  }

  KDDiaObject.prototype.mouseDown = function(e) {
    this.emit("DiaObjectClicked");
    this._mouseDown = true;
    this.wc.once('ReceivedMouseUpElsewhere', (function(_this) {
      return function() {
        return _this._mouseDown = false;
      };
    })(this));
    if (!this.getOption('draggable')) {
      return this.utils.stopDOMEvent(e);
    }
  };

  KDDiaObject.prototype.mouseLeave = function(e) {
    var bounds, joint;
    if (!this._mouseDown) {
      return;
    }
    bounds = this.getBounds();
    joint = null;
    bounds.w = bounds.w * this.parent.scale;
    bounds.h = bounds.h * this.parent.scale;
    if (e.pageX >= bounds.x + bounds.w) {
      joint = this.joints['right'];
    }
    if (e.pageX <= bounds.x) {
      joint = this.joints['left'];
    }
    if (e.pageY >= bounds.y + bounds.h) {
      joint = this.joints['bottom'];
    }
    if (e.pageY <= bounds.y) {
      joint = this.joints['top'];
    }
    if (joint) {
      return this.emit("JointRequestsLine", joint);
    }
  };

  KDDiaObject.prototype.addJoint = function(type) {
    var joint, jointItemClass, staticJoints, _base, _ref;
    if (this.joints[type] != null) {
      warn("KDDiaObject: Tried to add same joint! Destroying old one. ");
      if (typeof (_base = this.joints[type]).destroy === "function") {
        _base.destroy();
      }
    }
    _ref = this.getOptions(), jointItemClass = _ref.jointItemClass, staticJoints = _ref.staticJoints;
    this.addSubView(joint = new jointItemClass({
      type: type,
      "static": __indexOf.call(staticJoints, type) >= 0
    }));
    return this.joints[type] = joint;
  };

  KDDiaObject.prototype.getJointPos = function(joint) {
    var dx, dy, j, jx, jy, p, s, x, y, _ref, _ref1, _ref2, _ref3, _ref4;
    if (typeof joint === "string") {
      joint = this.joints[joint];
    }
    if (!joint) {
      return {
        x: 0,
        y: 0
      };
    }
    _ref = [this.parent.getElement(), this.getElement(), joint.getElement()], p = _ref[0], s = _ref[1], j = _ref[2];
    _ref1 = [p.offsetLeft + s.offsetLeft, p.offsetTop + s.offsetTop], x = _ref1[0], y = _ref1[1];
    _ref2 = [j.offsetLeft, j.offsetTop], jx = _ref2[0], jy = _ref2[1];
    _ref4 = (_ref3 = joint.type) === 'left' || _ref3 === 'right' ? [10, 4] : [4, 10], dx = _ref4[0], dy = _ref4[1];
    return {
      x: x + jx + dx,
      y: y + jy + dy
    };
  };

  KDDiaObject.prototype.getDiaId = function() {
    return this.domElement.attr("dia-id");
  };

  return KDDiaObject;

})(KDView);


},{"./../../core/view.coffee":106}],32:[function(require,module,exports){
var KDCustomHTMLView, KDDiaScene, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDView = require('./../../core/view.coffee');

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

module.exports = KDDiaScene = (function(_super) {
  __extends(KDDiaScene, _super);

  function KDDiaScene(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry("kddia-scene", options.cssClass);
    options.bind = KD.utils.curry("mousemove", options.bind);
    options.lineCap || (options.lineCap = "round");
    if (options.lineWidth == null) {
      options.lineWidth = 2;
    }
    options.lineColor || (options.lineColor = "#ccc");
    options.lineColorActive || (options.lineColorActive = "orange");
    if (options.lineDashes == null) {
      options.lineDashes = [];
    }
    options.fakeLineColor || (options.fakeLineColor = "green");
    if (options.fakeLineDashes == null) {
      options.fakeLineDashes = [];
    }
    if (options.curveDistance == null) {
      options.curveDistance = 50;
    }
    KDDiaScene.__super__.constructor.apply(this, arguments);
    this.containers = [];
    this.connections = [];
    this.activeDias = [];
    this.activeJoints = [];
    this.fakeConnections = [];
  }

  KDDiaScene.prototype.diaAdded = function(container, diaObj) {
    diaObj.on("JointRequestsLine", this.bound("handleLineRequest"));
    diaObj.on("DragInAction", (function(_this) {
      return function() {
        return _this.highlightLines(diaObj);
      };
    })(this));
    return diaObj.on("RemoveMyConnections", (function(_this) {
      return function() {
        return _this.disconnectAllConnections(diaObj);
      };
    })(this));
  };

  KDDiaScene.prototype.addContainer = function(container, pos) {
    var padding, _ref, _ref1, _ref2, _ref3;
    if (pos == null) {
      pos = {};
    }
    this.addSubView(container);
    container.on("NewDiaObjectAdded", this.bound("diaAdded"));
    container.on("DragInAction", this.bound("updateScene"));
    container.on("UpdateScene", this.bound("updateScene"));
    container.on("HighlightDia", this.bound("highlightLines"));
    this.containers.push(container);
    padding = (_ref = container.getOption('draggable')) != null ? (_ref1 = _ref.containment) != null ? _ref1.padding : void 0 : void 0;
    if (padding) {
      pos.x = Math.max(padding, (_ref2 = pos.x) != null ? _ref2 : 0);
      pos.y = Math.max(padding, (_ref3 = pos.y) != null ? _ref3 : 0);
    }
    if (pos.x != null) {
      container.setX(pos.x);
    }
    if (pos.y != null) {
      container.setY(pos.y);
    }
    return this.createCanvas();
  };

  KDDiaScene.prototype.drawFakeLine = function(options) {
    var ex, ey, lineDashes, sx, sy;
    if (options == null) {
      options = {};
    }
    sx = options.sx, sy = options.sy, ex = options.ex, ey = options.ey;
    this.cleanup(this.fakeCanvas);
    this.fakeContext.beginPath();
    this.fakeContext.moveTo(sx, sy);
    this.fakeContext.lineTo(ex, ey);
    this.fakeContext.lineCap = this.getOption("lineCap");
    this.fakeContext.lineWidth = this.getOption("lineWidth");
    this.fakeContext.strokeStyle = this._trackJoint.parent.getOption('colorTag') || this.getOption("fakeLineColor");
    lineDashes = this.getOption("fakeLineDashes");
    if (lineDashes.length > 0) {
      this.fakeContext.setLineDash(lineDashes);
    }
    return this.fakeContext.stroke();
  };

  KDDiaScene.prototype.click = function(e) {
    if (e.target !== e.currentTarget) {
      return;
    }
    return this.highlightLines();
  };

  KDDiaScene.prototype.mouseMove = function(e) {
    var ex, ey, x, y, _ref;
    if (!this._trackJoint) {
      return;
    }
    _ref = this._trackJoint.getPos(), x = _ref.x, y = _ref.y;
    ex = x + (e.clientX - this._trackJoint.getX());
    ey = y + (e.clientY - this._trackJoint.getY());
    return this.drawFakeLine({
      sx: x,
      sy: y,
      ex: ex,
      ey: ey
    });
  };

  KDDiaScene.prototype.mouseUp = function(e) {
    var source, sourceId, target, targetId;
    if (!this._trackJoint) {
      return;
    }
    targetId = $(e.target).closest(".kddia-object").attr("dia-id");
    sourceId = this._trackJoint.getDiaId();
    delete this._trackJoint;
    this.cleanup(this.fakeCanvas);
    if (!targetId) {
      return;
    }
    source = this.getDia(sourceId);
    target = this.getDia(targetId);
    if (!target.joint) {
      target.joint = this.guessJoint(target, source);
    }
    if (target.joint) {
      return this.connect(source, target);
    }
  };

  KDDiaScene.prototype.guessJoint = function(target, source) {
    if (source.joint === "right" && (target.dia.joints.left != null)) {
      return "left";
    }
    if (source.joint === "left" && (target.dia.joints.right != null)) {
      return "right";
    }
  };

  KDDiaScene.prototype.getDia = function(id) {
    var container, dia, joint, objId, parts, _i, _len, _ref, _ref1;
    parts = (id.match(/dia\-((.*)\-joint\-(.*)|(.*))/)).filter(function(m) {
      return !!m;
    });
    if (!parts) {
      return null;
    }
    _ref = parts.slice(-2), objId = _ref[0], joint = _ref[1];
    if (objId === joint) {
      joint = null;
    }
    _ref1 = this.containers;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      container = _ref1[_i];
      if (dia = container.dias[objId]) {
        break;
      }
    }
    return {
      dia: dia,
      joint: joint,
      container: container
    };
  };

  KDDiaScene.prototype.highlightLines = function(dia, update) {
    var connection, container, joint, source, target, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
    if (dia == null) {
      dia = [];
    }
    if (update == null) {
      update = true;
    }
    if (!Array.isArray(dia)) {
      dia = [dia];
    }
    this.activeDias = dia;
    _ref = this.activeJoints;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      joint = _ref[_i];
      joint.off('DeleteRequested');
    }
    _ref1 = this.containers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      container = _ref1[_j];
      container.emit('UnhighlightDias');
    }
    this.activeJoints = [];
    if (update) {
      this.updateScene();
    }
    if (this.activeDias.length !== 1) {
      return;
    }
    dia = dia.first;
    _ref2 = this.connections;
    _results = [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      connection = _ref2[_k];
      source = connection.source, target = connection.target;
      if ((source.dia === dia) || (target.dia === dia)) {
        _results.push([source, target].forEach((function(_this) {
          return function(conn) {
            conn.dia.setClass('highlight');
            if (conn.dia !== dia) {
              joint = conn.dia.joints[conn.joint];
              if (__indexOf.call(_this.activeJoints, joint) < 0) {
                joint.showDeleteButton();
                joint.on('DeleteRequested', _this.bound('disconnect'));
                return _this.activeJoints.push(joint);
              }
            }
          };
        })(this)));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  KDDiaScene.prototype.handleLineRequest = function(joint) {
    return this._trackJoint = joint;
  };

  KDDiaScene.prototype.findTargetConnection = function(dia, joint) {
    var activeDia, conn, isEqual, _i, _len, _ref;
    isEqual = (function(_this) {
      return function(connection) {
        return (dia === connection.dia) && (joint === connection.joint);
      };
    })(this);
    activeDia = this.activeDias.first;
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      conn = _ref[_i];
      if (((isEqual(conn.source)) || (isEqual(conn.target))) && ((conn.source.dia === activeDia) || (conn.target.dia === activeDia))) {
        return conn;
      }
    }
  };

  KDDiaScene.prototype.disconnect = function(dia, joint) {
    var c, connectionsToDelete;
    if (this.activeDias.length !== 1) {
      return;
    }
    connectionsToDelete = this.findTargetConnection(dia, joint);
    this.connections = (function() {
      var _i, _len, _ref, _results;
      _ref = this.connections;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (c !== connectionsToDelete) {
          _results.push(c);
        }
      }
      return _results;
    }).call(this);
    return this.highlightLines(this.activeDias);
  };

  KDDiaScene.prototype.disconnectAllConnections = function(dia) {
    var connection, newConnections, source, target, _i, _len, _ref, _ref1;
    newConnections = [];
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      source = connection.source, target = connection.target;
      if ((_ref1 = dia.getDiaId()) !== source.dia.getDiaId() && _ref1 !== target.dia.getDiaId()) {
        newConnections.push(connection);
      }
    }
    this.connections = newConnections;
    return this.highlightLines();
  };

  KDDiaScene.prototype.allowedToConnect = function(source, target) {
    var allowList, i, restrictions, _i, _ref, _ref1, _ref2, _ref3;
    if (!(source && target)) {
      return false;
    }
    if (((_ref = source.dia) != null ? _ref.id : void 0) === ((_ref1 = target.dia) != null ? _ref1.id : void 0)) {
      return false;
    }
    for (i = _i = 0; _i <= 1; i = ++_i) {
      if ((source.dia.allowedConnections != null) && Object.keys(source.dia.allowedConnections).length > 0) {
        allowList = source.dia.allowedConnections;
        restrictions = allowList[target.dia.constructor.name];
        if (!restrictions) {
          return false;
        }
        if (_ref2 = source.joint, __indexOf.call(restrictions, _ref2) >= 0) {
          return false;
        }
      }
      _ref3 = [target, source], source = _ref3[0], target = _ref3[1];
    }
    return true;
  };

  KDDiaScene.prototype.connect = function(source, target, update) {
    if (update == null) {
      update = true;
    }
    if (!this.allowedToConnect(source, target)) {
      return;
    }
    this.emit("ConnectionCreated", source, target);
    this.connections.push({
      source: source,
      target: target
    });
    return this.highlightLines(target.dia, update);
  };

  KDDiaScene.prototype.resetScene = function() {
    this.fakeConnections = [];
    return this.updateScene();
  };

  KDDiaScene.prototype.updateScene = function() {
    var connection, _i, _j, _len, _len1, _ref, _ref1, _results;
    this.cleanup(this.realCanvas);
    _ref = this.connections;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      connection = _ref[_i];
      this.drawConnectionLine(connection);
    }
    _ref1 = this.fakeConnections;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      connection = _ref1[_j];
      _results.push(this.drawConnectionLine(connection));
    }
    return _results;
  };

  KDDiaScene.prototype.drawConnectionLine = function(_arg) {
    var activeColor, activeDia, cd, lineColor, lineDashes, options, sJoint, source, sx, sy, tJoint, target, tx, ty, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
    source = _arg.source, target = _arg.target, options = _arg.options;
    if (!(source || target)) {
      return;
    }
    options || (options = {});
    activeColor = this.getOption('lineColorActive');
    lineDashes = this.getOption('lineDashes');
    lineColor = this.getOption('lineColor');
    this.realContext.beginPath();
    activeDia = (_ref = source.dia, __indexOf.call(this.activeDias, _ref) >= 0) ? source : (_ref1 = target.dia, __indexOf.call(this.activeDias, _ref1) >= 0) ? target : void 0;
    if (activeDia) {
      lineColor = options.lineColor || (activeDia.dia.getOption('colorTag')) || activeColor;
      lineDashes = options.lineDashes || (activeDia.dia.getOption('lineDashes')) || lineDashes;
    }
    sJoint = source.dia.getJointPos(source.joint);
    tJoint = target.dia.getJointPos(target.joint);
    this.realContext.strokeStyle = lineColor;
    if (lineDashes.length > 0) {
      this.realContext.setLineDash(lineDashes);
    }
    this.realContext.moveTo(sJoint.x, sJoint.y);
    cd = this.getOption('curveDistance');
    _ref2 = [0, 0, 0, 0], sx = _ref2[0], sy = _ref2[1], tx = _ref2[2], ty = _ref2[3];
    if ((_ref3 = source.joint) === "top" || _ref3 === "bottom") {
      sy = source.joint === "top" ? -cd : cd;
    } else if ((_ref4 = source.joint) === "left" || _ref4 === "right") {
      sx = source.joint === "left" ? -cd : cd;
    }
    if ((_ref5 = target.joint) === "top" || _ref5 === "bottom") {
      ty = target.joint === "top" ? -cd : cd;
    } else if ((_ref6 = target.joint) === "left" || _ref6 === "right") {
      tx = target.joint === "left" ? -cd : cd;
    }
    this.realContext.bezierCurveTo(sJoint.x + sx, sJoint.y + sy, tJoint.x + tx, tJoint.y + ty, tJoint.x, tJoint.y);
    this.realContext.lineWidth = this.getOption('lineWidth');
    return this.realContext.stroke();
  };

  KDDiaScene.prototype.addFakeConnection = function(connection) {
    this.drawConnectionLine(connection);
    return this.fakeConnections.push(connection);
  };

  KDDiaScene.prototype.createCanvas = function() {
    var _ref, _ref1;
    if ((_ref = this.realCanvas) != null) {
      _ref.destroy();
    }
    if ((_ref1 = this.fakeCanvas) != null) {
      _ref1.destroy();
    }
    this.addSubView(this.realCanvas = new KDCustomHTMLView({
      tagName: "canvas",
      attributes: this.getSceneSize()
    }));
    this.realContext = this.realCanvas.getElement().getContext("2d");
    if (this.realContext.setLineDash == null) {
      this.realContext.setLineDash = noop;
    }
    this.addSubView(this.fakeCanvas = new KDCustomHTMLView({
      tagName: "canvas",
      cssClass: "fakeCanvas",
      attributes: this.getSceneSize()
    }));
    return this.fakeContext = this.fakeCanvas.getElement().getContext("2d");
  };

  KDDiaScene.prototype.setScale = function(scale) {
    var container, _i, _len, _ref;
    if (scale == null) {
      scale = 1;
    }
    _ref = this.containers;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      container = _ref[_i];
      container.setScale(scale);
    }
    return this.updateScene();
  };

  KDDiaScene.prototype.cleanup = function(canvas) {
    return canvas.setAttributes(this.getSceneSize());
  };

  KDDiaScene.prototype.parentDidResize = function() {
    KDDiaScene.__super__.parentDidResize.apply(this, arguments);
    return _.throttle((function(_this) {
      return function() {
        return _this.updateScene();
      };
    })(this))();
  };

  KDDiaScene.prototype.getSceneSize = function() {
    return {
      width: this.getWidth(),
      height: this.getHeight()
    };
  };

  KDDiaScene.prototype.dumpScene = function() {
    return log(this.containers, this.connections);
  };

  KDDiaScene.prototype.reset = function(update) {
    if (update == null) {
      update = true;
    }
    this.connections = [];
    this.fakeConnections = [];
    if (update) {
      return this.updateScene();
    }
  };

  return KDDiaScene;

})(KDView);


},{"./../../core/customhtmlview.coffee":97,"./../../core/view.coffee":106}],33:[function(require,module,exports){
var KDButtonView, KDDialogView, KDOverlayView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDOverlayView = require('./../overlay/overlayview.coffee');

KDButtonView = require('./../buttons/buttonview.coffee');

module.exports = KDDialogView = (function(_super) {
  __extends(KDDialogView, _super);

  function KDDialogView(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry('kddialogview', options.cssClass);
    if (options.offset == null) {
      options.offset = true;
    }
    options.container || (options.container = null);
    options.buttons || (options.buttons = {
      Cancel: {
        style: 'clean-red',
        callback: this.bound('hide')
      }
    });
    KDDialogView.__super__.constructor.call(this, options, data);
    this.bindTransitionEnd();
    this.setButtons();
  }

  KDDialogView.prototype.show = function() {
    return KD.utils.defer((function(_this) {
      return function() {
        var container, _ref;
        if ((_ref = _this.overlay) != null) {
          _ref.destroy();
        }
        container = _this.getOptions().container;
        _this.overlay = new KDOverlayView({
          click: _this.bound('hide'),
          container: container
        });
        return _this.setClass('in');
      };
    })(this));
  };

  KDDialogView.prototype.hide = function() {
    this.once('transitionend', (function(_this) {
      return function() {
        _this.overlay.destroy();
        return _this.destroy();
      };
    })(this));
    return this.unsetClass('in');
  };

  KDDialogView.prototype.setButtons = function() {
    var buttonOptions, buttonTitle, buttons, _results;
    buttons = this.getOptions().buttons;
    this.buttons = {};
    this.buttonHolder = new KDView({
      cssClass: "kddialog-buttons clearfix"
    });
    this.addSubView(this.buttonHolder);
    _results = [];
    for (buttonTitle in buttons) {
      if (!__hasProp.call(buttons, buttonTitle)) continue;
      buttonOptions = buttons[buttonTitle];
      _results.push(this.createButton(buttonTitle, buttonOptions));
    }
    return _results;
  };

  KDDialogView.prototype.createButton = function(title, buttonOptions) {
    var button;
    this.buttonHolder.addSubView(button = new KDButtonView({
      title: title,
      loader: buttonOptions.loader,
      style: buttonOptions.style,
      callback: buttonOptions.callback
    }));
    return this.buttons[title] = button;
  };

  return KDDialogView;

})(KDView);


},{"./../../core/view.coffee":106,"./../buttons/buttonview.coffee":20,"./../overlay/overlayview.coffee":62}],34:[function(require,module,exports){
var KDFormView, KDInputView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

KDView = require('./../../core/view.coffee');

KDInputView = require('./../inputs/inputview.coffee');

module.exports = KDFormView = (function(_super) {
  __extends(KDFormView, _super);

  KDFormView.findChildInputs = function(parent) {
    var inputs, subViews;
    inputs = [];
    subViews = parent.getSubViews();
    if (subViews.length > 0) {
      subViews.forEach(function(subView) {
        if (subView instanceof KDInputView) {
          inputs.push(subView);
        }
        return inputs = inputs.concat(KDFormView.findChildInputs(subView));
      });
    }
    return inputs;
  };

  KDFormView.sanitizeFormOptions = function(options) {
    var key, option, _results;
    _results = [];
    for (key in options) {
      option = options[key];
      if (option.title == null) {
        option.title = key;
      }
      option.key = key;
      _results.push(option);
    }
    return _results;
  };


  /*
  INSTANCE LEVEL
   */

  function KDFormView(options, data) {
    if (options == null) {
      options = {};
    }
    options.tagName = "form";
    options.cssClass = KD.utils.curry("kdformview", options.cssClass);
    options.callback || (options.callback = noop);
    options.customData || (options.customData = {});
    options.bind || (options.bind = "submit");
    KDFormView.__super__.constructor.call(this, options, data);
    this.unsetClass("kdview");
    this.valid = null;
    this.setCallback(options.callback);
    this.customData = {};
  }

  KDFormView.prototype.childAppended = function(child) {
    if (typeof child.associateForm === "function") {
      child.associateForm(this);
    }
    if (child instanceof KDInputView) {
      this.emit('inputWasAdded', child);
    }
    return KDFormView.__super__.childAppended.apply(this, arguments);
  };

  KDFormView.prototype.getCustomData = function(path) {
    if (path) {
      return JsPath.getAt(this.customData, path);
    } else {
      return this.customData;
    }
  };

  KDFormView.prototype.addCustomData = function(path, value) {
    var key, _results;
    if ('string' === typeof path) {
      return JsPath.setAt(this.customData, path, value);
    } else {
      _results = [];
      for (key in path) {
        if (!__hasProp.call(path, key)) continue;
        value = path[key];
        _results.push(JsPath.setAt(this.customData, key, value));
      }
      return _results;
    }
  };

  KDFormView.prototype.removeCustomData = function(path) {
    var isArrayElement, last, pathUntil, _i;
    if ('string' === typeof path) {
      path = path.split('.');
    }
    pathUntil = 2 <= path.length ? __slice.call(path, 0, _i = path.length - 1) : (_i = 0, []), last = path[_i++];
    isArrayElement = !isNaN(+last);
    if (isArrayElement) {
      return JsPath.spliceAt(this.customData, pathUntil, last);
    } else {
      return JsPath.deleteAt(this.customData, path);
    }
  };

  KDFormView.prototype.serializeFormData = function(data) {
    var inputData, _i, _len, _ref;
    if (data == null) {
      data = {};
    }
    _ref = this.getDomElement().serializeArray();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      inputData = _ref[_i];
      data[inputData.name] = inputData.value;
    }
    return data;
  };

  KDFormView.prototype.getData = function() {
    var formData;
    formData = $.extend({}, this.getCustomData());
    this.serializeFormData(formData);
    return formData;
  };

  KDFormView.prototype.getFormData = function() {
    var formData, inputs;
    inputs = KDFormView.findChildInputs(this);
    formData = this.getCustomData() || {};
    inputs.forEach(function(input) {
      if (input.getName()) {
        return formData[input.getName()] = input.getValue();
      }
    });
    return formData;
  };

  KDFormView.prototype.focusFirstElement = function() {
    return KDFormView.findChildInputs(this)[0].$().trigger("focus");
  };

  KDFormView.prototype.setCallback = function(callback) {
    return this.formCallback = callback;
  };

  KDFormView.prototype.getCallback = function() {
    return this.formCallback;
  };

  KDFormView.prototype.reset = function() {
    return this.getElement().reset();
  };

  KDFormView.prototype.submit = function(event) {
    var form, formData, inputs, toBeValidatedInputs, validInputs, validationCount;
    if (event) {
      event.stopPropagation();
      event.preventDefault();
    }
    form = this;
    inputs = KDFormView.findChildInputs(form);
    validationCount = 0;
    toBeValidatedInputs = [];
    validInputs = [];
    formData = this.getCustomData() || {};
    this.once("FormValidationFinished", function(isValid) {
      var _ref;
      if (isValid == null) {
        isValid = true;
      }
      form.valid = isValid;
      if (isValid) {
        if ((_ref = form.getCallback()) != null) {
          _ref.call(form, formData, event);
        }
        return form.emit("FormValidationPassed");
      } else {
        return form.emit("FormValidationFailed");
      }
    });
    inputs.forEach(function(input) {
      var inputOptions, name, value;
      inputOptions = input.getOptions();
      if (inputOptions.validate || inputOptions.required) {
        return toBeValidatedInputs.push(input);
      } else {
        name = input.getName();
        value = input.getValue();
        if (name) {
          return formData[name] = value;
        }
      }
    });
    toBeValidatedInputs.forEach(function(inputToBeValidated) {
      (function() {
        return inputToBeValidated.once("ValidationResult", function(result) {
          var input, valid, _i, _len;
          validationCount++;
          if (result) {
            validInputs.push(inputToBeValidated);
          }
          if (toBeValidatedInputs.length === validationCount) {
            if (validInputs.length === toBeValidatedInputs.length) {
              for (_i = 0, _len = validInputs.length; _i < _len; _i++) {
                input = validInputs[_i];
                formData[input.getName()] = input.getValue();
              }
            } else {
              valid = false;
            }
            return form.emit("FormValidationFinished", valid);
          }
        });
      })();
      return inputToBeValidated.validate(null, event);
    });
    if (toBeValidatedInputs.length === 0) {
      return form.emit("FormValidationFinished");
    }
  };

  return KDFormView;

})(KDView);


},{"./../../core/view.coffee":106,"./../inputs/inputview.coffee":46}],35:[function(require,module,exports){
var KDButtonBar, KDCustomHTMLView, KDFormView, KDFormViewWithFields, KDInputView, KDLabelView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

KDFormView = require('./formview.coffee');

KDButtonBar = require('./../buttons/buttonbar.coffee');

KDLabelView = require('./../inputs/labelview.coffee');

KDInputView = require('./../inputs/inputview.coffee');

module.exports = KDFormViewWithFields = (function(_super) {
  __extends(KDFormViewWithFields, _super);

  function KDFormViewWithFields() {
    var buttons, fields, _ref;
    KDFormViewWithFields.__super__.constructor.apply(this, arguments);
    this.setClass("with-fields");
    this.inputs = {};
    this.fields = {};
    _ref = this.getOptions(), fields = _ref.fields, buttons = _ref.buttons;
    if (fields) {
      this.createFields(KDFormView.sanitizeFormOptions(fields));
    }
    if (buttons) {
      this.createButtons(buttons);
      this.buttons = this.buttonField.buttons;
    }
  }

  KDFormViewWithFields.prototype.createFields = function(fields) {
    var fieldData, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      fieldData = fields[_i];
      _results.push(this.addSubView(this.createField(fieldData)));
    }
    return _results;
  };

  KDFormViewWithFields.prototype.createButtons = function(buttons) {
    return this.addSubView(this.buttonField = new KDButtonBar({
      buttons: buttons
    }));
  };

  KDFormViewWithFields.prototype.createField = function(fieldData, field, isNextElement) {
    var hint, input, inputWrapper, itemClass, key, label, next, title, _ref, _ref1;
    if (isNextElement == null) {
      isNextElement = false;
    }
    itemClass = fieldData.itemClass, title = fieldData.title;
    itemClass || (itemClass = KDInputView);
    fieldData.cssClass || (fieldData.cssClass = "");
    fieldData.name || (fieldData.name = title);
    field || (field = new KDView({
      cssClass: "formline " + (KD.utils.slugify(fieldData.name)) + " " + fieldData.cssClass
    }));
    if (fieldData.label) {
      field.addSubView(label = fieldData.label = this.createLabel(fieldData));
    }
    if (!isNextElement) {
      field.addSubView(inputWrapper = new KDCustomHTMLView({
        cssClass: "input-wrapper"
      }));
      inputWrapper.addSubView(input = this.createInput(itemClass, fieldData));
    } else {
      field.addSubView(input = this.createInput(itemClass, fieldData));
    }
    if (fieldData.hint) {
      inputWrapper.addSubView(hint = new KDCustomHTMLView({
        partial: fieldData.hint,
        tagName: "cite",
        cssClass: "hint"
      }));
    }
    this.fields[title] = field;
    if (fieldData.nextElement) {
      _ref = fieldData.nextElement;
      for (key in _ref) {
        next = _ref[key];
        next.title || (next.title = key);
        this.createField(next, inputWrapper || field, true);
      }
    }
    if (fieldData.nextElementFlat) {
      _ref1 = fieldData.nextElementFlat;
      for (key in _ref1) {
        if (!__hasProp.call(_ref1, key)) continue;
        next = _ref1[key];
        next.title || (next.title = key);
        this.createField(next, field);
      }
    }
    return field;
  };

  KDFormViewWithFields.prototype.createLabel = function(data) {
    return new KDLabelView({
      title: data.label,
      cssClass: this.utils.slugify(data.label)
    });
  };

  KDFormViewWithFields.prototype.createInput = function(itemClass, options) {
    var data, input;
    data = options.data;
    if (data) {
      delete options.data;
    }
    this.inputs[options.title] = input = new itemClass(options, data);
    return input;
  };

  return KDFormViewWithFields;

})(KDFormView);


},{"./../../core/customhtmlview.coffee":97,"./../../core/view.coffee":106,"./../buttons/buttonbar.coffee":17,"./../inputs/inputview.coffee":46,"./../inputs/labelview.coffee":47,"./formview.coffee":34}],36:[function(require,module,exports){
var KDHeaderView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDHeaderView = (function(_super) {
  __extends(KDHeaderView, _super);

  function KDHeaderView(options, data) {
    var _ref;
    options = options != null ? options : {};
    options.type = (_ref = options.type) != null ? _ref : "default";
    KDHeaderView.__super__.constructor.call(this, options, data);
    if (options.title != null) {
      if (this.lazy) {
        this.updateTitle(options.title);
      } else {
        this.setTitle(options.title);
      }
    }
  }

  KDHeaderView.prototype.setTitle = function(title) {
    return this.getDomElement().append("<span>" + title + "</span>");
  };

  KDHeaderView.prototype.updateTitle = function(title) {
    return this.$().find('span').html(title);
  };

  KDHeaderView.prototype.setDomElement = function(cssClass) {
    var type;
    if (cssClass == null) {
      cssClass = "";
    }
    type = this.getOptions().type;
    this.setOption("tagName", (function() {
      switch (type) {
        case "big":
          return "h1";
        case "medium":
          return "h2";
        case "small":
          return "h3";
        default:
          return "h4";
      }
    })());
    return KDHeaderView.__super__.setDomElement.call(this, this.utils.curry("kdheaderview", cssClass));
  };

  return KDHeaderView;

})(KDView);


},{"./../../core/view.coffee":106}],37:[function(require,module,exports){
var KDButtonView, KDCustomHTMLView, KDView, KDWebcamView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

KDButtonView = require('./../buttons/buttonview.coffee');

module.exports = KDWebcamView = (function(_super) {
  __extends(KDWebcamView, _super);

  function KDWebcamView(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass || (options.cssClass = "kdwebcamview");
    if (options.screenFlash == null) {
      options.screenFlash = true;
    }
    if (options.hideControls == null) {
      options.hideControls = false;
    }
    options.snapTitle || (options.snapTitle = "Snap Photo");
    options.resnapTitle || (options.resnapTitle = "Resnap");
    options.saveTitle || (options.saveTitle = "Save");
    if (options.countdown == null) {
      options.countdown = 3;
    }
    KDWebcamView.__super__.constructor.call(this, options, data);
    this.attachEvents();
    this.video = new KDCustomHTMLView({
      tagName: "video",
      attributes: {
        autoplay: true
      }
    });
    this.picture = new KDCustomHTMLView({
      tagName: "canvas"
    });
    this.button = options.hideControls ? new KDView({
      cssClass: "hidden"
    }) : new KDButtonView({
      title: options.snapTitle,
      cssClass: "snap-button hidden",
      callback: this.bound('countDown')
    });
    this.retake = options.hideControls ? new KDView({
      cssClass: "hidden"
    }) : new KDButtonView({
      title: options.resnapTitle,
      cssClass: "snap-button retake hidden",
      callback: (function(_this) {
        return function() {
          return _this.resetView();
        };
      })(this)
    });
    this.save = options.hideControls ? new KDView({
      cssClass: "hidden"
    }) : new KDButtonView({
      title: options.saveTitle,
      cssClass: "snap-button save hidden",
      callback: (function(_this) {
        return function() {
          _this.resetView();
          _this.video.setClass("invisible");
          _this.button.hide();
          return _this.emit("save");
        };
      })(this)
    });
  }

  KDWebcamView.prototype.attachEvents = function() {
    var snapTitle;
    snapTitle = this.getOptions().snapTitle;
    this.on("KDObjectWillBeDestroyed", (function(_this) {
      return function() {
        return _this.unsetVideoStream();
      };
    })(this));
    this.on("viewAppended", (function(_this) {
      return function() {
        _this.context = _this.picture.getElement().getContext("2d");
        return _this.getUserMedia();
      };
    })(this));
    this.on("error", function(error) {
      return this.emit("forbidden");
    });
    this.on("snap", (function(_this) {
      return function() {
        return _this.video.setClass("invisible");
      };
    })(this));
    return this.on("countDownEnd", (function(_this) {
      return function() {
        _this.button.hide();
        _this.retake.show();
        _this.save.show();
        _this.takePicture();
        return _this.button.setTitle(snapTitle);
      };
    })(this));
  };

  KDWebcamView.prototype.resetView = function() {
    this.button.show();
    this.retake.hide();
    this.save.hide();
    return this.reset();
  };

  KDWebcamView.prototype.reset = function() {
    return this.video.unsetClass("invisible");
  };

  KDWebcamView.prototype.countDown = function() {
    var count, countdown, counter, timer;
    countdown = this.getOptions().countdown;
    if (countdown > 0) {
      counter = (function(_this) {
        return function() {
          _this.button.setTitle(countdown);
          return countdown--;
        };
      })(this);
      count = this.utils.repeat(1000, counter);
      counter();
      return timer = this.utils.wait((countdown + 1) * 1000, (function(_this) {
        return function() {
          _this.utils.killRepeat(count);
          _this.utils.killWait(timer);
          return _this.emit("countDownEnd");
        };
      })(this));
    } else {
      return this.emit("countDownEnd");
    }
  };

  KDWebcamView.prototype.autoResize = function() {
    var size, video;
    video = this.video.getElement();
    size = {
      width: video.clientWidth,
      height: video.clientHeight
    };
    this.picture.setAttributes(size);
    return this.setSize(size);
  };

  KDWebcamView.prototype.unsetVideoStream = function() {
    var video, _ref;
    video = this.video.getElement();
    video.pause();
    KDWebcamView.setVideoStreamVendor(video, "");
    return (_ref = this.localMediaStream) != null ? _ref.stop() : void 0;
  };

  KDWebcamView.prototype.setVideoStream = function(stream) {
    var video;
    video = this.video.getElement();
    KDWebcamView.setVideoStreamVendor(video, stream);
    video.play();
    return video.addEventListener("playing", (function(_this) {
      return function() {
        _this.show();
        _this.button.show();
        _this.autoResize();
        return _this.emit("allowed");
      };
    })(this));
  };

  KDWebcamView.setVideoStreamVendor = function(video, stream) {
    if (video.mozSrcObject !== void 0) {
      return video.mozSrcObject = stream;
    } else {
      return video.src = stream;
    }
  };

  KDWebcamView.getUserMediaVendor = function() {
    return navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
  };

  KDWebcamView.getURLVendor = function() {
    return window.URL || window.webkitURL || window.mozURL;
  };

  KDWebcamView.prototype.getUserMedia = function() {
    var _onError;
    _onError = (function(_this) {
      return function(error) {
        return _this.emit("error", error);
      };
    })(this);
    navigator.getUserMedia = KDWebcamView.getUserMediaVendor();
    window.URL = KDWebcamView.getURLVendor();
    if (navigator.getUserMedia) {
      return navigator.getUserMedia({
        video: true
      }, (function(_this) {
        return function(stream) {
          _this.localMediaStream = stream;
          return _this.setVideoStream((window.URL && window.URL.createObjectURL(stream)) || stream);
        };
      })(this), _onError);
    } else {
      return _onError({
        notSupported: true
      });
    }
  };

  KDWebcamView.prototype.flash = function() {
    var flash;
    flash = new KDView({
      cssClass: "kdwebcamview-flash"
    });
    flash.appendToDomBody();
    return KD.utils.defer(function() {
      flash.setClass("flashed");
      return KD.utils.wait(500, function() {
        return flash.destroy();
      });
    });
  };

  KDWebcamView.prototype.takePicture = function() {
    var picture, screenFlash, video;
    video = this.video.getElement();
    picture = this.picture.getElement();
    screenFlash = this.getOptions().screenFlash;
    if (screenFlash) {
      this.flash();
    }
    this.autoResize();
    this.context.drawImage(video, 0, 0, video.clientWidth, video.clientHeight);
    return this.emit("snap", picture.toDataURL(), picture);
  };

  KDWebcamView.prototype.viewAppended = function() {
    var view, _i, _len, _ref, _results;
    KDWebcamView.__super__.viewAppended.call(this);
    _ref = [this.button, this.save, this.retake, this.video, this.picture];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      view = _ref[_i];
      _results.push(this.addSubView(view));
    }
    return _results;
  };

  return KDWebcamView;

})(KDView);


},{"./../../core/customhtmlview.coffee":97,"./../../core/view.coffee":106,"./../buttons/buttonview.coffee":20}],38:[function(require,module,exports){
var KDCheckBox, KDInputView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDCheckBox = (function(_super) {
  __extends(KDCheckBox, _super);

  function KDCheckBox(options, data) {
    var _base;
    if (options == null) {
      options = {};
    }
    options.type || (options.type = "checkbox");
    if (options.attributes == null) {
      options.attributes = {};
    }
    if ((_base = options.attributes).checked == null) {
      _base.checked = options.defaultValue || false;
    }
    KDCheckBox.__super__.constructor.call(this, options, data);
  }

  return KDCheckBox;

})(KDInputView);


},{"./inputview.coffee":46}],39:[function(require,module,exports){
var KDContentEditableView, KDNotificationView, KDView,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDNotificationView = require('./../notifications/notificationview.coffee');

module.exports = KDContentEditableView = (function(_super) {
  __extends(KDContentEditableView, _super);

  function KDContentEditableView(options, data) {
    var _ref;
    if (options == null) {
      options = {};
    }
    this.keyDown = __bind(this.keyDown, this);
    this.input = __bind(this.input, this);
    this.click = __bind(this.click, this);
    options.cssClass = KD.utils.curry("kdcontenteditableview", options.cssClass);
    options.bind = KD.utils.curry("click input keydown paste drop", options.bind);
    options.type || (options.type = "text");
    if (options.multiline == null) {
      options.multiline = false;
    }
    options.placeholder || (options.placeholder = "");
    if (options.tabNavigation == null) {
      options.tabNavigation = false;
    }
    KDContentEditableView.__super__.constructor.call(this, options, data);
    if ((_ref = this.getDelegate()) != null) {
      _ref.on("EditingModeToggled", (function(_this) {
        return function(state) {
          return _this.setEditingMode(state);
        };
      })(this));
    }
    this.validationNotifications = {};
  }

  KDContentEditableView.prototype.viewAppended = function() {
    this.setEditingMode(false);
    return KDContentEditableView.__super__.viewAppended.apply(this, arguments);
  };

  KDContentEditableView.prototype.getEditableElement = function() {
    if (!this.editableElement) {
      if (this.getData()) {
        this.editableElement = this.getElement().children[0];
      } else {
        this.editableElement = document.createElement("div");
        this.getDomElement().append(this.editableElement);
      }
    }
    return this.editableElement;
  };

  KDContentEditableView.prototype.getEditableDomElement = function() {
    if (!this.editableDomElement) {
      this.editableDomElement = $(this.getEditableElement());
    }
    return this.editableDomElement;
  };

  KDContentEditableView.prototype.setEditingMode = function(state) {
    this.editingMode = state;
    this.getEditableElement().setAttribute("contenteditable", state);
    if (this.getValue() === "") {
      if (this.editingMode && this.getOptions().placeholder) {
        return this.setPlaceholder();
      } else {
        return this.unsetPlaceholder();
      }
    }
  };

  KDContentEditableView.prototype.getValue = function(forceType) {
    var element, placeholder, type, value, _ref;
    _ref = this.getOptions(), type = _ref.type, placeholder = _ref.placeholder;
    element = this.getEditableElement();
    if (forceType) {
      type = forceType;
    }
    switch (type) {
      case "text":
        value = element.textContent;
        break;
      case "html":
        value = element.innerHTML;
    }
    if (value === Encoder.htmlDecode(placeholder)) {
      return "";
    } else {
      return value.trim();
    }
  };

  KDContentEditableView.prototype.setContent = function(content) {
    var element, type;
    type = this.getOptions().type;
    element = this.getEditableElement();
    if (content) {
      switch (type) {
        case "text":
          return element.textContent = content;
        case "html":
          return element.innerHTML = content;
      }
    } else if (this.editingMode && content === "") {
      return this.setPlaceholder();
    }
  };

  KDContentEditableView.prototype.focus = function() {
    var windowController, _base;
    if (this.getValue().length === 0) {
      this.unsetPlaceholder();
    }
    if (!this.focused) {
      this.getEditableDomElement().trigger("focus");
    }
    windowController = KD.getSingleton("windowController");
    windowController.addLayer(this);
    if (!this.focused) {
      this.once("ReceivedClickElsewhere", this.bound('blur'));
    }
    this.focused = true;
    return typeof (_base = this.getOptions()).focus === "function" ? _base.focus() : void 0;
  };

  KDContentEditableView.prototype.blur = function() {
    this.focused = false;
    if (this.getValue("text").length === 0) {
      this.setPlaceholder();
    } else {
      if (this.getOptions().type !== "html") {
        this.setContent(this.getValue());
      }
    }
    return this.emit('BlurHappened');
  };

  KDContentEditableView.prototype.click = function() {
    if (this.editingMode && !this.focused) {
      return this.focus();
    }
  };

  KDContentEditableView.prototype.input = function(event) {
    return this.emit("ValueChanged", event);
  };

  KDContentEditableView.prototype.keyDown = function(event) {
    var maxLength, multiline, tabNavigation, validate, value, _ref, _ref1, _ref2;
    _ref = this.getOptions(), tabNavigation = _ref.tabNavigation, multiline = _ref.multiline, validate = _ref.validate;
    switch (event.which) {
      case 9:
        if (tabNavigation) {
          this.utils.stopDOMEvent(event);
        }
        break;
      case 13:
        this.utils.stopDOMEvent(event);
    }
    switch (event.which) {
      case 9:
        if (!tabNavigation) {
          break;
        }
        this.blur();
        if (event.shiftKey) {
          this.emit("PreviousTabStop");
        } else {
          this.emit("NextTabStop");
        }
        break;
      case 13:
        if (this.getOptions().multiline) {
          this.appendNewline();
        } else {
          this.emit("EnterPressed");
        }
    }
    value = this.getValue();
    maxLength = ((_ref1 = this.getOptions().validate) != null ? (_ref2 = _ref1.rules) != null ? _ref2.maxLength : void 0 : void 0) || 0;
    if (event.which === 13 || (maxLength > 0 && value.length === maxLength)) {
      return event.preventDefault();
    } else if (value.length === 0) {
      this.unsetPlaceholder();
      if (event.target !== this.getEditableElement()) {
        return this.focus();
      }
    }
  };

  KDContentEditableView.prototype.paste = function(event) {
    var text;
    event.preventDefault();
    text = event.originalEvent.clipboardData.getData("text/plain");
    return document.execCommand("insertText", false, text);
  };

  KDContentEditableView.prototype.drop = function(event) {
    var clientX, clientY, commonAncestorContainer, endOffset, startOffset, text, _ref, _ref1;
    event.preventDefault();
    text = event.originalEvent.dataTransfer.getData("text/plain");
    _ref = event.originalEvent, clientX = _ref.clientX, clientY = _ref.clientY;
    if (this.getValue() === "") {
      startOffset = 0;
      this.unsetPlaceholder();
    }
    _ref1 = document.caretRangeFromPoint(clientX, clientY), commonAncestorContainer = _ref1.commonAncestorContainer, startOffset = _ref1.startOffset, endOffset = _ref1.endOffset;
    return this.utils.replaceRange(commonAncestorContainer, text, startOffset);
  };

  KDContentEditableView.prototype.setPlaceholder = function() {
    var placeholder;
    this.setClass("placeholder");
    placeholder = this.getOptions().placeholder;
    if (placeholder) {
      return this.setContent(placeholder);
    }
  };

  KDContentEditableView.prototype.unsetPlaceholder = function() {
    var content, defaultValue, element, value;
    this.unsetClass("placeholder");
    content = "";
    defaultValue = this.getOptions().defaultValue;
    value = this.getValue();
    if (this.editingMode) {
      content = value || "";
    } else {
      content = value || defaultValue || "";
    }
    element = this.getEditableDomElement();
    element.text("");
    return element.append(document.createTextNode(content));
  };

  KDContentEditableView.prototype.validate = function(event) {
    var message, name, rule, valid, validator, _ref, _ref1;
    valid = true;
    _ref1 = ((_ref = this.getOptions().validate) != null ? _ref.rules : void 0) || {};
    for (name in _ref1) {
      if (!__hasProp.call(_ref1, name)) continue;
      rule = _ref1[name];
      validator = KDInputValidator["rule" + (name.capitalize())];
      if (validator && (message = validator(this, event))) {
        valid = false;
        this.notify(message, {
          title: message,
          type: "mini",
          cssClass: "error",
          duration: 2500
        });
        break;
      }
    }
    return valid;
  };

  KDContentEditableView.prototype.notify = function(message, options) {
    var notice;
    this.validationNotifications[message] = notice = new KDNotificationView(options);
    return notice.on("KDObjectWillBeDestroyed", (function(_this) {
      return function() {
        message = notice.getOptions().title;
        return delete _this.validationNotifications[message];
      };
    })(this));
  };

  KDContentEditableView.prototype.appendNewline = function() {
    var count, i, newline, range, selection, _i;
    selection = window.getSelection();
    count = selection.baseNode.length === selection.focusOffset ? 1 : 0;
    range = selection.getRangeAt(0);
    for (i = _i = 0; 0 <= count ? _i <= count : _i >= count; i = 0 <= count ? ++_i : --_i) {
      range.insertNode(newline = document.createElement("br"));
    }
    return this.utils.selectEnd(newline);
  };

  KDContentEditableView.prototype.viewAppended = function() {
    KDContentEditableView.__super__.viewAppended.apply(this, arguments);
    if (!this.editingMode && this.getValue().length === 0) {
      return this.unsetPlaceholder();
    }
  };

  return KDContentEditableView;

})(KDView);


},{"./../../core/view.coffee":106,"./../notifications/notificationview.coffee":61}],40:[function(require,module,exports){
var KDDelimitedInputView, KDInputView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDDelimitedInputView = (function(_super) {
  __extends(KDDelimitedInputView, _super);

  function KDDelimitedInputView(options, data) {
    var defaultValue;
    if (options == null) {
      options = {};
    }
    if (options.delimiter == null) {
      options.delimiter = ',';
    }
    if (options.usePadding == null) {
      options.usePadding = true;
    }
    defaultValue = options.defaultValue;
    if ((defaultValue != null ? defaultValue.join : void 0) != null) {
      options.defaultValue = this.join(defaultValue, options);
    }
    KDDelimitedInputView.__super__.constructor.call(this, options, data);
  }

  KDDelimitedInputView.prototype.change = function() {
    return this.setValue(this.getValue());
  };

  KDDelimitedInputView.prototype.getPadding = function(options) {
    if (options == null) {
      options = this.getOptions();
    }
    if (options.usePadding) {
      return ' ';
    } else {
      return '';
    }
  };

  KDDelimitedInputView.prototype.split = function(value, options) {
    if (options == null) {
      options = this.getOptions();
    }
    return this.utils.splitTrim(value, options.delimiter);
  };

  KDDelimitedInputView.prototype.join = function(value, options) {
    if (options == null) {
      options = this.getOptions();
    }
    return value.join("" + options.delimiter + (this.getPadding(options)));
  };

  KDDelimitedInputView.prototype.getValue = function() {
    return this.split(KDDelimitedInputView.__super__.getValue.apply(this, arguments));
  };

  KDDelimitedInputView.prototype.setValue = function(value) {
    return KDDelimitedInputView.__super__.setValue.call(this, value.join != null ? this.join(value) : value);
  };

  return KDDelimitedInputView;

})(KDInputView);


},{"./inputview.coffee":46}],41:[function(require,module,exports){

/*
todo:

  - on enter should validation fire by default??? Sinan - 6/6/2012
 */
var KDHitEnterInputView, KDInputView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDHitEnterInputView = (function(_super) {
  __extends(KDHitEnterInputView, _super);

  function KDHitEnterInputView(options, data) {
    var _ref;
    if (options == null) {
      options = {};
    }
    options.type || (options.type = "textarea");
    options.button || (options.button = null);
    if (options.showButton == null) {
      options.showButton = false;
    }
    options.label || (options.label = null);
    options.placeholder || (options.placeholder = "");
    options.callback || (options.callback = null);
    options.togglerPartials || (options.togglerPartials = ["quick update disabled", "quick update enabled"]);
    KDHitEnterInputView.__super__.constructor.call(this, options, data);
    this.setClass("hitenterview");
    this.button = (_ref = this.getOptions().button) != null ? _ref : null;
    this.enableEnterKey();
    if (options.label != null) {
      this.setToggler();
    }
    if (this.getOptions().showButton) {
      this.disableEnterKey();
    }
    this.on("ValidationPassed", (function(_this) {
      return function() {
        var _ref1;
        _this.blur();
        return (_ref1 = _this.getOptions().callback) != null ? _ref1.call(_this, _this.getValue()) : void 0;
      };
    })(this));
  }

  KDHitEnterInputView.prototype.enableEnterKey = function() {
    this.setClass("active");
    if (this.button) {
      this.hideButton();
    }
    if (this.inputEnterToggler != null) {
      this.inputEnterToggler.$().html(this.getOptions().togglerPartials[1]);
    }
    return this.enterKeyEnabled = true;
  };

  KDHitEnterInputView.prototype.disableEnterKey = function() {
    this.unsetClass("active");
    if (this.button) {
      this.showButton();
    }
    if (this.inputEnterToggler != null) {
      this.inputEnterToggler.$().html(this.getOptions().togglerPartials[0]);
    }
    return this.enterKeyEnabled = false;
  };

  KDHitEnterInputView.prototype.setToggler = function() {
    var o;
    o = this.getOptions();
    this.inputEnterToggler = new KDCustomHTMLView({
      tagName: "a",
      cssClass: "hitenterview-toggle",
      partial: o.showButton ? o.togglerPartials[0] : o.togglerPartials[1],
      click: this.bound("toggleEnterKey")
    });
    return this.inputLabel.addSubView(this.inputEnterToggler);
  };

  KDHitEnterInputView.prototype.hideButton = function() {
    return this.button.hide();
  };

  KDHitEnterInputView.prototype.showButton = function() {
    return this.button.show();
  };

  KDHitEnterInputView.prototype.toggleEnterKey = function() {
    if (this.enterKeyEnabled) {
      return this.disableEnterKey();
    } else {
      return this.enableEnterKey();
    }
  };

  KDHitEnterInputView.prototype.keyDown = function(event) {
    if (event.which === 13 && (event.altKey || event.shiftKey) !== true && this.enterKeyEnabled) {
      this.emit("EnterPerformed");
      this.validate();
      return false;
    } else if (event.which === 27) {
      return this.emit("EscapePerformed");
    }
  };

  return KDHitEnterInputView;

})(KDInputView);


},{"./inputview.coffee":46}],42:[function(require,module,exports){
var KDInputCheckboxGroup, KDInputRadioGroup,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputRadioGroup = require('./inputradiogroup.coffee');

module.exports = KDInputCheckboxGroup = (function(_super) {
  __extends(KDInputCheckboxGroup, _super);

  function KDInputCheckboxGroup(options, data) {
    if (options == null) {
      options = {};
    }
    options.checkboxes || (options.checkboxes = []);
    options.radios || (options.radios = options.checkboxes);
    options.type || (options.type = 'checkbox');
    KDInputCheckboxGroup.__super__.constructor.call(this, options, data);
  }

  KDInputCheckboxGroup.prototype.click = function(event) {
    if (event.target.tagName !== 'LABEL') {
      return this.setValue(this.getValue());
    }
  };

  KDInputCheckboxGroup.prototype.getValue = function() {
    var el, values, _i, _len, _ref;
    values = [];
    _ref = this.getDomElement().find('input:checked');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      values.push($(el).val());
    }
    return values;
  };

  KDInputCheckboxGroup.prototype.setValue = function(value) {
    var v, _i, _len, _results;
    this.$('input').prop('checked', false);
    this.$('.kd-radio-holder').removeClass('active');
    if (value instanceof Array) {
      _results = [];
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        v = value[_i];
        _results.push(this._setValue(v));
      }
      return _results;
    } else {
      return this._setValue(value);
    }
  };

  KDInputCheckboxGroup.prototype._setValue = function(value) {
    this.$("input[value='" + value + "']").prop('checked', true);
    if (value) {
      return this.$(".kd-radio-holder.role-" + value).addClass('active');
    }
  };

  return KDInputCheckboxGroup;

})(KDInputRadioGroup);


},{"./inputradiogroup.coffee":43}],43:[function(require,module,exports){
var KDInputRadioGroup, KDInputView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDInputRadioGroup = (function(_super) {
  __extends(KDInputRadioGroup, _super);

  function KDInputRadioGroup(options) {
    options.type || (options.type = 'radio');
    if (options.hideRadios == null) {
      options.hideRadios = false;
    }
    if (options.showIcons == null) {
      options.showIcons = false;
    }
    options.cssClassPrefix || (options.cssClassPrefix = '');
    KDInputRadioGroup.__super__.constructor.call(this, options);
    this._currentValue = this.getOption('defaultValue');
  }

  KDInputRadioGroup.prototype.setDomElement = function() {
    var disabledClass, div, i, label, options, radio, radioOptions, _i, _len, _ref;
    options = this.getOptions();
    this.domElement = $("<fieldset class='" + (this.utils.curry('radiogroup kdinput', options.cssClass)) + "'></fieldset>");
    _ref = options.radios;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      radioOptions = _ref[i];
      if (radioOptions.visible == null) {
        radioOptions.visible = true;
      }
      radioOptions.callback || (radioOptions.callback = function() {});
      disabledClass = radioOptions.disabled ? 'disabled ' : '';
      div = $("<div/>", {
        "class": "kd-" + (this.getType()) + "-holder " + disabledClass + options.cssClassPrefix + (this.utils.slugify(radioOptions.value))
      });
      radio = $("<input/>", {
        type: this.getType(),
        name: options.name,
        value: radioOptions.value,
        "class": "no-kdinput" + (options.hideRadios ? ' hidden' : ''),
        id: "" + (this.getId()) + "_" + (this.getType()) + "_" + i,
        change: radioOptions.callback
      });
      if (radioOptions.disabled) {
        radio[0].setAttribute('disabled', 'disabled');
      }
      label = $("<label/>", {
        "for": "" + (this.getId()) + "_" + (this.getType()) + "_" + i,
        html: radioOptions.title,
        "class": options.cssClassPrefix + this.utils.slugify(radioOptions.value)
      });
      div.append(radio);
      if (options.showIcons) {
        div.append($("<span/>", {
          "class": "icon"
        }));
      }
      div.append(label);
      this.domElement.append(div);
      if (!radioOptions.visible) {
        div.hide();
      }
    }
    return this.domElement;
  };

  KDInputRadioGroup.prototype.click = function(event) {
    var input;
    input = $(event.target).closest(".kd-" + (this.getType()) + "-holder").find('input');
    if (input.length < 1) {
      return;
    }
    if (input[0].getAttribute('disabled') === 'disabled') {
      return false;
    }
    return this.setValue(input[0].getAttribute("value"));
  };

  KDInputRadioGroup.prototype.setDefaultValue = function(value) {
    this.inputDefaultValue = value;
    return this.setValue(value, true);
  };

  KDInputRadioGroup.prototype.getValue = function() {
    return this.$('input[checked=checked]').val();
  };

  KDInputRadioGroup.prototype.setValue = function(value, isDefault) {
    var inputElement;
    if (isDefault == null) {
      isDefault = false;
    }
    this.$("input").attr("checked", false);
    inputElement = this.$("input[value='" + value + "']");
    inputElement.attr("checked", "checked");
    inputElement.prop("checked", true);
    if ((value != null) && value !== this._currentValue && !isDefault) {
      this.emit("change", value);
    }
    this._currentValue = value;
    this.$(".kd-radio-holder").removeClass('active');
    if ((value != null) && value !== "") {
      return this.$(".kd-radio-holder." + value).addClass('active');
    }
  };

  KDInputRadioGroup.prototype.getInputElements = function() {
    return this.getDomElement().find('input');
  };

  return KDInputRadioGroup;

})(KDInputView);


},{"./inputview.coffee":46}],44:[function(require,module,exports){
var KDInputSwitch, KDInputView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDInputSwitch = (function(_super) {
  __extends(KDInputSwitch, _super);

  function KDInputSwitch(options) {
    if (options == null) {
      options = {};
    }
    options.type = "switch";
    KDInputSwitch.__super__.constructor.call(this, options);
    this.setPartial("<input class='checkbox hidden no-kdinput' type='checkbox' name='" + (this.getName()) + "'/>");
  }

  KDInputSwitch.prototype.setDomElement = function() {
    return this.domElement = $("<span class='kdinput kdinputswitch off'></span>");
  };

  KDInputSwitch.prototype.setDefaultValue = function(value) {
    switch (value) {
      case true:
      case "on":
      case "true":
      case "yes":
      case 1:
        return this._setDefaultValue(true);
      default:
        return this._setDefaultValue(false);
    }
  };

  KDInputSwitch.prototype.getDefaultValue = function() {
    return this.inputDefaultValue;
  };

  KDInputSwitch.prototype.getValue = function() {
    return this.getDomElement().find("input").eq(0).is(":checked");
  };

  KDInputSwitch.prototype.setValue = function(value) {
    switch (value) {
      case true:
        return this.switchAnimateOn();
      case false:
        return this.switchAnimateOff();
    }
  };

  KDInputSwitch.prototype._setDefaultValue = function(val) {
    return setTimeout((function(_this) {
      return function() {
        val = !!val;
        if (val) {
          _this.inputDefaultValue = true;
          _this.getDomElement().find("input").eq(0).attr("checked", true);
          return _this.getDomElement().removeClass("off").addClass("on");
        } else {
          _this.inputDefaultValue = false;
          _this.getDomElement().find("input").eq(0).attr("checked", false);
          return _this.getDomElement().removeClass("on").addClass("off");
        }
      };
    })(this), 0);
  };

  KDInputSwitch.prototype.switchAnimateOff = function() {
    var counter, timer;
    if (!this.getValue()) {
      return;
    }
    counter = 0;
    return timer = setInterval((function(_this) {
      return function() {
        _this.getDomElement().css("background-position", "left -" + (counter * 20) + "px");
        if (counter === 6) {
          clearInterval(timer);
          _this.getDomElement().find("input").eq(0).attr("checked", false);
          _this.getDomElement().removeClass("on").addClass("off");
          _this.switchStateChanged();
        }
        return counter++;
      };
    })(this), 20);
  };

  KDInputSwitch.prototype.switchAnimateOn = function() {
    var counter, timer;
    if (this.getValue()) {
      return;
    }
    counter = 6;
    return timer = setInterval((function(_this) {
      return function() {
        _this.getDomElement().css("background-position", "left -" + (counter * 20) + "px");
        if (counter === 0) {
          clearInterval(timer);
          _this.getDomElement().find("input").eq(0).attr("checked", true);
          _this.getDomElement().removeClass("off").addClass("on");
          _this.switchStateChanged();
        }
        return counter--;
      };
    })(this), 20);
  };

  KDInputSwitch.prototype.switchStateChanged = function() {
    if (this.getCallback() != null) {
      return this.getCallback().call(this, this.getValue());
    }
  };

  KDInputSwitch.prototype.mouseDown = function() {
    switch (this.getValue()) {
      case true:
        this.setValue(false);
        break;
      case false:
        this.setValue(true);
    }
    return false;
  };

  return KDInputSwitch;

})(KDInputView);


},{"./inputview.coffee":46}],45:[function(require,module,exports){
var KDInputValidator;

module.exports = KDInputValidator = (function() {
  function KDInputValidator() {}

  KDInputValidator.ruleRequired = function(input, event) {
    var doesValidate, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    doesValidate = value.length > 0;
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.required : void 0) || "Field is required";
    }
  };

  KDInputValidator.ruleEmail = function(input, event) {
    var doesValidate, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    doesValidate = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(value);
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.email : void 0) || "Please enter a valid email address";
    }
  };

  KDInputValidator.ruleMinLength = function(input, event) {
    var doesValidate, minLength, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    minLength = ruleSet.rules.minLength;
    doesValidate = value.length >= minLength;
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.minLength : void 0) || ("Please enter a value that has " + minLength + " characters or more");
    }
  };

  KDInputValidator.ruleMaxLength = function(input, event) {
    var doesValidate, maxLength, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    maxLength = ruleSet.rules.maxLength;
    doesValidate = value.length <= maxLength;
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.maxLength : void 0) || ("Please enter a value that has " + maxLength + " characters or less");
    }
  };

  KDInputValidator.ruleRangeLength = function(input, event) {
    var doesValidate, rangeLength, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    rangeLength = ruleSet.rules.rangeLength;
    doesValidate = value.length <= rangeLength[1] && value.length >= rangeLength[0];
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.rangeLength : void 0) || ("Please enter a value that has more than " + rangeLength[0] + " and less than " + rangeLength[1] + " characters");
    }
  };

  KDInputValidator.ruleMatch = function(input, event) {
    var doesValidate, matchView, matchViewVal, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    matchView = ruleSet.rules.match;
    matchViewVal = $.trim(matchView.getValue());
    doesValidate = value === matchViewVal;
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.match : void 0) || "Values do not match";
    }
  };

  KDInputValidator.ruleCreditCard = function(input, event) {

    /*
    Visa:             start with a 4. New cards have 16 digits. Old cards have 13.
    MasterCard:       start with the numbers 51 through 55. All have 16 digits.
    American Express: start with 34 or 37 and have 15 digits.
    Diners Club:      start with 300 through 305, 36 or 38. All have 14 digits. There are Diners Club cards that begin with 5 and have 16 digits. These are a joint venture between Diners Club and MasterCard, and should be processed like a MasterCard.
    Discover:         start with 6011 or 65. All have 16 digits.
    JCB:              start with 2131 or 1800 have 15 digits. JCB cards beginning with 35 have 16 digits.
     */
    var doesValidate, ruleSet, type, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue().replace(/-|\s/g, ""));
    ruleSet = input.getOptions().validate;
    doesValidate = /(^4[0-9]{12}(?:[0-9]{3})?$)|(^5[1-5][0-9]{14}$)|(^3[47][0-9]{13}$)|(^3(?:0[0-5]|[68][0-9])[0-9]{11}$)|(^6(?:011|5[0-9]{2})[0-9]{12}$)|(^(?:2131|1800|35\d{3})\d{11}$)/.test(value);
    if (doesValidate) {
      type = /^4[0-9]{12}(?:[0-9]{3})?$/.test(value) ? "Visa" : /^5[1-5][0-9]{14}$/.test(value) ? "MasterCard" : /^3[47][0-9]{13}$/.test(value) ? "Amex" : /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/.test(value) ? "Diners" : /^6(?:011|5[0-9]{2})[0-9]{12}$/.test(value) ? "Discover" : /^(?:2131|1800|35\d{3})\d{11}$/.test(value) ? "JCB" : false;
      input.emit("CreditCardTypeIdentified", type);
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.creditCard : void 0) || "Please enter a valid credit card number";
    }
  };

  KDInputValidator.ruleJSON = function(input, event) {
    var doesValidate, err, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    doesValidate = true;
    try {
      if (value) {
        JSON.parse(value);
      }
    } catch (_error) {
      err = _error;
      error(err, doesValidate);
      doesValidate = false;
    }
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.JSON : void 0) || "a valid JSON is required";
    }
  };

  KDInputValidator.ruleRegExp = function(input, event) {
    var doesValidate, regExp, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    regExp = ruleSet.rules.regExp;
    doesValidate = regExp.test(value);
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.regExp : void 0) || "Validation failed";
    }
  };

  KDInputValidator.ruleUri = function(input, event) {
    var doesValidate, regExp, ruleSet, value, _ref;
    if ((event != null ? event.which : void 0) === 9) {
      return;
    }
    regExp = /^([a-z0-9+.-]+):(?:\/\/(?:((?:[a-z0-9-._~!$&'()*+,;=:]|%[0-9A-F]{2})*)@)?((?:[a-z0-9-._~!$&'()*+,;=]|%[0-9A-F]{2})*)(?::(\d*))?(\/(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?|(\/?(?:[a-z0-9-._~!$&'()*+,;=:@]|%[0-9A-F]{2})+(?:[a-z0-9-._~!$&'()*+,;=:@\/]|%[0-9A-F]{2})*)?)(?:\?((?:[a-z0-9-._~!$&'()*+,;=:\/?@]|%[0-9A-F]{2})*))?(?:)?$/i;
    value = $.trim(input.getValue());
    ruleSet = input.getOptions().validate;
    doesValidate = regExp.test(value);
    if (doesValidate) {
      return null;
    } else {
      return ((_ref = ruleSet.messages) != null ? _ref.uri : void 0) || "Not a valid URI";
    }
  };

  return KDInputValidator;

})();


/*
Credits
  email check regex:
  by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/
 */


},{}],46:[function(require,module,exports){
var KDInputValidator, KDInputView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDView = require('./../../core/view.coffee');

KDInputValidator = require('./inputvalidator.coffee');

module.exports = KDInputView = (function(_super) {
  __extends(KDInputView, _super);

  function KDInputView(o, data) {
    var options;
    if (o == null) {
      o = {};
    }
    o.type || (o.type = "text");
    o.name || (o.name = "");
    o.label || (o.label = null);
    o.cssClass || (o.cssClass = "");
    o.callback || (o.callback = null);
    if (o.defaultValue == null) {
      o.defaultValue = "";
    }
    o.placeholder || (o.placeholder = "");
    if (o.disabled == null) {
      o.disabled = false;
    }
    o.selectOptions || (o.selectOptions = null);
    o.validate || (o.validate = null);
    if (o.decorateValidation == null) {
      o.decorateValidation = true;
    }
    o.hint || (o.hint = null);
    if (o.autogrow == null) {
      o.autogrow = false;
    }
    if (o.enableTabKey == null) {
      o.enableTabKey = false;
    }
    o.bind || (o.bind = "");
    o.forceCase || (o.forceCase = null);
    o.bind += " blur change focus";
    this.setType(o.type);
    KDInputView.__super__.constructor.call(this, o, data);
    options = this.getOptions();
    this.validationNotifications = {};
    this.valid = true;
    this.inputCallback = null;
    this.setName(options.name);
    this.setLabel();
    this.setCallback();
    this.setDefaultValue(options.defaultValue);
    this.setPlaceHolder(options.placeholder);
    if (options.disabled) {
      this.makeDisabled();
    }
    if ((options.selectOptions != null) && 'function' !== typeof options.selectOptions) {
      this.setSelectOptions(options.selectOptions);
    }
    if (options.autogrow) {
      this.setAutoGrow();
    }
    if (options.enableTabKey) {
      this.enableTabKey();
    }
    if (options.forceCase) {
      this.setCase(options.forceCase);
    }
    if (options.required) {
      (function(v) {
        if (v.rules == null) {
          v.rules = {};
        }
        if (v.messages == null) {
          v.messages = {};
        }
        v.rules.required = true;
        return v.messages.required = options.required;
      })(options.validate != null ? options.validate : options.validate = {});
    }
    if (options.validate) {
      this.setValidation(options.validate);
    }
    this.bindValidationEvents();
    if (options.type === "select" && options.selectOptions) {
      this.on("viewAppended", (function(_this) {
        return function() {
          var kallback;
          o = _this.getOptions();
          if ('function' === typeof o.selectOptions) {
            kallback = _this.bound("setSelectOptions");
            return o.selectOptions.call(_this, kallback);
          } else if (!o.selectOptions.length) {
            if (!o.defaultValue) {
              return _this.setValue(o.selectOptions[Object.keys(o.selectOptions)[0]][0].value);
            }
          } else {
            if (!o.defaultValue) {
              return _this.setValue(o.selectOptions[0].value);
            }
          }
        };
      })(this));
    }
    if (o.autogrow) {
      this.once("focus", (function(_this) {
        return function() {
          if (!_this.initialHeight) {
            return _this.initialHeight = _this.$().height();
          }
        };
      })(this));
    }
  }

  KDInputView.prototype.setDomElement = function(cssClass) {
    var name;
    if (cssClass == null) {
      cssClass = "";
    }
    name = "name='" + this.options.name + "'";
    return this.domElement = (function() {
      switch (this.getType()) {
        case "text":
          return $("<input " + name + " type='text' class='kdinput text " + cssClass + "'/>");
        case "password":
          return $("<input " + name + " type='password' class='kdinput text " + cssClass + "'/>");
        case "hidden":
          return $("<input " + name + " type='hidden' class='kdinput hidden " + cssClass + "'/>");
        case "checkbox":
          return $("<input " + name + " type='checkbox' class='kdinput checkbox " + cssClass + "'/>");
        case "textarea":
          return $("<textarea " + name + " class='kdinput text " + cssClass + "'></textarea>");
        case "select":
          return $("<select " + name + " class='kdinput select " + cssClass + "'/>");
        case "range":
          return $("<input " + name + " type='range' class='kdinput range " + cssClass + "'/>");
        default:
          return $("<input " + name + " type='" + (this.getType()) + "' class='kdinput " + (this.getType()) + " " + cssClass + "'/>");
      }
    }).call(this);
  };

  KDInputView.prototype.bindValidationEvents = function() {
    this.on("ValidationError", this.bound("giveValidationFeedback"));
    this.on("ValidationPassed", this.bound("giveValidationFeedback"));
    return this.on("focus", this.bound("clearValidationFeedback"));
  };

  KDInputView.prototype.setLabel = function(label) {
    if (label == null) {
      label = this.getOptions().label;
    }
    if (!label) {
      return;
    }
    this.inputLabel = label;
    this.inputLabel.$()[0].setAttribute("for", this.getName());
    return this.inputLabel.$().bind("click", (function(_this) {
      return function() {
        _this.$().trigger("focus");
        return _this.$().trigger("click");
      };
    })(this));
  };

  KDInputView.prototype.getLabel = function() {
    return this.inputLabel;
  };

  KDInputView.prototype.setCallback = function() {
    return this.inputCallback = this.getOptions().callback;
  };

  KDInputView.prototype.getCallback = function() {
    return this.inputCallback;
  };

  KDInputView.prototype.setType = function(inputType) {
    this.inputType = inputType != null ? inputType : "text";
  };

  KDInputView.prototype.getType = function() {
    return this.inputType;
  };

  KDInputView.prototype.setName = function(inputName) {
    this.inputName = inputName;
  };

  KDInputView.prototype.getName = function() {
    return this.inputName;
  };

  KDInputView.prototype.setFocus = function() {
    (KD.getSingleton("windowController")).setKeyView(this);
    return this.$().trigger("focus");
  };

  KDInputView.prototype.setBlur = function() {
    (KD.getSingleton("windowController")).setKeyView(null);
    return this.$().trigger("blur");
  };

  KDInputView.prototype.setSelectOptions = function(options) {
    var $optGroup, optGroup, option, subOptions, _i, _j, _len, _len1;
    if (!options.length) {
      for (optGroup in options) {
        if (!__hasProp.call(options, optGroup)) continue;
        subOptions = options[optGroup];
        $optGroup = $("<optgroup label='" + optGroup + "'/>");
        this.$().append($optGroup);
        for (_i = 0, _len = subOptions.length; _i < _len; _i++) {
          option = subOptions[_i];
          $optGroup.append("<option value='" + option.value + "'>" + option.title + "</option>");
        }
      }
    } else if (options.length) {
      for (_j = 0, _len1 = options.length; _j < _len1; _j++) {
        option = options[_j];
        this.$().append("<option value='" + option.value + "'>" + option.title + "</option>");
      }
    } else {
      warn("no valid options specified for the input:", this);
    }
    return this.$().val(this.getDefaultValue());
  };

  KDInputView.prototype.setDefaultValue = function(value) {
    if ((value == null) && value !== '') {
      return;
    }
    KDInputView.prototype.setValue.call(this, value);
    return this.inputDefaultValue = value;
  };

  KDInputView.prototype.getDefaultValue = function() {
    return this.inputDefaultValue;
  };

  KDInputView.prototype.setPlaceHolder = function(value) {
    if (this.$().is("input") || this.$().is("textarea")) {
      this.$().attr("placeholder", value);
      return this.options.placeholder = value;
    }
  };

  KDInputView.prototype.makeDisabled = function() {
    return this.getDomElement().attr("disabled", "disabled");
  };

  KDInputView.prototype.makeEnabled = function() {
    return this.getDomElement().removeAttr("disabled");
  };

  KDInputView.prototype.getValue = function() {
    var forceCase, value;
    if (this.getOption("type") === "checkbox") {
      value = this.$().is(':checked');
    } else {
      value = this.getDomElement().val();
      forceCase = this.getOptions().forceCase;
      if (forceCase) {
        value = forceCase.toLowerCase() === 'uppercase' ? value.toUpperCase() : value.toLowerCase();
      }
    }
    return value;
  };

  KDInputView.prototype.setValue = function(value) {
    var $el, el, _ref;
    $el = this.$();
    el = $el[0];
    if ((_ref = this.getOption("type")) === "checkbox" || _ref === "radio") {
      if (value) {
        return el.setAttribute("checked", "checked");
      } else {
        return el.removeAttribute("checked");
      }
    } else {
      return $el.val(value);
    }
  };

  KDInputView.prototype.setCase = function(forceCase) {
    var cb;
    cb = (function(_this) {
      return function() {
        var $el, el, end, start, val;
        $el = _this.getDomElement();
        el = $el[0];
        val = _this.getValue();
        if (val === $el.val()) {
          return;
        }
        start = el.selectionStart;
        end = el.selectionEnd;
        _this.setValue(val);
        if (el.setSelectionRange) {
          return el.setSelectionRange(start, end);
        }
      };
    })(this);
    this.on("keyup", cb);
    return this.on("blur", cb);
  };

  KDInputView.prototype.unsetValidation = function() {
    return this.setValidation({});
  };

  KDInputView.prototype.setValidation = function(ruleSet) {
    var oldCallback, oldCallbacks, oldEventName, _i, _len, _ref;
    this.valid = false;
    this.currentRuleset = ruleSet;
    this.validationCallbacks || (this.validationCallbacks = {});
    this.createRuleChain(ruleSet);
    _ref = this.validationCallbacks;
    for (oldEventName in _ref) {
      if (!__hasProp.call(_ref, oldEventName)) continue;
      oldCallbacks = _ref[oldEventName];
      for (_i = 0, _len = oldCallbacks.length; _i < _len; _i++) {
        oldCallback = oldCallbacks[_i];
        this.off(oldEventName, oldCallback);
      }
    }
    return this.ruleChain.forEach((function(_this) {
      return function(rule) {
        var cb, eventName, _base;
        eventName = ruleSet.events ? ruleSet.events[rule] ? ruleSet.events[rule] : ruleSet.event ? ruleSet.event : void 0 : ruleSet.event ? ruleSet.event : void 0;
        if (eventName) {
          (_base = _this.validationCallbacks)[eventName] || (_base[eventName] = []);
          _this.validationCallbacks[eventName].push(cb = function(event) {
            if (__indexOf.call(_this.ruleChain, rule) >= 0) {
              return _this.validate(rule, event);
            }
          });
          return _this.on(eventName, cb);
        }
      };
    })(this));
  };

  KDInputView.prototype.validate = function(rule, event) {
    var allClear, errMsg, result, ruleSet, rulesToBeValidated, _ref;
    if (event == null) {
      event = {};
    }
    this.ruleChain || (this.ruleChain = []);
    this.validationResults || (this.validationResults = {});
    rulesToBeValidated = rule ? [rule] : this.ruleChain;
    ruleSet = this.currentRuleset || this.getOptions().validate;
    if (this.ruleChain.length > 0) {
      rulesToBeValidated.forEach((function(_this) {
        return function(rule) {
          var result;
          if (KDInputValidator["rule" + (rule.capitalize())] != null) {
            result = KDInputValidator["rule" + (rule.capitalize())](_this, event);
            return _this.setValidationResult(rule, result);
          } else if ("function" === typeof ruleSet.rules[rule]) {
            return ruleSet.rules[rule](_this, event);
          }
        };
      })(this));
    } else {
      this.valid = true;
    }
    allClear = true;
    _ref = this.validationResults;
    for (result in _ref) {
      if (!__hasProp.call(_ref, result)) continue;
      errMsg = _ref[result];
      if (errMsg) {
        allClear = false;
      }
    }
    this.valid = allClear ? true : false;
    if (this.valid) {
      this.emit("ValidationPassed");
    }
    this.emit("ValidationResult", this.valid);
    return this.valid;
  };

  KDInputView.prototype.createRuleChain = function(ruleSet) {
    var rule, rules, value, _i, _len, _ref, _results;
    rules = ruleSet.rules;
    this.validationResults || (this.validationResults = {});
    this.ruleChain = typeof rules === "object" ? (function() {
      var _results;
      _results = [];
      for (rule in rules) {
        if (!__hasProp.call(rules, rule)) continue;
        value = rules[rule];
        _results.push(rule);
      }
      return _results;
    })() : [rules];
    _ref = this.ruleChain;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      rule = _ref[_i];
      _results.push(this.validationResults[rule] = null);
    }
    return _results;
  };

  KDInputView.prototype.setValidationResult = function(rule, err, showNotification) {
    if (showNotification == null) {
      showNotification = true;
    }
    if (err) {
      this.validationResults[rule] = err;
      if (this.getOptions().validate.notifications && showNotification) {
        this.showValidationError(err);
      }
      this.emit("ValidationError", err);
      return this.valid = false;
    } else {
      this.validationResults[rule] = null;
      return this.valid = !_.values(this.validationResults).map(function(result) {
        return Boolean(result);
      }).indexOf(true) > -1;
    }
  };

  KDInputView.prototype.showValidationError = function(message) {
    var container, notice, notifications, str, _ref, _ref1;
    if ((_ref = this.validationNotifications[message]) != null) {
      _ref.destroy();
    }
    _ref1 = this.getOption('validate'), container = _ref1.container, notifications = _ref1.notifications;
    if ((notifications != null ? notifications.type : void 0) === 'tooltip') {
      if (this.tooltip) {
        str = "- " + message + "<br>" + (this.tooltip.getOption('title'));
      }
      this.unsetTooltip();
      notifications = {
        cssClass: notifications.cssClass || 'input-validation',
        delegate: notifications.delegate || this,
        title: notifications.title || str || message,
        placement: notifications.placement || 'right',
        direction: notifications.direction || 'left',
        forcePosition: true
      };
      this.validationNotifications[message] = notice = this.setTooltip(notifications);
      notice.show();
    } else if (notifications) {
      this.validationNotifications[message] = notice = new KDNotificationView({
        container: container,
        title: message,
        type: 'growl',
        cssClass: 'mini',
        duration: 2500
      });
    }
    return notice.on("KDObjectWillBeDestroyed", (function(_this) {
      return function() {
        message = notice.getOptions().title;
        return delete _this.validationNotifications[message];
      };
    })(this));
  };

  KDInputView.prototype.clearValidationFeedback = function() {
    this.unsetClass("validation-error validation-passed");
    return this.emit("ValidationFeedbackCleared");
  };

  KDInputView.prototype.giveValidationFeedback = function(err) {
    if (!this.getOption("decorateValidation")) {
      return;
    }
    if (err) {
      return this.setClass("validation-error");
    } else {
      this.setClass("validation-passed");
      return this.unsetClass("validation-error");
    }
  };

  KDInputView.prototype.setCaretPosition = function(pos) {
    return this.selectRange(pos, pos);
  };

  KDInputView.prototype.getCaretPosition = function() {
    var el, r, rc, re;
    el = this.$()[0];
    if (el.selectionStart) {
      return el.selectionStart;
    } else if (document.selection) {
      el.focus();
      r = document.selection.createRange();
      if (!r) {
        return 0;
      }
      re = el.createTextRange();
      rc = re.duplicate();
      re.moveToBookmark(r.getBookmark());
      rc.setEndPoint('EndToStart', re);
      return rc.text.length;
    }
    return 0;
  };

  KDInputView.prototype.selectAll = function() {
    return this.getDomElement().select();
  };

  KDInputView.prototype.selectRange = function(selectionStart, selectionEnd) {
    var input, range;
    input = this.$()[0];
    if (input.setSelectionRange) {
      input.focus();
      return input.setSelectionRange(selectionStart, selectionEnd);
    } else if (input.createTextRange) {
      range = input.createTextRange();
      range.collapse(true);
      range.moveEnd('character', selectionEnd);
      range.moveStart('character', selectionStart);
      return range.select();
    }
  };

  KDInputView.prototype.setAutoGrow = function() {
    var $input;
    $input = this.$();
    $input.css("overflow", "hidden");
    this.setClass("autogrow");
    this._clone = $("<div/>", {
      "class": "invisible"
    });
    this.on("focus", (function(_this) {
      return function() {
        _this._clone.appendTo('body');
        return _this._clone.css({
          height: "auto",
          zIndex: 100000,
          width: $input.css('width'),
          boxSizing: $input.css('box-sizing'),
          borderTop: $input.css('border-top'),
          borderRight: $input.css('border-right'),
          borderBottom: $input.css('border-bottom'),
          borderLeft: $input.css('border-left'),
          minHeight: $input.css('minHeight'),
          maxHeight: $input.css('maxHeight'),
          paddingTop: $input.css('padding-top'),
          paddingRight: $input.css('padding-right'),
          paddingBottom: $input.css('padding-bottom'),
          paddingLeft: $input.css('padding-left'),
          wordBreak: $input.css('wordBreak'),
          fontSize: $input.css('fontSize'),
          fontWeight: $input.css('fontWeight'),
          lineHeight: $input.css('lineHeight'),
          whiteSpace: "pre-line"
        });
      };
    })(this));
    this.on("blur", (function(_this) {
      return function() {
        _this._clone.detach();
        return _this.$()[0].style.height = "none";
      };
    })(this));
    return this.on("keyup", (function(_this) {
      return function(event) {
        return _this.resize();
      };
    })(this));
  };

  KDInputView.prototype.resize = function() {
    var border, height, padding;
    if (!this._clone) {
      return;
    }
    if (!document.body.contains(this._clone[0])) {
      this._clone.appendTo('body');
    }
    this._clone.html(Encoder.XSSEncode(this.getValue()));
    this._clone.append(document.createElement("br"));
    height = this._clone.height();
    if (this.$().css("boxSizing") === "border-box") {
      padding = parseInt(this._clone.css("paddingTop"), 10) + parseInt(this._clone.css("paddingBottom"), 10);
      border = parseInt(this._clone.css("borderTopWidth"), 10) + parseInt(this._clone.css("borderBottomWidth"), 10);
      height = height + border + padding;
    }
    return this.setHeight(this.initialHeight ? Math.max(this.initialHeight, height) : height);
  };

  KDInputView.prototype.enableTabKey = function() {
    return this.inputTabKeyEnabled = true;
  };

  KDInputView.prototype.disableTabKey = function() {
    return this.inputTabKeyEnabled = false;
  };

  KDInputView.prototype.change = function() {};

  KDInputView.prototype.keyUp = function() {
    return true;
  };

  KDInputView.prototype.keyDown = function(event) {
    if (this.inputTabKeyEnabled) {
      this.checkTabKey(event);
    }
    return true;
  };

  KDInputView.prototype.focus = function() {
    this.setKeyView();
    return true;
  };

  KDInputView.prototype.blur = function() {
    KD.getSingleton("windowController").revertKeyView(this);
    return true;
  };

  KDInputView.prototype.mouseDown = function() {
    this.setFocus();
    return false;
  };

  KDInputView.prototype.checkTabKey = function(event) {
    var post, pre, se, sel, ss, t, tab, tabLength;
    tab = "  ";
    tabLength = tab.length;
    t = event.target;
    ss = t.selectionStart;
    se = t.selectionEnd;
    if (event.which === 9) {
      event.preventDefault();
      if (ss !== se && t.value.slice(ss, se).indexOf("n") !== -1) {
        pre = t.value.slice(0, ss);
        sel = t.value.slice(ss, se).replace(/n/g, "n" + tab);
        post = t.value.slice(se, t.value.length);
        t.value = pre.concat(tab).concat(sel).concat(post);
        t.selectionStart = ss + tab.length;
        return t.selectionEnd = se + tab.length;
      } else {
        t.value = t.value.slice(0, ss).concat(tab).concat(t.value.slice(ss, t.value.length));
        if (ss === se) {
          return t.selectionStart = t.selectionEnd = ss + tab.length;
        } else {
          t.selectionStart = ss + tab.length;
          return t.selectionEnd = se + tab.length;
        }
      }
    } else if (event.which === 8 && t.value.slice(ss - tabLength, ss) === tab) {
      event.preventDefault();
      t.value = t.value.slice(0, ss - tabLength).concat(t.value.slice(ss, t.value.length));
      return t.selectionStart = t.selectionEnd = ss - tab.length;
    } else if (event.which === 46 && t.value.slice(se, se + tabLength) === tab) {
      event.preventDefault();
      t.value = t.value.slice(0, ss).concat(t.value.slice(ss + tabLength, t.value.length));
      return t.selectionStart = t.selectionEnd = ss;
    } else if (event.which === 37 && t.value.slice(ss - tabLength, ss) === tab) {
      event.preventDefault();
      return t.selectionStart = t.selectionEnd = ss - tabLength;
    } else if (event.which === 39 && t.value.slice(ss, ss + tabLength) === tab) {
      event.preventDefault();
      return t.selectionStart = t.selectionEnd = ss + tabLength;
    }
  };

  return KDInputView;

})(KDView);


},{"./../../core/view.coffee":106,"./inputvalidator.coffee":45}],47:[function(require,module,exports){
var KDLabelView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDLabelView = (function(_super) {
  __extends(KDLabelView, _super);

  function KDLabelView(options) {
    if ((options != null ? options.title : void 0) != null) {
      this.setTitle(options.title);
    }
    KDLabelView.__super__.constructor.call(this, options);
  }

  KDLabelView.prototype.setDomElement = function(cssClass) {
    return this.domElement = $("<label class='kdlabel " + cssClass + "'>" + (this.getTitle()) + "</label>");
  };

  KDLabelView.prototype.setTitle = function(title) {
    return this.labelTitle = title || '';
  };

  KDLabelView.prototype.updateTitle = function(title) {
    this.setTitle(title);
    return this.$().html(title);
  };

  KDLabelView.prototype.getTitle = function() {
    return this.labelTitle;
  };

  return KDLabelView;

})(KDView);


},{"./../../core/view.coffee":106}],48:[function(require,module,exports){
var KDInputView, KDMultipleChoice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDInputView = require('./inputview.coffee');

module.exports = KDMultipleChoice = (function(_super) {
  var setCurrent;

  __extends(KDMultipleChoice, _super);

  function KDMultipleChoice(options, data) {
    if (options == null) {
      options = {};
    }
    if (options.disabled == null) {
      options.disabled = false;
    }
    options.size || (options.size = "small");
    options.labels || (options.labels = ["ON", "OFF"]);
    options.titles || (options.titles = options.labels);
    if (options.multiple == null) {
      options.multiple = false;
    }
    options.defaultValue || (options.defaultValue = options.multiple ? options.labels[0] : void 0);
    if (!options.multiple && Array.isArray(options.defaultValue)) {
      options.defaultValue = options.defaultValue[0];
    }
    KDMultipleChoice.__super__.constructor.call(this, options, data);
    this.setClass(options.size);
    this.setPartial("<input class='hidden no-kdinput' name='" + (this.getName()) + "'/>");
    this.oldValue = null;
    if (options.multiple) {
      this.currentValue = [];
    }
    this.setDisabled(options.disabled);
  }

  KDMultipleChoice.prototype.setDomElement = function(cssClass) {
    var activeClass, clsName, defaultValue, i, label, labelItems, labels, name, titles, _i, _len, _ref;
    _ref = this.getOptions(), titles = _ref.titles, labels = _ref.labels, name = _ref.name, defaultValue = _ref.defaultValue;
    this.inputName = name;
    labelItems = "";
    for (i = _i = 0, _len = labels.length; _i < _len; i = ++_i) {
      label = labels[i];
      activeClass = label === defaultValue ? ' active' : '';
      clsName = "multiple-choice-" + label + activeClass;
      labelItems += "<a href='#' name='" + label + "' class='" + clsName + "' title='" + (titles[i] || 'Select ' + label) + "'>" + label + "</a>";
    }
    return this.domElement = $("<div class='kdinput on-off multiple-choice " + cssClass + "'>\n  " + labelItems + "\n</div> ");
  };

  KDMultipleChoice.prototype.getDefaultValue = function() {
    return this.getOptions().defaultValue;
  };

  KDMultipleChoice.prototype.getValue = function() {
    return this.currentValue;
  };

  setCurrent = function(view, label) {
    if (__indexOf.call(view.currentValue, label) >= 0) {
      view.$("a[name$='" + label + "']").removeClass('active');
      return view.currentValue.splice(view.currentValue.indexOf(label), 1);
    } else {
      view.$("a[name$='" + label + "']").addClass('active');
      return view.currentValue.push(label);
    }
  };

  KDMultipleChoice.prototype.setDisabled = function(disable) {
    if (disable == null) {
      disable = true;
    }
    return this._disabled = disable;
  };

  KDMultipleChoice.prototype.setValue = function(label, wCallback) {
    var multiple, obj, val, _ref;
    if (wCallback == null) {
      wCallback = true;
    }
    multiple = this.getOptions().multiple;
    if (multiple) {
      this.oldValue = (_ref = [
        (function() {
          var _i, _len, _ref1, _results;
          _ref1 = this.currentValue;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            obj = _ref1[_i];
            _results.push(obj);
          }
          return _results;
        }).call(this)
      ]) != null ? _ref.first : void 0;
      if (Array.isArray(label)) {
        [
          (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = label.length; _i < _len; _i++) {
              val = label[_i];
              _results.push(setCurrent(this, val));
            }
            return _results;
          }).call(this)
        ];
      } else {
        setCurrent(this, label);
      }
      if (wCallback) {
        return this.switchStateChanged();
      }
    } else {
      this.$("a").removeClass('active');
      this.$("a[name='" + label + "']").addClass('active');
      this.oldValue = this.currentValue;
      this.currentValue = label;
      if (this.currentValue !== this.oldValue && wCallback) {
        return this.switchStateChanged();
      }
    }
  };

  KDMultipleChoice.prototype.switchStateChanged = function() {
    if (this._disabled) {
      return;
    }
    if (this.getCallback() != null) {
      return this.getCallback().call(this, this.getValue());
    }
  };

  KDMultipleChoice.prototype.fallBackToOldState = function() {
    var multiple;
    multiple = this.getOptions().multiple;
    if (multiple) {
      this.currentValue = [];
      this.$("a").removeClass('active');
    }
    return this.setValue(this.oldValue, false);
  };

  KDMultipleChoice.prototype.mouseDown = function(event) {
    if (this._disabled) {
      return;
    }
    if ($(event.target).is('a')) {
      return this.setValue(event.target.name);
    }
  };

  return KDMultipleChoice;

})(KDInputView);


},{"./inputview.coffee":46}],49:[function(require,module,exports){
var KDInputView, KDOnOffSwitch,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDOnOffSwitch = (function(_super) {
  __extends(KDOnOffSwitch, _super);

  function KDOnOffSwitch(options, data) {
    if (options == null) {
      options = {};
    }
    options.type = "switch";
    options.title || (options.title = "");
    options.size || (options.size = "small");
    options.labels || (options.labels = ["ON", "OFF"]);
    if (options.defaultValue == null) {
      options.defaultValue = false;
    }
    KDOnOffSwitch.__super__.constructor.call(this, options, data);
    this.setClass(options.size);
    this.setPartial("<input class='checkbox hidden no-kdinput' type='checkbox' name='" + (this.getName()) + "'/>");
    this.setDefaultValue(options.defaultValue);
  }

  KDOnOffSwitch.prototype.setDomElement = function(cssClass) {
    var labels, name, title, _ref;
    _ref = this.getOptions(), title = _ref.title, labels = _ref.labels, name = _ref.name;
    if (title !== '') {
      title = "<span>" + title + "</span>";
    }
    this.inputName = name;
    return this.domElement = $("<div class='kdinput on-off off " + cssClass + "'>\n  " + title + "\n  <a href='#' class='on' title='turn on'>" + labels[0] + "</a><a href='#' class='off' title='turn off'>" + labels[1] + "</a>\n</div> ");
  };

  KDOnOffSwitch.prototype.getValue = function() {
    return this.$("input").attr("checked") === "checked";
  };

  KDOnOffSwitch.prototype.setValue = function(value, wCallback) {
    if (wCallback == null) {
      wCallback = true;
    }
    switch (value) {
      case true:
        return this.setOn(wCallback);
      case false:
        return this.setOff(wCallback);
    }
  };

  KDOnOffSwitch.prototype.setDefaultValue = function(value) {
    switch (value) {
      case true:
      case "on":
      case "true":
      case "yes":
      case 1:
        return this.setValue(true, false);
      default:
        return this.setValue(false, false);
    }
  };

  KDOnOffSwitch.prototype.setOff = function(wCallback) {
    if (wCallback == null) {
      wCallback = true;
    }
    if (!this.getValue() && wCallback) {
      return;
    }
    this.$("input").attr("checked", false);
    this.$('a.on').removeClass('active');
    this.$('a.off').addClass('active');
    if (wCallback) {
      return this.switchStateChanged();
    }
  };

  KDOnOffSwitch.prototype.setOn = function(wCallback) {
    if (wCallback == null) {
      wCallback = true;
    }
    if (this.getValue() && wCallback) {
      return;
    }
    this.$("input").attr("checked", true);
    this.$('a.off').removeClass('active');
    this.$('a.on').addClass('active');
    if (wCallback) {
      return this.switchStateChanged();
    }
  };

  KDOnOffSwitch.prototype.switchStateChanged = function() {
    this.emit('SwitchStateChanged', this.getValue());
    if (this.getCallback() != null) {
      return this.getCallback().call(this, this.getValue());
    }
  };

  KDOnOffSwitch.prototype.click = KD.utils.stopDOMEvent;

  KDOnOffSwitch.prototype.mouseDown = function(event) {
    if ($(event.target).is('a.on')) {
      return this.setValue(true);
    } else if ($(event.target).is('a.off')) {
      return this.setValue(false);
    }
  };

  return KDOnOffSwitch;

})(KDInputView);


},{"./inputview.coffee":46}],50:[function(require,module,exports){
var KDInputView, KDSelectBox,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDSelectBox = (function(_super) {
  __extends(KDSelectBox, _super);

  function KDSelectBox(options) {
    if (options == null) {
      options = {};
    }
    options.type = "select";
    KDSelectBox.__super__.constructor.call(this, options);
  }

  KDSelectBox.prototype.setDomElement = function(cssClass) {
    var name;
    this.inputName = this.getOption("name");
    name = "name='" + this.options.name + "'";
    this.domElement = $("<div class='kdselectbox " + cssClass + "'>\n  <select " + name + "></select>\n  <span class='title'></span>\n  <span class='arrows'></span>\n</div>\"");
    this._$select = this.$("select").eq(0);
    this._$title = this.$("span.title").eq(0);
    return this.domElement;
  };

  KDSelectBox.prototype.bindEvents = function() {
    this._$select.bind("blur change focus", (function(_this) {
      return function(event) {
        var _base;
        if (event.type === "change") {
          if (typeof (_base = _this.getCallback()) === "function") {
            _base(_this.getValue());
          }
        }
        _this.emit(event.type, event, _this.getValue());
        return _this.handleEvent(event);
      };
    })(this));
    return KDSelectBox.__super__.bindEvents.apply(this, arguments);
  };

  KDSelectBox.prototype.setDefaultValue = function(value) {
    if (value !== "") {
      this.getDomElement().val(value);
    }
    this._$select.val(value);
    this._$title.text(this._$select.find("option[value=\"" + value + "\"]").text());
    return this.inputDefaultValue = value;
  };

  KDSelectBox.prototype.getDefaultValue = function() {
    return this.inputDefaultValue;
  };

  KDSelectBox.prototype.getValue = function() {
    return this._$select.val();
  };

  KDSelectBox.prototype.setValue = function(value) {
    this._$select.val(value);
    return this.change();
  };

  KDSelectBox.prototype.makeDisabled = function() {
    this.setClass("disabled");
    return this._$select.attr("disabled", "disabled");
  };

  KDSelectBox.prototype.makeEnabled = function() {
    this.unsetClass("disabled");
    return this._$select.removeAttr("disabled");
  };

  KDSelectBox.prototype.setSelectOptions = function(options) {
    var $optGroup, firstOption, optGroup, option, subOptions, value, _i, _j, _len, _len1;
    firstOption = null;
    if (!options.length) {
      for (optGroup in options) {
        if (!__hasProp.call(options, optGroup)) continue;
        subOptions = options[optGroup];
        $optGroup = $("<optgroup label='" + optGroup + "'/>");
        this._$select.append($optGroup);
        for (_i = 0, _len = subOptions.length; _i < _len; _i++) {
          option = subOptions[_i];
          firstOption || (firstOption = option);
          $optGroup.append("<option value='" + option.value + "'>" + option.title + "</option>");
        }
      }
    } else if (options.length) {
      for (_j = 0, _len1 = options.length; _j < _len1; _j++) {
        option = options[_j];
        this._$select.append("<option value='" + option.value + "'>" + option.title + "</option>");
        firstOption || (firstOption = option);
      }
    } else {
      warn("no valid options specified for the input:", this);
    }
    value = this.getDefaultValue() || (firstOption != null ? firstOption.value : void 0) || "";
    this._$select.val(value + "");
    return this._$title.text(this._$select.find("option[value=\"" + value + "\"]").text());
  };

  KDSelectBox.prototype.removeSelectOptions = function() {
    this._$select.find("optgroup").remove();
    return this._$select.find("option").remove();
  };

  KDSelectBox.prototype.change = function() {
    return this._$title.text(this._$select.find("option[value=\"" + (this.getValue()) + "\"]").text());
  };

  KDSelectBox.prototype.focus = function() {
    return this.setClass('focus');
  };

  KDSelectBox.prototype.blur = function() {
    return this.unsetClass('focus');
  };

  return KDSelectBox;

})(KDInputView);


},{"./inputview.coffee":46}],51:[function(require,module,exports){
var KDContentEditableView, KDContextMenu, KDTokenizedInput,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDContentEditableView = require('./contenteditableview.coffee');

KDContextMenu = require('./../contextmenu/contextmenu.coffee');

module.exports = KDTokenizedInput = (function(_super) {
  __extends(KDTokenizedInput, _super);

  function KDTokenizedInput(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry("kdtokenizedinputview", options.cssClass);
    options.bind = KD.utils.curry("keyup", options.bind);
    options.rules || (options.rules = {});
    options.layer || (options.layer = {});
    KDTokenizedInput.__super__.constructor.call(this, options, data);
    this.tokenViews = {};
  }

  KDTokenizedInput.prototype.getValue = function(options) {
    var node, nodeValue, value, _i, _len, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    value = "";
    _ref = this.getEditableElement().childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (((_ref1 = node.tagName) != null ? _ref1.toLowerCase() : void 0) === "div") {
        value += "\n";
      }
      nodeValue = this.getValueOfNode(node);
      if (nodeValue !== "\n") {
        value += nodeValue;
      }
    }
    if (value === Encoder.htmlDecode(this.getOptions().placeholder)) {
      return "";
    } else {
      return value;
    }
  };

  KDTokenizedInput.prototype.getValueOfNode = function(node) {
    var value;
    value = "";
    switch (node.nodeType) {
      case Node.TEXT_NODE:
        if (node.textContent !== "") {
          value += node.textContent;
        }
        break;
      case Node.ELEMENT_NODE:
        value += this.getValueOfElement(node);
    }
    return value;
  };

  KDTokenizedInput.prototype.getValueOfElement = function(element) {
    var child, key, tagName, value, _i, _len, _ref, _ref1;
    key = (_ref = element.dataset) != null ? _ref.key : void 0;
    if (key) {
      value = this.getValueOfTokenElement(key);
    }
    if (value) {
      return value;
    }
    tagName = element.tagName.toLowerCase();
    switch (tagName) {
      case "br":
        return "\n";
      default:
        value = "";
        _ref1 = element.childNodes;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          child = _ref1[_i];
          value += this.getValueOfNode(child);
        }
        return value || "";
    }
  };

  KDTokenizedInput.prototype.getValueOfTokenElement = function(key) {
    var view;
    view = this.getTokenView(key);
    if (key && view) {
      return view.encodeValue();
    }
  };

  KDTokenizedInput.prototype.getTokens = function() {
    return this.findTokensInElement(this.getEditableElement());
  };

  KDTokenizedInput.prototype.findTokensInElement = function(element) {
    var child, data, key, tokens, type, view, _i, _len, _ref, _ref1;
    tokens = [];
    _ref = element.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      switch (child.nodeType) {
        case Node.ELEMENT_NODE:
          if (key = (_ref1 = child.dataset) != null ? _ref1.key : void 0) {
            view = this.getTokenView(key);
            type = view.getOptions().type;
            data = view.getData();
            tokens.push({
              type: type,
              data: data
            });
          } else {
            tokens = tokens.concat(this.findTokensInElement(child));
          }
      }
    }
    return tokens;
  };

  KDTokenizedInput.prototype.getTokenView = function(key) {
    return this.tokenViews[key];
  };

  KDTokenizedInput.prototype.matchPrefix = function() {
    var char, name, node, range, rule, start, _ref, _ref1, _results;
    if (this.tokenInput) {
      return;
    }
    if (!(range = this.utils.getSelectionRange())) {
      return;
    }
    node = range.commonAncestorContainer;
    if (((_ref = node.children) != null ? _ref.length : void 0) === 1) {
      return node.textContent === node.children[0].textContent;
    }
    start = range.startOffset - 1;
    char = node.textContent[start];
    _ref1 = this.getOptions().rules;
    _results = [];
    for (name in _ref1) {
      rule = _ref1[name];
      if (char === rule.prefix) {
        this.activeRule = rule;
        this.tokenInput = document.createElement("span");
        this.tokenInput.textContent = rule.prefix;
        this.utils.replaceRange(node, this.tokenInput, start, start + rule.prefix.length);
        _results.push(this.utils.selectText(this.tokenInput, rule.prefix.length));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  KDTokenizedInput.prototype.matchToken = function() {
    var dataSource, token;
    if (!this.tokenInput.parentNode) {
      return this.cancel();
    }
    this.sanitizeInput();
    token = this.tokenInput.textContent.substring(this.activeRule.prefix.length);
    if (token.trim()) {
      dataSource = this.activeRule.dataSource;
      return dataSource(token, this.bound("showMenu"));
    } else if (token.length !== 0) {
      return this.cancel();
    }
  };

  KDTokenizedInput.prototype.sanitizeInput = function() {};

  KDTokenizedInput.prototype.showMenu = function(options, data) {
    var pos, _ref;
    if ((_ref = this.menu) != null) {
      _ref.destroy();
    }
    this.blur();
    if (!(this.tokenInput && data.length)) {
      return;
    }
    pos = this.tokenInput.getBoundingClientRect();
    options.x = pos.left;
    options.y = pos.top + parseInt(window.getComputedStyle(this.tokenInput).lineHeight, 10);
    this.menu = new KDContextMenu(options, data);
    return this.menu.on("ContextMenuItemReceivedClick", this.bound("menuItemClicked"));
  };

  KDTokenizedInput.prototype.hideMenu = function() {
    var _ref;
    if ((_ref = this.menu) != null) {
      _ref.destroy();
    }
    this.menu = null;
    this.activeRule = null;
    return this.tokenInput = null;
  };

  KDTokenizedInput.prototype.menuItemClicked = function(item, tokenViewClass) {
    this.addToken(item.data, tokenViewClass);
    return this.hideMenu();
  };

  KDTokenizedInput.prototype.addToken = function(item, tokenViewClass) {
    var pistachio, prefix, tokenElement, tokenKey, tokenView, type, _ref;
    if (tokenViewClass == null) {
      tokenViewClass = this.getOptions().tokenViewClass;
    }
    _ref = this.activeRule, type = _ref.type, prefix = _ref.prefix, pistachio = _ref.pistachio;
    tokenView = new tokenViewClass({
      type: type,
      prefix: prefix,
      pistachio: pistachio
    }, item);
    tokenElement = tokenView.getElement();
    tokenKey = "" + (tokenView.getId()) + "-" + (tokenView.getKey());
    this.tokenViews[tokenKey] = tokenView;
    tokenView.setAttributes({
      "data-key": tokenKey
    });
    this.tokenInput.parentElement.insertBefore(tokenElement, this.tokenInput);
    tokenView.emit("viewAppended");
    this.tokenInput.nextSibling.textContent = "\u00a0";
    this.utils.selectText(this.tokenInput.nextSibling, 1);
    this.tokenInput.remove();
    return this.emit("TokenAdded", type, item);
  };

  KDTokenizedInput.prototype.keyDown = function(event) {
    switch (event.which) {
      case 9:
      case 13:
      case 27:
      case 38:
      case 40:
        if (this.menu) {
          this.menu.treeController.keyEventHappened(event);
          this.utils.stopDOMEvent(event);
        }
        break;
      default:
        KDTokenizedInput.__super__.keyDown.call(this, event);
    }
    switch (event.which) {
      case 27:
        if (this.tokenInput) {
          return this.cancel();
        }
    }
  };

  KDTokenizedInput.prototype.keyUp = function(event) {
    KDTokenizedInput.__super__.keyUp.apply(this, arguments);
    switch (event.which) {
      case 9:
      case 13:
      case 27:
      case 38:
      case 40:
        break;
      default:
        if (event.altKey || event.ctrlKey || event.metaKey) {
          return;
        }
        if (this.activeRule) {
          return this.matchToken();
        } else {
          return this.matchPrefix();
        }
    }
  };

  KDTokenizedInput.prototype.cancel = function() {
    var text;
    if (this.tokenInput.parentNode) {
      text = document.createTextNode(this.tokenInput.textContent);
      this.tokenInput.parentElement.insertBefore(text, this.tokenInput);
      this.tokenInput.nextSibling.remove();
      this.tokenInput.remove();
      this.utils.selectEnd(text);
    }
    return this.hideMenu();
  };

  KDTokenizedInput.prototype.reset = function() {
    var id, view, _ref, _results;
    this.setPlaceholder();
    this.blur();
    _ref = this.tokenViews;
    _results = [];
    for (id in _ref) {
      if (!__hasProp.call(_ref, id)) continue;
      view = _ref[id];
      view.destroy();
      _results.push(delete this.tokenViews[id]);
    }
    return _results;
  };

  KDTokenizedInput.prototype.viewAppended = function() {
    KDTokenizedInput.__super__.viewAppended.apply(this, arguments);
    return this.setEditingMode(true);
  };

  return KDTokenizedInput;

})(KDContentEditableView);


},{"./../contextmenu/contextmenu.coffee":23,"./contenteditableview.coffee":39}],52:[function(require,module,exports){
var KDInputView, KDWmdInput,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDInputView = require('./inputview.coffee');

module.exports = KDWmdInput = (function(_super) {
  __extends(KDWmdInput, _super);

  function KDWmdInput(options, data) {
    var _ref;
    options = options != null ? options : {};
    options.type = "textarea";
    options.preview = (_ref = options.preview) != null ? _ref : false;
    KDWmdInput.__super__.constructor.call(this, options, data);
    this.setClass("monospace");
  }

  KDWmdInput.prototype.setWMD = function() {
    var preview;
    preview = this.getOptions().preview;
    this.getDomElement().wmd({
      preview: preview
    });
    if (preview) {
      return this.getDomElement().after("<h3 class='wmd-preview-title'>Preview:</h3>");
    }
  };

  return KDWmdInput;

})(KDInputView);


},{"./inputview.coffee":46}],53:[function(require,module,exports){
var KDListItemView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDListItemView = (function(_super) {
  __extends(KDListItemView, _super);

  function KDListItemView(options, data) {
    var _ref, _ref1;
    if (options == null) {
      options = {};
    }
    options.type = (_ref = options.type) != null ? _ref : "default";
    options.cssClass = "kdlistitemview kdlistitemview-" + options.type + " " + ((_ref1 = options.cssClass) != null ? _ref1 : '');
    options.bind || (options.bind = "mouseenter mouseleave");
    options.childClass || (options.childClass = null);
    options.childOptions || (options.childOptions = {});
    if (options.selectable == null) {
      options.selectable = true;
    }
    KDListItemView.__super__.constructor.call(this, options, data);
    this.content = {};
  }

  KDListItemView.prototype.viewAppended = function() {
    var childClass, childOptions, _ref;
    _ref = this.getOptions(), childClass = _ref.childClass, childOptions = _ref.childOptions;
    if (childClass) {
      return this.addSubView(this.child = new childClass(childOptions, this.getData()));
    } else {
      return this.setPartial(this.partial(this.data));
    }
  };

  KDListItemView.prototype.partial = function() {
    return "<div class='kdlistitemview-default-content'> <p>This is a default partial of <b>KDListItemView</b>, you need to override this partial to have your custom content here.</p> </div>";
  };

  KDListItemView.prototype.dim = function() {
    return this.setClass("dimmed");
  };

  KDListItemView.prototype.undim = function() {
    return this.unsetClass("dimmed");
  };

  KDListItemView.prototype.highlight = function() {
    this.undim();
    return this.setClass("selected");
  };

  KDListItemView.prototype.removeHighlight = function() {
    this.undim();
    return this.unsetClass("selected");
  };

  KDListItemView.prototype.getItemDataId = function() {
    var _base;
    return (typeof (_base = this.getData()).getId === "function" ? _base.getId() : void 0) || this.getData().id || this.getData()._id;
  };

  return KDListItemView;

})(KDView);


},{"./../../core/view.coffee":106}],54:[function(require,module,exports){
var KDListView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDListView = (function(_super) {
  __extends(KDListView, _super);

  function KDListView(options, data) {
    if (options == null) {
      options = {};
    }
    options.type || (options.type = "default");
    if (options.lastToFirst == null) {
      options.lastToFirst = false;
    }
    options.cssClass = options.cssClass != null ? "kdlistview kdlistview-" + options.type + " " + options.cssClass : "kdlistview kdlistview-" + options.type;
    if (!this.items) {
      this.items = [];
    }
    KDListView.__super__.constructor.call(this, options, data);
  }

  KDListView.prototype.empty = function() {
    var i, item, _i, _len, _ref;
    _ref = this.items;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      item = _ref[i];
      if (item != null) {
        item.destroy();
      }
    }
    return this.items = [];
  };

  KDListView.prototype.keyDown = function(event) {
    event.stopPropagation();
    event.preventDefault();
    return this.emit("KeyDownOnList", event);
  };

  KDListView.prototype.addItem = function(itemData, index, animation) {
    var itemChildClass, itemChildOptions, itemInstance, itemOptions, _ref, _ref1;
    _ref = this.getOptions(), itemChildClass = _ref.itemChildClass, itemChildOptions = _ref.itemChildOptions;
    if ((index != null) && typeof index !== 'number') {
      itemOptions = index;
      index = null;
    } else {
      itemOptions = this.getOptions().itemOptions;
    }
    itemOptions = (typeof this.customizeItemOptions === "function" ? this.customizeItemOptions(itemOptions, itemData) : void 0) || itemOptions || {};
    itemOptions.delegate || (itemOptions.delegate = this);
    itemOptions.childClass || (itemOptions.childClass = itemChildClass);
    itemOptions.childOptions || (itemOptions.childOptions = itemChildOptions);
    itemInstance = new ((_ref1 = this.getOptions().itemClass) != null ? _ref1 : KDListItemView)(itemOptions, itemData);
    this.addItemView(itemInstance, index, animation);
    return itemInstance;
  };

  KDListView.prototype.removeItem = function(itemInstance, itemData, index) {
    var i, item, _i, _len, _ref;
    if (index != null) {
      this.emit('ItemIsBeingDestroyed', {
        view: this.items[index],
        index: index
      });
      item = this.items.splice(index, 1);
      item[0].destroy();
    } else {
      _ref = this.items;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        if (itemInstance === item || itemData === item.getData()) {
          this.emit('ItemIsBeingDestroyed', {
            view: item,
            index: i
          });
          this.items.splice(i, 1);
          item.destroy();
          return;
        }
      }
    }
  };

  KDListView.prototype.removeItemByData = function(itemData) {
    return this.removeItem(null, itemData);
  };

  KDListView.prototype.removeItemByIndex = function(index) {
    return this.removeItem(null, null, index);
  };

  KDListView.prototype.destroy = function(animated, animationType, duration) {
    var item, _i, _len, _ref;
    if (animated == null) {
      animated = false;
    }
    if (animationType == null) {
      animationType = "slideUp";
    }
    if (duration == null) {
      duration = 100;
    }
    _ref = this.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      item.destroy();
    }
    return KDListView.__super__.destroy.call(this);
  };

  KDListView.prototype.addItemView = function(itemInstance, index, animation) {
    var actualIndex;
    this.emit('ItemWasAdded', itemInstance, index);
    if (index != null) {
      actualIndex = this.getOptions().lastToFirst ? this.items.length - index - 1 : index;
      this.items.splice(actualIndex, 0, itemInstance);
      this.appendItemAtIndex(itemInstance, index, animation);
    } else {
      this.items[this.getOptions().lastToFirst ? 'unshift' : 'push'](itemInstance);
      this.appendItem(itemInstance, animation);
    }
    return itemInstance;
  };

  KDListView.prototype.appendItem = function(itemInstance, animation) {
    var scroll;
    itemInstance.setParent(this);
    scroll = this.doIHaveToScroll();
    if (animation != null) {
      itemInstance.$().hide();
      this.$()[this.getOptions().lastToFirst ? 'prepend' : 'append'](itemInstance.$());
      itemInstance.$()[animation.type](animation.duration, (function(_this) {
        return function() {
          return itemInstance.emit('introEffectCompleted');
        };
      })(this));
    } else {
      this.$()[this.getOptions().lastToFirst ? 'prepend' : 'append'](itemInstance.$());
    }
    if (scroll) {
      this.scrollDown();
    }
    if (this.parentIsInDom) {
      itemInstance.emit('viewAppended');
    }
    return null;
  };

  KDListView.prototype.appendItemAtIndex = function(itemInstance, index, animation) {
    var actualIndex;
    itemInstance.setParent(this);
    actualIndex = this.getOptions().lastToFirst ? this.items.length - index - 1 : index;
    if (animation != null) {
      itemInstance.$().hide();
      if (index === 0) {
        this.$()[this.getOptions().lastToFirst ? 'append' : 'prepend'](itemInstance.$());
      }
      if (index > 0) {
        this.items[actualIndex - 1].$()[this.getOptions().lastToFirst ? 'before' : 'after'](itemInstance.$());
      }
      itemInstance.$()[animation.type](animation.duration, (function(_this) {
        return function() {
          return itemInstance.emit('introEffectCompleted');
        };
      })(this));
    } else {
      if (index === 0) {
        this.$()[this.getOptions().lastToFirst ? 'append' : 'prepend'](itemInstance.$());
      }
      if (index > 0) {
        this.items[actualIndex - 1].$()[this.getOptions().lastToFirst ? 'before' : 'after'](itemInstance.$());
      }
    }
    if (this.parentIsInDom) {
      itemInstance.emit('viewAppended');
    }
    return null;
  };

  KDListView.prototype.getItemIndex = function(targetItem) {
    var index, item, _i, _len, _ref;
    _ref = this.items;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      item = _ref[index];
      if (item === targetItem) {
        return index;
      }
    }
    return -1;
  };

  KDListView.prototype.moveItemToIndex = function(item, newIndex) {
    var currentIndex, diff, targetItem;
    currentIndex = this.getItemIndex(item);
    if (currentIndex < 0) {
      warn("Item doesn't exists", item);
      return this.items;
    }
    newIndex = Math.max(0, Math.min(this.items.length - 1, newIndex));
    if (newIndex >= this.items.length - 1) {
      targetItem = this.items.last;
      targetItem.$().after(item.$());
    } else {
      diff = newIndex > currentIndex ? 1 : 0;
      targetItem = this.items[newIndex + diff];
      targetItem.$().before(item.$());
    }
    this.items.splice(currentIndex, 1);
    this.items.splice(newIndex, 0, item);
    return this.items;
  };

  KDListView.prototype.scrollDown = function() {
    clearTimeout(this._scrollDownTimeout);
    return this._scrollDownTimeout = setTimeout((function(_this) {
      return function() {
        var scrollView, slidingHeight, slidingView;
        scrollView = _this.$().closest(".kdscrollview");
        slidingView = scrollView.find('> .kdview');
        slidingHeight = slidingView.height();
        return scrollView.animate({
          scrollTop: slidingHeight
        }, {
          duration: 200,
          queue: false
        });
      };
    })(this), 50);
  };

  KDListView.prototype.doIHaveToScroll = function() {
    var scrollView;
    scrollView = this.$().closest(".kdscrollview");
    if (this.getOptions().autoScroll) {
      if (scrollView.length && scrollView[0].scrollHeight <= scrollView.height()) {
        return true;
      } else {
        return this.isScrollAtBottom();
      }
    } else {
      return false;
    }
  };

  KDListView.prototype.isScrollAtBottom = function() {
    var scrollTop, scrollView, scrollViewheight, slidingHeight, slidingView;
    scrollView = this.$().closest(".kdscrollview");
    slidingView = scrollView.find('> .kdview');
    scrollTop = scrollView.scrollTop();
    slidingHeight = slidingView.height();
    scrollViewheight = scrollView.height();
    if (slidingHeight - scrollViewheight === scrollTop) {
      return true;
    } else {
      return false;
    }
  };

  return KDListView;

})(KDView);


},{"./../../core/view.coffee":106}],55:[function(require,module,exports){
var KDListView, KDListViewController, KDLoaderView, KDScrollView, KDView, KDViewController,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDView = require('./../../core/view.coffee');

KDViewController = require('./../../core/viewcontroller.coffee');

KDScrollView = require('./../scrollview/scrollview.coffee');

KDListView = require('./../list/listview.coffee');

KDLoaderView = require('./../loader/loaderview.coffee');

module.exports = KDListViewController = (function(_super) {
  __extends(KDListViewController, _super);

  function KDListViewController(options, data) {
    var listView, noItemFoundWidget, viewOptions;
    if (options == null) {
      options = {};
    }
    if (options.wrapper == null) {
      options.wrapper = true;
    }
    if (options.scrollView == null) {
      options.scrollView = true;
    }
    if (options.keyNav == null) {
      options.keyNav = false;
    }
    if (options.multipleSelection == null) {
      options.multipleSelection = false;
    }
    if (options.selection == null) {
      options.selection = false;
    }
    if (options.ownScrollBars == null) {
      options.ownScrollBars = false;
    }
    if (options.startWithLazyLoader == null) {
      options.startWithLazyLoader = false;
    }
    options.itemChildClass || (options.itemChildClass = null);
    options.itemChildOptions || (options.itemChildOptions = {});
    options.noItemFoundWidget || (options.noItemFoundWidget = null);
    options.noMoreItemFoundWidget || (options.noMoreItemFoundWidget = null);
    if (!this.itemsOrdered) {
      this.itemsOrdered = [];
    }
    this.itemsIndexed = {};
    this.selectedItems = [];
    this.lazyLoader = null;
    if (options.view) {
      this.setListView(listView = options.view);
    } else {
      viewOptions = options.viewOptions || {};
      viewOptions.lastToFirst || (viewOptions.lastToFirst = options.lastToFirst);
      viewOptions.itemClass || (viewOptions.itemClass = options.itemClass);
      viewOptions.itemOptions || (viewOptions.itemOptions = options.itemOptions);
      viewOptions.itemChildClass || (viewOptions.itemChildClass = options.itemChildClass);
      viewOptions.itemChildOptions || (viewOptions.itemChildOptions = options.itemChildOptions);
      this.setListView(listView = new KDListView(viewOptions));
    }
    if (options.scrollView) {
      this.scrollView = new KDScrollView({
        lazyLoadThreshold: options.lazyLoadThreshold,
        ownScrollBars: options.ownScrollBars
      });
    }
    options.view = options.wrapper ? new KDView({
      cssClass: "listview-wrapper"
    }) : listView;
    KDListViewController.__super__.constructor.call(this, options, data);
    noItemFoundWidget = this.getOptions().noItemFoundWidget;
    listView.on('ItemWasAdded', (function(_this) {
      return function(view, index) {
        _this.registerItem(view, index);
        if (noItemFoundWidget) {
          return _this.hideNoItemWidget();
        }
      };
    })(this));
    listView.on('ItemIsBeingDestroyed', (function(_this) {
      return function(itemInfo) {
        _this.unregisterItem(itemInfo);
        if (noItemFoundWidget) {
          return _this.showNoItemWidget();
        }
      };
    })(this));
    if (options.keyNav) {
      listView.on('KeyDownOnList', (function(_this) {
        return function(event) {
          return _this.keyDownPerformed(listView, event);
        };
      })(this));
    }
  }

  KDListViewController.prototype.loadView = function(mainView) {
    var options, _ref;
    options = this.getOptions();
    if (options.scrollView) {
      mainView.addSubView(this.scrollView);
      this.scrollView.addSubView(this.getListView());
      if (options.startWithLazyLoader) {
        this.showLazyLoader(false);
      }
      this.scrollView.on('LazyLoadThresholdReached', this.bound("showLazyLoader"));
    }
    if (options.noItemFoundWidget) {
      this.putNoItemView();
    }
    this.instantiateListItems(((_ref = this.getData()) != null ? _ref.items : void 0) || []);
    return KD.getSingleton("windowController").on("ReceivedMouseUpElsewhere", (function(_this) {
      return function(event) {
        return _this.mouseUpHappened(event);
      };
    })(this));
  };

  KDListViewController.prototype.instantiateListItems = function(items) {
    var itemData, newItems;
    newItems = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        itemData = items[_i];
        _results.push(this.getListView().addItem(itemData));
      }
      return _results;
    }).call(this);
    this.emit("AllItemsAddedToList");
    return newItems;
  };


  /*
  HELPERS
   */

  KDListViewController.prototype.itemForId = function(id) {
    return this.itemsIndexed[id];
  };

  KDListViewController.prototype.getItemsOrdered = function() {
    return this.itemsOrdered;
  };

  KDListViewController.prototype.getItemCount = function() {
    return this.itemsOrdered.length;
  };

  KDListViewController.prototype.setListView = function(listView) {
    return this.listView = listView;
  };

  KDListViewController.prototype.getListView = function() {
    return this.listView;
  };

  KDListViewController.prototype.forEachItemByIndex = function(ids, callback) {
    var _ref;
    if (!callback) {
      _ref = [ids, callback], callback = _ref[0], ids = _ref[1];
    }
    if (!Array.isArray(ids)) {
      ids = [ids];
    }
    return ids.forEach((function(_this) {
      return function(id) {
        var item;
        item = _this.itemsIndexed[id];
        if (item != null) {
          return callback(item);
        }
      };
    })(this));
  };

  KDListViewController.prototype.putNoItemView = function() {
    var noItemFoundWidget;
    noItemFoundWidget = this.getOptions().noItemFoundWidget;
    return this.getListView().addSubView(this.noItemView = noItemFoundWidget);
  };

  KDListViewController.prototype.showNoItemWidget = function() {
    var _ref;
    if (this.itemsOrdered.length === 0) {
      return (_ref = this.noItemView) != null ? _ref.show() : void 0;
    }
  };

  KDListViewController.prototype.hideNoItemWidget = function() {
    var _ref;
    return (_ref = this.noItemView) != null ? _ref.hide() : void 0;
  };

  KDListViewController.prototype.showNoMoreItemWidget = function() {
    var noMoreItemFoundWidget;
    noMoreItemFoundWidget = this.getOptions().noMoreItemFoundWidget;
    if (noMoreItemFoundWidget) {
      return this.scrollView.addSubView(noMoreItemFoundWidget);
    }
  };


  /*
  ITEM OPERATIONS
   */

  KDListViewController.prototype.addItem = function(itemData, index, animation) {
    return this.getListView().addItem(itemData, index, animation);
  };

  KDListViewController.prototype.removeItem = function(itemInstance, itemData, index) {
    return this.getListView().removeItem(itemInstance, itemData, index);
  };

  KDListViewController.prototype.registerItem = function(view, index) {
    var actualIndex, options;
    options = this.getOptions();
    if (index != null) {
      actualIndex = this.getOptions().lastToFirst ? this.getListView().items.length - index - 1 : index;
      this.itemsOrdered.splice(actualIndex, 0, view);
    } else {
      this.itemsOrdered[this.getOptions().lastToFirst ? 'unshift' : 'push'](view);
    }
    if (view.getData() != null) {
      this.itemsIndexed[view.getItemDataId()] = view;
    }
    if (options.selection) {
      view.on('click', (function(_this) {
        return function(event) {
          return _this.selectItem(view, event);
        };
      })(this));
    }
    if (options.keyNav || options.multipleSelection) {
      view.on("mousedown", (function(_this) {
        return function(event) {
          return _this.mouseDownHappenedOnItem(view, event);
        };
      })(this));
      return view.on("mouseenter", (function(_this) {
        return function(event) {
          return _this.mouseEnterHappenedOnItem(view, event);
        };
      })(this));
    }
  };

  KDListViewController.prototype.unregisterItem = function(itemInfo) {
    var actualIndex, index, view;
    this.emit("UnregisteringItem", itemInfo);
    index = itemInfo.index, view = itemInfo.view;
    actualIndex = this.getOptions().lastToFirst ? this.getListView().items.length - index - 1 : index;
    this.itemsOrdered.splice(actualIndex, 1);
    if (view.getData() != null) {
      return delete this.itemsIndexed[view.getItemDataId()];
    }
  };

  KDListViewController.prototype.replaceAllItems = function(items) {
    this.removeAllItems();
    return this.instantiateListItems(items);
  };

  KDListViewController.prototype.removeAllItems = function() {
    var itemsOrdered, listView;
    itemsOrdered = this.itemsOrdered;
    this.itemsOrdered.length = 0;
    this.itemsIndexed = {};
    listView = this.getListView();
    if (listView.items.length) {
      listView.empty();
    }
    return itemsOrdered;
  };

  KDListViewController.prototype.moveItemToIndex = function(item, newIndex) {
    newIndex = Math.max(0, Math.min(this.itemsOrdered.length - 1, newIndex));
    return this.itemsOrdered = this.getListView().moveItemToIndex(item, newIndex).slice();
  };


  /*
  HANDLING MOUSE EVENTS
   */

  KDListViewController.prototype.mouseDownHappenedOnItem = function(item, event) {
    if (this.getOptions().keyNav) {
      KD.getSingleton("windowController").setKeyView(this.getListView());
    }
    this.lastEvent = event;
    if (__indexOf.call(this.selectedItems, item) < 0) {
      this.mouseDown = true;
      this.mouseDownTempItem = item;
      return this.mouseDownTimer = setTimeout((function(_this) {
        return function() {
          _this.mouseDown = false;
          _this.mouseDownTempItem = null;
          return _this.selectItem(item, event);
        };
      })(this), 300);
    } else {
      this.mouseDown = false;
      return this.mouseDownTempItem = null;
    }
  };

  KDListViewController.prototype.mouseUpHappened = function(event) {
    clearTimeout(this.mouseDownTimer);
    this.mouseDown = false;
    return this.mouseDownTempItem = null;
  };

  KDListViewController.prototype.mouseEnterHappenedOnItem = function(item, event) {
    clearTimeout(this.mouseDownTimer);
    if (this.mouseDown) {
      if (!(event.metaKey || event.ctrlKey || event.shiftKey)) {
        this.deselectAllItems();
      }
      return this.selectItemsByRange(this.mouseDownTempItem, item);
    } else {
      return this.emit("MouseEnterHappenedOnItem", item);
    }
  };


  /*
  HANDLING KEY EVENTS
   */

  KDListViewController.prototype.keyDownPerformed = function(mainView, event) {
    switch (event.which) {
      case 40:
      case 38:
        this.selectItemBelowOrAbove(event);
        return this.emit("KeyDownOnListHandled", this.selectedItems);
    }
  };


  /*
  ITEM SELECTION
   */

  KDListViewController.prototype.selectItem = function(item, event) {
    var ctrlKey, metaKey, multipleSelection, selectable, shiftKey;
    if (event == null) {
      event = {};
    }
    if (item == null) {
      return;
    }
    this.lastEvent = event;
    selectable = item.getOptions().selectable;
    multipleSelection = this.getOptions().multipleSelection;
    metaKey = event.metaKey, ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
    if (!multipleSelection) {
      this.deselectAllItems();
    }
    if (selectable && !(metaKey || ctrlKey || shiftKey)) {
      this.deselectAllItems();
    }
    if (event.shiftKey && this.selectedItems.length > 0) {
      this.selectItemsByRange(this.selectedItems[0], item);
    } else {
      if (__indexOf.call(this.selectedItems, item) < 0) {
        this.selectSingleItem(item);
      } else {
        this.deselectSingleItem(item);
      }
    }
    return this.selectedItems;
  };

  KDListViewController.prototype.selectItemBelowOrAbove = function(event) {
    var addend, direction, lastSelectedIndex, selectedIndex;
    direction = event.which === 40 ? "down" : "up";
    addend = event.which === 40 ? 1 : -1;
    selectedIndex = this.itemsOrdered.indexOf(this.selectedItems[0]);
    lastSelectedIndex = this.itemsOrdered.indexOf(this.selectedItems[this.selectedItems.length - 1]);
    if (this.itemsOrdered[selectedIndex + addend]) {
      if (!(event.metaKey || event.ctrlKey || event.shiftKey)) {
        return this.selectItem(this.itemsOrdered[selectedIndex + addend]);
      } else {
        if (this.selectedItems.indexOf(this.itemsOrdered[lastSelectedIndex + addend]) !== -1) {
          if (this.itemsOrdered[lastSelectedIndex]) {
            return this.deselectSingleItem(this.itemsOrdered[lastSelectedIndex]);
          }
        } else {
          if (this.itemsOrdered[lastSelectedIndex + addend]) {
            return this.selectSingleItem(this.itemsOrdered[lastSelectedIndex + addend]);
          }
        }
      }
    }
  };

  KDListViewController.prototype.selectNextItem = function(item, event) {
    var selectedIndex;
    if (!item) {
      item = this.selectedItems[0];
    }
    selectedIndex = this.itemsOrdered.indexOf(item);
    return this.selectItem(this.itemsOrdered[selectedIndex + 1]);
  };

  KDListViewController.prototype.selectPrevItem = function(item, event) {
    var selectedIndex;
    if (!item) {
      item = this.selectedItems[0];
    }
    selectedIndex = this.itemsOrdered.indexOf(item);
    return this.selectItem(this.itemsOrdered[selectedIndex + -1]);
  };

  KDListViewController.prototype.deselectAllItems = function() {
    var deselectedItems, selectedItem, _i, _len, _ref, _results;
    _ref = this.selectedItems;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      selectedItem = _ref[_i];
      selectedItem.removeHighlight();
      deselectedItems = this.selectedItems.concat([]);
      this.selectedItems = [];
      this.getListView().unsetClass("last-item-selected");
      _results.push(this.itemDeselectionPerformed(deselectedItems));
    }
    return _results;
  };

  KDListViewController.prototype.deselectSingleItem = function(item) {
    item.removeHighlight();
    this.selectedItems.splice(this.selectedItems.indexOf(item), 1);
    if (item === this.itemsOrdered[this.itemsOrdered.length - 1]) {
      this.getListView().unsetClass("last-item-selected");
    }
    return this.itemDeselectionPerformed([item]);
  };

  KDListViewController.prototype.selectSingleItem = function(item) {
    if (item.getOption("selectable") && !(__indexOf.call(this.selectedItems, item) >= 0)) {
      item.highlight();
      this.selectedItems.push(item);
      if (item === this.itemsOrdered[this.itemsOrdered.length - 1]) {
        this.getListView().setClass("last-item-selected");
      }
      return this.itemSelectionPerformed();
    }
  };

  KDListViewController.prototype.selectAllItems = function() {
    var item, _i, _len, _ref, _results;
    _ref = this.itemsOrdered;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      _results.push(this.selectSingleItem(item));
    }
    return _results;
  };

  KDListViewController.prototype.selectItemsByRange = function(item1, item2) {
    var indicesToBeSliced, item, itemsToBeSelected, _i, _len;
    indicesToBeSliced = [this.itemsOrdered.indexOf(item1), this.itemsOrdered.indexOf(item2)];
    indicesToBeSliced.sort(function(a, b) {
      return a - b;
    });
    itemsToBeSelected = this.itemsOrdered.slice(indicesToBeSliced[0], indicesToBeSliced[1] + 1);
    for (_i = 0, _len = itemsToBeSelected.length; _i < _len; _i++) {
      item = itemsToBeSelected[_i];
      this.selectSingleItem(item);
    }
    return this.itemSelectionPerformed();
  };

  KDListViewController.prototype.itemSelectionPerformed = function() {
    return this.emit("ItemSelectionPerformed", this, {
      event: this.lastEvent,
      items: this.selectedItems
    });
  };

  KDListViewController.prototype.itemDeselectionPerformed = function(deselectedItems) {
    return this.emit("ItemDeselectionPerformed", this, {
      event: this.lastEvent,
      items: deselectedItems
    });
  };


  /*
  LAZY LOADER
   */

  KDListViewController.prototype.showLazyLoader = function(emitWhenReached) {
    var itemClass, lazyLoaderOptions, spinnerOptions, wrapper;
    if (emitWhenReached == null) {
      emitWhenReached = true;
    }
    if (this.noItemView && this.getOptions().noItemFoundWidget) {
      this.hideNoItemWidget();
    }
    if (!this.lazyLoader) {
      lazyLoaderOptions = this.getOptions().lazyLoaderOptions;
      lazyLoaderOptions || (lazyLoaderOptions = {});
      lazyLoaderOptions.itemClass || (lazyLoaderOptions.itemClass = KDCustomHTMLView);
      if (lazyLoaderOptions.partial == null) {
        lazyLoaderOptions.partial = '';
      }
      lazyLoaderOptions.cssClass = KD.utils.curry('lazy-loader', lazyLoaderOptions.cssClass);
      lazyLoaderOptions.spinnerOptions || (lazyLoaderOptions.spinnerOptions = {
        size: {
          width: 32
        }
      });
      itemClass = lazyLoaderOptions.itemClass, spinnerOptions = lazyLoaderOptions.spinnerOptions;
      delete lazyLoaderOptions.itemClass;
      wrapper = this.scrollView || this.getView();
      wrapper.addSubView(this.lazyLoader = new itemClass(lazyLoaderOptions));
      this.lazyLoader.addSubView(this.lazyLoader.spinner = new KDLoaderView(spinnerOptions));
      this.lazyLoader.spinner.show();
      if (emitWhenReached) {
        this.emit('LazyLoadThresholdReached');
      }
      return KD.utils.defer((function(_this) {
        return function() {
          var _ref;
          return (_ref = _this.scrollView) != null ? _ref.stopScrolling = true : void 0;
        };
      })(this));
    }
  };

  KDListViewController.prototype.hideLazyLoader = function() {
    KD.utils.wait(300, (function(_this) {
      return function() {
        var _ref;
        return (_ref = _this.scrollView) != null ? _ref.stopScrolling = false : void 0;
      };
    })(this));
    if (this.noItemView && this.getOptions().noItemFoundWidget) {
      this.showNoItemWidget();
    }
    if (this.lazyLoader) {
      this.lazyLoader.spinner.hide();
      this.lazyLoader.destroy();
      return this.lazyLoader = null;
    }
  };

  return KDListViewController;

})(KDViewController);


},{"./../../core/view.coffee":106,"./../../core/viewcontroller.coffee":107,"./../list/listview.coffee":54,"./../loader/loaderview.coffee":56,"./../scrollview/scrollview.coffee":69}],56:[function(require,module,exports){
var KDLoaderView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDLoaderView = (function(_super) {
  __extends(KDLoaderView, _super);

  function KDLoaderView(options, data) {
    var o;
    o = options || {};
    o.loaderOptions || (o.loaderOptions = {});
    o.size || (o.size = {});
    options = {
      tagName: o.tagName || "span",
      bind: o.bind || "mouseenter mouseleave",
      showLoader: o.showLoader || false,
      size: {
        width: o.size.width || 24,
        height: o.size.height || 24
      },
      loaderOptions: {
        color: o.loaderOptions.color || "#000000",
        shape: o.loaderOptions.shape || "rect",
        diameter: o.loaderOptions.diameter || 20,
        density: o.loaderOptions.density || 12,
        range: o.loaderOptions.range || 1,
        speed: o.loaderOptions.speed || 1,
        FPS: o.loaderOptions.FPS || 24
      }
    };
    options.loaderOptions.diameter = options.size.height = options.size.width;
    options.cssClass = o.cssClass ? "" + o.cssClass + " kdloader" : "kdloader";
    KDLoaderView.__super__.constructor.call(this, options, data);
  }

  KDLoaderView.prototype.viewAppended = function() {
    var loaderOptions, option, showLoader, value, _ref;
    this.canvas = new CanvasLoader(this.getElement(), {
      id: "cl_" + this.id
    });
    _ref = this.getOptions(), loaderOptions = _ref.loaderOptions, showLoader = _ref.showLoader;
    for (option in loaderOptions) {
      if (!__hasProp.call(loaderOptions, option)) continue;
      value = loaderOptions[option];
      this.canvas["set" + (option.capitalize())](value);
    }
    if (showLoader) {
      return this.show();
    }
  };

  KDLoaderView.prototype.show = function() {
    KDLoaderView.__super__.show.apply(this, arguments);
    this.active = true;
    if (this.canvas) {
      return this.canvas.show();
    }
  };

  KDLoaderView.prototype.hide = function() {
    KDLoaderView.__super__.hide.apply(this, arguments);
    this.active = false;
    if (this.canvas) {
      return this.canvas.hide();
    }
  };

  return KDLoaderView;

})(KDView);


},{"./../../core/view.coffee":106}],57:[function(require,module,exports){
var KDBlockingModalView, KDModalView, KDOverlayView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDModalView = require('./modalview.coffee');

KDOverlayView = require('./../overlay/overlayview.coffee');

module.exports = KDBlockingModalView = (function(_super) {
  __extends(KDBlockingModalView, _super);

  function KDBlockingModalView(options, data) {
    if (options == null) {
      options = {};
    }
    KDBlockingModalView.__super__.constructor.call(this, options, data);
    $(window).off("keydown.modal");
  }

  KDBlockingModalView.prototype.putOverlay = function() {
    this.overlay = new KDOverlayView({
      isRemovable: false
    });
    return this.overlay.on("click", (function(_this) {
      return function() {
        return _this.doBlockingAnimation();
      };
    })(this));
  };

  KDBlockingModalView.prototype.doBlockingAnimation = function() {
    this.setClass("blocking-animation");
    return KD.utils.wait(200, (function(_this) {
      return function() {
        return _this.unsetClass("blocking-animation");
      };
    })(this));
  };

  KDBlockingModalView.prototype.setDomElement = function(cssClass) {
    return this.domElement = $("<div class='kdmodal " + cssClass + "'>\n  <div class='kdmodal-shadow'>\n    <div class='kdmodal-inner'>\n      <div class='kdmodal-title'></div>\n      <div class='kdmodal-content'></div>\n    </div>\n  </div>\n</div>");
  };

  KDBlockingModalView.prototype.click = function(e) {};

  return KDBlockingModalView;

})(KDModalView);


},{"./../overlay/overlayview.coffee":62,"./modalview.coffee":58}],58:[function(require,module,exports){
var KDButtonView, KDModalView, KDModalViewStack, KDOverlayView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDOverlayView = require('./../overlay/overlayview.coffee');

KDButtonView = require('./../buttons/buttonview.coffee');

KDModalViewStack = require('./modalviewstack.coffee');

module.exports = KDModalView = (function(_super) {
  __extends(KDModalView, _super);

  function KDModalView(options, data) {
    var modalButtonsInnerWidth;
    if (options == null) {
      options = {};
    }
    if (options.overlay == null) {
      options.overlay = false;
    }
    if (options.overlayClick == null) {
      options.overlayClick = true;
    }
    options.height || (options.height = "auto");
    if (options.width == null) {
      options.width = 600;
    }
    options.position || (options.position = {});
    options.title || (options.title = null);
    options.subtitle || (options.subtitle = null);
    options.content || (options.content = null);
    options.buttons || (options.buttons = null);
    if (options.fx == null) {
      options.fx = false;
    }
    options.view || (options.view = null);
    if (options.draggable == null) {
      options.draggable = {
        handle: ".kdmodal-title"
      };
    }
    if (options.resizable == null) {
      options.resizable = false;
    }
    if (options.appendToDomBody == null) {
      options.appendToDomBody = true;
    }
    options.helpContent || (options.helpContent = null);
    options.helpTitle || (options.helpTitle = "Need help?");
    if (options.cancelable == null) {
      options.cancelable = true;
    }
    KDModalView.__super__.constructor.call(this, options, data);
    this.setClass("initial");
    if (options.overlay) {
      this.putOverlay(options.overlay);
    }
    if (options.fx) {
      this.setClass("fx");
    }
    if (options.title) {
      this.setTitle(options.title);
    }
    if (options.subtitle) {
      this.setSubtitle(options.subtitle);
    }
    if (options.content) {
      this.setContent(options.content);
    }
    if (options.view) {
      this.addSubView(options.view);
    }
    if (options.cancel) {
      this.on('ModalCancelled', options.cancel);
    }
    this.on("viewAppended", (function(_this) {
      return function() {
        return _this.utils.wait(500, function() {
          return _this.unsetClass("initial");
        });
      };
    })(this));
    if (this.getOptions().appendToDomBody) {
      this.appendToDomBody();
    }
    this.setModalWidth(options.width);
    if (options.height) {
      this.setModalHeight(options.height);
    }
    if (options.buttons) {
      this.buttonHolder = new KDView({
        cssClass: "kdmodal-buttons clearfix"
      });
      this.addSubView(this.buttonHolder, ".kdmodal-inner");
      this.setButtons(options.buttons);
      modalButtonsInnerWidth = this.$(".kdmodal-inner").width();
      this.buttonHolder.setWidth(modalButtonsInnerWidth);
    }
    this.display();
    this._windowDidResize();
    $(window).one("keydown.modal", (function(_this) {
      return function(e) {
        if (e.which === 27) {
          return _this.cancel();
        }
      };
    })(this));
    this.on("childAppended", this.setPositions.bind(this));
    this.listenWindowResize();
  }

  KDModalView.prototype.setDomElement = function(cssClass) {
    var helpButton, helpContent, helpTitle, _ref;
    _ref = this.getOptions(), helpContent = _ref.helpContent, helpTitle = _ref.helpTitle;
    if (helpContent) {
      helpButton = "<span class='showHelp'>" + helpTitle + "</span>";
    } else {
      helpButton = "";
    }
    return this.domElement = $("<div class='kdmodal " + cssClass + "'>\n  <div class='kdmodal-inner'>\n    " + helpButton + "\n    <span class='close-icon closeModal' title='Close [ESC]'></span>\n    <div class='kdmodal-title hidden'></div>\n    <div class='kdmodal-content'></div>\n  </div>\n</div>");
  };

  KDModalView.prototype.addSubView = function(view, selector) {
    if (selector == null) {
      selector = ".kdmodal-content";
    }
    if (this.$(selector).length === 0) {
      selector = null;
    }
    return KDModalView.__super__.addSubView.call(this, view, selector);
  };

  KDModalView.prototype.setButtons = function(buttonDataSet, destroyExists) {
    var button, buttonOptions, buttonTitle, defaultFocusTitle, focused, _ref;
    if (destroyExists == null) {
      destroyExists = false;
    }
    this.buttons || (this.buttons = {});
    this.setClass("with-buttons");
    defaultFocusTitle = null;
    if (destroyExists) {
      this.destroyButtons();
    }
    for (buttonTitle in buttonDataSet) {
      if (!__hasProp.call(buttonDataSet, buttonTitle)) continue;
      buttonOptions = buttonDataSet[buttonTitle];
      if (defaultFocusTitle == null) {
        defaultFocusTitle = buttonTitle;
      }
      button = this.createButton(buttonOptions.title || buttonTitle, buttonOptions);
      this.buttons[buttonTitle] = button;
      if (buttonOptions.focus) {
        focused = true;
      }
    }
    if (!focused && defaultFocusTitle) {
      return (_ref = this.buttons[defaultFocusTitle]) != null ? _ref.setFocus() : void 0;
    }
  };

  KDModalView.prototype.destroyButtons = function() {
    var button, _key, _ref, _results;
    _ref = this.buttons;
    _results = [];
    for (_key in _ref) {
      if (!__hasProp.call(_ref, _key)) continue;
      button = _ref[_key];
      _results.push(button.destroy());
    }
    return _results;
  };

  KDModalView.prototype.click = function(e) {
    var helpContent;
    if ($(e.target).is(".closeModal")) {
      this.cancel();
    }
    if ($(e.target).is(".showHelp")) {
      helpContent = this.getOptions().helpContent;
      if (helpContent) {
        helpContent = KD.utils.applyMarkdown(helpContent);
        return new KDModalView({
          cssClass: "help-dialog",
          overlay: true,
          content: "<div class='modalformline'><p>" + helpContent + "</p></div>"
        });
      }
    }
  };

  KDModalView.prototype.setTitle = function(title) {
    this.$().find(".kdmodal-title").removeClass('hidden').html("<span class='title'>" + title + "</span>");
    return this.modalTitle = title;
  };

  KDModalView.prototype.setSubtitle = function(subtitle) {
    this.$().find(".kdmodal-title").append("<span class='subtitle'>" + subtitle + "</span>");
    return this.modalSubtitle = subtitle;
  };

  KDModalView.prototype.setModalHeight = function(value) {
    if (value === "auto") {
      this.$().css("height", "auto");
      return this.modalHeight = this.getHeight();
    } else {
      this.$().height(value);
      return this.modalHeight = value;
    }
  };

  KDModalView.prototype.setModalWidth = function(value) {
    this.modalWidth = value;
    return this.$().width(value);
  };

  KDModalView.prototype.setPositions = function() {
    return this.utils.defer((function(_this) {
      return function() {
        var bottom, height, left, newRules, right, top, width, _ref;
        _ref = _this.getOptions().position, top = _ref.top, right = _ref.right, bottom = _ref.bottom, left = _ref.left;
        newRules = {};
        height = $(window).height();
        width = $(window).width();
        newRules.top = Math.round(top != null ? top : height / 2 - _this.getHeight() / 2);
        newRules.left = Math.round(left != null ? left : width / 2 - _this.modalWidth / 2);
        if (right) {
          newRules.left = Math.round(width - _this.modalWidth - right - 20);
        }
        newRules.opacity = 1;
        return _this.$().css(newRules);
      };
    })(this));
  };

  KDModalView.prototype._windowDidResize = function() {
    var innerHeight;
    this.setPositions();
    innerHeight = window.innerHeight;
    this.$('.kdmodal-content').css({
      maxHeight: innerHeight - 120
    });
    if (!this.getOptions().position.top) {
      return this.setY(Math.round((innerHeight - this.getHeight()) / 2));
    }
  };

  KDModalView.prototype.putOverlay = function() {
    var isRemovable;
    isRemovable = this.getOptions().overlayClick;
    this.overlay = new KDOverlayView({
      isRemovable: isRemovable
    });
    if (isRemovable) {
      return this.overlay.once("click", this.bound("destroy"));
    }
  };

  KDModalView.prototype.createButton = function(title, buttonOptions) {
    var button, itemClass;
    buttonOptions.title = title;
    buttonOptions.delegate = this;
    itemClass = buttonOptions.itemClass;
    delete buttonOptions.itemClass;
    this.buttonHolder.addSubView(button = new (itemClass || KDButtonView)(buttonOptions));
    button.on('KDModalShouldClose', (function(_this) {
      return function() {
        return _this.emit('KDModalShouldClose');
      };
    })(this));
    return button;
  };

  KDModalView.prototype.setContent = function(content) {
    this.modalContent = content;
    return this.getDomElement().find(".kdmodal-content").html(content);
  };

  KDModalView.prototype.display = function() {
    if (this.getOptions().fx) {
      return this.utils.defer((function(_this) {
        return function() {
          return _this.setClass("active");
        };
      })(this));
    }
  };

  KDModalView.prototype.cancel = function() {
    if (!this.getOptions().cancelable) {
      return;
    }
    this.emit('ModalCancelled');
    return this.destroy();
  };

  KDModalView.prototype.destroy = function() {
    var uber, _ref;
    $(window).off("keydown.modal");
    uber = KDView.prototype.destroy.bind(this);
    if (this.options.fx) {
      this.unsetClass("active");
      setTimeout(uber, 300);
    } else {
      this.getDomElement().hide();
      uber();
    }
    if ((_ref = this.overlay) != null) {
      _ref.destroy();
    }
    return this.emit('KDModalViewDestroyed', this);
  };


  /* STACK HELPERS */

  KDModalView.createStack = function(options) {
    return this.stack || (this.stack = new KDModalViewStack(options));
  };

  KDModalView.addToStack = function(modal) {
    return this.stack.addModal(modal);
  };

  KDModalView.destroyStack = function() {
    this.stack.destroy();
    return delete this.stack;
  };

  KDModalView.confirm = function(options) {
    var cancel, content, description, modal, noop, ok, title;
    noop = function() {
      return modal.destroy();
    };
    ok = options.ok, cancel = options.cancel, title = options.title, content = options.content, description = options.description;
    if (!ok || 'function' === typeof ok) {
      ok = {
        callback: ok
      };
    }
    if (!cancel || 'function' === typeof cancel) {
      cancel = {
        callback: cancel
      };
    }
    modal = new this({
      title: title || 'You must confirm this action',
      content: content || (description ? "<div class='modalformline'>\n  <p>" + description + "</p>\n</div>" : void 0),
      overlay: true,
      buttons: {
        OK: {
          title: ok.title,
          style: ok.style || "modal-clean-red",
          callback: ok.callback || noop
        },
        cancel: {
          title: cancel.title,
          style: cancel.style || "modal-cancel",
          callback: cancel.callback || noop
        }
      }
    });
    if (options.subView) {
      modal.addSubView(options.subView);
    }
    return modal;
  };

  return KDModalView;

})(KDView);


},{"./../../core/view.coffee":106,"./../buttons/buttonview.coffee":20,"./../overlay/overlayview.coffee":62,"./modalviewstack.coffee":59}],59:[function(require,module,exports){
var KDModalViewStack, KDObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDObject = require('./../../core/object.coffee');

module.exports = KDModalViewStack = (function(_super) {
  __extends(KDModalViewStack, _super);

  function KDModalViewStack(options, data) {
    if (options == null) {
      options = {};
    }
    if (options.lastToFirst == null) {
      options.lastToFirst = false;
    }
    KDModalViewStack.__super__.constructor.call(this, options, data);
    this.modals = [];
  }

  KDModalViewStack.prototype.addModal = function(modal) {
    var lastToFirst;
    if (!(modal instanceof KDModalView)) {
      return warn("You can only add KDModalView instances to the modal stack.");
    }
    modal.on("KDObjectWillBeDestroyed", (function(_this) {
      return function() {
        return _this.next();
      };
    })(this));
    lastToFirst = this.getOptions().lastToFirst;
    this.modals.push(modal);
    KD.utils.defer((function(_this) {
      return function() {
        modal.hide();
        if (lastToFirst) {
          _this.modals.forEach(function(modal) {
            return modal.hide();
          });
          return _this.modals.last.show();
        } else {
          return _this.modals.first.show();
        }
      };
    })(this));
    return modal;
  };

  KDModalViewStack.prototype.next = function() {
    var lastToFirst, _ref, _ref1;
    lastToFirst = this.getOptions().lastToFirst;
    if (lastToFirst) {
      this.modals.pop();
      return (_ref = this.modals.last) != null ? _ref.show() : void 0;
    } else {
      this.modals.shift();
      return (_ref1 = this.modals.first) != null ? _ref1.show() : void 0;
    }
  };

  KDModalViewStack.prototype.destroy = function() {
    this.modals.forEach(function(modal) {
      return KD.utils.defer(function() {
        return modal.destroy();
      });
    });
    this.modals = [];
    return KDModalViewStack.__super__.destroy.apply(this, arguments);
  };

  return KDModalViewStack;

})(KDObject);


},{"./../../core/object.coffee":102}],60:[function(require,module,exports){
var KDModalView, KDModalViewWithForms, KDTabViewWithForms,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDModalView = require('./modalview.coffee');

KDTabViewWithForms = require('./../tabs/tabviewwithforms');

module.exports = KDModalViewWithForms = (function(_super) {
  __extends(KDModalViewWithForms, _super);

  function KDModalViewWithForms(options, data) {
    this.modalButtons = [];
    KDModalViewWithForms.__super__.constructor.call(this, options, data);
    this.addSubView(this.modalTabs = new KDTabViewWithForms(options.tabs));
  }

  KDModalViewWithForms.prototype.aggregateFormData = function() {
    var data, form, formName;
    data = (function() {
      var _ref, _results;
      _ref = this.modalTabs.forms;
      _results = [];
      for (formName in _ref) {
        if (!__hasProp.call(_ref, formName)) continue;
        form = _ref[formName];
        _results.push({
          name: formName,
          data: form.getData()
        });
      }
      return _results;
    }).call(this);
    return data.reduce(function(acc, form) {
      var key, val, _ref;
      _ref = form.data;
      for (key in _ref) {
        if (!__hasProp.call(_ref, key)) continue;
        val = _ref[key];
        if (key in acc) {
          console.warn("Property " + key + " will be overwitten!");
        }
        acc[key] = val;
      }
      return acc;
    }, {});
  };

  return KDModalViewWithForms;

})(KDModalView);


},{"./../tabs/tabviewwithforms":83,"./modalview.coffee":58}],61:[function(require,module,exports){
var KDLoaderView, KDNotificationView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDLoaderView = require('./../loader/loaderview.coffee');

module.exports = KDNotificationView = (function(_super) {
  __extends(KDNotificationView, _super);

  function KDNotificationView(options) {
    KDNotificationView.__super__.constructor.call(this, options);
    options = this.notificationSetDefaults(options);
    this.notificationSetType(options.type);
    if (options.title != null) {
      this.notificationSetTitle(options.title);
    }
    if (options.content != null) {
      this.notificationSetContent(options.content);
    }
    if (options.duration != null) {
      this.notificationSetTimer(options.duration);
    }
    if (options.overlay != null) {
      this.notificationSetOverlay(options.overlay);
    }
    if (options.followUps != null) {
      this.notificationSetFollowUps(options.followUps);
    }
    if (options.showTimer != null) {
      this.notificationShowTimer();
    }
    this.notificationSetCloseHandle(options.closeManually);
    if (options.loader) {
      this.once("viewAppended", this.bound("setLoader"));
    }
    this.notificationDisplay();
  }

  KDNotificationView.prototype.setDomElement = function(cssClass) {
    if (cssClass == null) {
      cssClass = '';
    }
    return this.domElement = $("<div class='kdnotification " + cssClass + "'> <a class='kdnotification-close hidden'></a> <div class='kdnotification-timer hidden'></div> <div class='kdnotification-title'></div> <div class='kdnotification-content hidden'></div> </div>");
  };

  KDNotificationView.prototype.destroy = function() {
    this.notificationCloseHandle.unbind(".notification");
    if (this.notificationOverlay != null) {
      this.notificationOverlay.remove();
    }
    KDNotificationView.__super__.destroy.call(this);
    this.notificationStopTimer();
    return this.notificationRepositionOtherNotifications();
  };

  KDNotificationView.prototype.viewAppended = function() {
    return this.notificationSetPositions();
  };

  KDNotificationView.prototype.notificationSetDefaults = function(options) {
    if (options.duration == null) {
      options.duration = 1500;
    }
    if (options.duration > 2999 || options.duration === 0) {
      if (options.closeManually == null) {
        options.closeManually = true;
      }
    }
    return options;
  };

  KDNotificationView.prototype.notificationSetTitle = function(title) {
    if (!(title instanceof KDView)) {
      this.$().find(".kdnotification-title").html(title);
    } else {
      if (this.notificationTitle && this.notificationTitle instanceof KDView) {
        this.notificationTitle.destroy();
      }
      this.addSubView(title, ".kdnotification-title");
    }
    return this.notificationTitle = title;
  };

  KDNotificationView.prototype.notificationSetType = function(type) {
    if (type == null) {
      type = "main";
    }
    return this.notificationType = type;
  };

  KDNotificationView.prototype.notificationSetPositions = function() {
    var bottomMargin, i, notification, sameTypeNotifications, styles, topMargin, winHeight, winWidth, _i, _j, _len, _len1;
    this.setClass(this.notificationType);
    sameTypeNotifications = $("body").find(".kdnotification." + this.notificationType);
    if (this.getOptions().container) {
      winHeight = this.getOptions().container.getHeight();
      winWidth = this.getOptions().container.getWidth();
    } else {
      winWidth = window.innerWidth;
      winHeight = window.innerHeight;
    }
    switch (this.notificationType) {
      case "tray":
        bottomMargin = 8;
        for (i = _i = 0, _len = sameTypeNotifications.length; _i < _len; i = ++_i) {
          notification = sameTypeNotifications[i];
          if (i !== 0) {
            bottomMargin += $(notification).outerHeight(false) + 8;
          }
        }
        styles = {
          bottom: bottomMargin,
          right: 8,
          paddingRight: this.options.content && this.options.title ? 10 : 25
        };
        break;
      case "growl":
        topMargin = 63;
        for (i = _j = 0, _len1 = sameTypeNotifications.length; _j < _len1; i = ++_j) {
          notification = sameTypeNotifications[i];
          if (i !== 0) {
            topMargin += $(notification).outerHeight(false) + 8;
          }
        }
        styles = {
          top: topMargin,
          right: 8
        };
        break;
      case "mini":
        styles = {
          top: 0,
          left: winWidth / 2 - this.getDomElement().width() / 2
        };
        break;
      case "sticky":
        styles = {
          top: 0,
          left: winWidth / 2 - this.getDomElement().width() / 2
        };
        break;
      default:
        styles = {
          top: winHeight / 2 - this.getDomElement().height() / 2,
          left: winWidth / 2 - this.getDomElement().width() / 2
        };
    }
    return this.getDomElement().css(styles);
  };

  KDNotificationView.prototype.notificationRepositionOtherNotifications = function() {
    var elm, h, heights, i, j, newValue, options, position, sameTypeNotifications, _i, _j, _len, _len1, _ref, _results;
    sameTypeNotifications = $("body").find(".kdnotification." + this.notificationType);
    heights = (function() {
      var _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = sameTypeNotifications.length; _i < _len; i = ++_i) {
        elm = sameTypeNotifications[i];
        _results.push($(elm).outerHeight(false));
      }
      return _results;
    })();
    _results = [];
    for (i = _i = 0, _len = sameTypeNotifications.length; _i < _len; i = ++_i) {
      elm = sameTypeNotifications[i];
      switch (this.notificationType) {
        case "tray":
        case "growl":
          newValue = 0;
          position = this.notificationType === "tray" ? "bottom" : "top";
          _ref = heights.slice(0, +i + 1 || 9e9);
          for (j = _j = 0, _len1 = _ref.length; _j < _len1; j = ++_j) {
            h = _ref[j];
            if (j !== 0) {
              newValue += h;
            } else {
              newValue = 8;
            }
          }
          options = {};
          options[position] = newValue + i * 8;
          _results.push($(elm).css(options));
          break;
        default:
          _results.push(void 0);
      }
    }
    return _results;
  };

  KDNotificationView.prototype.notificationSetCloseHandle = function(closeManually) {
    if (closeManually == null) {
      closeManually = false;
    }
    this.notificationCloseHandle = this.getDomElement().find(".kdnotification-close");
    if (closeManually) {
      this.notificationCloseHandle.removeClass("hidden");
    }
    this.notificationCloseHandle.bind("click.notification", (function(_this) {
      return function(e) {
        return _this.destroy();
      };
    })(this));
    return $(window).bind("keydown.notification", (function(_this) {
      return function(e) {
        if (e.which === 27) {
          return _this.destroy();
        }
      };
    })(this));
  };

  KDNotificationView.prototype.notificationSetTimer = function(duration) {
    if (duration === 0) {
      return;
    }
    this.notificationTimerDiv = this.getDomElement().find(".kdnotification-timer");
    this.notificationTimerDiv.text(Math.floor(duration / 1000));
    this.notificationTimeout = setTimeout((function(_this) {
      return function() {
        return _this.getDomElement().fadeOut(200, function() {
          return _this.destroy();
        });
      };
    })(this), duration);
    return this.notificationInterval = setInterval((function(_this) {
      return function() {
        var next;
        next = parseInt(_this.notificationTimerDiv.text(), 10) - 1;
        return _this.notificationTimerDiv.text(next);
      };
    })(this), 1000);
  };

  KDNotificationView.prototype.notificationSetFollowUps = function(followUps) {
    var chainDuration;
    if (!Array.isArray(followUps)) {
      followUps = [followUps];
    }
    chainDuration = 0;
    return followUps.forEach((function(_this) {
      return function(followUp) {
        var _ref;
        chainDuration += (_ref = followUp.duration) != null ? _ref : 10000;
        return _this.utils.wait(chainDuration, function() {
          if (followUp.title) {
            _this.notificationSetTitle(followUp.title);
          }
          if (followUp.content) {
            _this.notificationSetContent(followUp.content);
          }
          return _this.notificationSetPositions();
        });
      };
    })(this));
  };

  KDNotificationView.prototype.notificationShowTimer = function() {
    this.notificationTimerDiv.removeClass("hidden");
    this.getDomElement().bind("mouseenter", (function(_this) {
      return function() {
        return _this.notificationStopTimer();
      };
    })(this));
    return this.getDomElement().bind("mouseleave", (function(_this) {
      return function() {
        var newDuration;
        newDuration = parseInt(_this.notificationTimerDiv.text(), 10) * 1000;
        return _this.notificationSetTimer(newDuration);
      };
    })(this));
  };

  KDNotificationView.prototype.notificationStopTimer = function() {
    clearTimeout(this.notificationTimeout);
    return clearInterval(this.notificationInterval);
  };

  KDNotificationView.prototype.notificationSetOverlay = function(options) {
    if (options.transparent == null) {
      options.transparent = true;
    }
    if (options.destroyOnClick == null) {
      options.destroyOnClick = true;
    }
    this.notificationOverlay = $("<div/>", {
      "class": "kdoverlay transparent"
    });
    this.notificationOverlay.hide();
    if (!options.transparent) {
      this.notificationOverlay.removeClass("transparent");
    }
    this.notificationOverlay.appendTo("body");
    this.notificationOverlay.fadeIn(200);
    return this.notificationOverlay.bind("click", (function(_this) {
      return function() {
        if (options.destroyOnClick) {
          return _this.destroy();
        }
      };
    })(this));
  };

  KDNotificationView.prototype.notificationGetOverlay = function() {
    return this.notificationOverlay;
  };

  KDNotificationView.prototype.setLoader = function() {
    var diameters, loader, _ref, _ref1, _ref2, _ref3;
    this.setClass("w-loader");
    loader = this.getOptions().loader;
    diameters = {
      tray: 25,
      growl: 30,
      mini: 18,
      sticky: 25
    };
    loader.diameter = diameters[this.notificationType] || 30;
    this.loader = new KDLoaderView({
      size: {
        width: loader.diameter
      },
      loaderOptions: {
        color: loader.color || "#ffffff",
        shape: loader.shape || "spiral",
        diameter: loader.diameter,
        density: (_ref = loader.density) != null ? _ref : 30,
        range: (_ref1 = loader.range) != null ? _ref1 : 0.4,
        speed: (_ref2 = loader.speed) != null ? _ref2 : 1.5,
        FPS: (_ref3 = loader.FPS) != null ? _ref3 : 24
      }
    });
    this.addSubView(this.loader, null, true);
    this.setCss("paddingLeft", loader.diameter * 2);
    this.loader.setStyle({
      position: "absolute",
      left: loader.left || Math.floor(loader.diameter / 2),
      top: loader.top || "50%",
      marginTop: -(loader.diameter / 2)
    });
    return this.loader.show();
  };

  KDNotificationView.prototype.showLoader = function() {
    this.setClass("loading");
    return this.loader.show();
  };

  KDNotificationView.prototype.hideLoader = function() {
    this.unsetClass("loading");
    return this.loader.hide();
  };

  KDNotificationView.prototype.notificationSetContent = function(content) {
    this.notificationContent = content;
    return this.getDomElement().find(".kdnotification-content").removeClass("hidden").html(content);
  };

  KDNotificationView.prototype.notificationDisplay = function() {
    if (this.getOptions().container) {
      return this.getOptions().container.addSubView(this);
    } else {
      return this.appendToDomBody();
    }
  };

  return KDNotificationView;

})(KDView);


},{"./../../core/view.coffee":106,"./../loader/loaderview.coffee":56}],62:[function(require,module,exports){
var KDOverlayView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDOverlayView = (function(_super) {
  __extends(KDOverlayView, _super);

  function KDOverlayView(options, data) {
    if (options == null) {
      options = {};
    }
    if (options.isRemovable == null) {
      options.isRemovable = true;
    }
    if (options.animated == null) {
      options.animated = false;
    }
    if (options.color == null) {
      options.color = false;
    }
    if (options.transparent == null) {
      options.transparent = false;
    }
    if (options.opacity == null) {
      options.opacity = 0.5;
    }
    if (options.appendToDomBody == null) {
      options.appendToDomBody = true;
    }
    options.cssClass = KD.utils.curry("kdoverlay", options.cssClass);
    KDOverlayView.__super__.constructor.call(this, options, data);
    if (options.animated) {
      this.setClass("animated");
    }
    if (options.transparent) {
      this.setClass("transparent");
    }
    if (options.color) {
      this.setStyle({
        backgroundColor: options.color,
        opacity: options.opacity
      });
    }
    if (options.container instanceof KDView) {
      options.container.addSubView(this);
      this.setCss("position", "absolute");
    } else if (options.appendToDomBody) {
      this.appendToDomBody();
    }
    if (options.animated) {
      this.utils.defer((function(_this) {
        return function() {
          return _this.setClass("in");
        };
      })(this));
      this.utils.wait(300, (function(_this) {
        return function() {
          return _this.emit("OverlayAdded", _this);
        };
      })(this));
    } else {
      this.emit("OverlayAdded", this);
    }
    if (options.isRemovable) {
      if (options.animated) {
        this.once("click", (function(_this) {
          return function() {
            _this.unsetClass("in");
            return _this.utils.wait(300, function() {
              return _this.remove();
            });
          };
        })(this));
      } else {
        this.once("click", (function(_this) {
          return function() {
            return _this.remove();
          };
        })(this));
      }
    }
  }

  KDOverlayView.prototype.remove = function() {
    this.emit("OverlayWillBeRemoved");
    this.destroy();
    return this.emit("OverlayRemoved", this);
  };

  return KDOverlayView;

})(KDView);


},{"./../../core/view.coffee":106}],63:[function(require,module,exports){
var KDSpotlightView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDSpotlightView = (function(_super) {
  __extends(KDSpotlightView, _super);

  function KDSpotlightView(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry("kdspotlightview", options.cssClass);
    if (options.margin == null) {
      options.margin = 50;
    }
    if (options.radial == null) {
      options.radial = true;
    }
    if (options.isRemovable == null) {
      options.isRemovable = true;
    }
    KDSpotlightView.__super__.constructor.call(this, options, data);
    if (!options.radial) {
      this.setClass("shadow");
    }
    this.createElements();
    this.appendToDomBody();
  }

  KDSpotlightView.prototype.createElements = function() {
    var boundaries, height, isRemovable, left, position, top, view, width, _ref, _results;
    isRemovable = this.getOptions().isRemovable;
    _ref = this.getBoundaries();
    _results = [];
    for (position in _ref) {
      boundaries = _ref[position];
      width = boundaries.width, height = boundaries.height, top = boundaries.top, left = boundaries.left;
      if (width > 0 && height > 0) {
        view = new KDView({
          cssClass: KD.utils.curry("kdoverlay", position),
          size: {
            width: width,
            height: height
          },
          position: {
            top: top,
            left: left
          }
        });
        if (isRemovable) {
          view.on("click", (function(_this) {
            return function() {
              _this.destroy();
              return _this.emit("OverlayDestroyed");
            };
          })(this));
        }
        _results.push(this.addSubView(view));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  KDSpotlightView.prototype.getBoundaries = function() {
    var bottomHeight, boundaries, delegate, height, left, leftWidth, margin, radial, top, topHeight, width, windowHeight, windowWidth;
    radial = this.getOptions().radial;
    delegate = this.getDelegate();
    top = delegate.getY();
    left = delegate.getX();
    width = delegate.getWidth();
    height = delegate.getHeight();
    margin = this.getOption("margin");
    windowWidth = window.innerWidth;
    windowHeight = window.innerHeight;
    if (radial) {
      width = height = Math.min(width, height);
    }
    topHeight = top - margin;
    leftWidth = left - margin;
    bottomHeight = windowHeight - (top + height + margin);
    boundaries = {
      top: {
        top: 0,
        left: 0,
        width: windowWidth,
        height: topHeight
      },
      left: {
        top: topHeight,
        left: 0,
        width: leftWidth,
        height: windowHeight - top + margin
      },
      bottom: {
        top: top + height + margin,
        left: leftWidth,
        width: windowWidth - left + margin,
        height: bottomHeight
      },
      right: {
        top: topHeight,
        left: left + width + margin,
        width: windowWidth - (left + width + margin),
        height: windowHeight - (bottomHeight + topHeight)
      },
      main: {
        top: topHeight,
        left: leftWidth,
        width: width + margin + margin,
        height: height + margin + margin
      }
    };
    return boundaries;
  };

  return KDSpotlightView;

})(KDView);


},{"./../../core/view.coffee":106}],64:[function(require,module,exports){
var KDCustomHTMLView, KDProgressBarView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

module.exports = KDProgressBarView = (function(_super) {
  __extends(KDProgressBarView, _super);

  function KDProgressBarView(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry("progressbar-container", options.cssClass);
    if (options.determinate == null) {
      options.determinate = true;
    }
    if (options.initial == null) {
      options.initial = false;
    }
    if (options.title == null) {
      options.title = "";
    }
    KDProgressBarView.__super__.constructor.call(this, options, data);
  }

  KDProgressBarView.prototype.viewAppended = function() {
    var initial, title, _ref;
    _ref = this.getOptions(), initial = _ref.initial, title = _ref.title;
    this.createBar();
    return this.updateBar(initial || 1, "%", title);
  };

  KDProgressBarView.prototype.createBar = function(value, label) {
    if (label == null) {
      label = this.getOptions().title;
    }
    this.addSubView(this.bar = new KDCustomHTMLView({
      cssClass: "bar"
    }));
    this.addSubView(this.spinner = new KDCustomHTMLView({
      cssClass: "bar spinner hidden"
    }));
    this.addSubView(this.darkLabel = new KDCustomHTMLView({
      tagName: "span",
      cssClass: 'dark-label'
    }));
    this.bar.addSubView(this.lightLabel = new KDCustomHTMLView({
      tagName: "span",
      cssClass: 'light-label'
    }));
    return this.lightLabel.setWidth(this.getWidth());
  };

  KDProgressBarView.prototype.updateBar = function(value, unit, label) {
    var determinate;
    if (unit == null) {
      unit = '%';
    }
    if (label == null) {
      label = this.getOptions().title;
    }
    determinate = this.getOptions().determinate;
    if (determinate) {
      this.bar.show();
      this.spinner.hide();
      this.bar.setWidth(value, unit);
      this.darkLabel.updatePartial("" + label + "&nbsp;");
      return this.lightLabel.updatePartial("" + label + "&nbsp;");
    } else {
      this.bar.hide();
      return this.spinner.show();
    }
  };

  return KDProgressBarView;

})(KDCustomHTMLView);


},{"./../../core/customhtmlview.coffee":97}],65:[function(require,module,exports){
var KDCustomHTMLView, KDCustomScrollView, KDCustomScrollViewWrapper, KDScrollTrack,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

require('jquery-mousewheel')($);

KDCustomHTMLView = require('./../../core/customhtmlview');

KDScrollTrack = require('./scrolltrack');

KDCustomScrollViewWrapper = require('./customscrollviewinner');

module.exports = KDCustomScrollView = (function(_super) {
  var intent;

  __extends(KDCustomScrollView, _super);

  function KDCustomScrollView(options, data) {
    var mouseWheelSpeed;
    if (options == null) {
      options = {};
    }
    if (options.bind == null) {
      options.bind = 'mouseenter mouseleave';
    }
    options.cssClass = KD.utils.curry('kdcustomscrollview', options.cssClass);
    if (options.mouseWheelSpeed == null) {
      options.mouseWheelSpeed = 3;
    }
    KDCustomScrollView.__super__.constructor.call(this, options, data);
    mouseWheelSpeed = this.getOptions().mouseWheelSpeed;
    this.wrapper = new KDCustomScrollViewWrapper({
      tagName: 'main',
      mouseWheelSpeed: mouseWheelSpeed
    });
    this.verticalTrack = new KDScrollTrack({
      delegate: this.wrapper
    });
    this.horizontalTrack = new KDScrollTrack({
      delegate: this.wrapper,
      type: 'horizontal'
    });
    this.wrapper.verticalThumb = this.verticalTrack.thumb;
    this.wrapper.horizontalThumb = this.horizontalTrack.thumb;
    this.wrapper.on('ScrollTrackShown', (function(_this) {
      return function(type) {
        return _this.setClass("has-" + type);
      };
    })(this));
    this.wrapper.on('ScrollTrackHidden', (function(_this) {
      return function(type) {
        return _this.unsetClass("has-" + type);
      };
    })(this));
    this.on('mouseenter', this.bound('showTracks'));
    this.on('mouseleave', this.bound('hideTracks'));
  }

  KDCustomScrollView.prototype.viewAppended = function() {
    this.addSubView(this.wrapper);
    this.addSubView(this.verticalTrack);
    this.addSubView(this.horizontalTrack);
    this.wrapper.observeMutations();
    this.wrapper.on('MutationHappened', this.verticalTrack.thumb.bound('handleMutation'));
    return this.wrapper.on('MutationHappened', this.horizontalTrack.thumb.bound('handleMutation'));
  };

  intent = null;

  KDCustomScrollView.prototype.hideTracks = function() {
    return intent = KD.utils.wait(1000, (function(_this) {
      return function() {
        _this.verticalTrack.setClass('out');
        return _this.horizontalTrack.setClass('out');
      };
    })(this));
  };

  KDCustomScrollView.prototype.showTracks = function() {
    if (intent) {
      KD.utils.killWait(intent);
    }
    this.verticalTrack.unsetClass('out');
    return this.horizontalTrack.unsetClass('out');
  };

  return KDCustomScrollView;

})(KDCustomHTMLView);


},{"./../../core/customhtmlview":97,"./customscrollviewinner":66,"./scrolltrack":68,"jquery-mousewheel":2}],66:[function(require,module,exports){
var KDCustomHTMLView, KDCustomScrollViewWrapper, KDScrollThumb, KDScrollTrack, KDScrollView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

require('jquery-mousewheel')($);

KDCustomHTMLView = require('./../../core/customhtmlview');

KDScrollView = require('./scrollview');

KDScrollThumb = require('./scrollthumb');

KDScrollTrack = require('./scrolltrack');

module.exports = KDCustomScrollViewWrapper = (function(_super) {
  __extends(KDCustomScrollViewWrapper, _super);

  function KDCustomScrollViewWrapper() {
    return KDCustomScrollViewWrapper.__super__.constructor.apply(this, arguments);
  }

  KDCustomScrollViewWrapper.prototype.scroll = function(event) {
    if (this.verticalThumb.beingDragged || this.horizontalThumb.beingDragged) {
      return KD.utils.stopDOMEvent(event);
    }
  };

  KDCustomScrollViewWrapper.prototype.mouseWheel = function(event) {
    var deltaFactor, resX, resY, speed, stop, x, y, _delta;
    KDCustomScrollViewWrapper.__super__.mouseWheel.apply(this, arguments);
    _delta = event._delta, deltaFactor = event.deltaFactor;
    if (!_delta) {
      return;
    }
    speed = deltaFactor || this.getOptions().mouseWheelSpeed;
    x = _delta.deltaX;
    y = _delta.deltaY;
    resX = x !== 0 && this.getScrollWidth() > this.getWidth() ? this._scrollHorizontally({
      speed: speed,
      velocity: x
    }) : false;
    resY = y !== 0 && this.getScrollHeight() > this.getHeight() ? this._scrollVertically({
      speed: speed,
      velocity: y
    }) : false;
    stop = Math.abs(x) > Math.abs(y) ? resX : resY;
    return !stop;
  };

  KDCustomScrollViewWrapper.prototype._scrollVertically = (function() {
    var lastPosition;
    lastPosition = 0;
    return function(_arg) {
      var actPosition, newPosition, shouldStop, speed, stepInPixels, velocity;
      speed = _arg.speed, velocity = _arg.velocity;
      stepInPixels = velocity * speed;
      actPosition = this.getScrollTop();
      newPosition = actPosition - stepInPixels;
      shouldStop = velocity > 0 ? lastPosition > newPosition : lastPosition < newPosition;
      this.setScrollTop(lastPosition = newPosition);
      return shouldStop;
    };
  })();

  KDCustomScrollViewWrapper.prototype._scrollHorizontally = (function() {
    var lastPosition;
    lastPosition = 0;
    return function(_arg) {
      var actPosition, newPosition, shouldStop, speed, stepInPixels, velocity;
      speed = _arg.speed, velocity = _arg.velocity;
      stepInPixels = velocity * speed;
      actPosition = this.getScrollLeft();
      newPosition = actPosition + stepInPixels;
      shouldStop = velocity < 0 ? lastPosition >= newPosition : lastPosition <= newPosition;
      this.setScrollLeft(lastPosition = newPosition);
      return shouldStop;
    };
  })();

  return KDCustomScrollViewWrapper;

})(KDScrollView);


},{"./../../core/customhtmlview":97,"./scrollthumb":67,"./scrolltrack":68,"./scrollview":69,"jquery-mousewheel":2}],67:[function(require,module,exports){
var KDScrollThumb, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDScrollThumb = (function(_super) {
  __extends(KDScrollThumb, _super);

  function KDScrollThumb(options, data) {
    var _ref;
    if (options == null) {
      options = {};
    }
    options.type || (options.type = 'vertical');
    options.cssClass = KD.utils.curry('kdscrollthumb', options.cssClass);
    if (options.draggable == null) {
      options.draggable = {
        axis: options.type === 'vertical' ? 'y' : 'x',
        containment: this
      };
    }
    KDScrollThumb.__super__.constructor.call(this, options, data);
    _ref = this.getOptions(), this.type = _ref.type, this.track = _ref.track;
    this.view = this.track.getDelegate();
    this.on('viewAppended', this.bound('calculateSize'));
    this.on('DragInAction', this.bound('handleDrag'));
    this.view.on('scroll', this.bound('calculatePosition'));
    this.listenWindowResize();
  }

  KDScrollThumb.prototype.resetSizes = function() {
    this.size = null;
    this.trackSize = null;
    return this.scrollSize = null;
  };

  KDScrollThumb.prototype.handleMutation = function() {
    this.scrollSize = null;
    return this.calculateSize();
  };

  KDScrollThumb.prototype.handleDrag = function() {
    var availOffset, offset, ratio, size, trackSize;
    size = this.getSize();
    offset = this.getOffset();
    trackSize = this.getTrackSize();
    availOffset = trackSize - size;
    ratio = Math.min(Math.max(0, offset / availOffset), 1);
    if (this.isVertical()) {
      return this.view.setScrollTop((this.view.getScrollHeight() - trackSize) * ratio);
    } else {
      return this.view.setScrollLeft((this.view.getScrollWidth() - trackSize) * ratio);
    }
  };

  KDScrollThumb.prototype.isVertical = function() {
    return this.type === 'vertical';
  };

  KDScrollThumb.prototype.getTrackSize = function() {
    if (this.trackSize) {
      return this.trackSize;
    } else if (this.isVertical()) {
      return this.track.getHeight();
    } else {
      return this.track.getWidth();
    }
  };

  KDScrollThumb.prototype.setSize = function(size) {
    if (this.isVertical()) {
      this.setHeight(size);
    } else {
      this.setWidth(size);
    }
    return this.size = size;
  };

  KDScrollThumb.prototype.getSize = function() {
    if (this.size) {
      return this.size;
    } else if (this.isVertical()) {
      return this.getHeight();
    } else {
      return this.getWidth();
    }
  };

  KDScrollThumb.prototype.setOffset = function(offset) {
    return this.setStyle(this.isVertical() ? {
      top: offset
    } : {
      left: offset
    });
  };

  KDScrollThumb.prototype.getOffset = function() {
    if (this.isVertical()) {
      return this.getY() - this.track.getY();
    } else {
      return this.getX() - this.track.getX();
    }
  };

  KDScrollThumb.prototype.getScrollOffset = function() {
    if (this.isVertical()) {
      return this.view.getScrollTop();
    } else {
      return this.view.getScrollLeft();
    }
  };

  KDScrollThumb.prototype.getScrollSize = function() {
    if (this.scrollSize) {
      return this.scrollSize;
    } else if (this.isVertical()) {
      return this.view.getScrollHeight();
    } else {
      return this.view.getScrollWidth();
    }
  };

  KDScrollThumb.prototype.calculateSize = function() {
    this.trackSize = this.getTrackSize();
    this.scrollSize = this.getScrollSize();
    if (this.trackSize >= this.scrollSize) {
      this.track.hide();
    } else {
      this.track.show();
    }
    return this.setSize(this.trackSize * this.trackSize / this.scrollSize);
  };

  KDScrollThumb.prototype.calculatePosition = function(event) {
    var ratio;
    ratio = this.getScrollOffset() / this.getScrollSize();
    return this.setOffset(this.getTrackSize() * ratio);
  };

  KDScrollThumb.prototype._windowDidResize = function() {
    return this.resetSizes();
  };

  return KDScrollThumb;

})(KDView);


},{"./../../core/view.coffee":106}],68:[function(require,module,exports){
var KDScrollTrack, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view');

module.exports = KDScrollTrack = (function(_super) {
  __extends(KDScrollTrack, _super);

  function KDScrollTrack(options, data) {
    if (options == null) {
      options = {};
    }
    options.type || (options.type = 'vertical');
    options.cssClass = KD.utils.curry("kdscrolltrack " + options.type, options.cssClass);
    KDScrollTrack.__super__.constructor.call(this, options, data);
    this.type = this.getOptions().type;
    this.thumb = new KDScrollThumb({
      cssClass: 'kdscrollthumb',
      type: this.type,
      track: this
    });
  }

  KDScrollTrack.prototype.viewAppended = function() {
    KDScrollTrack.__super__.viewAppended.call(this);
    return this.addSubView(this.thumb);
  };

  KDScrollTrack.prototype.show = function() {
    this.getDelegate().emit("ScrollTrackShown", this.type);
    return this.unsetClass('invisible');
  };

  KDScrollTrack.prototype.hide = function() {
    this.getDelegate().emit("ScrollTrackHidden", this.type);
    return this.setClass('invisible');
  };

  return KDScrollTrack;

})(KDView);


},{"./../../core/view":106}],69:[function(require,module,exports){
var KDScrollView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

require('jquery-mousewheel')($);

KDView = require('./../../core/view.coffee');

module.exports = KDScrollView = (function(_super) {
  __extends(KDScrollView, _super);

  function KDScrollView(options, data) {
    if (options == null) {
      options = {};
    }
    options.bind || (options.bind = "mouseenter");
    options.cssClass = KD.utils.curry("kdscrollview", options.cssClass);
    KDScrollView.__super__.constructor.call(this, options, data);
    this.stopScrolling = false;
    this.on('click', function() {
      return KD.getSingleton('windowController').enableScroll();
    });
  }

  KDScrollView.prototype.bindEvents = function() {
    this.$().bind("mousewheel scroll", (function(_this) {
      return function(event, delta, deltaX, deltaY) {
        if (delta) {
          event._delta = {
            delta: delta,
            deltaX: deltaX,
            deltaY: deltaY
          };
        }
        return _this.handleEvent(event);
      };
    })(this));
    return KDScrollView.__super__.bindEvents.apply(this, arguments);
  };

  KDScrollView.prototype.hasScrollBars = function() {
    return this.getScrollHeight() > this.getHeight();
  };

  KDScrollView.prototype.getScrollHeight = function() {
    return this.getElement().scrollHeight;
  };

  KDScrollView.prototype.getScrollWidth = function() {
    return this.getElement().scrollWidth;
  };

  KDScrollView.prototype.getScrollTop = function() {
    return this.getElement().scrollTop;
  };

  KDScrollView.prototype.getScrollLeft = function() {
    return this.getElement().scrollLeft;
  };

  KDScrollView.prototype.setScrollHeight = function(val) {
    return this.getElement().scrollHeight = val;
  };

  KDScrollView.prototype.setScrollWidth = function(val) {
    return this.getElement().scrollWidth = val;
  };

  KDScrollView.prototype.setScrollTop = function(val) {
    return this.getElement().scrollTop = val;
  };

  KDScrollView.prototype.setScrollLeft = function(val) {
    return this.getElement().scrollLeft = val;
  };

  KDScrollView.prototype.scrollTo = function(_arg, callback) {
    var duration, left, top;
    top = _arg.top, left = _arg.left, duration = _arg.duration;
    top || (top = 0);
    left || (left = 0);
    duration || (duration = null);
    if (duration) {
      return this.$().animate({
        scrollTop: top,
        scrollLeft: left
      }, duration, callback);
    } else {
      this.setScrollTop(top);
      this.setScrollLeft(left);
      return typeof callback === "function" ? callback() : void 0;
    }
  };

  KDScrollView.prototype.scrollToSubView = function(subView) {
    var subViewHeight, subViewRelTop, subViewTop, viewHeight, viewScrollTop, viewTop;
    viewTop = this.getY();
    viewHeight = this.getHeight();
    viewScrollTop = this.getScrollTop();
    subViewTop = subView.getY();
    subViewHeight = subView.getHeight();
    subViewRelTop = subViewTop - viewTop + viewScrollTop;
    if (subViewTop - viewTop + subViewHeight < viewHeight && subViewTop - viewTop >= 0) {

    } else if (subViewTop - viewTop < 0) {
      return this.scrollTo({
        top: subViewRelTop
      });
    } else if (subViewTop - viewTop + subViewHeight > viewHeight) {
      return this.scrollTo({
        top: subViewRelTop - viewHeight + subViewHeight
      });
    }
  };

  KDScrollView.prototype.fractionOfHeightBelowFold = function(_arg) {
    var scrollViewGlobalOffset, view, viewGlobalOffset, viewHeight, viewOffsetFromScrollView;
    view = _arg.view;
    viewHeight = view.getHeight();
    viewGlobalOffset = view.$().offset().top;
    scrollViewGlobalOffset = this.$().offset().top;
    viewOffsetFromScrollView = viewGlobalOffset - scrollViewGlobalOffset;
    return (viewHeight + viewOffsetFromScrollView - this.getHeight()) / this.getHeight();
  };

  KDScrollView.prototype.mouseWheel = function() {
    if (this.stopScrolling) {
      return false;
    }
  };

  return KDScrollView;

})(KDView);


},{"./../../core/view.coffee":106,"jquery-mousewheel":2}],70:[function(require,module,exports){
var KDCustomHTMLView, KDSliderBarHandleView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

module.exports = KDSliderBarHandleView = (function(_super) {
  __extends(KDSliderBarHandleView, _super);

  function KDSliderBarHandleView(options) {
    if (options == null) {
      options = {};
    }
    options.tagName = "a";
    options.cssClass = "handle";
    if (options.value == null) {
      options.value = 0;
    }
    options.draggable = {
      axis: "x"
    };
    KDSliderBarHandleView.__super__.constructor.call(this, options);
    this.value = this.getOption('value');
  }

  KDSliderBarHandleView.prototype.attachEvents = function() {
    var currentValue, maxValue, minValue, width, _ref;
    _ref = this.parent.getOptions(), maxValue = _ref.maxValue, minValue = _ref.minValue, width = _ref.width;
    currentValue = this.value;
    this.on("DragStarted", function() {
      return currentValue = this.value;
    });
    this.on("DragInAction", function() {
      var relPos, valueChange;
      relPos = this.dragState.position.relative.x;
      valueChange = ((maxValue - minValue) * relPos) / width;
      this.setValue(currentValue + valueChange);
      if (this.parent.getOption("snapOnDrag")) {
        return this.snap();
      }
    });
    return this.on("DragFinished", function() {
      if (this.parent.getOption("snap")) {
        return this.snap();
      }
    });
  };

  KDSliderBarHandleView.prototype.getPosition = function() {
    var maxValue, minValue, percentage, position, sliderWidth, _ref;
    _ref = this.parent.getOptions(), maxValue = _ref.maxValue, minValue = _ref.minValue;
    sliderWidth = this.parent.getWidth();
    percentage = ((this.value - minValue) * 100) / (maxValue - minValue);
    position = (sliderWidth / 100) * percentage;
    return "" + position + "px";
  };

  KDSliderBarHandleView.prototype.setValue = function(value) {
    var leftLimit, rightLimit, _ref;
    _ref = this.getOptions(), leftLimit = _ref.leftLimit, rightLimit = _ref.rightLimit;
    if (typeof rightLimit === "number") {
      value = Math.min(value, rightLimit);
    }
    if (typeof leftLimit === "number") {
      value = Math.max(value, leftLimit);
    }
    this.value = value;
    this.setX(this.getPosition());
    return this.parent.setValue(value, this, false);
  };

  KDSliderBarHandleView.prototype.getSnappedValue = function(value) {
    var interval, mid, mod;
    interval = this.parent.getOptions().interval;
    value || (value = this.value);
    if (interval) {
      mod = value % interval;
      mid = interval / 2;
      return value = (function() {
        switch (false) {
          case !(mod <= mid):
            return value - mod;
          case !(mod > mid):
            return value + (interval - mod);
          default:
            return value;
        }
      })();
    }
  };

  KDSliderBarHandleView.prototype.snap = function() {
    var interval, value;
    interval = this.parent.getOptions().interval;
    value = this.getSnappedValue();
    if (interval && this.parent.getOption("snap")) {
      this.setValue(value);
      if (this.parent.getOption('drawBar')) {
        return this.parent.drawBar();
      }
    }
  };

  KDSliderBarHandleView.prototype.viewAppended = function() {
    this.setX("" + (this.getPosition()));
    this.attachEvents();
    if (this.parent.getOption("snap")) {
      return this.snap();
    }
  };

  return KDSliderBarHandleView;

})(KDCustomHTMLView);


},{"./../../core/customhtmlview.coffee":97}],71:[function(require,module,exports){
var KDCustomHTMLView, KDSliderBarHandleView, KDSliderBarView,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

KDSliderBarHandleView = require('./sliderbarhandleview.coffee');

module.exports = KDSliderBarView = (function(_super) {
  __extends(KDSliderBarView, _super);

  function KDSliderBarView(options, data) {
    if (options == null) {
      options = {};
    }
    if (data == null) {
      data = {};
    }
    this._createLabel = __bind(this._createLabel, this);
    options.cssClass = KD.utils.curry("sliderbar-container", options.cssClass);
    if (options.minValue == null) {
      options.minValue = 0;
    }
    if (options.maxValue == null) {
      options.maxValue = 100;
    }
    if (options.interval == null) {
      options.interval = false;
    }
    if (options.drawBar == null) {
      options.drawBar = true;
    }
    if (options.showLabels == null) {
      options.showLabels = true;
    }
    if (options.snap == null) {
      options.snap = true;
    }
    if (options.snapOnDrag == null) {
      options.snapOnDrag = false;
    }
    options.width || (options.width = 300);
    if (options.drawOpposite == null) {
      options.drawOpposite = false;
    }
    KDSliderBarView.__super__.constructor.call(this, options, data);
    this.handles = [];
    this.labels = [];
  }

  KDSliderBarView.prototype.createHandles = function() {
    var handle, sortRef, value, _i, _len, _ref;
    _ref = this.getOption("handles");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      value = _ref[_i];
      this.handles.push(this.addSubView(handle = new KDSliderBarHandleView({
        value: value
      })));
    }
    sortRef = function(a, b) {
      if (a.options.value < b.options.value) {
        return -1;
      }
      if (a.options.value > b.options.value) {
        return 1;
      }
      return 0;
    };
    this.handles.sort(sortRef);
    return this.setClass("labeled");
  };

  KDSliderBarView.prototype.drawBar = function() {
    var diff, handle, left, len, positions, right, _i, _len, _ref;
    positions = [];
    _ref = this.handles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      handle = _ref[_i];
      positions.push(handle.getRelativeX());
    }
    len = positions.length;
    left = (len > 1 ? parseInt(positions.first) : void 0) || 0;
    right = parseInt(positions.last);
    diff = right - left;
    if (!this.bar) {
      this.addSubView(this.bar = new KDCustomHTMLView({
        cssClass: "bar"
      }));
    }
    this.bar.setWidth(diff);
    return this.bar.setX("" + left + "px");
  };

  KDSliderBarView.prototype.drawOppositeBar = function() {
    var diff, handle, positions, right, _i, _len, _ref;
    positions = [];
    _ref = this.handles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      handle = _ref[_i];
      positions.push(handle.getRelativeX());
    }
    right = parseInt(positions.last);
    diff = this.getWidth() - right;
    if (!this.oppositeBar) {
      this.addSubView(this.oppositeBar = new KDCustomHTMLView({
        cssClass: "opposite bar"
      }));
    }
    this.oppositeBar.setWidth(diff);
    return this.oppositeBar.setX("" + right + "px");
  };

  KDSliderBarView.prototype._createLabel = function(value) {
    var interval, label, maxValue, minValue, pos, showLabels, _ref;
    _ref = this.getOptions(), maxValue = _ref.maxValue, minValue = _ref.minValue, interval = _ref.interval, showLabels = _ref.showLabels;
    pos = ((value - minValue) * 100) / (maxValue - minValue);
    this.labels.push(this.addSubView(label = new KDCustomHTMLView({
      cssClass: "sliderbar-label",
      partial: "" + value
    })));
    return label.setX("" + pos + "%");
  };

  KDSliderBarView.prototype.addLabels = function() {
    var interval, maxValue, minValue, showLabels, value, _i, _j, _len, _ref, _results, _results1;
    _ref = this.getOptions(), maxValue = _ref.maxValue, minValue = _ref.minValue, interval = _ref.interval, showLabels = _ref.showLabels;
    if (Array.isArray(showLabels)) {
      _results = [];
      for (_i = 0, _len = showLabels.length; _i < _len; _i++) {
        value = showLabels[_i];
        _results.push(this._createLabel(value));
      }
      return _results;
    } else {
      _results1 = [];
      for (value = _j = minValue; interval > 0 ? _j <= maxValue : _j >= maxValue; value = _j += interval) {
        _results1.push(this._createLabel(value));
      }
      return _results1;
    }
  };

  KDSliderBarView.prototype.getValues = function() {
    var handle, _i, _len, _ref, _results;
    _ref = this.handles;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      handle = _ref[_i];
      _results.push(handle.getOptions().value);
    }
    return _results;
  };

  KDSliderBarView.prototype.setValue = function(value, handle, updateHandle) {
    if (handle == null) {
      handle = this.handles.first;
    }
    if (updateHandle == null) {
      updateHandle = true;
    }
    if (updateHandle) {
      handle.setValue(value);
    }
    if (this.getOption('drawBar')) {
      this.drawBar();
    }
    if (this.getOption('drawOpposite')) {
      this.drawOppositeBar();
    }
    this.setLimits();
    this.emit("ValueIsChanging", handle.value);
    return this.emit("ValueChanged", handle);
  };

  KDSliderBarView.prototype.setLimits = function() {
    var handle, i, interval, maxValue, minValue, options, _i, _len, _ref, _ref1, _ref2, _ref3, _results;
    _ref = this.getOptions(), maxValue = _ref.maxValue, minValue = _ref.minValue, interval = _ref.interval;
    if (this.handles.length === 1) {
      this.handles.first.options.leftLimit = minValue;
      return this.handles.first.options.rightLimit = maxValue;
    } else {
      _ref1 = this.handles;
      _results = [];
      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
        handle = _ref1[i];
        options = handle.getOptions();
        options.leftLimit = ((_ref2 = this.handles[i - 1]) != null ? _ref2.value : void 0) + interval || minValue;
        _results.push(options.rightLimit = ((_ref3 = this.handles[i + 1]) != null ? _ref3.value : void 0) - interval || maxValue);
      }
      return _results;
    }
  };

  KDSliderBarView.prototype.attachEvents = function() {
    return this.on("click", function(event) {
      var clickedPos, clickedValue, closestHandle, diff, handle, maxValue, minValue, mindiff, sliderWidth, snappedValue, value, _i, _len, _ref, _ref1;
      _ref = this.getOptions(), maxValue = _ref.maxValue, minValue = _ref.minValue;
      sliderWidth = this.getWidth();
      clickedPos = event.pageX - this.getBounds().x;
      clickedValue = ((maxValue - minValue) * clickedPos) / sliderWidth + minValue;
      snappedValue = this.handles.first.getSnappedValue(clickedValue);
      closestHandle = null;
      mindiff = null;
      _ref1 = this.handles;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        handle = _ref1[_i];
        value = handle.value;
        diff = Math.abs(clickedValue - value);
        if ((diff < mindiff) || !mindiff) {
          mindiff = diff;
          closestHandle = handle;
        }
      }
      return closestHandle.setValue(snappedValue);
    });
  };

  KDSliderBarView.prototype.viewAppended = function() {
    this.setWidth(this.getOption("width"));
    this.createHandles();
    this.setLimits();
    if (this.getOption('drawBar')) {
      this.drawBar();
    }
    if (this.getOption('drawOpposite')) {
      this.drawOppositeBar();
    }
    if (this.getOption('showLabels')) {
      this.addLabels();
    }
    return this.attachEvents();
  };

  return KDSliderBarView;

})(KDCustomHTMLView);


},{"./../../core/customhtmlview.coffee":97,"./sliderbarhandleview.coffee":70}],72:[function(require,module,exports){
var KDSlidePageView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDSlidePageView = (function(_super) {
  __extends(KDSlidePageView, _super);

  function KDSlidePageView(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry('kd-page', options.cssClass);
    KDSlidePageView.__super__.constructor.call(this, options, data);
    this._currentCssClass = null;
  }

  KDSlidePageView.prototype.move = function(cssClass) {
    if (!cssClass) {
      return;
    }
    this.unsetClass(this._currentCssClass);
    this._currentCssClass = cssClass;
    return this.setClass(cssClass);
  };

  return KDSlidePageView;

})(KDView);


},{"./../../core/view.coffee":106}],73:[function(require,module,exports){
var KDSlideShowView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDSlideShowView = (function(_super) {
  var X_COORD, Y_COORD, _ref;

  __extends(KDSlideShowView, _super);

  _ref = [1, 2], X_COORD = _ref[0], Y_COORD = _ref[1];

  function KDSlideShowView(options, data) {
    var animation, direction, hammer, leftToRight, topToBottom, touchCallbacks, touchEnabled, _ref1;
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry('kd-slide', options.cssClass);
    if (options.animation == null) {
      options.animation = 'move';
    }
    if (options.direction == null) {
      options.direction = 'leftToRight';
    }
    if (options.touchEnabled == null) {
      options.touchEnabled = true;
    }
    KDSlideShowView.__super__.constructor.call(this, options, data);
    this.pages = [];
    this._coordsY = [];
    this._currentX = 0;
    _ref1 = this.getOptions(), animation = _ref1.animation, direction = _ref1.direction, touchEnabled = _ref1.touchEnabled;
    topToBottom = [["" + animation + "FromTop", "" + animation + "FromBottom"], ["" + animation + "ToBottom", "" + animation + "ToTop"]];
    leftToRight = [["" + animation + "FromLeft", "" + animation + "FromRight"], ["" + animation + "ToRight", "" + animation + "ToLeft"]];
    if (direction === 'topToBottom') {
      this.xcoordAnimations = topToBottom;
      this.ycoordAnimations = leftToRight;
      touchCallbacks = ['nextSubPage', 'previousSubPage', 'nextPage', 'previousPage'];
    } else {
      this.xcoordAnimations = leftToRight;
      this.ycoordAnimations = topToBottom;
      touchCallbacks = ['nextPage', 'previousPage', 'nextSubPage', 'previousSubPage'];
    }
    if (touchEnabled) {
      hammer = Hammer(this.getElement());
      hammer.on("swipeleft", this.bound(touchCallbacks[0]));
      hammer.on("swiperight", this.bound(touchCallbacks[1]));
      hammer.on("swipeup", this.bound(touchCallbacks[2]));
      hammer.on("swipedown", this.bound(touchCallbacks[3]));
      hammer.on("touchmove", function(e) {
        return e.preventDefault();
      });
    }
  }

  KDSlideShowView.prototype.addPage = function(page) {
    this.addSubView(page);
    if (this.pages.length === 0) {
      page.setClass('current');
      this.currentPage = page;
    }
    this.pages.push([page]);
    return this._coordsY.push(0);
  };

  KDSlideShowView.prototype.addSubPage = function(page) {
    var lastAddedPage;
    this.addSubView(page);
    lastAddedPage = this.pages.last;
    return lastAddedPage.push(page);
  };

  KDSlideShowView.prototype.nextPage = function() {
    return this.jump(this._currentX + 1, X_COORD);
  };

  KDSlideShowView.prototype.previousPage = function() {
    return this.jump(this._currentX - 1, X_COORD);
  };

  KDSlideShowView.prototype.nextSubPage = function() {
    return this.jump(this._coordsY[this._currentX] + 1, Y_COORD);
  };

  KDSlideShowView.prototype.previousSubPage = function() {
    return this.jump(this._coordsY[this._currentX] - 1, Y_COORD);
  };

  KDSlideShowView.prototype.jump = function(pageIndex, coord, callback) {
    var current, currentPage, direction, index, newPage, pages, _ref1, _ref2;
    if (coord == null) {
      coord = 1;
    }
    if (callback == null) {
      callback = noop;
    }
    if (coord === X_COORD) {
      _ref1 = [this.pages, this._currentX], pages = _ref1[0], current = _ref1[1];
    } else {
      _ref2 = [this.pages[this._currentX], this._coordsY[this._currentX]], pages = _ref2[0], current = _ref2[1];
    }
    if (pages.length <= 1) {
      return;
    }
    index = Math.min(pages.length - 1, Math.max(0, pageIndex));
    if (current === index) {
      return;
    }
    direction = index < current ? 0 : 1;
    if (coord === X_COORD) {
      currentPage = pages[current][this._coordsY[current]];
      newPage = pages[index][this._coordsY[index]];
      this._currentX = index;
      newPage.move(this.xcoordAnimations[0][direction]);
      currentPage.move(this.xcoordAnimations[1][direction]);
    } else {
      currentPage = pages[current];
      newPage = pages[index];
      this._coordsY[this._currentX] = index;
      newPage.move(this.ycoordAnimations[0][direction]);
      currentPage.move(this.ycoordAnimations[1][direction]);
    }
    this.emit('CurrentPageChanged', {
      x: this._currentX,
      y: this._coordsY[this._currentX]
    });
    newPage.setClass('current');
    this.currentPage = newPage;
    return this.utils.wait(600, function() {
      currentPage.unsetClass('current');
      return callback();
    });
  };

  return KDSlideShowView;

})(KDView);


},{"./../../core/view.coffee":106}],74:[function(require,module,exports){
var KDSplitComboView, KDSplitView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDSplitView = require('./splitview.coffee');

module.exports = KDSplitComboView = (function(_super) {
  __extends(KDSplitComboView, _super);

  function KDSplitComboView(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass || (options.cssClass = "kdsplitcomboview");
    KDSplitComboView.__super__.constructor.call(this, options, data);
    this.init(options);
  }

  KDSplitComboView.prototype.init = function(options) {
    return this.addSubView(this.createSplitView(options.direction, options.sizes, options.views));
  };

  KDSplitComboView.prototype.createSplitView = function(type, sizes, viewsConfig) {
    var config, index, options, views, _i, _len;
    views = [];
    for (index = _i = 0, _len = viewsConfig.length; _i < _len; index = ++_i) {
      config = viewsConfig[index];
      if (config.type === "split") {
        options = config.options;
        views.push(this.createSplitView(options.direction, options.sizes, config.views));
      } else {
        views.push(config);
      }
    }
    return new KDSplitView({
      type: type,
      sizes: sizes,
      views: views
    });
  };

  return KDSplitComboView;

})(KDView);


},{"./../../core/view.coffee":106,"./splitview.coffee":77}],75:[function(require,module,exports){
var KDScrollView, KDSplitViewPanel,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDScrollView = require('./../scrollview/scrollview.coffee');

module.exports = KDSplitViewPanel = (function(_super) {
  __extends(KDSplitViewPanel, _super);

  function KDSplitViewPanel(options, data) {
    var _ref;
    if (options == null) {
      options = {};
    }
    if (options.fixed == null) {
      options.fixed = false;
    }
    options.minimum || (options.minimum = null);
    options.maximum || (options.maximum = null);
    options.view || (options.view = null);
    KDSplitViewPanel.__super__.constructor.call(this, options, data);
    this.isVertical = this.getOptions().type.toLowerCase() === "vertical";
    this.isFixed = this.getOptions().fixed;
    _ref = this.options, this.size = _ref.size, this.minimum = _ref.minimum, this.maximum = _ref.maximum;
  }

  KDSplitViewPanel.prototype._getIndex = function() {
    return this.parent.getPanelIndex(this);
  };

  KDSplitViewPanel.prototype._getSize = function() {
    if (this.isVertical) {
      return this.getWidth();
    } else {
      return this.getHeight();
    }
  };

  KDSplitViewPanel.prototype._setSize = function(size) {
    if (this._wouldResize(size)) {
      if (size < 0) {
        size = 0;
      }
      if (this.isVertical) {
        this.setWidth(size);
      } else {
        this.setHeight(size);
      }
      this.parent.sizes[this._getIndex()] = this.size = size;
      this.parent.emit("PanelDidResize", {
        panel: this
      });
      this.emit("PanelDidResize", {
        newSize: size
      });
      return size;
    } else {
      return false;
    }
  };

  KDSplitViewPanel.prototype._wouldResize = function(size) {
    if (this.minimum == null) {
      this.minimum = -1;
    }
    if (this.maximum == null) {
      this.maximum = 99999;
    }
    if (size > this.minimum && size < this.maximum) {
      return true;
    } else {
      if (size < this.minimum) {
        this.parent._panelReachedMinimum(this._getIndex());
      } else if (size > this.maximum) {
        this.parent._panelReachedMaximum(this._getIndex());
      }
      return false;
    }
  };

  KDSplitViewPanel.prototype._setOffset = function(offset) {
    if (offset < 0) {
      offset = 0;
    }
    if (this.isVertical) {
      this.$().css({
        left: offset
      });
    } else {
      this.$().css({
        top: offset
      });
    }
    return this.parent.panelsBounds[this._getIndex()] = offset;
  };

  KDSplitViewPanel.prototype._getOffset = function() {
    if (this.isVertical) {
      return this.getRelativeX();
    } else {
      return this.getRelativeY();
    }
  };

  KDSplitViewPanel.prototype._animateTo = function(size, offset, callback) {
    var cb, d, options, panel, properties;
    if ("undefined" === typeof callback && "function" === typeof offset) {
      callback = offset;
    }
    callback || (callback = noop);
    panel = this;
    d = panel.parent.options.duration;
    cb = function() {
      var newSize;
      newSize = panel._getSize();
      panel.parent.sizes[panel.index] = panel.size = newSize;
      panel.parent.emit("PanelDidResize", {
        panel: panel
      });
      panel.emit("PanelDidResize", {
        newSize: newSize
      });
      return callback.call(panel);
    };
    properties = {};
    if (size < 0) {
      size = 0;
    }
    if (panel.isVertical) {
      properties.width = size;
      if (offset != null) {
        properties.left = offset;
      }
    } else {
      properties.height = size;
      if (offset != null) {
        properties.top = offset;
      }
    }
    options = {
      duration: d,
      complete: cb
    };
    panel.$().stop();
    return panel.$().animate(properties, options);
  };

  return KDSplitViewPanel;

})(KDScrollView);


},{"./../scrollview/scrollview.coffee":69}],76:[function(require,module,exports){
var KDSplitResizer, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDSplitResizer = (function(_super) {
  __extends(KDSplitResizer, _super);

  function KDSplitResizer(options, data) {
    var axis, _ref;
    if (options == null) {
      options = {};
    }
    this.isVertical = options.type.toLowerCase() === "vertical";
    axis = this.isVertical ? "x" : "y";
    if (options.draggable == null) {
      options.draggable = {
        axis: axis
      };
    }
    KDSplitResizer.__super__.constructor.call(this, options, data);
    _ref = this.getOptions(), this.panel0 = _ref.panel0, this.panel1 = _ref.panel1;
    this.on("DragFinished", this.dragFinished);
    this.on("DragInAction", this.dragInAction);
    this.on("DragStarted", this.dragStarted);
  }

  KDSplitResizer.prototype._setOffset = function(offset) {
    if (offset < 0) {
      offset = 0;
    }
    if (this.isVertical) {
      return this.$().css({
        left: offset - 5
      });
    } else {
      return this.$().css({
        top: offset - 5
      });
    }
  };

  KDSplitResizer.prototype._getOffset = function(offset) {
    if (this.isVertical) {
      return this.getRelativeX();
    } else {
      return this.getRelativeY();
    }
  };

  KDSplitResizer.prototype._animateTo = function(offset) {
    var d;
    d = this.parent.options.duration;
    if (this.isVertical) {
      offset -= this.getWidth() / 2;
      return this.$().animate({
        left: offset
      }, d);
    } else {
      offset -= this.getHeight() / 2;
      return this.$().animate({
        top: offset
      }, d);
    }
  };

  KDSplitResizer.prototype.dragFinished = function(event, dragState) {
    return this.parent._resizeDidStop(event);
  };

  KDSplitResizer.prototype.dragStarted = function(event, dragState) {
    this.parent._resizeDidStart();
    this.rOffset = this._getOffset();
    this.p0Size = this.panel0._getSize();
    this.p1Size = this.panel1._getSize();
    return this.p1Offset = this.panel1._getOffset();
  };

  KDSplitResizer.prototype.dragInAction = function(x, y) {
    var p0DidResize, p0WouldResize, p1DidResize, p1WouldResize;
    if (this.isVertical) {
      p0WouldResize = this.panel0._wouldResize(x + this.p0Size);
      if (p0WouldResize) {
        p1WouldResize = this.panel1._wouldResize(-x + this.p1Size);
      }
      this.dragIsAllowed = p1WouldResize ? (this.panel0._setSize(x + this.p0Size), this.panel1._setSize(-x + this.p1Size), true) : (this._setOffset(this.panel1._getOffset()), false);
      if (this.dragIsAllowed) {
        return this.panel1._setOffset(x + this.p1Offset);
      }
    } else {
      p0WouldResize = this.panel0._wouldResize(y + this.p0Size);
      p1WouldResize = this.panel1._wouldResize(-y + this.p1Size);
      p0DidResize = p0WouldResize && p1WouldResize ? this.panel0._setSize(y + this.p0Size) : false;
      p1DidResize = p0WouldResize && p1WouldResize ? this.panel1._setSize(-y + this.p1Size) : false;
      if (p0DidResize && p1DidResize) {
        return this.panel1._setOffset(y + this.p1Offset);
      }
    }
  };

  return KDSplitResizer;

})(KDView);


},{"./../../core/view.coffee":106}],77:[function(require,module,exports){
var KD, KDSplitResizer, KDSplitView, KDSplitViewPanel, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KD = require('./../../core/kd.coffee');

KDView = require('./../../core/view.coffee');

KDSplitViewPanel = require('./splitpanel.coffee');

KDSplitResizer = require('./splitresizer.coffee');

module.exports = KDSplitView = (function(_super) {
  __extends(KDSplitView, _super);

  function KDSplitView(options, data) {
    if (options == null) {
      options = {};
    }
    options.type || (options.type = "vertical");
    if (options.resizable == null) {
      options.resizable = true;
    }
    options.sizes || (options.sizes = ["50%", "50%"]);
    options.minimums || (options.minimums = null);
    options.maximums || (options.maximums = null);
    options.views || (options.views = null);
    options.fixed || (options.fixed = []);
    options.duration || (options.duration = 200);
    options.separator || (options.separator = null);
    if (options.colored == null) {
      options.colored = false;
    }
    if (options.animated == null) {
      options.animated = true;
    }
    options.type = options.type.toLowerCase();
    KDSplitView.__super__.constructor.call(this, options, data);
    this.setClass("kdsplitview kdsplitview-" + (this.getOptions().type) + " " + (this.getOptions().cssClass));
    this.panels = [];
    this.panelsBounds = [];
    this.resizers = [];
    this.sizes = [];
  }

  KDSplitView.prototype.viewAppended = function() {
    this._sanitizeSizes();
    this._createPanels();
    this._calculatePanelBounds();
    this._putPanels();
    this._setPanelPositions();
    this._putViews();
    if (this.getOptions().resizable && this.panels.length) {
      this._createResizers();
    }
    return this.listenWindowResize();
  };

  KDSplitView.prototype._createPanels = function() {
    var i, panelCount;
    panelCount = this.getOptions().sizes.length;
    return this.panels = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= panelCount ? _i < panelCount : _i > panelCount; i = 0 <= panelCount ? ++_i : --_i) {
        _results.push(this._createPanel(i));
      }
      return _results;
    }).call(this);
  };

  KDSplitView.prototype._createPanel = function(index) {
    var fixed, maximums, minimums, panel, type, _ref;
    _ref = this.getOptions(), type = _ref.type, fixed = _ref.fixed, minimums = _ref.minimums, maximums = _ref.maximums;
    panel = new KDSplitViewPanel({
      cssClass: "kdsplitview-panel panel-" + index,
      index: index,
      type: type,
      size: this._sanitizeSize(this.sizes[index]),
      fixed: fixed[index] != null,
      minimum: minimums ? this._sanitizeSize(minimums[index]) : void 0,
      maximum: maximums ? this._sanitizeSize(maximums[index]) : void 0
    });
    panel.on("KDObjectWillBeDestroyed", (function(_this) {
      return function() {
        return _this._panelIsBeingDestroyed(panel);
      };
    })(this));
    this.emit("SplitPanelCreated", panel);
    return panel;
  };

  KDSplitView.prototype._calculatePanelBounds = function() {
    var i, offset, prevSize, size;
    return this.panelsBounds = (function() {
      var _i, _j, _len, _ref, _results;
      _ref = this.sizes;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        size = _ref[i];
        if (i === 0) {
          _results.push(0);
        } else {
          offset = 0;
          for (prevSize = _j = 0; 0 <= i ? _j < i : _j > i; prevSize = 0 <= i ? ++_j : --_j) {
            offset += this.sizes[prevSize];
          }
          _results.push(offset);
        }
      }
      return _results;
    }).call(this);
  };

  KDSplitView.prototype._putPanels = function() {
    var panel, _i, _len, _ref, _results;
    _ref = this.panels;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      panel = _ref[_i];
      this.addSubView(panel);
      if (this.getOptions().colored) {
        _results.push(panel.$().css({
          backgroundColor: KD.utils.getRandomRGB()
        }));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  KDSplitView.prototype._setPanelPositions = function() {
    var i, panel, _i, _len, _ref;
    _ref = this.panels;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      panel = _ref[i];
      panel._setSize(this.sizes[i]);
      panel._setOffset(this.panelsBounds[i]);
    }
    return false;
  };

  KDSplitView.prototype._panelIsBeingDestroyed = function(panel) {
    var index, o;
    index = this.getPanelIndex(panel);
    o = this.getOptions();
    this.panels = this.panels.slice(0, index).concat(this.panels.slice(index + 1));
    this.sizes = this.sizes.slice(0, index).concat(this.sizes.slice(index + 1));
    this.panelsBounds = this.panelsBounds.slice(0, index).concat(this.panelsBounds.slice(index + 1));
    o.minimums.splice(index, 1);
    o.maximums.splice(index, 1);
    if (o.views[index] != null) {
      return o.views.splice(index, 1);
    }
  };

  KDSplitView.prototype._createResizers = function() {
    var i;
    this.resizers = (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 1, _ref = this.sizes.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
        _results.push(this._createResizer(i));
      }
      return _results;
    }).call(this);
    return this._repositionResizers();
  };

  KDSplitView.prototype._createResizer = function(index) {
    var resizer;
    this.addSubView(resizer = new KDSplitResizer({
      cssClass: "kdsplitview-resizer " + (this.getOptions().type),
      type: this.getOptions().type,
      panel0: this.panels[index - 1],
      panel1: this.panels[index]
    }));
    return resizer;
  };

  KDSplitView.prototype._repositionResizers = function() {
    var i, resizer, _i, _len, _ref, _results;
    _ref = this.resizers;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      resizer = _ref[i];
      _results.push(resizer._setOffset(this.panelsBounds[i + 1]));
    }
    return _results;
  };

  KDSplitView.prototype._putViews = function() {
    var i, view, _base, _i, _len, _ref, _results;
    if ((_base = this.getOptions()).views == null) {
      _base.views = [];
    }
    _ref = this.getOptions().views;
    _results = [];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      view = _ref[i];
      if (view instanceof KDView) {
        _results.push(this.setView(view, i));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  KDSplitView.prototype._sanitizeSizes = function() {
    var i, newSizes, nullCount, nullSize, o, panelSize, size, splitSize, totalOccupied;
    this._setMinsAndMaxs();
    o = this.getOptions();
    nullCount = 0;
    totalOccupied = 0;
    splitSize = this._getSize();
    newSizes = (function() {
      var _i, _len, _ref, _results;
      _ref = o.sizes;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        size = _ref[i];
        if (size === null) {
          nullCount++;
          _results.push(null);
        } else {
          panelSize = this._sanitizeSize(size);
          this._getLegitPanelSize(size, i);
          totalOccupied += panelSize;
          _results.push(panelSize);
        }
      }
      return _results;
    }).call(this);
    this.sizes = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = newSizes.length; _i < _len; _i++) {
        size = newSizes[_i];
        if (size === null) {
          nullSize = (splitSize - totalOccupied) / nullCount;
          _results.push(Math.round(nullSize));
        } else {
          _results.push(Math.round(size));
        }
      }
      return _results;
    })();
    return this.sizes;
  };

  KDSplitView.prototype._sanitizeSize = function(size) {
    var splitSize;
    if ("number" === typeof size || /px$/.test(size)) {
      return parseInt(size, 10);
    } else if (/%$/.test(size)) {
      splitSize = this._getSize();
      return splitSize / 100 * parseInt(size, 10);
    }
  };

  KDSplitView.prototype._setMinsAndMaxs = function() {
    var i, panelAmount, _base, _base1, _i, _results;
    if ((_base = this.getOptions()).minimums == null) {
      _base.minimums = [];
    }
    if ((_base1 = this.getOptions()).maximums == null) {
      _base1.maximums = [];
    }
    panelAmount = this.getOptions().sizes.length || 2;
    _results = [];
    for (i = _i = 0; 0 <= panelAmount ? _i < panelAmount : _i > panelAmount; i = 0 <= panelAmount ? ++_i : --_i) {
      this.getOptions().minimums[i] = this.getOptions().minimums[i] ? this._sanitizeSize(this.getOptions().minimums[i]) : -1;
      _results.push(this.getOptions().maximums[i] = this.getOptions().maximums[i] ? this._sanitizeSize(this.getOptions().maximums[i]) : 99999);
    }
    return _results;
  };

  KDSplitView.prototype._getSize = function() {
    if (this.getOptions().type === "vertical") {
      return this.getWidth();
    } else {
      return this.getHeight();
    }
  };

  KDSplitView.prototype._setSize = function(size) {
    if (this.getOptions().type === "vertical") {
      return this.setWidth(size);
    } else {
      return this.setHeight(size);
    }
  };

  KDSplitView.prototype._getParentSize = function() {
    var $parent, type;
    type = this.getOptions().type;
    $parent = this.$().parent();
    if (type === "vertical") {
      return $parent.width();
    } else {
      return $parent.height();
    }
  };

  KDSplitView.prototype._getLegitPanelSize = function(size, index) {
    return size = this.getOptions().minimums[index] > size ? this.getOptions().minimums[index] : this.getOptions().maximums[index] < size ? this.getOptions().maximums[index] : size;
  };

  KDSplitView.prototype._resizePanels = function() {
    return this._sanitizeSizes();
  };

  KDSplitView.prototype._repositionPanels = function() {
    this._calculatePanelBounds();
    return this._setPanelPositions();
  };

  KDSplitView.prototype._windowDidResize = function(event) {
    this._setSize(this._getParentSize());
    this._resizePanels();
    this._repositionPanels();
    this._setPanelPositions();
    if (this.getOptions().resizable) {
      return this._repositionResizers();
    }
  };

  KDSplitView.prototype.mouseUp = function(event) {
    this.$().unbind("mousemove.resizeHandle");
    return this._resizeDidStop(event);
  };

  KDSplitView.prototype._panelReachedMinimum = function(panelIndex) {
    this.panels[panelIndex].emit("PanelReachedMinimum");
    return this.emit("PanelReachedMinimum", {
      panel: this.panels[panelIndex]
    });
  };

  KDSplitView.prototype._panelReachedMaximum = function(panelIndex) {
    this.panels[panelIndex].emit("PanelReachedMaximum");
    return this.emit("PanelReachedMaximum", {
      panel: this.panels[panelIndex]
    });
  };

  KDSplitView.prototype._resizeDidStart = function(event) {
    $('body').addClass("resize-in-action");
    return this.emit("ResizeDidStart", {
      orgEvent: event
    });
  };

  KDSplitView.prototype._resizeDidStop = function(event) {
    this.emit("ResizeDidStop", {
      orgEvent: event
    });
    return this.utils.wait(300, function() {
      return $('body').removeClass("resize-in-action");
    });
  };


  /* PUBLIC METHODS */

  KDSplitView.prototype.isVertical = function() {
    return this.getOptions().type === "vertical";
  };

  KDSplitView.prototype.getPanelIndex = function(panel) {
    var i, p, _i, _len, _ref;
    _ref = this.panels;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      p = _ref[i];
      if (p.getId() === panel.getId()) {
        return i;
      }
    }
  };

  KDSplitView.prototype.hidePanel = function(panelIndex, callback) {
    var panel;
    if (callback == null) {
      callback = noop;
    }
    panel = this.panels[panelIndex];
    panel._lastSize = panel._getSize();
    return this.resizePanel(0, panelIndex, (function(_this) {
      return function() {
        return callback.call(_this, {
          panel: panel,
          index: panelIndex
        });
      };
    })(this));
  };

  KDSplitView.prototype.showPanel = function(panelIndex, callback) {
    var newSize, panel;
    if (callback == null) {
      callback = noop;
    }
    panel = this.panels[panelIndex];
    newSize = panel._lastSize || this.getOptions().sizes[panelIndex] || 200;
    panel._lastSize = null;
    return this.resizePanel(newSize, panelIndex, function() {
      return callback.call(this, {
        panel: panel,
        index: panelIndex
      });
    });
  };

  KDSplitView.prototype.resizePanel = function(value, panelIndex, callback) {
    var isReverse, p0offset, p0size, p1index, p1newSize, p1offset, p1size, panel0, panel1, race, raceCounter, resizer, surplus, totalActionArea;
    if (value == null) {
      value = 0;
    }
    if (panelIndex == null) {
      panelIndex = 0;
    }
    if (callback == null) {
      callback = noop;
    }
    this._resizeDidStart();
    value = this._sanitizeSize(value);
    panel0 = this.panels[panelIndex];
    isReverse = false;
    if (panel0.size === value) {
      this._resizeDidStop();
      callback();
      return;
    }
    panel1 = this.panels.length - 1 !== panelIndex ? (p1index = panelIndex + 1, this.getOptions().resizable ? resizer = this.resizers[panelIndex] : void 0, this.panels[p1index]) : (isReverse = true, p1index = panelIndex - 1, this.getOptions().resizable ? resizer = this.resizers[p1index] : void 0, this.panels[p1index]);
    totalActionArea = panel0.size + panel1.size;
    if (value > totalActionArea) {
      return false;
    }
    p0size = this._getLegitPanelSize(value, panelIndex);
    surplus = panel0.size - p0size;
    p1newSize = panel1.size + surplus;
    p1size = this._getLegitPanelSize(p1newSize, p1index);
    raceCounter = 0;
    race = (function(_this) {
      return function() {
        raceCounter++;
        if (raceCounter === 2) {
          _this._resizeDidStop();
          return callback();
        }
      };
    })(this);
    if (!isReverse) {
      p1offset = panel1._getOffset() - surplus;
      if (this.getOptions().animated) {
        panel0._animateTo(p0size, race);
        panel1._animateTo(p1size, p1offset, race);
        if (resizer) {
          return resizer._animateTo(p1offset);
        }
      } else {
        panel0._setSize(p0size);
        race();
        panel1._setSize(p1size, panel1._setOffset(p1offset));
        race();
        if (resizer) {
          return resizer._setOffset(p1offset);
        }
      }
    } else {
      p0offset = panel0._getOffset() + surplus;
      if (this.getOptions().animated) {
        panel0._animateTo(p0size, p0offset, race);
        panel1._animateTo(p1size, race);
        if (resizer) {
          return resizer._animateTo(p0offset);
        }
      } else {
        panel0._setSize(p0size);
        panel0._setOffset(p0offset);
        race();
        panel1._setSize(p1size);
        race();
        if (resizer) {
          return resizer._setOffset(p0offset);
        }
      }
    }
  };

  KDSplitView.prototype.splitPanel = function(index, options) {
    var i, isLastPanel, newIndex, newPanel, newPanelOptions, newResizer, newSize, o, oldResizer, panel, panelToBeSplitted, _i, _len, _ref;
    newPanelOptions = {};
    o = this.getOptions();
    isLastPanel = this.resizers[index] ? false : true;
    panelToBeSplitted = this.panels[index];
    this.panels.splice(index + 1, 0, newPanel = this._createPanel(index));
    this.sizes.splice(index + 1, 0, this.sizes[index] / 2);
    this.sizes[index] = this.sizes[index] / 2;
    o.minimums.splice(index + 1, 0, newPanelOptions.minimum);
    o.maximums.splice(index + 1, 0, newPanelOptions.maximum);
    o.views.splice(index + 1, 0, newPanelOptions.view);
    o.sizes = this.sizes;
    this.subViews.push(newPanel);
    newPanel.setParent(this);
    panelToBeSplitted.$().after(newPanel.$());
    newPanel.emit('viewAppended');
    newSize = panelToBeSplitted._getSize() / 2;
    panelToBeSplitted._setSize(newSize);
    newPanel._setSize(newSize);
    newPanel._setOffset(panelToBeSplitted._getOffset() + newSize);
    this._calculatePanelBounds();
    _ref = this.panels.slice(index + 1, this.panels.length);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      panel = _ref[i];
      panel.index = newIndex = index + 1 + i;
      panel.unsetClass("panel-" + (index + i)).setClass("panel-" + newIndex);
    }
    if (this.getOptions().resizable) {
      if (!isLastPanel) {
        oldResizer = this.resizers[index];
        oldResizer._setOffset(this.panelsBounds[index + 1]);
        oldResizer.panel0 = panelToBeSplitted;
        oldResizer.panel1 = newPanel;
        this.resizers.splice(index + 1, 0, newResizer = this._createResizer(index + 2));
        newResizer._setOffset(this.panelsBounds[index + 2]);
      } else {
        this.resizers.push(newResizer = this._createResizer(index + 1));
        newResizer._setOffset(this.panelsBounds[index + 1]);
      }
    }
    this.emit("panelSplitted", newPanel);
    return newPanel;
  };

  KDSplitView.prototype.removePanel = function(index) {
    var l, panel, r, res;
    l = this.panels.length;
    if (l === 1) {
      warn("this is the only panel left");
      return false;
    }
    panel = this.panels[index];
    panel.destroy();
    if (index === 0) {
      r = this.resizers.shift();
      r.destroy();
      if (res = this.resizers[0]) {
        res.panel0 = this.panels[0];
        res.panel1 = this.panels[1];
      }
    } else if (index === l - 1) {
      r = this.resizers.pop();
      r.destroy();
      if (res = this.resizers[l - 2]) {
        res.panel0 = this.panels[l - 2];
        res.panel1 = this.panels[l - 1];
      }
    } else {
      r = this.resizers.splice(index - 1, 1)[0];
      r.destroy();
      this.resizers[index - 1].panel0 = this.panels[index - 1];
      this.resizers[index - 1].panel1 = this.panels[index];
    }
    return true;
  };

  KDSplitView.prototype.setView = function(view, index) {
    if (index > this.panels.length || !view) {
      warn("Either 'view' or 'index' is missing at KDSplitView::setView!");
      return;
    }
    return this.panels[index].addSubView(view);
  };

  return KDSplitView;

})(KDView);


},{"./../../core/kd.coffee":100,"./../../core/view.coffee":106,"./splitpanel.coffee":75,"./splitresizer.coffee":76}],78:[function(require,module,exports){
var KDTabHandleContainer, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDTabHandleContainer = (function(_super) {
  __extends(KDTabHandleContainer, _super);

  function KDTabHandleContainer(options, data) {
    if (options == null) {
      options = {};
    }
    KDTabHandleContainer.__super__.constructor.call(this, options, data);
    this.tabs = new KDView({
      cssClass: 'kdtabhandle-tabs clearfix'
    });
  }

  KDTabHandleContainer.prototype.viewAppended = function() {
    return this.addSubView(this.tabs);
  };

  return KDTabHandleContainer;

})(KDView);


},{"./../../core/view.coffee":106}],79:[function(require,module,exports){
var KDCustomHTMLView, KDTabHandleMoveNav,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

module.exports = KDTabHandleMoveNav = (function(_super) {
  __extends(KDTabHandleMoveNav, _super);

  function KDTabHandleMoveNav(options, data) {
    if (options == null) {
      options = {};
    }
    options.cssClass = KD.utils.curry('kdtabhandle-movenav', options.cssClass);
    KDTabHandleMoveNav.__super__.constructor.call(this, options, data);
    this._current = 0;
  }

  KDTabHandleMoveNav.prototype.viewAppended = function() {
    this.addSubView(this.left = new KDCustomHTMLView({
      cssClass: 'leftButton',
      click: (function(_this) {
        return function() {
          return _this.move('right');
        };
      })(this)
    }));
    this.addSubView(this.right = new KDCustomHTMLView({
      cssClass: 'rightButton',
      click: (function(_this) {
        return function() {
          return _this.move('left');
        };
      })(this)
    }));
    return this.listenWindowResize();
  };

  KDTabHandleMoveNav.prototype._windowDidResize = function() {
    var delegate;
    delegate = this.getDelegate();
    if (!(delegate.getWidth() > delegate._tabsWidth + 50)) {
      return this.show();
    } else {
      this.move('initial');
      return this.hide();
    }
  };

  KDTabHandleMoveNav.prototype.move = function(direction) {
    var delegate, handleWidth, tabHandleContainer;
    tabHandleContainer = (delegate = this.getDelegate()).tabHandleContainer;
    handleWidth = delegate.getOption('maxHandleWidth');
    switch (direction) {
      case 'left':
        if (handleWidth * delegate.handles.length + 100 < tabHandleContainer.getWidth() - this._current) {
          return;
        }
        this._current -= handleWidth;
        break;
      case 'right':
        if (this._current === 0) {
          return;
        }
        this._current += handleWidth;
        break;
      case 'initial':
        this._current = 0;
    }
    return tabHandleContainer.tabs.setCss('marginLeft', "" + this._current + "px");
  };

  return KDTabHandleMoveNav;

})(KDCustomHTMLView);


},{"./../../core/customhtmlview.coffee":97}],80:[function(require,module,exports){
var KDTabHandleView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDTabHandleView = (function(_super) {
  __extends(KDTabHandleView, _super);

  function KDTabHandleView(options, data) {
    if (options == null) {
      options = {};
    }
    if (options.hidden == null) {
      options.hidden = false;
    }
    options.title || (options.title = "Title");
    if (options.pane == null) {
      options.pane = null;
    }
    if (options.view == null) {
      options.view = null;
    }
    if (options.sortable == null) {
      options.sortable = false;
    }
    if (options.closable == null) {
      options.closable = true;
    }
    if (options.addTitleAttribute == null) {
      options.addTitleAttribute = true;
    }
    if (options.sortable) {
      options.draggable = {
        axis: "x"
      };
      this.dragStartPosX = null;
    }
    KDTabHandleView.__super__.constructor.call(this, options, data);
    this.on("DragStarted", (function(_this) {
      return function(event, dragState) {
        _this.startedDragFromCloseElement = $(event.target).hasClass("close-tab");
        return _this.handleDragStart(event, dragState);
      };
    })(this));
    this.on("DragInAction", (function(_this) {
      return function(x, y) {
        if (_this.startedDragFromCloseElement) {
          _this.dragIsAllowed = false;
        }
        return _this.handleDragInAction(x, y);
      };
    })(this));
    this.on("DragFinished", (function(_this) {
      return function(event) {
        _this.handleDragFinished(event);
        return _this.getDelegate().showPaneByIndex(_this.index);
      };
    })(this));
  }

  KDTabHandleView.prototype.setDomElement = function(cssClass) {
    var addTitleAttribute, closable, closeHandle, hidden, tagName, title, _ref;
    if (cssClass == null) {
      cssClass = "";
    }
    _ref = this.getOptions(), hidden = _ref.hidden, closable = _ref.closable, tagName = _ref.tagName, title = _ref.title, addTitleAttribute = _ref.addTitleAttribute;
    cssClass = hidden ? "" + cssClass + " hidden" : cssClass;
    closeHandle = closable ? "<span class='close-tab'></span>" : "";
    title = addTitleAttribute ? "title='" + title + "'" : "";
    return this.domElement = $("<" + tagName + " " + title + " class='kdtabhandle " + cssClass + "'>" + closeHandle + "</" + tagName + ">");
  };

  KDTabHandleView.prototype.viewAppended = function() {
    var view;
    view = this.getOptions().view;
    if (view && view instanceof KDView) {
      return this.addSubView(view);
    } else {
      return this.setPartial(this.partial());
    }
  };

  KDTabHandleView.prototype.partial = function() {
    return "<b>" + (this.getOptions().title || 'Default Title') + "</b>";
  };

  KDTabHandleView.prototype.makeActive = function() {
    return this.getDomElement().addClass("active");
  };

  KDTabHandleView.prototype.makeInactive = function() {
    return this.getDomElement().removeClass("active");
  };

  KDTabHandleView.prototype.setTitle = function(title) {
    return this.setAttribute("title", title);
  };

  KDTabHandleView.prototype.isHidden = function() {
    return this.getOptions().hidden;
  };

  KDTabHandleView.prototype.getWidth = function() {
    return this.$().outerWidth(false) || 0;
  };

  KDTabHandleView.prototype.cloneElement = function(x) {
    var holder, pane, tabView;
    if (this.$cloned) {
      return;
    }
    pane = this.getOptions().pane;
    tabView = pane.getDelegate();
    holder = tabView.tabHandleContainer;
    this.$cloned = this.$().clone();
    holder.$().append(this.$cloned);
    return this.$cloned.css({
      marginLeft: -(tabView.handles.length - this.index) * this.getWidth()
    });
  };

  KDTabHandleView.prototype.updateClonedElementPosition = function(x) {
    return this.$cloned.css({
      left: x
    });
  };

  KDTabHandleView.prototype.reorderTabHandles = function(x) {
    var dragDir, targetDiff, targetIndex, width;
    dragDir = this.dragState.direction;
    width = this.getWidth();
    if (dragDir.current.x === 'left') {
      targetIndex = this.index - 1;
      targetDiff = -(width * this.draggedItemIndex - width * targetIndex - width / 2);
      if (x < targetDiff) {
        this.emit("HandleIndexHasChanged", this.index, 'left');
        return this.index--;
      }
    } else {
      targetIndex = this.index + 1;
      targetDiff = width * targetIndex - width * this.draggedItemIndex - width / 2;
      if (x > targetDiff) {
        this.emit("HandleIndexHasChanged", this.index, 'right');
        return this.index++;
      }
    }
  };

  KDTabHandleView.prototype.handleDragStart = function(event, dragState) {
    var handles, pane, tabView;
    pane = this.getOptions().pane;
    tabView = pane.getDelegate();
    handles = tabView.handles;
    this.index = handles.indexOf(this);
    return this.draggedItemIndex = this.index;
  };

  KDTabHandleView.prototype.handleDragInAction = function(x, y) {
    if (!this.dragIsAllowed) {
      return;
    }
    if (-(this.draggedItemIndex * this.getWidth()) > x) {
      return this.$().css({
        'left': 0
      });
    }
    this.unsetClass('first');
    this.cloneElement(x);
    this.$().css({
      opacity: 0
    });
    this.updateClonedElementPosition(x);
    return this.reorderTabHandles(x);
  };

  KDTabHandleView.prototype.handleDragFinished = function(event) {
    if (!this.$cloned) {
      return;
    }
    this.$cloned.remove();
    this.$().css({
      left: '',
      opacity: 1,
      marginLeft: ''
    });
    if (!this.targetTabHandle && this.draggedItemIndex === 0) {
      this.$().css({
        left: 0
      });
    }
    this.targetTabHandle = null;
    return this.$cloned = null;
  };

  return KDTabHandleView;

})(KDView);


},{"./../../core/view.coffee":106}],81:[function(require,module,exports){
var KDTabPaneView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDTabPaneView = (function(_super) {
  __extends(KDTabPaneView, _super);

  function KDTabPaneView(options, data) {
    var defaultCssClass;
    if (options == null) {
      options = {};
    }
    if (options.hiddenHandle == null) {
      options.hiddenHandle = false;
    }
    options.name || (options.name = "");
    defaultCssClass = "kdtabpaneview kdhiddentab " + (KD.utils.slugify(options.name.toLowerCase())) + " clearfix";
    options.cssClass = KD.utils.curry(defaultCssClass, options.cssClass);
    KDTabPaneView.__super__.constructor.call(this, options, data);
    this.name = options.name;
    this.lastScrollTops = {
      window: 0,
      parent: 0,
      self: 0,
      body: 0
    };
    this.on("KDTabPaneActive", this.bound("setMainView"));
    this.on("KDTabPaneLazyViewAdded", this.bound("fireLazyCallback"));
  }

  KDTabPaneView.prototype.show = function() {
    var _ref;
    this.setClass("active");
    this.unsetClass("kdhiddentab");
    if (this.getOption("detachable")) {
      if ((_ref = this.parent) != null) {
        _ref.getElement().appendChild(this.getElement());
      }
    }
    this.active = true;
    this.emit("KDTabPaneActive");
    return KD.utils.defer((function(_this) {
      return function() {
        var _ref1;
        _this.getElement().scrollTop = _this.lastScrollTops.self;
        return (_ref1 = _this.parent) != null ? _ref1.getElement().scrollTop = _this.lastScrollTops.parent : void 0;
      };
    })(this));
  };

  KDTabPaneView.prototype.hide = function() {
    var _ref, _ref1;
    if (!this.active) {
      return;
    }
    this.lastScrollTops.parent = ((_ref = this.parent) != null ? _ref.getElement().scrollTop : void 0) || 0;
    this.lastScrollTops.self = this.getElement().scrollTop;
    this.setClass("kdhiddentab");
    this.unsetClass("active");
    if (this.active && this.getOption("detachable")) {
      if ((_ref1 = this.parent) != null) {
        _ref1.getElement().removeChild(this.getElement());
      }
    }
    this.active = false;
    return this.emit("KDTabPaneInactive");
  };

  KDTabPaneView.prototype.setTitle = function(title) {
    this.getDelegate().setPaneTitle(this, title);
    return this.name = title;
  };

  KDTabPaneView.prototype.getHandle = function() {
    return this.getDelegate().getHandleByPane(this);
  };

  KDTabPaneView.prototype.hideTabCloseIcon = function() {
    return this.getDelegate().hideCloseIcon(this);
  };

  KDTabPaneView.prototype.setMainView = function(view) {
    var data, options, viewClass, viewOptions, _ref;
    if (!view) {
      _ref = this.getOptions(), view = _ref.view, viewOptions = _ref.viewOptions;
    }
    if (this.mainView) {
      return;
    }
    if (!(view || viewOptions)) {
      return;
    }
    if (view instanceof KDView) {
      this.mainView = this.addSubView(view);
    } else if (viewOptions) {
      viewClass = viewOptions.viewClass, options = viewOptions.options, data = viewOptions.data;
      this.mainView = this.addSubView(new viewClass(options, data));
    } else {
      return warn("probably you set a weird lazy view!");
    }
    this.emit("KDTabPaneLazyViewAdded", this, this.mainView);
    return this.mainView;
  };

  KDTabPaneView.prototype.getMainView = function() {
    return this.mainView;
  };

  KDTabPaneView.prototype.destroyMainView = function() {
    this.mainView.destroy();
    return delete this.mainView;
  };

  KDTabPaneView.prototype.fireLazyCallback = function(pane, view) {
    var callback, viewOptions;
    viewOptions = this.getOptions().viewOptions;
    if (!viewOptions) {
      return;
    }
    callback = viewOptions.callback;
    if (!callback) {
      return;
    }
    return callback.call(this, pane, view);
  };

  return KDTabPaneView;

})(KDView);


},{"./../../core/view.coffee":106}],82:[function(require,module,exports){
var KDScrollView, KDTabHandleContainer, KDTabHandleMoveNav, KDTabHandleView, KDTabPaneView, KDTabView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDScrollView = require('./../scrollview/scrollview.coffee');

KDTabHandleContainer = require('./tabhandlecontainer.coffee');

KDTabHandleMoveNav = require('./tabhandlemovenav.coffee');

KDTabHandleView = require('./tabhandleview.coffee');

KDTabPaneView = require('./tabpaneview.coffee');

module.exports = KDTabView = (function(_super) {
  __extends(KDTabView, _super);

  function KDTabView(options, data) {
    var _ref;
    if (options == null) {
      options = {};
    }
    if (options.resizeTabHandles == null) {
      options.resizeTabHandles = false;
    }
    if (options.maxHandleWidth == null) {
      options.maxHandleWidth = 128;
    }
    if (options.minHandleWidth == null) {
      options.minHandleWidth = 30;
    }
    if (options.lastTabHandleMargin == null) {
      options.lastTabHandleMargin = 0;
    }
    if (options.sortable == null) {
      options.sortable = false;
    }
    if (options.hideHandleContainer == null) {
      options.hideHandleContainer = false;
    }
    if (options.hideHandleCloseIcons == null) {
      options.hideHandleCloseIcons = false;
    }
    if (options.enableMoveTabHandle == null) {
      options.enableMoveTabHandle = false;
    }
    if (options.detachPanes == null) {
      options.detachPanes = true;
    }
    if (options.tabHandleContainer == null) {
      options.tabHandleContainer = null;
    }
    options.tabHandleClass || (options.tabHandleClass = KDTabHandleView);
    options.paneData || (options.paneData = []);
    options.cssClass = KD.utils.curry("kdtabview", options.cssClass);
    this.handles = [];
    this.panes = [];
    this.selectedIndex = [];
    this.tabConstructor = (_ref = options.tabClass) != null ? _ref : KDTabPaneView;
    this.lastOpenPaneIndex = 0;
    KDTabView.__super__.constructor.call(this, options, data);
    this.activePane = null;
    this.handlesHidden = false;
    this.blockTabHandleResize = false;
    this.setTabHandleContainer(options.tabHandleContainer);
    if (options.enableMoveTabHandle) {
      this.setTabHandleMoveNav();
    }
    if (options.hideHandleCloseIcons) {
      this.hideHandleCloseIcons();
    }
    if (options.hideHandleContainer) {
      this.hideHandleContainer();
    }
    this.on("PaneRemoved", (function(_this) {
      return function() {
        return _this.resizeTabHandles();
      };
    })(this));
    this.on("PaneAdded", (function(_this) {
      return function() {
        _this.blockTabHandleResize = false;
        return _this.resizeTabHandles();
      };
    })(this));
    this.on("PaneDidShow", this.bound("setActivePane"));
    if (options.paneData.length > 0) {
      this.on("viewAppended", (function(_this) {
        return function() {
          return _this.createPanes(options.paneData);
        };
      })(this));
    }
    this.tabHandleContainer.on("mouseleave", (function(_this) {
      return function() {
        if (_this.blockTabHandleResize) {
          _this.blockTabHandleResize = false;
          return _this.resizeTabHandles();
        }
      };
    })(this));
  }

  KDTabView.prototype.createPanes = function(paneData) {
    var paneOptions, _i, _len, _results;
    if (paneData == null) {
      paneData = this.getOptions().paneData;
    }
    _results = [];
    for (_i = 0, _len = paneData.length; _i < _len; _i++) {
      paneOptions = paneData[_i];
      _results.push(this.addPane(new this.tabConstructor(paneOptions, null)));
    }
    return _results;
  };

  KDTabView.prototype.addPane = function(paneInstance, shouldShow) {
    var closable, detachPanes, hiddenHandle, lazy, maxHandleWidth, minHandleWidth, name, newTabHandle, sortable, tabHandleClass, tabHandleView, title, _ref, _ref1, _ref2;
    if (shouldShow == null) {
      shouldShow = true;
    }
    if (paneInstance instanceof KDTabPaneView) {
      _ref = this.getOptions(), tabHandleClass = _ref.tabHandleClass, sortable = _ref.sortable, detachPanes = _ref.detachPanes;
      paneInstance.setOption("detachable", detachPanes);
      this.panes.push(paneInstance);
      _ref1 = paneInstance.getOptions(), name = _ref1.name, title = _ref1.title, hiddenHandle = _ref1.hiddenHandle, tabHandleView = _ref1.tabHandleView, closable = _ref1.closable, lazy = _ref1.lazy;
      this.addHandle(newTabHandle = new tabHandleClass({
        pane: paneInstance,
        title: name || title,
        hidden: hiddenHandle,
        cssClass: KD.utils.slugify(name.toLowerCase()),
        view: tabHandleView,
        closable: closable,
        sortable: sortable,
        click: (function(_this) {
          return function(event) {
            return _this.handleMouseDownDefaultAction(newTabHandle, event);
          };
        })(this)
      }));
      paneInstance.tabHandle = newTabHandle;
      this.appendPane(paneInstance);
      if (shouldShow && !lazy) {
        this.showPane(paneInstance);
      }
      this.emit("PaneAdded", paneInstance);
      _ref2 = this.getOptions(), minHandleWidth = _ref2.minHandleWidth, maxHandleWidth = _ref2.maxHandleWidth;
      newTabHandle.getDomElement().css({
        maxWidth: maxHandleWidth,
        minWidth: minHandleWidth
      });
      newTabHandle.on("HandleIndexHasChanged", this.bound("resortTabHandles"));
      return paneInstance;
    } else {
      name = ((paneInstance != null ? paneInstance.constructor : void 0) != null).name;
      warn("You can't add " + (name ? name : void 0) + " as a pane, use KDTabPaneView instead");
      return false;
    }
  };

  KDTabView.prototype.resortTabHandles = function(index, dir) {
    var methodName, newIndex, splicedHandle, splicedPane, targetIndex;
    if ((index === 0 && dir === 'left') || (index === this.handles.length - 1 && dir === 'right') || (index >= this.handles.length) || (index < 0)) {
      return;
    }
    this.handles[0].unsetClass('first');
    if (dir === 'right') {
      methodName = 'insertAfter';
      targetIndex = index + 1;
    } else {
      methodName = 'insertBefore';
      targetIndex = index - 1;
    }
    this.handles[index].$()[methodName](this.handles[targetIndex].$());
    newIndex = dir === 'left' ? index - 1 : index + 1;
    splicedHandle = this.handles.splice(index, 1);
    splicedPane = this.panes.splice(index, 1);
    this.handles.splice(newIndex, 0, splicedHandle[0]);
    this.panes.splice(newIndex, 0, splicedPane[0]);
    this.handles[0].setClass('first');
    return this.emit('TabsSorted');
  };

  KDTabView.prototype.removePane = function(pane) {
    var firstPane, handle, index, isActivePane, prevPane;
    pane.emit("KDTabPaneDestroy");
    index = this.getPaneIndex(pane);
    isActivePane = this.getActivePane() === pane;
    this.panes.splice(index, 1);
    pane.destroy();
    handle = this.getHandleByIndex(index);
    this.handles.splice(index, 1);
    handle.destroy();
    if (isActivePane) {
      if (prevPane = this.getPaneByIndex(this.lastOpenPaneIndex)) {
        this.showPane(prevPane);
      } else if (firstPane = this.getPaneByIndex(0)) {
        this.showPane(firstPane);
      }
    }
    return this.emit("PaneRemoved");
  };

  KDTabView.prototype.removePaneByName = function(name) {
    var pane, _i, _len, _ref, _results;
    _ref = this.panes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pane = _ref[_i];
      if (pane.name === name) {
        this.removePane(pane);
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  KDTabView.prototype.appendHandleContainer = function() {
    return this.addSubView(this.tabHandleContainer);
  };

  KDTabView.prototype.appendPane = function(pane) {
    pane.setDelegate(this);
    return this.addSubView(pane);
  };

  KDTabView.prototype.appendHandle = function(tabHandle) {
    var enableMoveTabHandle, maxHandleWidth, _ref;
    this.handleHeight || (this.handleHeight = this.tabHandleContainer.getHeight());
    tabHandle.setDelegate(this);
    this.tabHandleContainer.tabs.addSubView(tabHandle);
    _ref = this.getOptions(), enableMoveTabHandle = _ref.enableMoveTabHandle, maxHandleWidth = _ref.maxHandleWidth;
    if (enableMoveTabHandle) {
      return this._tabsWidth = this.handles.length * maxHandleWidth;
    }
  };

  KDTabView.prototype.addHandle = function(handle) {
    var name;
    if (handle instanceof KDTabHandleView) {
      this.handles.push(handle);
      this.appendHandle(handle);
      if (handle.getOptions().hidden) {
        handle.setClass("hidden");
      }
      return handle;
    } else {
      name = ((handle != null ? handle.constructor : void 0) != null).name;
      return warn("You can't add " + (name != null ? name : void 0) + " as a pane, use KDTabHandleView instead");
    }
  };

  KDTabView.prototype.removeHandle = function() {};

  KDTabView.prototype.showPane = function(pane) {
    var activePane, handle, index;
    if (!pane) {
      return;
    }
    activePane = this.getActivePane();
    if (pane === activePane) {
      return;
    }
    if (activePane) {
      this.lastOpenPaneIndex = this.getPaneIndex(activePane);
    }
    this.hideAllPanes();
    pane.show();
    index = this.getPaneIndex(pane);
    handle = this.getHandleByIndex(index);
    handle.makeActive();
    pane.emit("PaneDidShow");
    this.emit("PaneDidShow", pane, index);
    return pane;
  };

  KDTabView.prototype.hideAllPanes = function() {
    var handle, pane, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.panes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pane = _ref[_i];
      if (pane) {
        pane.hide();
      }
    }
    _ref1 = this.handles;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      handle = _ref1[_j];
      if (handle) {
        _results.push(handle.makeInactive());
      }
    }
    return _results;
  };

  KDTabView.prototype.hideHandleContainer = function() {
    this.tabHandleContainer.hide();
    return this.handlesHidden = true;
  };

  KDTabView.prototype.showHandleContainer = function() {
    this.tabHandleContainer.show();
    return this.handlesHidden = false;
  };

  KDTabView.prototype.toggleHandleContainer = function(duration) {
    if (duration == null) {
      duration = 0;
    }
    return this.tabHandleContainer.$().toggle(duration);
  };

  KDTabView.prototype.hideHandleCloseIcons = function() {
    return this.tabHandleContainer.$().addClass("hide-close-icons");
  };

  KDTabView.prototype.showHandleCloseIcons = function() {
    return this.tabHandleContainer.$().removeClass("hide-close-icons");
  };

  KDTabView.prototype.handleMouseDownDefaultAction = function(clickedTabHandle, event) {
    var handle, index, _i, _len, _ref, _results;
    _ref = this.handles;
    _results = [];
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      handle = _ref[index];
      if (clickedTabHandle === handle) {
        _results.push(this.handleClicked(index, event));
      }
    }
    return _results;
  };

  KDTabView.prototype.handleClicked = function(index, event) {
    var pane;
    pane = this.getPaneByIndex(index);
    if ($(event.target).hasClass("close-tab")) {
      this.blockTabHandleResize = true;
      this.removePane(pane);
      return false;
    }
    return this.showPane(pane);
  };

  KDTabView.prototype.setTabHandleContainer = function(aViewInstance) {
    if (aViewInstance != null) {
      if (this.tabHandleContainer != null) {
        this.tabHandleContainer.destroy();
      }
      this.tabHandleContainer = aViewInstance;
    } else {
      this.tabHandleContainer = new KDTabHandleContainer;
      this.appendHandleContainer();
    }
    return this.tabHandleContainer.setClass("kdtabhandlecontainer");
  };

  KDTabView.prototype.getTabHandleContainer = function() {
    return this.tabHandleContainer;
  };

  KDTabView.prototype.setTabHandleMoveNav = function() {
    return this.tabHandleContainer.addSubView(new KDTabHandleMoveNav({
      delegate: this
    }));
  };

  KDTabView.prototype.checkPaneExistenceById = function(id) {
    var pane, result, _i, _len, _ref;
    result = false;
    _ref = this.panes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pane = _ref[_i];
      if (pane.id === id) {
        result = true;
      }
    }
    return result;
  };

  KDTabView.prototype.getPaneByName = function(name) {
    var pane, result, _i, _len, _ref;
    result = false;
    _ref = this.panes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pane = _ref[_i];
      if (pane.name === name) {
        result = pane;
      }
    }
    return result;
  };

  KDTabView.prototype.getPaneById = function(id) {
    var pane, paneInstance, _i, _len, _ref;
    paneInstance = null;
    _ref = this.panes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pane = _ref[_i];
      if (pane.id === id) {
        paneInstance = pane;
      }
    }
    return paneInstance;
  };

  KDTabView.prototype.getActivePane = function() {
    return this.activePane;
  };

  KDTabView.prototype.getActivePaneIndex = function() {
    return this.getPaneIndex(this.getActivePane());
  };

  KDTabView.prototype.setActivePane = function(activePane) {
    this.activePane = activePane;
  };

  KDTabView.prototype.getPaneByIndex = function(index) {
    return this.panes[index];
  };

  KDTabView.prototype.getHandleByIndex = function(index) {
    return this.handles[index];
  };

  KDTabView.prototype.getPaneIndex = function(aPane) {
    if (!aPane) {
      throw new Error("no pane provided!");
    }
    return this.panes.indexOf(aPane);
  };

  KDTabView.prototype.showPaneByIndex = function(index) {
    return this.showPane(this.getPaneByIndex(index));
  };

  KDTabView.prototype.showPaneByName = function(name) {
    return this.showPane(this.getPaneByName(name));
  };

  KDTabView.prototype.showNextPane = function() {
    var activeIndex, activePane;
    activePane = this.getActivePane();
    activeIndex = this.getPaneIndex(activePane);
    return this.showPane(this.getPaneByIndex(activeIndex + 1));
  };

  KDTabView.prototype.showPreviousPane = function() {
    var activeIndex, activePane;
    activePane = this.getActivePane();
    activeIndex = this.getPaneIndex(activePane);
    return this.showPane(this.getPaneByIndex(activeIndex - 1));
  };

  KDTabView.prototype.setPaneTitle = function(pane, title) {
    var handle;
    handle = this.getHandleByPane(pane);
    handle.getDomElement().find("b").text(title);
    return handle.setAttribute("title", title);
  };

  KDTabView.prototype.getHandleByPane = function(pane) {
    var handle, index;
    index = this.getPaneIndex(pane);
    return handle = this.getHandleByIndex(index);
  };

  KDTabView.prototype.hideCloseIcon = function(pane) {
    var handle, index;
    index = this.getPaneIndex(pane);
    handle = this.getHandleByIndex(index);
    return handle.getDomElement().addClass("hide-close-icon");
  };

  KDTabView.prototype.getVisibleHandles = function() {
    return this.handles.filter(function(handle) {
      return handle.isHidden() === false;
    });
  };

  KDTabView.prototype.getVisibleTabs = function() {
    return this.panes.filter(function(pane) {
      return pane.tabHandle.isHidden() === false;
    });
  };

  KDTabView.prototype.resizeTabHandles = function() {
    var containerMargin, containerSize, handle, lastTabHandleMargin, outerWidth, possiblePercent, visibleHandles, visibleTotalSize, _i, _j, _len, _len1, _ref, _results;
    if (!this.getOptions().resizeTabHandles || this._tabHandleContainerHidden || this.blockTabHandleResize) {
      return;
    }
    lastTabHandleMargin = this.getOptions().lastTabHandleMargin;
    visibleHandles = [];
    visibleTotalSize = 0;
    outerWidth = this.tabHandleContainer.tabs.getElement().offsetWidth;
    if (outerWidth <= 0) {
      return;
    }
    containerSize = outerWidth - lastTabHandleMargin;
    containerMargin = 100 - (100 * lastTabHandleMargin / containerSize);
    _ref = this.handles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      handle = _ref[_i];
      if (!(!handle.isHidden())) {
        continue;
      }
      visibleHandles.push(handle);
      visibleTotalSize += handle.getElement().offsetWidth;
    }
    possiblePercent = (containerMargin / visibleHandles.length).toFixed(2);
    _results = [];
    for (_j = 0, _len1 = visibleHandles.length; _j < _len1; _j++) {
      handle = visibleHandles[_j];
      _results.push(handle.setWidth(possiblePercent, "%"));
    }
    return _results;
  };

  return KDTabView;

})(KDScrollView);


},{"./../scrollview/scrollview.coffee":69,"./tabhandlecontainer.coffee":78,"./tabhandlemovenav.coffee":79,"./tabhandleview.coffee":80,"./tabpaneview.coffee":81}],83:[function(require,module,exports){
var KDFormViewWithFields, KDTabPaneView, KDTabView, KDTabViewWithForms,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDTabView = require('./tabview.coffee');

KDTabPaneView = require('./tabpaneview.coffee');

KDFormViewWithFields = require('./../forms/formviewwithfields.coffee');

module.exports = KDTabViewWithForms = (function(_super) {
  __extends(KDTabViewWithForms, _super);

  function KDTabViewWithForms(options, data) {
    var forms;
    if (options == null) {
      options = {};
    }
    if (options.navigable == null) {
      options.navigable = true;
    }
    if (options.goToNextFormOnSubmit == null) {
      options.goToNextFormOnSubmit = true;
    }
    KDTabViewWithForms.__super__.constructor.call(this, options, data);
    this.forms = {};
    this.hideHandleCloseIcons();
    forms = this.getOptions().forms;
    if (forms) {
      this.createTabs(forms = KDFormViewWithFields.sanitizeFormOptions(forms));
      this.showPane(this.panes[0]);
    }
    if (forms.length === 1) {
      this.hideHandleContainer();
    }
  }

  KDTabViewWithForms.prototype.handleClicked = function(index, event) {
    if (this.getOptions().navigable) {
      return KDTabViewWithForms.__super__.handleClicked.apply(this, arguments);
    }
  };

  KDTabViewWithForms.prototype.createTab = function(formData, index) {
    var oldCallback, tab;
    this.addPane((tab = new KDTabPaneView({
      name: formData.title
    })), formData.shouldShow);
    oldCallback = formData.callback;
    formData.callback = (function(_this) {
      return function(formData) {
        var forms;
        if (_this.getOptions().goToNextFormOnSubmit) {
          _this.showNextPane();
        }
        if (typeof oldCallback === "function") {
          oldCallback(formData);
        }
        forms = _this.getOptions().forms;
        if (forms && index === Object.keys(forms).length - 1) {
          return _this.fireFinalCallback();
        }
      };
    })(this);
    this.createForm(formData, tab);
    return tab;
  };

  KDTabViewWithForms.prototype.createTabs = function(forms) {
    return forms.forEach((function(_this) {
      return function(formData, i) {
        return _this.createTab(formData, i);
      };
    })(this));
  };

  KDTabViewWithForms.prototype.createForm = function(formData, parentTab) {
    var form;
    parentTab.addSubView(form = new KDFormViewWithFields(formData));
    this.forms[formData.title] = parentTab.form = form;
    return form;
  };

  KDTabViewWithForms.prototype.getFinalData = function() {
    var finalData, pane, _i, _len, _ref;
    finalData = {};
    _ref = this.panes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pane = _ref[_i];
      finalData = $.extend(pane.form.getData(), finalData);
    }
    return finalData;
  };

  KDTabViewWithForms.prototype.fireFinalCallback = function() {
    var finalData, _base;
    finalData = this.getFinalData();
    return typeof (_base = this.getOptions()).callback === "function" ? _base.callback(finalData) : void 0;
  };

  return KDTabViewWithForms;

})(KDTabView);


},{"./../forms/formviewwithfields.coffee":35,"./tabpaneview.coffee":81,"./tabview.coffee":82}],84:[function(require,module,exports){
var KDTimeAgoView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDTimeAgoView = (function(_super) {
  __extends(KDTimeAgoView, _super);

  KDTimeAgoView.registerStaticEmitter();

  KD.utils.repeat(60000, function() {
    return KDTimeAgoView.emit("OneMinutePassed");
  });

  function KDTimeAgoView(options, data) {
    if (options == null) {
      options = {};
    }
    options.tagName = "time";
    KDTimeAgoView.__super__.constructor.call(this, options, data);
    KDTimeAgoView.on("OneMinutePassed", (function(_this) {
      return function() {
        return _this.updatePartial($.timeago(_this.getData()));
      };
    })(this));
  }

  KDTimeAgoView.prototype.setData = function() {
    KDTimeAgoView.__super__.setData.apply(this, arguments);
    if (this.parent) {
      return this.updatePartial($.timeago(this.getData()));
    }
  };

  KDTimeAgoView.prototype.viewAppended = function() {
    return this.setPartial($.timeago(this.getData()));
  };

  return KDTimeAgoView;

})(KDView);


},{"./../../core/view.coffee":106}],85:[function(require,module,exports){

/*

  KDTooltip

  A tooltip has a position and a direction, relative to the delegate
  element it is attached to.

  Valid positioning types are 'top','bottom','left' and 'right'
  Valid direction types are 'top','bottom','left','right' and 'center'

  Should a tooltip move off-screen, it will be relocated to be fully
  visible.
 */
var KDTooltip, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

module.exports = KDTooltip = (function(_super) {
  var directionMap, getBoundaryViolations, getCoordsDiff, getCoordsFromPlacement, placementMap;

  __extends(KDTooltip, _super);

  function KDTooltip(options, data) {
    options.bind || (options.bind = "mouseenter mouseleave");
    if (options.sticky == null) {
      options.sticky = false;
    }
    options.cssClass = KD.utils.curry("kdtooltip", options.cssClass);
    KDTooltip.__super__.constructor.call(this, options, data);
    this.visible = false;
    this.parentView = this.getDelegate();
    this.wrapper = new KDView({
      cssClass: 'wrapper'
    });
    if (this.getOptions().animate) {
      this.setClass('out');
    } else {
      this.hide();
    }
    this.addListeners();
    KD.singletons.windowController.on("ScrollHappened", this.bound("hide"));
    this.once("viewAppended", (function(_this) {
      return function() {
        var o;
        o = _this.getOptions();
        if (o.view != null) {
          _this.setView(o.view);
        } else {
          _this.setClass('just-text');
          _this.setTitle(o.title, o);
        }
        _this.parentView.emit('TooltipReady');
        _this.addSubView(_this.wrapper);
        return _this.visible = true;
      };
    })(this));
  }

  KDTooltip.prototype.show = function(event) {
    var selector;
    selector = this.getOptions().selector;
    if (selector) {
      return;
    }
    this.display();
    KDTooltip.__super__.show.apply(this, arguments);
    return this.visible = true;
  };

  KDTooltip.prototype.hide = function(event) {
    if (!this.visible) {
      return;
    }
    KDTooltip.__super__.hide.apply(this, arguments);
    this.getDomElement().remove();
    KD.singletons.windowController.removeLayer(this);
    return this.visible = false;
  };

  KDTooltip.prototype.update = function(o, view) {
    if (o == null) {
      o = this.getOptions();
    }
    if (view == null) {
      view = null;
    }
    if (!view) {
      o.selector || (o.selector = null);
      o.title || (o.title = "");
      this.getOptions().title = o.title;
      this.setTitle(o.title);
      this.display(this.getOptions());
    } else {
      this.setView(view);
    }
    return this.visible = true;
  };

  KDTooltip.prototype.addListeners = function() {
    var events, name, _hide, _i, _len, _show;
    events = this.getOptions().events;
    _show = this.bound("show");
    _hide = this.bound("hide");
    for (_i = 0, _len = events.length; _i < _len; _i++) {
      name = events[_i];
      this.parentView.bindEvent(name);
    }
    this.parentView.on('mouseenter', _show);
    this.parentView.on('mouseleave', _hide);
    this.on('ReceivedClickElsewhere', _hide);
    return this.once('KDObjectWillBeDestroyed', (function(_this) {
      return function() {
        _this.parentView.off('mouseenter', _show);
        return _this.parentView.off('mouseleave', _hide);
      };
    })(this));
  };

  KDTooltip.prototype.setView = function(childView) {
    var constructorName, data, options;
    if (!childView) {
      return;
    }
    if (this.wrapper.view != null) {
      this.wrapper.view.destroy();
    }
    if (childView.constructorName) {
      options = childView.options, data = childView.data, constructorName = childView.constructorName;
      return this.childView = new constructorName(options, data);
    } else {
      return this.wrapper.addSubView(childView);
    }
  };

  KDTooltip.prototype.getView = function() {
    return this.childView;
  };

  KDTooltip.prototype.destroy = function() {
    this.parentView.tooltip = null;
    delete this.parentView.tooltip;
    return KDTooltip.__super__.destroy.apply(this, arguments);
  };

  KDTooltip.prototype.translateCompassDirections = function(o) {
    var gravity, placement;
    placement = o.placement, gravity = o.gravity;
    o.placement = placementMap[placement];
    o.direction = directionMap(o.placement, gravity);
    return o;
  };

  KDTooltip.prototype.display = function(o) {
    if (o == null) {
      o = this.getOptions();
    }
    this.appendToDomBody();
    KD.singletons.windowController.addLayer(this);
    if (o.gravity) {
      o = this.translateCompassDirections(o);
    }
    o.gravity = null;
    if (o.animate) {
      this.setClass('in');
    }
    this.utils.defer((function(_this) {
      return function() {
        return _this.setPositions(o);
      };
    })(this));
    return this.visible = true;
  };

  KDTooltip.prototype.getCorrectPositionCoordinates = function(o, positionValues, callback) {
    var container, correctValues, d, direction, forcePosition, placement, selector, variant, variants, violations, _i, _len;
    if (o == null) {
      o = {};
    }
    if (callback == null) {
      callback = noop;
    }
    container = this.$();
    selector = this.parentView.$(o.selector);
    d = {
      container: {
        height: container.height(),
        width: container.width()
      },
      selector: {
        offset: selector.offset(),
        height: selector.height(),
        width: selector.width()
      }
    };
    placement = positionValues.placement, direction = positionValues.direction;
    forcePosition = this.getOptions().forcePosition;
    violations = getBoundaryViolations(getCoordsFromPlacement(d, placement, direction), d.container.width, d.container.height);
    if (!forcePosition && Object.keys(violations).length > 0) {
      variants = [['top', 'right'], ['right', 'top'], ['right', 'bottom'], ['bottom', 'right'], ['top', 'left'], ['top', 'center'], ['right', 'center'], ['bottom', 'center'], ['bottom', 'left'], ['left', 'bottom'], ['left', 'center'], ['left', 'top']];
      for (_i = 0, _len = variants.length; _i < _len; _i++) {
        variant = variants[_i];
        if (Object.keys(getBoundaryViolations(getCoordsFromPlacement(d, variant[0], variant[1]), d.container.width, d.container.height)).length === 0) {
          placement = variant[0], direction = variant[1];
          break;
        }
      }
    }
    correctValues = {
      coords: getCoordsFromPlacement(d, placement, direction),
      placement: placement,
      direction: direction
    };
    callback(correctValues);
    return correctValues;
  };

  KDTooltip.prototype.setPositions = function(o, animate) {
    var coords, direction, direction_, offset, placement, placement_, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    if (o == null) {
      o = this.getOptions();
    }
    if (animate == null) {
      animate = false;
    }
    if (animate) {
      this.setClass('animate-movement');
    }
    placement = o.placement || 'top';
    direction = o.direction || 'right';
    offset = Number === typeof o.offset ? {
      top: o.offset,
      left: 0
    } : o.offset;
    direction = (placement === 'top' || placement === 'bottom') && (direction === 'top' || direction === 'bottom') ? 'center' : (placement === 'left' || placement === 'right') && (direction === 'left' || direction === 'right') ? 'center' : direction;
    _ref = this.getCorrectPositionCoordinates(o, {
      placement: placement,
      direction: direction
    }), coords = _ref.coords, placement = _ref.placement, direction = _ref.direction;
    _ref1 = ['top', 'bottom', 'left', 'right'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      placement_ = _ref1[_i];
      if (placement === placement_) {
        this.setClass('placement-' + placement_);
      } else {
        this.unsetClass('placement-' + placement_);
      }
    }
    _ref2 = ['top', 'bottom', 'left', 'right', 'center'];
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      direction_ = _ref2[_j];
      if (direction === direction_) {
        this.setClass('direction-' + direction_);
      } else {
        this.unsetClass('direction-' + direction_);
      }
    }
    this.$().css({
      left: coords.left + offset.left,
      top: coords.top + offset.top
    });
    return this.utils.wait(500, (function(_this) {
      return function() {
        return _this.unsetClass('animate-movement');
      };
    })(this));
  };

  KDTooltip.prototype.setTitle = function(title, o) {
    if (o == null) {
      o = {};
    }
    if (o.html !== false) {
      return this.wrapper.updatePartial(title);
    } else {
      return this.wrapper.updatePartial(Encoder.htmlEncode(title));
    }
  };

  directionMap = function(placement, gravity) {
    if (placement === "top" || placement === "bottom") {
      if (/e/.test(gravity)) {
        return "left";
      } else if (/w/.test(gravity)) {
        return "right";
      } else {
        return "center";
      }
    } else if (placement === "left" || placement === "right") {
      if (/n/.test(gravity)) {
        return "top";
      } else if (/s/.test(gravity)) {
        return "bottom";
      } else {
        return placement;
      }
    }
  };

  placementMap = {
    top: "top",
    above: "top",
    below: "bottom",
    bottom: "bottom",
    left: "left",
    right: "right"
  };

  getBoundaryViolations = function(coordinates, width, height) {
    var violations;
    violations = {};
    if (coordinates.left < 0) {
      violations.left = -coordinates.left;
    }
    if (coordinates.top < 0) {
      violations.top = -coordinates.top;
    }
    if (coordinates.left + width > window.innerWidth) {
      violations.right = coordinates.left + width - window.innerWidth;
    }
    if (coordinates.top + height > window.innerHeight) {
      violations.bottom = coordinates.top + height - window.innerHeight;
    }
    return violations;
  };

  getCoordsDiff = function(dimensions, type, center) {
    var diff;
    if (center == null) {
      center = false;
    }
    diff = dimensions.selector[type] - dimensions.container[type];
    if (center) {
      return diff / 2;
    } else {
      return diff;
    }
  };

  getCoordsFromPlacement = function(dimensions, placement, direction) {
    var coordinates, dynamicAxis, dynamicC, exclusion, staticAxis, staticC, _ref;
    coordinates = {
      top: dimensions.selector.offset.top,
      left: dimensions.selector.offset.left
    };
    _ref = /o/.test(placement) ? ['height', 'width', 'top', 'left', 'right'] : ['width', 'height', 'left', 'top', 'bottom'], staticAxis = _ref[0], dynamicAxis = _ref[1], staticC = _ref[2], dynamicC = _ref[3], exclusion = _ref[4];
    coordinates[staticC] += !(placement.length < 5) ? dimensions.selector[staticAxis] + 10 : -(dimensions.container[staticAxis] + 10);
    if (direction !== exclusion) {
      coordinates[dynamicC] += getCoordsDiff(dimensions, dynamicAxis, direction === 'center');
    }
    return coordinates;
  };

  return KDTooltip;

})(KDView);


},{"./../../core/view.coffee":106}],86:[function(require,module,exports){
var JTreeItemView, KDListItemView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListItemView = require('./../list/listitemview.coffee');

module.exports = JTreeItemView = (function(_super) {
  __extends(JTreeItemView, _super);

  function JTreeItemView(options, data) {
    var childClass, childOptions, _ref;
    if (options == null) {
      options = {};
    }
    if (data == null) {
      data = {};
    }
    options.tagName || (options.tagName = "li");
    options.type || (options.type = "jtreeitem");
    options.bind || (options.bind = "mouseenter contextmenu dragstart dragenter dragleave dragend dragover drop");
    options.childClass || (options.childClass = null);
    options.childOptions || (options.childOptions = {});
    JTreeItemView.__super__.constructor.call(this, options, data);
    this.setClass("jtreeitem");
    this.expanded = false;
    _ref = this.getOptions(), childClass = _ref.childClass, childOptions = _ref.childOptions;
    if (childClass) {
      this.child = new childClass(childOptions, this.getData());
    }
  }

  JTreeItemView.prototype.viewAppended = function() {
    if (this.getOptions().childClass) {
      return this.addSubView(this.child);
    } else {
      return this.updatePartial("<span class='arrow'></span>\n" + (this.getData().title));
    }
  };

  JTreeItemView.prototype.toggle = function(callback) {
    if (this.expanded) {
      return this.collapse();
    } else {
      return this.expand();
    }
  };

  JTreeItemView.prototype.expand = function(callback) {
    this.expanded = true;
    return this.setClass("expanded");
  };

  JTreeItemView.prototype.collapse = function(callback) {
    this.expanded = false;
    return this.unsetClass("expanded");
  };

  JTreeItemView.prototype.decorateSubItemsState = function(state) {
    if (state == null) {
      state = true;
    }
    if (state) {
      return this.setClass("has-sub-items");
    } else {
      return this.unsetClass("has-sub-items");
    }
  };

  return JTreeItemView;

})(KDListItemView);


},{"./../list/listitemview.coffee":53}],87:[function(require,module,exports){
var JTreeView, KDListView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListView = require('./../list/listview.coffee');

module.exports = JTreeView = (function(_super) {
  __extends(JTreeView, _super);

  function JTreeView(options, data) {
    if (options == null) {
      options = {};
    }
    if (options.animated == null) {
      options.animated = false;
    }
    JTreeView.__super__.constructor.call(this, options, data);
    this.setClass("jtreeview expanded");
  }

  JTreeView.prototype.toggle = function(callback) {
    if (this.expanded) {
      return this.collapse(callback);
    } else {
      return this.expand(callback);
    }
  };

  JTreeView.prototype.expand = function(callback) {
    if (this.getOptions().animated) {
      return this.$().slideDown(150, (function(_this) {
        return function() {
          _this.setClass("expanded");
          return typeof callback === "function" ? callback() : void 0;
        };
      })(this));
    } else {
      this.show();
      this.setClass("expanded");
      return typeof callback === "function" ? callback() : void 0;
    }
  };

  JTreeView.prototype.collapse = function(callback) {
    if (this.getOptions().animated) {
      return this.$().slideUp(100, (function(_this) {
        return function() {
          _this.unsetClass("expanded");
          return typeof callback === "function" ? callback() : void 0;
        };
      })(this));
    } else {
      this.hide();
      this.unsetClass("expanded");
      return typeof callback === "function" ? callback() : void 0;
    }
  };

  JTreeView.prototype.mouseDown = function() {
    KD.getSingleton("windowController").setKeyView(this);
    return false;
  };

  JTreeView.prototype.keyDown = function(event) {
    return this.emit("KeyDownOnTreeView", event);
  };

  JTreeView.prototype.destroy = function() {
    KD.getSingleton("windowController").revertKeyView(this);
    return JTreeView.__super__.destroy.apply(this, arguments);
  };

  JTreeView.prototype.appendItemAtIndex = function(itemInstance, index, animation) {
    var added, _ref;
    itemInstance.setParent(this);
    added = true;
    if (index <= 0) {
      this.$().prepend(itemInstance.$());
    } else if (index > 0) {
      if ((_ref = this.items[index - 1]) != null ? _ref.$().hasClass('has-sub-items') : void 0) {
        this.items[index - 1].$().next().after(itemInstance.$());
      } else if (this.items[index - 1] != null) {
        this.items[index - 1].$().after(itemInstance.$());
      } else {
        warn("Out of bound");
        added = false;
      }
    }
    if (this.parentIsInDom && added) {
      itemInstance.emit('viewAppended');
    }
    return null;
  };

  return JTreeView;

})(KDListView);


},{"./../list/listview.coffee":54}],88:[function(require,module,exports){
var JTreeViewController, KDListViewController, KDScrollView, KDViewController,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDViewController = require('./../../core/viewcontroller.coffee');

KDScrollView = require('./../scrollview/scrollview.coffee');

KDListViewController = require('./../list/listviewcontroller.coffee');

module.exports = JTreeViewController = (function(_super) {
  var cacheDragHelper, dragHelper, keyMap;

  __extends(JTreeViewController, _super);

  keyMap = function() {
    return {
      37: "left",
      38: "up",
      39: "right",
      40: "down",
      8: "backspace",
      9: "tab",
      13: "enter",
      27: "escape"
    };
  };

  dragHelper = null;

  cacheDragHelper = (function() {
    dragHelper = document.createElement('img');
    dragHelper.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAAAYCAMAAAAs/jgVAAAA0lBMVEX///+It9YAAAD///8AAACIt9aIt9aIt9aIt9aIt9aIt9YAAAD///+It9aIt9aIt9aIt9aIt9aIt9aIt9bT09OIt9aIt9aIt9b///+It9bv9fr+/v79/f2QvNn4+PioyuHA2enP4u/09PS41Obf7PTn8ff6+vr29vb3+vygxd78/Pz19fX7+/vs7OzY2NjR0dGwz+Tv7+/T09Pz8/PX19fQ0NCYwdvx8fHLy8vq6urZ2dnX5/H5+fny8vLOzs739/fPz8/W1tbu7u7w8PDH3ezd3d0P0SzzAAAAGHRSTlMAACZqGJkG2/k2rkZV4bG0V9gDaYBabJYxtX/TAAACLElEQVR4Xu3V127bMBQG4NT1SOw4s0kP59Ce3iN7tu//Sj2i0iiKE8AB7Juiv0SIFAR9OAQJ7mwy/9NsvElz61yDA4cEgGWQZA0Evm0xyAFAYkVMr/nCtU8PjsnGcnxw2n7lGMsSnmSMAX9slNxRh2w4naMXjrGEByzgCWPsqtdE7qT7ARDrOuCqL4LdE8tlyCCHWMZmjw3kWuSDuJ5V4K9iKl7BWl7LcgHnXOLFecAHV8jtkU841wqrHGbhreHtWS6QN5nMbiR2BjPkfhaAoh7QEQVfKFqMkNMAoEAp3wNwC05FQGNbXQwAeuEX7z2DXVP0NIAv6uUhl8gslFKGmUzkbIBcx3L4/XUUC+q+crYg5NDSkTBaRIpo33J2qj1NYhCeL2IwRFMBC6Lqy8VWJ8MwxSuUQTgpuN2SI0Tbf6xyKETKaAVFKs4OlWc/Kt4ZX5NadgvuPrxPp+E0xWc4mX2Bi4FgKi6ytVQcESZafMAtnWWKDdnhBLlOnYshJteW+2Vqk0ko8qOSG1FCDJKjihMuIXS0Mpnj6e341sE2HTuWa9U5YgCM5eJyqUQeYCHIxRRAl5ygoIUP4FVcOdSUeAbv16WSPz/l+WWePz3nl/PhpxthjV22zkZo9i4e7i7u5tgeLn4P7TbfDme3+f4PJ0wdZ+o4aegs5wXX7m6D67aRe18ecpizPtlw+mf2RHhfnuWwwPPDDYr9w/PyAFo9z7d8vGJ5399kf+cfyh+807YxJJdmLQAAAABJRU5ErkJggg==";
    return dragHelper.width = 110;
  })();

  function JTreeViewController(options, data) {
    var o;
    if (options == null) {
      options = {};
    }
    o = options;
    o.view || (o.view = new KDScrollView({
      cssClass: "jtreeview-wrapper"
    }));
    o.listViewControllerClass || (o.listViewControllerClass = KDListViewController);
    o.treeItemClass || (o.treeItemClass = JTreeItemView);
    o.listViewClass || (o.listViewClass = JTreeView);
    o.itemChildClass || (o.itemChildClass = null);
    o.itemChildOptions || (o.itemChildOptions = {});
    o.nodeIdPath || (o.nodeIdPath = "id");
    o.nodeParentIdPath || (o.nodeParentIdPath = "parentId");
    if (o.contextMenu == null) {
      o.contextMenu = false;
    }
    if (o.multipleSelection == null) {
      o.multipleSelection = false;
    }
    if (o.addListsCollapsed == null) {
      o.addListsCollapsed = false;
    }
    if (o.sortable == null) {
      o.sortable = false;
    }
    if (o.putDepthInfo == null) {
      o.putDepthInfo = true;
    }
    if (o.addOrphansToRoot == null) {
      o.addOrphansToRoot = true;
    }
    if (o.dragdrop == null) {
      o.dragdrop = false;
    }
    JTreeViewController.__super__.constructor.call(this, o, data);
    this.listData = {};
    this.listControllers = {};
    this.nodes = {};
    this.indexedNodes = [];
    this.selectedNodes = [];
  }

  JTreeViewController.prototype.loadView = function(treeView) {
    this.initTree(this.getData());
    this.setKeyView();
    this.setMainListeners();
    return this.registerBoundaries();
  };

  JTreeViewController.prototype.registerBoundaries = function() {
    return this.boundaries = {
      top: this.getView().getY(),
      left: this.getView().getX(),
      width: this.getView().getWidth(),
      height: this.getView().getHeight()
    };
  };


  /*
  HELPERS
   */

  JTreeViewController.prototype.initTree = function(nodes) {
    this.removeAllNodes();
    return this.addNodes(nodes);
  };

  JTreeViewController.prototype.logTreeStructure = function() {
    var index, node, o, _ref, _results;
    o = this.getOptions();
    _ref = this.indexedNodes;
    _results = [];
    for (index in _ref) {
      if (!__hasProp.call(_ref, index)) continue;
      node = _ref[index];
      _results.push(log(index, this.getNodeId(node), this.getNodePId(node), node.depth));
    }
    return _results;
  };

  JTreeViewController.prototype.getNodeId = function(nodeData) {
    return nodeData[this.getOptions().nodeIdPath];
  };

  JTreeViewController.prototype.getNodePId = function(nodeData) {
    return nodeData[this.getOptions().nodeParentIdPath];
  };

  JTreeViewController.prototype.getPathIndex = function(targetPath) {
    var index, node, _i, _len, _ref;
    _ref = this.indexedNodes;
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      node = _ref[index];
      if (this.getNodeId(node) === targetPath) {
        return index;
      }
    }
    return -1;
  };

  JTreeViewController.prototype.repairIds = function(nodeData) {
    var idPath, options, pIdPath;
    options = this.getOptions();
    idPath = options.nodeIdPath;
    pIdPath = options.nodeParentIdPath;
    nodeData[idPath] || (nodeData[idPath] = this.utils.getUniqueId());
    nodeData[idPath] = "" + (this.getNodeId(nodeData));
    nodeData[pIdPath] = this.getNodePId(nodeData) ? "" + (this.getNodePId(nodeData)) : "0";
    this.nodes[this.getNodeId(nodeData)] = {};
    if (options.putDepthInfo) {
      if (this.nodes[nodeData[pIdPath]]) {
        nodeData.depth = this.nodes[nodeData[pIdPath]].getData().depth + 1;
      } else {
        nodeData.depth = 0;
      }
    }
    if (nodeData[pIdPath] !== "0" && !this.nodes[nodeData[pIdPath]]) {
      if (options.addOrphansToRoot) {
        nodeData[pIdPath] = "0";
      } else {
        nodeData = false;
      }
    }
    return nodeData;
  };

  JTreeViewController.prototype.isNodeVisible = function(nodeView) {
    var nodeData, parentNode;
    nodeData = nodeView.getData();
    parentNode = this.nodes[this.getNodePId(nodeData)];
    if (parentNode) {
      if (parentNode.expanded) {
        return this.isNodeVisible(parentNode);
      } else {
        return false;
      }
    } else {
      return true;
    }
  };

  JTreeViewController.prototype.areSibling = function(node1, node2) {
    var node1PId, node2PId;
    node1PId = this.getNodePId(node1.getData());
    node2PId = this.getNodePId(node2.getData());
    return node1PId === node2PId;
  };


  /*
  DECORATORS
   */

  JTreeViewController.prototype.setFocusState = function() {
    var view;
    view = this.getView();
    KD.getSingleton("windowController").addLayer(view);
    return view.unsetClass("dim");
  };

  JTreeViewController.prototype.setBlurState = function() {
    var view;
    view = this.getView();
    KD.getSingleton("windowController").removeLayer(view);
    return view.setClass("dim");
  };


  /*
  CRUD OPERATIONS FOR NODES
   */

  JTreeViewController.prototype.addNode = function(nodeData, index) {
    var list, node, parentId;
    if (this.nodes[this.getNodeId(nodeData)]) {
      return;
    }
    nodeData = this.repairIds(nodeData);
    if (!nodeData) {
      return;
    }
    if (__indexOf.call(this.getData(), nodeData) < 0) {
      this.getData().push(nodeData);
    }
    this.registerListData(nodeData);
    parentId = this.getNodePId(nodeData);
    if (this.listControllers[parentId] != null) {
      list = this.listControllers[parentId].getListView();
    } else {
      list = this.createList(parentId).getListView();
      this.addSubList(this.nodes[parentId], parentId);
    }
    node = list.addItem(nodeData);
    this.emit("NodeWasAdded", node);
    this.addIndexedNode(nodeData);
    return node;
  };

  JTreeViewController.prototype.addNodes = function(nodes) {
    var node, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      _results.push(this.addNode(node));
    }
    return _results;
  };

  JTreeViewController.prototype.removeNode = function(id) {
    var index, nodeData, nodeIndexToRemove, nodeToRemove, parentId, _i, _len, _ref;
    nodeIndexToRemove = null;
    _ref = this.getData();
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      nodeData = _ref[index];
      if (this.getNodeId(nodeData) === id) {
        this.removeIndexedNode(nodeData);
        nodeIndexToRemove = index;
      }
    }
    if (nodeIndexToRemove != null) {
      nodeToRemove = this.getData().splice(nodeIndexToRemove, 1)[0];
      this.removeChildNodes(id);
      parentId = this.getNodePId(nodeToRemove);
      this.listControllers[parentId].getListView().removeItem(this.nodes[id]);
      return delete this.nodes[id];
    }
  };

  JTreeViewController.prototype.removeNodeView = function(nodeView) {
    return this.removeNode(this.getNodeId(nodeView.getData()));
  };

  JTreeViewController.prototype.removeAllNodes = function() {
    var id, listController, _ref;
    _ref = this.listControllers;
    for (id in _ref) {
      if (!__hasProp.call(_ref, id)) continue;
      listController = _ref[id];
      listController.itemsOrdered.forEach(this.bound('removeNodeView'));
      if (listController != null) {
        listController.getView().destroy();
      }
      delete this.listControllers[id];
      delete this.listData[id];
    }
    this.nodes = {};
    this.listData = {};
    this.indexedNodes = [];
    this.selectedNodes = [];
    return this.listControllers = {};
  };

  JTreeViewController.prototype.removeChildNodes = function(id) {
    var childNodeId, childNodeIdsToRemove, index, nodeData, _i, _j, _len, _len1, _ref, _ref1;
    childNodeIdsToRemove = [];
    _ref = this.getData();
    for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
      nodeData = _ref[index];
      if (this.getNodePId(nodeData) === id) {
        childNodeIdsToRemove.push(this.getNodeId(nodeData));
      }
    }
    for (_j = 0, _len1 = childNodeIdsToRemove.length; _j < _len1; _j++) {
      childNodeId = childNodeIdsToRemove[_j];
      this.removeNode(childNodeId);
    }
    if ((_ref1 = this.listControllers[id]) != null) {
      _ref1.getView().destroy();
    }
    delete this.listControllers[id];
    return delete this.listData[id];
  };

  JTreeViewController.prototype.nodeWasAdded = function(nodeView) {
    var id, nodeData, parentId;
    nodeData = nodeView.getData();
    if (this.getOptions().dragdrop) {
      nodeView.$().attr("draggable", "true");
    }
    id = nodeData.id, parentId = nodeData.parentId;
    this.nodes[this.getNodeId(nodeData)] = nodeView;
    if (this.nodes[this.getNodePId(nodeData)]) {
      if (!this.getOptions().addListsCollapsed) {
        this.expand(this.nodes[this.getNodePId(nodeData)]);
      }
      this.nodes[this.getNodePId(nodeData)].decorateSubItemsState();
    }
    if (!this.listControllers[id]) {
      return;
    }
    return this.addSubList(nodeView, id);
  };

  JTreeViewController.prototype.getChildNodes = function(aParentNode) {
    var children;
    children = [];
    this.indexedNodes.forEach((function(_this) {
      return function(node, index) {
        if (_this.getNodePId(node) === _this.getNodeId(aParentNode)) {
          return children.push({
            node: node,
            index: index
          });
        }
      };
    })(this));
    if (children.length) {
      return children;
    } else {
      return false;
    }
  };

  JTreeViewController.prototype.getPreviousNeighbor = function(aParentNode) {
    var children, lastChild, neighbor;
    neighbor = aParentNode;
    children = this.getChildNodes(aParentNode);
    if (children) {
      lastChild = children.last;
      neighbor = this.getPreviousNeighbor(lastChild.node);
    }
    return neighbor;
  };

  JTreeViewController.prototype.addIndexedNode = function(nodeData, index) {
    var neighborIndex, parentNodeView, prevNeighbor;
    if (index >= 0) {
      this.indexedNodes.splice(index + 1, 0, nodeData);
      return;
    }
    parentNodeView = this.nodes[this.getNodePId(nodeData)];
    if (parentNodeView) {
      prevNeighbor = this.getPreviousNeighbor(parentNodeView.getData());
      neighborIndex = this.indexedNodes.indexOf(prevNeighbor);
      return this.indexedNodes.splice(neighborIndex + 1, 0, nodeData);
    } else {
      return this.indexedNodes.push(nodeData);
    }
  };

  JTreeViewController.prototype.removeIndexedNode = function(nodeData) {
    var index;
    if (__indexOf.call(this.indexedNodes, nodeData) >= 0) {
      index = this.indexedNodes.indexOf(nodeData);
      this.indexedNodes.splice(index, 1);
      if (this.nodes[this.getNodePId(nodeData)] && !this.getChildNodes(this.nodes[this.getNodePId(nodeData)].getData())) {
        return this.nodes[this.getNodePId(nodeData)].decorateSubItemsState(false);
      }
    }
  };


  /*
  CREATING LISTS
   */

  JTreeViewController.prototype.registerListData = function(node) {
    var parentId, _base;
    parentId = this.getNodePId(node);
    (_base = this.listData)[parentId] || (_base[parentId] = []);
    return this.listData[parentId].push(node);
  };

  JTreeViewController.prototype.createList = function(listId, listItems) {
    var options, _ref, _ref1;
    options = this.getOptions();
    this.listControllers[listId] = new options.listViewControllerClass({
      id: "" + (this.getId()) + "_" + listId,
      wrapper: false,
      scrollView: false,
      selection: (_ref = options.selection) != null ? _ref : false,
      multipleSelection: (_ref1 = options.multipleSelection) != null ? _ref1 : false,
      view: new options.listViewClass({
        tagName: "ul",
        type: options.type,
        itemClass: options.treeItemClass,
        itemChildClass: options.itemChildClass,
        itemChildOptions: options.itemChildOptions
      })
    }, {
      items: listItems
    });
    this.setListenersForList(listId);
    return this.listControllers[listId];
  };

  JTreeViewController.prototype.addSubList = function(nodeView, id) {
    var listToBeAdded, o;
    o = this.getOptions();
    listToBeAdded = this.listControllers[id].getView();
    if (nodeView) {
      nodeView.$().after(listToBeAdded.$());
      listToBeAdded.parentIsInDom = true;
      listToBeAdded.emit('viewAppended');
      if (o.addListsCollapsed) {
        return this.collapse(nodeView);
      } else {
        return this.expand(nodeView);
      }
    } else {
      return this.getView().addSubView(listToBeAdded);
    }
  };


  /*
  REGISTERING LISTENERS
   */

  JTreeViewController.prototype.setMainListeners = function() {
    KD.getSingleton("windowController").on("ReceivedMouseUpElsewhere", (function(_this) {
      return function(event) {
        return _this.mouseUp(event);
      };
    })(this));
    return this.getView().on("ReceivedClickElsewhere", (function(_this) {
      return function() {
        return _this.setBlurState();
      };
    })(this));
  };

  JTreeViewController.prototype.setListenersForList = function(listId) {
    this.listControllers[listId].getView().on('ItemWasAdded', (function(_this) {
      return function(view, index) {
        return _this.setItemListeners(view, index);
      };
    })(this));
    this.listControllers[listId].on("ItemSelectionPerformed", (function(_this) {
      return function(listController, _arg) {
        var event, items;
        event = _arg.event, items = _arg.items;
        return _this.organizeSelectedNodes(listController, items, event);
      };
    })(this));
    this.listControllers[listId].on("ItemDeselectionPerformed", (function(_this) {
      return function(listController, _arg) {
        var event, items;
        event = _arg.event, items = _arg.items;
        return _this.deselectNodes(listController, items, event);
      };
    })(this));
    return this.listControllers[listId].getListView().on('KeyDownOnTreeView', (function(_this) {
      return function(event) {
        return _this.keyEventHappened(event);
      };
    })(this));
  };

  JTreeViewController.prototype.setItemListeners = function(view, index) {
    var mouseEvents;
    view.on("viewAppended", this.nodeWasAdded.bind(this, view));
    mouseEvents = ["dblclick", "click", "mousedown", "mouseup", "mouseenter", "mousemove"];
    if (this.getOptions().contextMenu) {
      mouseEvents.push("contextmenu");
    }
    if (this.getOptions().dragdrop) {
      mouseEvents = mouseEvents.concat(["dragstart", "dragenter", "dragleave", "dragend", "dragover", "drop"]);
    }
    return view.on(mouseEvents, (function(_this) {
      return function(event) {
        return _this.mouseEventHappened(view, event);
      };
    })(this));
  };


  /*
  NODE SELECTION
   */

  JTreeViewController.prototype.organizeSelectedNodes = function(listController, nodes, event) {
    var node, _i, _len, _results;
    if (event == null) {
      event = {};
    }
    if (!((event.metaKey || event.ctrlKey || event.shiftKey) && this.getOptions().multipleSelection)) {
      this.deselectAllNodes(listController);
    }
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      if (__indexOf.call(this.selectedNodes, node) < 0) {
        _results.push(this.selectedNodes.push(node));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  JTreeViewController.prototype.deselectNodes = function(listController, nodes, event) {
    var node, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      if (__indexOf.call(this.selectedNodes, node) >= 0) {
        _results.push(this.selectedNodes.splice(this.selectedNodes.indexOf(node), 1));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  JTreeViewController.prototype.deselectAllNodes = function(exceptThisController) {
    var id, listController, _ref;
    _ref = this.listControllers;
    for (id in _ref) {
      if (!__hasProp.call(_ref, id)) continue;
      listController = _ref[id];
      if (listController !== exceptThisController) {
        listController.deselectAllItems();
      }
    }
    return this.selectedNodes = [];
  };

  JTreeViewController.prototype.selectNode = function(nodeView, event, setFocus) {
    var controller;
    if (setFocus == null) {
      setFocus = true;
    }
    if (!nodeView) {
      return;
    }
    if (setFocus) {
      this.setFocusState();
    }
    controller = this.listControllers[this.getNodePId(nodeView.getData())];
    if (controller) {
      return controller.selectItem(nodeView, event);
    }
  };

  JTreeViewController.prototype.deselectNode = function(nodeView, event) {
    return this.listControllers[this.getNodePId(nodeView.getData())].deselectSingleItem(nodeView, event);
  };

  JTreeViewController.prototype.selectFirstNode = function() {
    return this.selectNode(this.nodes[this.getNodeId(this.indexedNodes[0])]);
  };

  JTreeViewController.prototype.selectNodesByRange = function(node1, node2) {
    var indicesToBeSliced, itemsToBeSelected, node, _i, _len, _results;
    indicesToBeSliced = [this.indexedNodes.indexOf(node1.getData()), this.indexedNodes.indexOf(node2.getData())];
    indicesToBeSliced.sort(function(a, b) {
      return a - b;
    });
    itemsToBeSelected = this.indexedNodes.slice(indicesToBeSliced[0], indicesToBeSliced[1] + 1);
    _results = [];
    for (_i = 0, _len = itemsToBeSelected.length; _i < _len; _i++) {
      node = itemsToBeSelected[_i];
      _results.push(this.selectNode(this.nodes[this.getNodeId(node)], {
        shiftKey: true
      }));
    }
    return _results;
  };


  /*
  COLLAPSE / EXPAND
   */

  JTreeViewController.prototype.toggle = function(nodeView) {
    if (nodeView.expanded) {
      return this.collapse(nodeView);
    } else {
      return this.expand(nodeView);
    }
  };

  JTreeViewController.prototype.expand = function(nodeView) {
    var nodeData, _ref;
    nodeData = nodeView.getData();
    nodeView.expand();
    return (_ref = this.listControllers[this.getNodeId(nodeData)]) != null ? _ref.getView().expand() : void 0;
  };

  JTreeViewController.prototype.collapse = function(nodeView) {
    var nodeData, _ref;
    nodeData = nodeView.getData();
    return (_ref = this.listControllers[this.getNodeId(nodeData)]) != null ? _ref.getView().collapse((function(_this) {
      return function() {
        return nodeView.collapse();
      };
    })(this)) : void 0;
  };


  /*
  DND UI FEEDBACKS
   */

  JTreeViewController.prototype.showDragOverFeedback = (function() {
    return _.throttle(function(nodeView, event) {
      var nodeData, _ref, _ref1;
      nodeData = nodeView.getData();
      if (nodeData.type !== "file") {
        nodeView.setClass("drop-target");
      } else {
        if ((_ref = this.nodes[nodeData.parentPath]) != null) {
          _ref.setClass("drop-target");
        }
        if ((_ref1 = this.listControllers[nodeData.parentPath]) != null) {
          _ref1.getListView().setClass("drop-target");
        }
      }
      return nodeView.setClass("items-hovering");
    }, 100);
  })();

  JTreeViewController.prototype.clearDragOverFeedback = (function() {
    return _.throttle(function(nodeView, event) {
      var nodeData, _ref, _ref1;
      nodeData = nodeView.getData();
      if (nodeData.type !== "file") {
        nodeView.unsetClass("drop-target");
      } else {
        if ((_ref = this.nodes[nodeData.parentPath]) != null) {
          _ref.unsetClass("drop-target");
        }
        if ((_ref1 = this.listControllers[nodeData.parentPath]) != null) {
          _ref1.getListView().unsetClass("drop-target");
        }
      }
      return nodeView.unsetClass("items-hovering");
    }, 100);
  })();

  JTreeViewController.prototype.clearAllDragFeedback = function() {
    return this.utils.wait(101, (function(_this) {
      return function() {
        var listController, nodeView, path, _ref, _ref1, _results;
        _this.getView().$('.drop-target').removeClass("drop-target");
        _this.getView().$('.items-hovering').removeClass("items-hovering");
        _ref = _this.listControllers;
        for (path in _ref) {
          if (!__hasProp.call(_ref, path)) continue;
          listController = _ref[path];
          listController.getListView().unsetClass("drop-target");
        }
        _ref1 = _this.nodes;
        _results = [];
        for (path in _ref1) {
          if (!__hasProp.call(_ref1, path)) continue;
          nodeView = _ref1[path];
          _results.push(nodeView.unsetClass("items-hovering drop-target"));
        }
        return _results;
      };
    })(this));
  };


  /*
  HANDLING MOUSE EVENTS
   */

  JTreeViewController.prototype.mouseEventHappened = function(nodeView, event) {
    switch (event.type) {
      case "mouseenter":
        return this.mouseEnter(nodeView, event);
      case "dblclick":
        return this.dblClick(nodeView, event);
      case "click":
        return this.click(nodeView, event);
      case "mousedown":
        return this.mouseDown(nodeView, event);
      case "mouseup":
        return this.mouseUp(nodeView, event);
      case "mousemove":
        return this.mouseMove(nodeView, event);
      case "contextmenu":
        return this.contextMenu(nodeView, event);
      case "dragstart":
        return this.dragStart(nodeView, event);
      case "dragenter":
        return this.dragEnter(nodeView, event);
      case "dragleave":
        return this.dragLeave(nodeView, event);
      case "dragover":
        return this.dragOver(nodeView, event);
      case "dragend":
        return this.dragEnd(nodeView, event);
      case "drop":
        return this.drop(nodeView, event);
    }
  };

  JTreeViewController.prototype.dblClick = function(nodeView, event) {
    return this.toggle(nodeView);
  };

  JTreeViewController.prototype.click = function(nodeView, event) {
    if (/arrow/.test(event.target.className)) {
      this.toggle(nodeView);
      return this.selectedItems;
    }
    this.lastEvent = event;
    if (!((event.metaKey || event.ctrlKey || event.shiftKey) && this.getOptions().multipleSelection)) {
      this.deselectAllNodes();
    }
    if (nodeView != null) {
      if (event.shiftKey && this.selectedNodes.length > 0 && this.getOptions().multipleSelection) {
        this.selectNodesByRange(this.selectedNodes[0], nodeView);
      } else {
        this.selectNode(nodeView, event);
      }
    }
    return this.selectedItems;
  };

  JTreeViewController.prototype.contextMenu = function(nodeView, event) {};

  JTreeViewController.prototype.mouseDown = function(nodeView, event) {
    this.lastEvent = event;
    if (__indexOf.call(this.selectedNodes, nodeView) < 0) {
      this.mouseIsDown = true;
      this.cancelDrag = true;
      this.mouseDownTempItem = nodeView;
      return this.mouseDownTimer = setTimeout((function(_this) {
        return function() {
          _this.mouseIsDown = false;
          _this.cancelDrag = false;
          _this.mouseDownTempItem = null;
          return _this.selectNode(nodeView, event);
        };
      })(this), 1000);
    } else {
      this.mouseIsDown = false;
      return this.mouseDownTempItem = null;
    }
  };

  JTreeViewController.prototype.mouseUp = function(event) {
    clearTimeout(this.mouseDownTimer);
    this.mouseIsDown = false;
    this.cancelDrag = false;
    return this.mouseDownTempItem = null;
  };

  JTreeViewController.prototype.mouseEnter = function(nodeView, event) {
    clearTimeout(this.mouseDownTimer);
    if (this.mouseIsDown && this.getOptions().multipleSelection) {
      this.cancelDrag = true;
      if (!((event.metaKey || event.ctrlKey || event.shiftKey) && this.getOptions().multipleSelection)) {
        this.deselectAllNodes();
      }
      return this.selectNodesByRange(this.mouseDownTempItem, nodeView);
    }
  };


  /*
  HANDLING DND
   */

  JTreeViewController.prototype.dragStart = function(nodeView, event) {
    var e, node, transferredData;
    if (this.cancelDrag) {
      event.preventDefault();
      event.stopPropagation();
      return false;
    }
    this.dragIsActive = true;
    e = event.originalEvent;
    e.dataTransfer.effectAllowed = 'copyMove';
    transferredData = (function() {
      var _i, _len, _ref, _results;
      _ref = this.selectedNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        _results.push(this.getNodeId(node.getData()));
      }
      return _results;
    }).call(this);
    e.dataTransfer.setData('Text', transferredData.join());
    if (this.selectedNodes.length > 1) {
      e.dataTransfer.setDragImage(dragHelper, -10, 0);
    }
    return nodeView.setClass("drag-started");
  };

  JTreeViewController.prototype.dragEnter = function(nodeView, event) {
    return this.emit("dragEnter", nodeView, event);
  };

  JTreeViewController.prototype.dragLeave = function(nodeView, event) {
    this.clearAllDragFeedback();
    return this.emit("dragLeave", nodeView, event);
  };

  JTreeViewController.prototype.dragOver = function(nodeView, event) {
    return this.emit("dragOver", nodeView, event);
  };

  JTreeViewController.prototype.dragEnd = function(nodeView, event) {
    this.dragIsActive = false;
    nodeView.unsetClass("drag-started");
    this.clearAllDragFeedback();
    return this.emit("dragEnd", nodeView, event);
  };

  JTreeViewController.prototype.drop = function(nodeView, event) {
    this.dragIsActive = false;
    event.preventDefault();
    event.stopPropagation();
    this.emit("drop", nodeView, event);
    return false;
  };


  /*
  HANDLING KEY EVENTS
   */

  JTreeViewController.prototype.setKeyView = function() {
    if (this.listControllers[0]) {
      return KD.getSingleton("windowController").setKeyView(this.listControllers[0].getListView());
    }
  };

  JTreeViewController.prototype.keyEventHappened = function(event) {
    var key, nextNode, nodeView, _base;
    key = keyMap()[event.which];
    nodeView = this.selectedNodes[0];
    this.emit("keyEventPerformedOnTreeView", event);
    if (!nodeView) {
      return;
    }
    switch (key) {
      case "down":
      case "up":
        event.preventDefault();
        nextNode = this["perform" + (key.capitalize()) + "Key"](nodeView, event);
        if (nextNode) {
          return typeof (_base = this.getView()).scrollToSubView === "function" ? _base.scrollToSubView(nextNode) : void 0;
        }
        break;
      case "left":
        return this.performLeftKey(nodeView, event);
      case "right":
        return this.performRightKey(nodeView, event);
      case "backspace":
        return this.performBackspaceKey(nodeView, event);
      case "enter":
        return this.performEnterKey(nodeView, event);
      case "escape":
        return this.performEscapeKey(nodeView, event);
      case "tab":
        return false;
    }
  };

  JTreeViewController.prototype.performDownKey = function(nodeView, event) {
    var nextIndex, nextNode, nodeData;
    if (this.selectedNodes.length > 1) {
      nodeView = this.selectedNodes[this.selectedNodes.length - 1];
      if (!((event.metaKey || event.ctrlKey || event.shiftKey) && this.getOptions().multipleSelection)) {
        this.deselectAllNodes();
        this.selectNode(nodeView);
      }
    }
    nodeData = nodeView.getData();
    nextIndex = this.indexedNodes.indexOf(nodeData) + 1;
    if (this.indexedNodes[nextIndex]) {
      nextNode = this.nodes[this.getNodeId(this.indexedNodes[nextIndex])];
      if (this.isNodeVisible(nextNode)) {
        if (__indexOf.call(this.selectedNodes, nextNode) >= 0) {
          return this.deselectNode(this.nodes[this.getNodeId(nodeData)]);
        } else {
          this.selectNode(nextNode, event);
          return nextNode;
        }
      } else {
        return this.performDownKey(nextNode, event);
      }
    }
  };

  JTreeViewController.prototype.performUpKey = function(nodeView, event) {
    var nextIndex, nextNode, nodeData;
    if (this.selectedNodes.length > 1) {
      nodeView = this.selectedNodes[this.selectedNodes.length - 1];
      if (!((event.metaKey || event.ctrlKey || event.shiftKey) && this.getOptions().multipleSelection)) {
        this.deselectAllNodes();
        this.selectNode(nodeView);
      }
    }
    nodeData = nodeView.getData();
    nextIndex = this.indexedNodes.indexOf(nodeData) - 1;
    if (this.indexedNodes[nextIndex]) {
      nextNode = this.nodes[this.getNodeId(this.indexedNodes[nextIndex])];
      if (this.isNodeVisible(nextNode)) {
        if (__indexOf.call(this.selectedNodes, nextNode) >= 0) {
          this.deselectNode(this.nodes[this.getNodeId(nodeData)]);
        } else {
          this.selectNode(nextNode, event);
        }
      } else {
        this.performUpKey(nextNode, event);
      }
    }
    return nextNode;
  };

  JTreeViewController.prototype.performRightKey = function(nodeView, event) {
    return this.expand(nodeView);
  };

  JTreeViewController.prototype.performLeftKey = function(nodeView, event) {
    var nodeData, parentNode;
    nodeData = nodeView.getData();
    if (this.nodes[this.getNodePId(nodeData)]) {
      parentNode = this.nodes[this.getNodePId(nodeData)];
      this.selectNode(parentNode);
    }
    return parentNode;
  };

  JTreeViewController.prototype.performBackspaceKey = function(nodeView, event) {};

  JTreeViewController.prototype.performEnterKey = function(nodeView, event) {};

  JTreeViewController.prototype.performEscapeKey = function(nodeView, event) {};

  return JTreeViewController;

})(KDViewController);


},{"./../../core/viewcontroller.coffee":107,"./../list/listviewcontroller.coffee":55,"./../scrollview/scrollview.coffee":69}],89:[function(require,module,exports){
var KDCustomHTMLView, KDFileUploadArea, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDCustomHTMLView = require('./../../core/customhtmlview.coffee');

module.exports = KDFileUploadArea = (function(_super) {
  __extends(KDFileUploadArea, _super);

  function KDFileUploadArea() {
    return KDFileUploadArea.__super__.constructor.apply(this, arguments);
  }

  KDFileUploadArea.prototype.dragEnter = function(e) {
    e.preventDefault();
    e.stopPropagation();
    return this.setClass("hover");
  };

  KDFileUploadArea.prototype.dragOver = function(e) {
    e.preventDefault();
    e.stopPropagation();
    return this.setClass("hover");
  };

  KDFileUploadArea.prototype.dragLeave = function(e) {
    e.preventDefault();
    e.stopPropagation();
    return this.unsetClass("hover");
  };

  KDFileUploadArea.prototype.drop = function(jQueryEvent) {
    var file, files, orgEvent, _i, _len;
    jQueryEvent.preventDefault();
    jQueryEvent.stopPropagation();
    this.unsetClass("hover");
    orgEvent = jQueryEvent.originalEvent;
    files = orgEvent.dataTransfer.files;
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      this.getDelegate().fileDropped(file);
    }
    return false;
  };

  KDFileUploadArea.prototype.viewAppended = function() {
    var o, title;
    title = this.getOptions().title;
    o = this.getDelegate().getOptions();
    this.setPartial("<span>" + title + "</span>");
    return this.addSubView(new KDCustomHTMLView({
      cssClass: "info",
      tagName: "span",
      tooltip: {
        title: "Max. File Amount: <b>" + o.limit + "</b> files<br/>Max. File Size: <b>" + o.fileMaxSize + "</b> kbytes<br/>Max. Total Size: <b>" + o.totalMaxSize + "</b> kbytes",
        placement: "above",
        offset: 0,
        delayIn: 300,
        html: true,
        animate: true,
        selector: null,
        partial: "i"
      }
    }));
  };

  return KDFileUploadArea;

})(KDView);


},{"./../../core/customhtmlview.coffee":97,"./../../core/view.coffee":106}],90:[function(require,module,exports){
var KDFileUploadListItemView, KDListItemView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListItemView = require('./../list/listitemview.coffee');

module.exports = KDFileUploadListItemView = (function(_super) {
  __extends(KDFileUploadListItemView, _super);

  function KDFileUploadListItemView(options, data) {
    KDFileUploadListItemView.__super__.constructor.call(this, options, data);
    this.setClass("kdfileuploadlistitem clearfix");
    this.active = false;
  }

  KDFileUploadListItemView.prototype.click = function(e) {
    if ($(e.target).is("span.iconic.x")) {
      return this.emit("removeFile", {
        orgEvent: e
      });
    }
  };

  KDFileUploadListItemView.prototype.viewAppended = function() {
    return this.$().append(this.partial(this.data));
  };

  KDFileUploadListItemView.prototype.partial = function(file) {
    return $("<span class='file-title'>" + file.name + "</span> <span class='file-size'>" + ((file.size / 1024).toFixed(2)) + "kb</span> <span class='x'></span>");
  };

  return KDFileUploadListItemView;

})(KDListItemView);


},{"./../list/listitemview.coffee":53}],91:[function(require,module,exports){
var KDFileUploadListView, KDListView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListView = require('./../list/listview.coffee');

module.exports = KDFileUploadListView = (function(_super) {
  __extends(KDFileUploadListView, _super);

  function KDFileUploadListView(options, data) {
    if (options.itemClass == null) {
      options.itemClass = KDFileUploadItemView;
    }
    KDFileUploadListView.__super__.constructor.call(this, options, data);
    this.setClass("kdfileuploadlist");
    this.itemsByName = {};
  }

  KDFileUploadListView.prototype.addItem = function(file) {
    var itemInstance;
    itemInstance = new (this.getOptions().itemClass)({
      delegate: this
    }, file);
    this.getDelegate().on("removeFile", this.getDelegate().removeFile);
    this.addItemView(itemInstance);
    return this.itemsByName[file.name] = itemInstance;
  };

  return KDFileUploadListView;

})(KDListView);


},{"./../list/listview.coffee":54}],92:[function(require,module,exports){
var KDFileUploadThumbItemView, KDListItemView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDListItemView = require('./../list/listitemview.coffee');

module.exports = KDFileUploadThumbItemView = (function(_super) {
  __extends(KDFileUploadThumbItemView, _super);

  function KDFileUploadThumbItemView(options, data) {
    KDFileUploadThumbItemView.__super__.constructor.call(this, options, data);
    this.setClass("kdfileuploadthumbitem clearfix");
    this.active = false;
  }

  KDFileUploadThumbItemView.prototype.click = function(e) {
    if ($(e.target).is("span.iconic.x")) {
      return this.emit("removeFile", {
        orgEvent: e
      });
    }
  };

  KDFileUploadThumbItemView.prototype.viewAppended = function() {
    return this.$().append(this.partial(this.data));
  };

  KDFileUploadThumbItemView.prototype.partial = function(file) {
    var fileUrl, imageType;
    imageType = /image.*/;
    fileUrl = file.type.match(imageType) ? window.URL.createObjectURL(file) : "./a/images/icon.file.png";
    return $("<img class='thumb' src='" + fileUrl + "'/> <p class='meta'> <span class='file-title'>" + file.name + "</span> <span class='file-size'>" + ((file.size / 1024).toFixed(2)) + "kb</span> <span class='close-icon'></span> </p>");
  };

  return KDFileUploadThumbItemView;

})(KDListItemView);


},{"./../list/listitemview.coffee":53}],93:[function(require,module,exports){
var KDFileUploadListView, KDFileUploadThumbListView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDFileUploadListView = require('./fileuploadlistview.coffee');

module.exports = KDFileUploadThumbListView = (function(_super) {
  __extends(KDFileUploadThumbListView, _super);

  function KDFileUploadThumbListView(options, data) {
    if (options.itemClass == null) {
      options.itemClass = KDFileUploadThumbItemView;
    }
    KDFileUploadThumbListView.__super__.constructor.call(this, options, data);
    this.setClass("kdfileuploadthumblist");
  }

  return KDFileUploadThumbListView;

})(KDFileUploadListView);


},{"./fileuploadlistview.coffee":91}],94:[function(require,module,exports){
var KDFileUploadArea, KDFileUploadListView, KDFileUploadThumbListView, KDFileUploadView, KDListViewController, KDMultipartUploader, KDNotificationView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./../../core/view.coffee');

KDListViewController = require('./../list/listviewcontroller.coffee');

KDNotificationView = require('./../notifications/notificationview.coffee');

KDFileUploadArea = require('./fileuploadarea.coffee');

KDFileUploadListView = require('./fileuploadlistview.coffee');

KDFileUploadThumbListView = require('./fileuploadthumblistview.coffee');

KDMultipartUploader = require('./multipartuploader.coffee');

module.exports = KDFileUploadView = (function(_super) {
  __extends(KDFileUploadView, _super);

  function KDFileUploadView(options, data) {
    if (window.FileReader != null) {
      if (options.limit == null) {
        options.limit = 20;
      }
      if (options.fileMaxSize == null) {
        options.fileMaxSize = 4096;
      }
      if (options.filetotalSize == null) {
        options.filetotalSize = 4096;
      }
      if (options.extensions == null) {
        options.extensions = null;
      }
      if (options.preview == null) {
        options.preview = "list";
      }
      if (options.title == null) {
        options.title = "Drop your files here!";
      }
      if (options.onlyOne == null) {
        options.onlyOne = false;
      }
      KDFileUploadView.__super__.constructor.call(this, options, data);
      this.listController = null;
      this.addDropArea();
      this.addList();
      this.files = {};
      this.totalSizeToUpload = 0;
      this.setClass("kdfileupload");
    } else {
      KDFileUploadView.__super__.constructor.call(this, options, data);
      this.setPartial("<p class='warning info'><strong>Oops sorry,</strong> file upload is only working on Chrome, Firefox and Opera at the moment. We're working on a fix.</p>");
    }
  }

  KDFileUploadView.prototype.addDropArea = function() {
    this.dropArea = new KDFileUploadArea({
      title: this.getOptions().title,
      bind: 'drop dragenter dragleave dragover dragstart dragend',
      cssClass: "kdfileuploadarea",
      delegate: this
    });
    return this.addSubView(this.dropArea);
  };

  KDFileUploadView.prototype.addList = function() {
    this.fileList = (function() {
      switch (this.getOptions().preview) {
        case "thumbs":
          return this.addThumbnailList();
        default:
          return this.addFileList();
      }
    }).call(this);
    this.listController = new KDListViewController({
      view: this.fileList
    });
    return this.addSubView(this.listController.getView());
  };

  KDFileUploadView.prototype.addFileList = function() {
    return new KDFileUploadListView({
      delegate: this
    });
  };

  KDFileUploadView.prototype.addThumbnailList = function() {
    return new KDFileUploadThumbListView({
      delegate: this
    });
  };

  KDFileUploadView.prototype.fileDropped = function(file) {
    var uploader;
    uploader = new KDMultipartUploader({
      url: '/Upload',
      file: file
    });
    uploader.send();
    uploader.once('FileReadComplete', (function(_this) {
      return function(event) {
        _this.emit('FileReadComplete', {
          file: file,
          progressEvent: event
        });
        return _this.fileReadComplete(file, event);
      };
    })(this));
    uploader.once('FileUploadSuccess', (function(_this) {
      return function(res) {
        return _this.fileUploadComplete(file, res);
      };
    })(this));
    return uploader.once('FileUploadError', this.bound('handleUploadError'));
  };

  KDFileUploadView.prototype.handleUploadError = function(xhr) {};

  KDFileUploadView.prototype.fileUploadComplete = function(file, res) {
    var _ref;
    if ((_ref = this.fileList.itemsByName[file.name]) != null) {
      _ref.setClass('uploaded');
    }
    return this.emit('FileUploadComplete', res);
  };

  KDFileUploadView.prototype.fileReadComplete = function(file, event) {
    file.data = event.target.result;
    return this.putFileInQueue(file);
  };

  KDFileUploadView.prototype.putFileInQueue = function(file) {
    if (this.getOptions().onlyOne) {
      this.files = {};
      this.fileList.empty();
    }
    if (!this.isDuplicate(file) && this.checkLimits(file)) {
      this.files[file.name] = file;
      this.fileList.addItem(file);
      return true;
    } else {
      return false;
    }
  };

  KDFileUploadView.prototype.removeFile = function(pubInst, event) {
    var file;
    file = pubInst.getData();
    delete this.files[file.name];
    return this.fileList.removeItem(pubInst);
  };

  KDFileUploadView.prototype.isDuplicate = function(file) {
    if (this.files[file.name] != null) {
      this.notify("File is already in queue!");
      return true;
    } else {
      return false;
    }
  };

  KDFileUploadView.prototype.checkLimits = function(file) {
    return this.checkFileAmount() && this.checkFileSize(file) && this.checkTotalSize(file);
  };

  KDFileUploadView.prototype.checkFileAmount = function() {
    var amount, file, maxAmount, name, _ref;
    maxAmount = this.getOptions().limit;
    amount = 1;
    _ref = this.files;
    for (name in _ref) {
      if (!__hasProp.call(_ref, name)) continue;
      file = _ref[name];
      amount++;
    }
    if (amount > maxAmount) {
      this.notify("Total number of allowed file is " + maxAmount);
      return false;
    } else {
      return true;
    }
  };

  KDFileUploadView.prototype.checkTotalSize = function(file) {
    var name, totalMaxSize, totalSize, _ref;
    totalMaxSize = this.getOptions().totalMaxSize;
    totalSize = file.size;
    _ref = this.files;
    for (name in _ref) {
      if (!__hasProp.call(_ref, name)) continue;
      file = _ref[name];
      totalSize += file.size;
    }
    if (totalSize / 1024 > totalMaxSize) {
      this.notify("Total allowed filesize is " + totalMaxSize + " kilobytes");
      return false;
    } else {
      return true;
    }
  };

  KDFileUploadView.prototype.checkFileSize = function(file) {
    var fileMaxSize;
    fileMaxSize = this.getOptions().fileMaxSize;
    if (file.size / 1024 > fileMaxSize) {
      this.notify("Maximum allowed filesize is " + fileMaxSize + " kilobytes");
      return false;
    } else {
      return true;
    }
  };

  KDFileUploadView.prototype.notify = function(title) {
    return new KDNotificationView({
      title: title,
      duration: 2000,
      type: "tray"
    });
  };

  return KDFileUploadView;

})(KDView);


},{"./../../core/view.coffee":106,"./../list/listviewcontroller.coffee":55,"./../notifications/notificationview.coffee":61,"./fileuploadarea.coffee":89,"./fileuploadlistview.coffee":91,"./fileuploadthumblistview.coffee":93,"./multipartuploader.coffee":95}],95:[function(require,module,exports){
var KDEventEmitter, KDMultipartUploader,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDEventEmitter = require('./../../core/eventemitter.coffee');

module.exports = KDMultipartUploader = (function(_super) {
  var boundary;

  __extends(KDMultipartUploader, _super);

  boundary = "gc0p4Jq0M2Yt08jU534c0p";

  function KDMultipartUploader(_arg) {
    var id;
    this.url = _arg.url, this.file = _arg.file, id = _arg.id;
    if (!("FileReader" in window)) {
      throw new Error("FileReader API not found!");
    }
    KDMultipartUploader.__super__.constructor.call(this);
    this.id = id != null ? id : 'file';
  }

  KDMultipartUploader.prototype.makeMultipartItem = function(name, value) {
    return "--" + boundary + "\r\n Content-Disposition: form-data; name=\"" + name + "\"\r\n\r\n " + value + "\r\n";
  };

  KDMultipartUploader.prototype.serializedToMultipart = function(list) {
    var i;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        i = list[_i];
        _results.push(this.makeMultipartItem(i.name, i.value));
      }
      return _results;
    }).call(this)).join("");
  };

  KDMultipartUploader.prototype.fileToMultipart = function(callback) {
    var fr, wrapFile;
    fr = new FileReader;
    if (!this.file) {
      return callback("");
    }
    wrapFile = (function(_this) {
      return function(fileData) {
        return "--" + boundary + "\r\n Content-Disposition: form-data; name=\"" + _this.id + "\"; filename=\"" + _this.file.name + "\"\r\n Content-Type: " + _this.file.type + "\r\n\r\n " + fileData + "\r\n --" + boundary + "--\r\n";
      };
    })(this);
    fr.onload = (function(_this) {
      return function(event) {
        if (event.loaded !== event.total) {
          return;
        }
        _this.emit('FileReadComplete', event);
        return callback(wrapFile(event.currentTarget.result));
      };
    })(this);
    return fr.readAsBinaryString(this.file);
  };

  KDMultipartUploader.prototype.send = function() {
    var body, fr, xhr;
    fr = new FileReader;
    xhr = new XMLHttpRequest;
    body = "";
    xhr.open("POST", this.url, true);
    xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
    xhr.onreadystatechange = (function(_this) {
      return function() {
        if (xhr.readyState !== 4) {
          return;
        }
        if (xhr.status >= 200 && xhr.status < 400) {
          return _this.emit('FileUploadSuccess', JSON.parse(xhr.responseText));
        } else {
          return _this.emit('FileUploadError', xhr);
        }
      };
    })(this);
    body += this.serializedToMultipart([
      {
        name: "" + this.id + "-size",
        value: this.file.size
      }
    ]);
    this.fileToMultipart(function(fileData) {
      var arrb, blob, i, len, ui8a;
      body += fileData;
      len = i = body.length;
      arrb = new ArrayBuffer(len);
      ui8a = new Uint8Array(arrb);
      while (i--) {
        ui8a[i] = body.charCodeAt(i) & 0xff;
      }
      blob = new Blob([ui8a]);
      return xhr.send(blob);
    });
    return this;
  };

  return KDMultipartUploader;

})(KDEventEmitter);


},{"./../../core/eventemitter.coffee":98}],96:[function(require,module,exports){
var KDController, KDObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDObject = require('./object.coffee');

module.exports = KDController = (function(_super) {
  __extends(KDController, _super);

  function KDController() {
    return KDController.__super__.constructor.apply(this, arguments);
  }

  return KDController;

})(KDObject);


},{"./object.coffee":102}],97:[function(require,module,exports){
var KDCustomHTMLView, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./view.coffee');

module.exports = KDCustomHTMLView = (function(_super) {
  __extends(KDCustomHTMLView, _super);

  function KDCustomHTMLView(options, data) {
    var _ref, _ref1;
    if (options == null) {
      options = {};
    }
    if (typeof options === 'string') {
      this.tagName = options;
    }
    if (this.tagName == null) {
      this.tagName = (_ref = options.tagName) != null ? _ref : 'div';
    }
    if (this.tagName === 'a' && (((_ref1 = options.attributes) != null ? _ref1.href : void 0) == null)) {
      options.attributes || (options.attributes = {});
      options.attributes.href = '#';
    }
    KDCustomHTMLView.__super__.constructor.call(this, options, data);
  }

  KDCustomHTMLView.prototype.setDomElement = function(cssClass) {
    var el;
    KDCustomHTMLView.__super__.setDomElement.apply(this, arguments);
    this.unsetClass('kdview');
    el = this.getElement();
    if (!el.classList.length) {
      return el.removeAttribute('class');
    }
  };

  return KDCustomHTMLView;

})(KDView);


},{"./view.coffee":106}],98:[function(require,module,exports){
var KDEventEmitter,
  __slice = [].slice;

module.exports = KDEventEmitter = (function() {
  var _off, _on, _registerEvent, _unregisterEvent;

  KDEventEmitter.registerStaticEmitter = function() {
    return this._e = {};
  };

  _registerEvent = function(registry, eventName, listener) {
    if (registry[eventName] == null) {
      registry[eventName] = [];
    }
    return registry[eventName].push(listener);
  };

  _unregisterEvent = function(registry, eventName, listener) {
    var cbIndex;
    if (!eventName || eventName === "*") {
      return registry = {};
    } else if (listener && registry[eventName]) {
      cbIndex = registry[eventName].indexOf(listener);
      if (cbIndex >= 0) {
        return registry[eventName].splice(cbIndex, 1);
      }
    } else {
      return registry[eventName] = [];
    }
  };

  _on = function(registry, eventName, listener) {
    var name, _i, _len, _results;
    if (eventName == null) {
      throw new Error('Try passing an event, genius!');
    }
    if (listener == null) {
      throw new Error('Try passing a listener, genius!');
    }
    if (Array.isArray(eventName)) {
      _results = [];
      for (_i = 0, _len = eventName.length; _i < _len; _i++) {
        name = eventName[_i];
        _results.push(_registerEvent(registry, name, listener));
      }
      return _results;
    } else {
      return _registerEvent(registry, eventName, listener);
    }
  };

  _off = function(registry, eventName, listener) {
    var name, _i, _len, _results;
    if (Array.isArray(eventName)) {
      _results = [];
      for (_i = 0, _len = eventName.length; _i < _len; _i++) {
        name = eventName[_i];
        _results.push(_unregisterEvent(registry, name, listener));
      }
      return _results;
    } else {
      return _unregisterEvent(registry, eventName, listener);
    }
  };

  KDEventEmitter.emit = function() {
    var args, eventName, listener, listeners, _base, _i, _len;
    if (this._e == null) {
      throw new Error('Static events are not enabled for this constructor.');
    }
    eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    listeners = (_base = this._e)[eventName] != null ? _base[eventName] : _base[eventName] = [];
    for (_i = 0, _len = listeners.length; _i < _len; _i++) {
      listener = listeners[_i];
      listener.apply(null, args);
    }
    return this;
  };

  KDEventEmitter.on = function(eventName, listener) {
    if ('function' !== typeof listener) {
      throw new Error('listener is not a function');
    }
    if (this._e == null) {
      throw new Error('Static events are not enabled for this constructor.');
    }
    this.emit('newListener', listener);
    _on(this._e, eventName, listener);
    return this;
  };

  KDEventEmitter.off = function(eventName, listener) {
    this.emit('listenerRemoved', eventName, listener);
    _off(this._e, eventName, listener);
    return this;
  };

  function KDEventEmitter(options) {
    var maxListeners;
    if (options == null) {
      options = {};
    }
    maxListeners = options.maxListeners;
    this._e = {};
    this._maxListeners = maxListeners > 0 ? maxListeners : 10;
  }

  KDEventEmitter.prototype.emit = function() {
    var args, eventName, listenerStack, _base;
    eventName = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((_base = this._e)[eventName] == null) {
      _base[eventName] = [];
    }
    listenerStack = [];
    listenerStack = listenerStack.concat(this._e[eventName].slice(0));
    listenerStack.forEach((function(_this) {
      return function(listener) {
        return listener.apply(_this, args);
      };
    })(this));
    return this;
  };

  KDEventEmitter.prototype.on = function(eventName, listener) {
    if ('function' !== typeof listener) {
      throw new Error('listener is not a function');
    }
    this.emit('newListener', eventName, listener);
    _on(this._e, eventName, listener);
    return this;
  };

  KDEventEmitter.prototype.off = function(eventName, listener) {
    this.emit('listenerRemoved', eventName, listener);
    _off(this._e, eventName, listener);
    return this;
  };

  KDEventEmitter.prototype.once = function(eventName, listener) {
    var _listener;
    _listener = (function(_this) {
      return function() {
        var args;
        args = [].slice.call(arguments);
        _this.off(eventName, _listener);
        return listener.apply(_this, args);
      };
    })(this);
    this.on(eventName, _listener);
    return this;
  };

  return KDEventEmitter;

})();


},{}],99:[function(require,module,exports){
var KDEventEmitter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

KDEventEmitter = require('./eventemitter.coffee');

module.exports = KDEventEmitter.Wildcard = (function(_super) {
  var getAllListeners, listenerKey, removeAllListeners, wildcardKey;

  __extends(Wildcard, _super);

  wildcardKey = '*';

  listenerKey = '_listeners';

  function Wildcard(options) {
    if (options == null) {
      options = {};
    }
    Wildcard.__super__.constructor.apply(this, arguments);
    this._delim = options.delimiter || '.';
  }

  Wildcard.prototype.setMaxListeners = function(n) {
    return this._maxListeners = n;
  };

  getAllListeners = function(node, edges, i) {
    var listeners, nextNode, straight, wild;
    if (i == null) {
      i = 0;
    }
    listeners = [];
    if (i === edges.length) {
      straight = node[listenerKey];
    }
    wild = node[wildcardKey];
    nextNode = node[edges[i]];
    if (straight != null) {
      listeners = listeners.concat(straight);
    }
    if (wild != null) {
      listeners = listeners.concat(getAllListeners(wild, edges, i + 1));
    }
    if (nextNode != null) {
      listeners = listeners.concat(getAllListeners(nextNode, edges, i + 1));
    }
    return listeners;
  };

  removeAllListeners = function(node, edges, it, i) {
    var edge, listener, listeners, nextNode;
    if (i == null) {
      i = 0;
    }
    edge = edges[i];
    nextNode = node[edge];
    if (nextNode != null) {
      return removeAllListeners(nextNode, edges, it, i + 1);
    }
    if ((it != null) && ((listeners = node[listenerKey]) != null)) {
      node[listenerKey] = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = listeners.length; _i < _len; _i++) {
          listener = listeners[_i];
          if (listener !== it) {
            _results.push(listener);
          }
        }
        return _results;
      })();
    } else {
      node[listenerKey] = [];
    }
  };

  Wildcard.prototype.emit = function() {
    var eventName, listener, listeners, oldEvent, rest, _i, _len;
    eventName = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    "use strict";
    if (this.hasOwnProperty('event')) {
      oldEvent = this.event;
    }
    this.event = eventName;
    listeners = getAllListeners(this._e, eventName.split(this._delim));
    for (_i = 0, _len = listeners.length; _i < _len; _i++) {
      listener = listeners[_i];
      listener.apply(this, rest);
    }
    if (oldEvent != null) {
      this.event = oldEvent;
    } else {
      delete this.event;
    }
    return this;
  };

  Wildcard.prototype.off = function(eventName, listener) {
    removeAllListeners(this._e, (eventName != null ? eventName : '*').split(this._delim), listener);
    return this;
  };

  Wildcard.prototype.on = function(eventName, listener) {
    var edge, edges, listeners, node, _i, _len;
    if ('function' !== typeof listener) {
      throw new Error('listener is not a function');
    }
    this.emit('newListener', eventName, listener);
    edges = eventName.split('.');
    node = this._e;
    for (_i = 0, _len = edges.length; _i < _len; _i++) {
      edge = edges[_i];
      node = node[edge] != null ? node[edge] : node[edge] = {};
    }
    listeners = node[listenerKey] != null ? node[listenerKey] : node[listenerKey] = [];
    listeners.push(listener);
    return this;
  };

  return Wildcard;

})(KDEventEmitter);


},{"./eventemitter.coffee":98}],100:[function(require,module,exports){
var e, noop, utils,
  __hasProp = {}.hasOwnProperty;

utils = window.utils = require('./utils.coffee');

require('./support');

window.KD || (window.KD = {});

noop = window.noop = function() {};

KD.log = window.log = console.log.bind(console);

KD.warn = window.warn = console.warn.bind(console);

KD.error = window.error = console.error.bind(console);

if (window.event == null) {
  try {
    Object.defineProperty(window, "event", {
      get: function() {
        return KD.warn("Global \"event\" property is accessed. Did you forget a parameter in a DOM event handler?");
      }
    });
  } catch (_error) {
    e = _error;
    log("we fail silently!", e);
  }
}

window.KD = $.extend(window.KD, (function() {
  var create;
  create = function(constructorName, options, data) {
    var konstructor, _ref;
    konstructor = (_ref = this.classes[constructorName]) != null ? _ref : this.classes["KD" + constructorName];
    if (konstructor != null) {
      return new konstructor(options, data);
    }
  };
  return {
    create: create,
    "new": create,
    debugStates: {},
    instances: {},
    singletons: {},
    subscriptions: [],
    classes: {},
    utils: utils,
    lastFuncCall: null,
    instancesToBeTested: {},
    registerInstance: function(anInstance) {
      if (this.instances[anInstance.id]) {
        warn("Instance being overwritten!!", anInstance);
      }
      return this.instances[anInstance.id] = anInstance;
    },
    unregisterInstance: function(anInstanceId) {
      return delete this.instances[anInstanceId];
    },
    deleteInstance: function(anInstanceId) {
      return this.unregisterInstance(anInstanceId);
    },
    extend: function(obj) {
      var key, val, _results;
      _results = [];
      for (key in obj) {
        val = obj[key];
        if (this[key]) {
          throw new Error("" + key + " is already registered");
        } else {
          _results.push(this[key] = val);
        }
      }
      return _results;
    },
    registerSingleton: function(singletonName, object, override) {
      var existingSingleton;
      if (override == null) {
        override = false;
      }
      if ((existingSingleton = KD.singletons[singletonName]) != null) {
        if (override) {
          warn("singleton overriden! KD.singletons[\"" + singletonName + "\"]");
          if (typeof existingSingleton.destroy === "function") {
            existingSingleton.destroy();
          }
          return KD.singletons[singletonName] = object;
        } else {
          error("KD.singletons[\"" + singletonName + "\"] singleton exists! if you want to override set override param to true]");
          return KD.singletons[singletonName];
        }
      } else {
        return KD.singletons[singletonName] = object;
      }
    },
    getSingleton: function(singletonName) {
      if (KD.singletons[singletonName] != null) {
        return KD.singletons[singletonName];
      } else {
        warn("\"" + singletonName + "\" singleton doesn't exist!");
        return null;
      }
    },
    getAllKDInstances: function() {
      return KD.instances;
    },
    getKDViewInstanceFromDomElement: function(el) {
      return this.instances[el.getAttribute("data-id")];
    },
    exportKDFramework: function() {
      var item, _ref;
      _ref = KD.classes;
      for (item in _ref) {
        if (!__hasProp.call(_ref, item)) continue;
        window[item] = KD.classes[item];
      }
      KD.exportKDFramework = function() {
        return "Already exported.";
      };
      return "KDFramework loaded successfully.";
    },
    registerInstanceForTesting: function(instance) {
      var key;
      key = instance.getOption('testPath');
      this.instancesToBeTested[key] = instance;
      return instance.on('KDObjectWillBeDestroyed', (function(_this) {
        return function() {
          return delete _this.instancesToBeTested[key];
        };
      })(this));
    },
    getInstanceForTesting: function(key) {
      return this.instancesToBeTested[key];
    }
  };
})());

module.exports = KD;


},{"./support":104,"./utils.coffee":105}],101:[function(require,module,exports){
/*Copyright (c) 2012 Jessie

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/


/*
Return URI:
http://127.0.0.1:1337/?addClass=1&appendChild=1&appendHtml=1&createElement=1&findProprietaryStyle=1&getAncestorByClassName=1&getAncestorByTagName=1&getDescendantsByClassName=1&getDescendantsByTagName=1&getElement=1&getElementParentElement=1&getElementPositionStyles=1&getElementTagName=1&getHtml=1&getInnerSize=1&getOuterSize=1&getPositionRelativeToDocument=1&getPositionRelativeToViewport=1&getStyleComputed=1&getText=3&hasClass=1&isDescendant=1&isInQuery=1&isNodeInNodeList=1&prependHtml=1&query=1&removeChild=1&removeClass=1&setHtml=1&setPosition=1&setSize=1&setText=3&attachBoundListener=1&attachBoundWindowListener=1&attachDocumentListener=1&attachListener=1&attachWindowListener=1&cancelDefault=1&cancelPropagation=1&delegateBoundClassNameListener=1&delegateBoundListener=1&delegateBoundQueryListener=1&delegateListener=1&delegateQueryListener=1&delegateTagNameListener=1&detachBoundListener=1&detachListener=1&detachWindowListener=1&getEventTarget=1&getEventTargetRelated=1&bind=1&getViewportScrollPosition=1&getViewportSize=1&htmlToNodes=1&setInputValue=1&setViewportScrollPosition=1&toArray=1&undelegateListener=1&undelegateQueryListener=1
*/

var KD = {};
KD.dom = KD.dom || {};
(function(global) {

	var globalDocument = global.document,
		isHostObjectProperty = function(object, property) {
			var objectProperty = object[property];
			return typeof objectProperty == 'object' && null !== objectProperty;
		},
		isHostMethod = function(object, method) {
			var objectMethod = object[method];
			var type = typeof objectMethod;
			return	type == 'function' ||
					type == 'object' && null !== objectMethod ||
					type == 'unknown';
		},
		areFeatures = function() {
			var i = arguments.length;
			while (i--) {
				if (!KD.dom[arguments[i]]) {
				return false;
				}
			}
			return true;
		},
		html = isHostObjectProperty(globalDocument, 'documentElement') && globalDocument.documentElement,
		canCall = !!Function.prototype.call,
		isStyleCapable = !!(html && isHostObjectProperty(html, 'style'));



/*
Description:
*/

var toArray;

toArray = function(a) {
	var result = [];
	for (var i = 0, l = a.length; i < l; i++) {
		result[i] = a[i];
	}
	return result;
};



/*
Description:
Relies on W3C `el.removeEventListener`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, NN4, Opera 7.6
*/

/*
Author:
David Mark
*/

var detachListener;

if(html && isHostMethod(html, 'removeEventListener')) {
	detachListener = function(el, eventType, fn) {
		el.removeEventListener(eventType, fn, false);
	};
}



/*
Description:
Relies on W3C `e.target`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Opera 7.6
*/

var getEventTarget;

if(html && isHostMethod(html, 'addEventListener')) {
	getEventTarget = function(e) {
		var target = e.target;
		// Check if not an element (e.g. a text node)
		if (1 != target.nodeType) {
			// Set reference to parent node (which must be an element)
			target = target.parentNode;
		}
		return target;
	};
}



/*
Description:
Relies on W3C `el.addEventListener`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Opera 7.6
*/

/*
Author:
David Mark
*/

var attachListener;

if(html && isHostMethod(html, 'addEventListener')) {
	attachListener = function(el, eventType, fn) {

		var listener = function(e) {
			fn.call(el, e);
		};

		el.addEventListener(eventType, listener, false);

		return listener;
	};
}



/*
Description:
Relies on `document.querySelectorAll` and `jessie.toArray`
*/

/*
Author:
David Mark
*/

var query;

if(globalDocument && isHostMethod(globalDocument, 'querySelectorAll') && toArray) {
	query = function(selector, doc) {
		return toArray((doc || document).querySelectorAll(selector));
	};
}

/*
Description:
Relies on `document.querySelector` and `jessie.toArray`
*/

/*
Author:
Christopher Thorn
*/

var queryOne;

if(globalDocument && isHostMethod(globalDocument, 'querySelector')) {
	queryOne = function(selector, doc) {
		return (doc || document).querySelector(selector);
	};
}



/*
Description:
Iterates a node list to see if any of the nodes match the passed in node.
*/

/*
Author:
Graham Veal
*/

var isNodeInNodeList;

isNodeInNodeList = function( node, nodeList ){

	var isInNodeList = false,
		i = 0,
		l = nodeList.length;

	// could use Array.prototype.indexOf in another rendition
	for( ; i < l; i++ ) {
		if(nodeList[i] === node) {
			isInNodeList = true;
			break;
		}
	}

	return isInNodeList;
};



/*
Description:
Relies on `Function.prototype.bind`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Chrome 6, Firefox 3.6, Safari 5.1, Opera 11.5
*/

/*
Author:
David Mark
*/

var bind;

if(canCall && Function.prototype.bind){
    bind = function(fn, thisObject) {
        return fn.bind.apply(fn, Array.prototype.slice.call(arguments, 1));
    };
}



/*
Description:
Relies on `jessie.detachListener`
*/

/*
Author:
Adam Silver
*/

var undelegateListener;

if(detachListener) {
	undelegateListener = function(el, eventType, delegateListener) {
		return detachListener(el, eventType, delegateListener);
	};
}



/*
Description:
Relies on `jessie.attachListener` and `jessie.getEventTarget` `Function.prototype.call`
*/

/*
Author:
Adam Silver
*/

var delegateListener;

if(attachListener && getEventTarget && canCall) {
	delegateListener = function(el, eventType, fn, fnDelegate) {

		var listener = function(e) {
			var currentTarget = fnDelegate(el, getEventTarget(e));
			if(currentTarget) {
				fn.call(currentTarget, e, currentTarget, el);
			}
		};

		return attachListener(el, eventType, listener);
	};
}



var getElementTagName;

/*
Description:
Relies on `el.tagName` or `el.nodeName`
*/

getElementTagName = function (el) {
	var tagName = (el.tagName || el.nodeName).toLowerCase();
	return tagName.indexOf('html:') > -1 ? tagName.substring(5) : tagName;
};



/*global html, globalDocument, isHostObjectProperty*/

var getElementParentElement;

/*
Description:
Relies on `el.parentNode`
*/

/*
Degrades:
IE5, IE4, IE3
*/

if (html && isHostObjectProperty(html, 'parentNode')) {
	getElementParentElement = function(el) {
		var parentNode = el.parentNode,
			parentElement = null;

		if (parentNode && (parentNode.tagName || parentNode.nodeType == 1)) {
			parentElement = parentNode;
		}
		return parentElement;
	};
}



/*
Description:
Relies on `jessie.isNodeInNodeList`, `jessie.query`
*/

/*
Author:
Graham Veal
*/

var isInQuery;

if(isNodeInNodeList && query) {
	isInQuery = function(el, selector) {

		return isNodeInNodeList( el, query(selector) );
	};
}



/*
Description:
Relies on `el.parentNode` which has very good support
*/

/*
Degrades:
In browsers without `el.parentNode`
*/

var isDescendant;

if(html && 'undefined' != typeof html.parentNode) {
	isDescendant = function(el, elDescendant) {
		var parent = elDescendant.parentNode;
		while(parent && parent != el) {
			parent = parent.parentNode;
		}
		return parent == el;
	};
}



/*
Description:
Relies on `jessie.attachListener`, `jessie.bind` and `jessie.getEventTarget` and `Function.prototype.call`
*/

/*
Author:
Adam Silver
*/

var delegateBoundListener;

if(attachListener && bind && getEventTarget && canCall) {
	delegateBoundListener = function(el, eventType, fn, fnDelegate, thisObject) {

		var listener = bind(function(e) {
			var currentTarget = fnDelegate(el, getEventTarget(e));
			if(currentTarget) {
				fn.call(thisObject, e, currentTarget);
			}
		}, thisObject);

		return attachListener(el, eventType, listener);
	};
}



/*
Description:
Relies on the `el.classList.contains`
*/

/*
Degrades:
IE9, IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Chrome 7, FF3.5, Safari 5.0, Opera 11.1, IOS Safari 4.3, Opera Mini 6.0, Opera Mobile 11.0, Android Safari 2.3
*/

/*
Author:
Adam Silver
*/

var hasClass;

if (html && isHostObjectProperty(html, "classList") && isHostMethod(html.classList, "contains") ) {
	hasClass = function(el, className) {
		return el.classList.contains(className);
	};
}




/*
Description:
Relies on `window.addEventListener`. No frames.
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Opera 7.6
*/

/*
Author:
David Mark
*/

var attachWindowListener;

if(window && isHostMethod(window, 'addEventListener')) {
	attachWindowListener = function(eventType, fn) {

		var listener = function(e) {
			fn.call(window, e);
		};

		window.addEventListener(eventType, listener, false);

		return listener;
	};
}



/*
Description:
Relies on `window.page(X/Y)Offset
*/

/*
Author:
David Mark
*/

var getViewportScrollPosition;

if('number' == typeof window.pageXOffset && 'number' == typeof window.pageYOffset ) {
	getViewportScrollPosition = function() {
		return [window.pageXOffset, window.pageYOffset];
	};
}



/*
Description:
Relies on `el.getBoundingClientRect`
*/

//https://groups.google.com/group/comp.lang.javascript/browse_thread/thread/cd625a14ce603084?hl=en&noredirect=true

/*
Author:
David Mark
*/

var getPositionRelativeToViewport;

if(html && isHostMethod(html, 'getBoundingClientRect')) {
	getPositionRelativeToViewport = function(el) {
		var rect = el.getBoundingClientRect();
		return [rect.left, rect.top];
	};
}



/*
Description:
Basic rendition which relies on valid markup i.e. forms with unique names and ids
*/

/*
See: <a href="https://groups.google.com/forum/#!starred/comp.lang.javascript/fVp-DWAIGnc">Article</a>

That's the most basic rendition: no allowance for screwy markup like this:

<input name="test">
<input id="test">
*/

/*
Degrades:
IE4, IE3, NN4
*/

/*
Author:
David Mark
*/

var getElement;

if (isHostMethod(document, 'getElementById')) {
	getElement = function(id, doc) {
		return (doc || document).getElementById(id);
	};
}



/*
Description:
Relies on `jessie.undelegateListener`
*/

/*
could have simply used detachListener
but this reinforces  that this function
expects a delegate listener which was returned
when it was attached
*/

/*
Author:
Adam Silver
*/

var undelegateQueryListener;

if(undelegateListener) {
	undelegateQueryListener = function(el, eventType, listener) {
		return undelegateListener(el, eventType, listener);
	};
}



/*
Description:
Relies on `window.scrollTo`
*/

var setViewportScrollPosition;

if(isHostMethod(global, "scrollTo")) {
	setViewportScrollPosition = function(x, y) {
		window.scrollTo(x, y);
	};
}



var setInputValue;

/*
Description:
setInputValue
*/

setInputValue = function(elInput, value) {
    elInput.value = value;
};


var getViewportSize;

/*

Description:
Will likely *include* space occupied by scroll bars

*** Viewport META

Relies on:
Degrades: IE8
*/


/*
Author: David Mark
*/

if (typeof global.innerWidth == 'number') {
	getViewportSize = function(win /* window */) {
		if (!win) {
			win = window;
		}
		return [win.innerWidth, win.innerHeight]; // Array
	};
}



/*
Description:
Relies on W3C `e.relatedTarget`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Opera 7.6
*/

/*
Author:
David Mark
*/

var getEventTargetRelated;

if(html && isHostMethod(html, 'addEventListener')) {
	getEventTargetRelated = function(e) {
		var target = e.relatedTarget;
		// Check if not an element (e.g. a text node)
		if (1 != target.nodeType) {
			// Set reference to parent node (which must be an element)
			target = target.parentNode;
		}
		return target;
	};
}



/*
Description:
Relies on W3C `window.removeEventListener`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, NN4, Opera 7.6
*/

/*
Author:
David Mark
*/

var detachWindowListener;

if(window && isHostMethod(window, 'removeEventListener')) {
	detachWindowListener = function(eventType, fn) {
		return window.removeEventListener(eventType, fn);
	};
}



/*
Description:
Relies on `jessie.detachListener`
*/

// could have simply used detachListener
// but this reinforces  that this function
// expects a bound listener

/*
Author:
David Mark
*/

var detachBoundListener;

if(detachListener) {
	detachBoundListener = function(el, eventType, boundListener) {
		return detachListener(el, eventType, boundListener);
	};
}



/*
Description:
Relies on `jessie.delegateListener` and `jessie.getElementTagName` and `jessie.getElementParentElement`
*/

/*
Author:
Adam Silver
*/

var delegateTagNameListener;

if(delegateListener && getElementTagName) {
	delegateTagNameListener = function(el, eventType, tagName, fn) {

		var fnDelegate = function(el, target) {
			var sourceNode,
				descendant;

			if(getElementTagName(target) === tagName) {
				sourceNode = target;
			} else {
				descendant = getElementParentElement(target);

				while (null !== descendant && descendant !== el) {
					if (getElementTagName(descendant) === tagName) {
						sourceNode = descendant;
						break;
					}
					descendant = getElementParentElement(descendant);
				}
			}
			return sourceNode;
		};

		return delegateListener(el, eventType, fn, fnDelegate);
	};
}



/*
Description:
Relies on `jessie.isNodeInNodeList`, `jessie.delegateListener`, `jessie.query` and `jessie.isDescendant`
*/

/*
Author:
Adam Silver, Graham Veal
*/

var delegateQueryListener;

if(isNodeInNodeList && delegateListener && query && isDescendant) {

	delegateQueryListener = function(el, eventType, selector, fn) {

		function fnDelegate(target) {

			var elements = query(selector),
				i = 0,
				l,
				el;

			if(isNodeInNodeList(target, elements)) {
				return target;
			}

			// its not in query so loop through by selector
			// if the target is a child of the element then
			// return that element

			for( l = elements.length ; i < l; i++ ) {

				el = elements[i];

				if( isDescendant(el, target) ) {
					return el;
				}
			}
		}

		return delegateListener(el, eventType, fn, fnDelegate);
	};
}



/*
Description:
Relies on `jessie.delegateBoundListener`, `jessie.query`, `jessie.isInQuery` and `jessie.isDecendant`
*/

/*
Author:
Adam Silver
*/

var delegateBoundQueryListener;

if(delegateBoundListener && query && isDescendant) {
	delegateBoundQueryListener = function(el, eventType, selector, fn, thisObject) {

		var fnDelegate = function(el, target) {
			if(isInQuery(target, selector)) {
				return target;
			}

			// its not in query so loop through by selector
			// if the target is a child of the element then
			// return that element
			var elements = jessie.query(selector);
			for(var i = 0; i < elements.length; i++) {
				if( isDescendant(elements[i], target) ) {
					return elements[i];
				}
			}
		};

		return delegateBoundListener(el, eventType, fn, fnDelegate, thisObject);
	};
}



/*
Description:
Relies on `jessie.delegateBoundListener`, `jessie.hasClass`, and `jessie.getElementParentElement`
*/

/*
Author:
Adam Silver
*/

var delegateBoundClassNameListener;

if(delegateBoundListener && hasClass && getElementParentElement) {
	delegateBoundClassNameListener = function(el, eventType, className, fn, thisObject) {

		var fnDelegate = function(el, target) {
			var currentTarget = target;

			if(el === currentTarget) {
				currentTarget = null;
			}

			// traverse up the tree until we find an element with the class or until we find the delegate/el
			while(currentTarget && (currentTarget !== el) && !hasClass(currentTarget, className)) {
				// if we clicked on the delegate/container/el then set to null
				currentTarget = getElementParentElement(currentTarget);
				if(el === currentTarget) {
					currentTarget = null;
				}
			}

			return currentTarget;
		};

		return delegateBoundListener(el, eventType, fn, fnDelegate, thisObject);
	};
}



/*
Description:
Relies on W3C compliant `e.stopPropagation()`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Opera 7.6
*/

/*
Author:
Adam Silver
*/

var cancelPropagation;

if(html && isHostMethod(html, 'addEventListener')) {
	cancelPropagation = function(e) {
		e.stopPropagation();
	};
}



/*
Description:
Relies on W3C compliant `e.preventDefault()`
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3, Opera 7.6
*/

/*
Author:
Adam Silver
*/

var cancelDefault;

if(html && isHostMethod(html, 'addEventListener')) {
	cancelDefault = function(e) {
		e.preventDefault();
	};
}



/*
Description:
Relies on `document.addEventListener`.
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3
*/

var attachDocumentListener;

if(globalDocument && isHostMethod(globalDocument, 'addEventListener') && attachListener) {
	attachDocumentListener = function(eventType, fn) {

		var listener = function(e) {
			fn.call(document, e);
		};

		return attachListener(document, eventType, fn);
	};
}



/*
Description:
Relies on `jessie.bind` and `jessie.attachWindowListener`
*/

/*
Author:
Adam Silver
*/

var attachBoundWindowListener;

if(attachWindowListener && bind) {
	attachBoundWindowListener = function(eventType, fn, thisObject) {
		var listener = bind(fn, thisObject);
		return attachWindowListener(eventType, listener);
	};
}



/*
Description:
Relies on `jessie.bind` and `jessie.attachListener`
*/

/*
Author:
Adam Silver
*/

var attachBoundListener;

if(bind && attachListener) {
	attachBoundListener = function(el, eventType, fn, thisObject) {
		var listener = bind(fn, thisObject);
		thisObject = null;
		return attachListener(el, eventType, listener);
	};
}



/*
Description:
Relies on `el.textContent` or `el.innerText` providing widest browser support.
*/

var setText;

if(html && "string" == typeof html.textContent) {
	setText = function(el, text) {
		el.textContent = text;
	};
} else if(html && "string" == typeof html.innerText) {
	setText = function(el, text) {
		el.innerText = text;
	};
}



var setSize;
if(html && isHostObjectProperty(html, "style")){
  setSize = (function() {
    var px = (typeof html.style.top == 'number') ? 0 : 'px';
    return function(el, h, w) {
      if (h !== null && h >= 0) { el.style.height = h + px; }
      if (w !== null && w >= 0) { el.style.width = w + px; }
    };
  }());
}



var setPosition;
if(html && isHostObjectProperty(html, "style")){
  setPosition = (function(el) {
    var px = (typeof html.style.top == 'number') ? 0 : 'px';
    return function(el, x, y) {
      if (x !== null) { el.style.left = x + px; }
      if (y !== null) { el.style.top = y + px; }
    };
  }());
}



/*
Description:
Relies on `el.innerHTML` which degrades in IE3
*/

/*
See: <a href="https://groups.google.com/forum/#!search/david$20mark$20innerHTML/comp.lang.javascript/QQ9ClOT6igQ/LIZ5QXmmuw0J">Related article</a>
NOTE: Don't use this rendition with anything but DIV's
*/

/*
Degrades:
IE3
*/

/*
Author:
David Mark
*/

var setHtml;

if(html && "string" == typeof html.innerHTML) {
	setHtml = function(el, html) {
		el.innerHTML = html;
	};
}



/*
Description:
Relies on the `el.classList.remove`
*/

/*
Degrades:
Chrome 7, FF3.5, IE9, Safari 5.0, Opera 11.1, IOS Safari 4.3, Opera Mini 6.0, Opera Mobile 11.0, Android Safari 2.3
*/

/*
Author:
Adam Silver
*/

var removeClass;

if (html && isHostObjectProperty(html, "classList") && isHostMethod(html.classList, "remove") ) {
    removeClass = function(el, className) {
			return el.classList.remove(className);
    };
}





/*
Description:
Relies on `el.removeChild`
*/

/*
Author:
Adam Silver
*/

var removeChild;

if(html && isHostMethod(html, "removeChild")) {
	removeChild = function(el, childNode) {
		return el.removeChild(childNode);
	};
}




/*
 Description:
 Relies on `el.insertAdjacentHTML
 IE6 `el.insertAdjacentHtml` does not work on table, tbody, thead, tr elements
 */

/*
 Degrades:
 IE3, Firefox 7, Safari 3, Opera 7
 */

/*
 Author:
 Ben Chidgey
 */

var prependHtml;

if (html && isHostMethod(html, 'insertAdjacentHTML')) {
	prependHtml = function (el, html) {
		el.insertAdjacentHTML('afterBegin', html);
	};
}



/*
Description:
Relies on `el.textContent` or `el.innerText` providing widest browser support.
*/

var getText;

if(html && "string" == typeof html.textContent) {
	getText = function(el) {
		return el.textContent;
	};
} else if(html && "string" == typeof html.innerText) {
	getText = function(el) {
		return el.innerText;
	};
}



/*
Description:
Relies on `document.defaultView.getComputedStyle` which degrades in IE8-
and compatibility modes. No float styles with this one and camel-case
names.
*/

/*
Degrades:
IE8, IE7, IE6, IE5.5, IE5, IE4, IE3
*/

/*
Author:
David Mark
*/

var getStyleComputed;

if (isHostObjectProperty(globalDocument, 'defaultView') &&
	isHostMethod(globalDocument.defaultView, 'getComputedStyle')) {
	getStyleComputed = function(el, style) {

		return document.defaultView.getComputedStyle(el, null)[style];
	};
}



/*
Description:

Note: no borders on the HTML element as that can add cross-browser complications (part of the chrome in IE and other MSHTML-based browsers, not so in others) and no quirks mode (as the BODY then becomes outermost element in the layout in IE and the BODY should be allowed to have borders).
*/

/*
Degrades:
*/

/*
Author:
Adam Silver
*/

var getPositionRelativeToDocument;

if(getPositionRelativeToViewport && getViewportScrollPosition) {
	getPositionRelativeToDocument = function(el) {
		var position = getPositionRelativeToViewport(el),
			scrollPosition = getViewportScrollPosition(),
			x = position[0]+scrollPosition[0],
			y = position[1]+scrollPosition[1];

		return [x, y];
	};
}



/*
Description:
Relies on `el.offsetWidth/Height`
*/

/*
Degrades:
IE3
*/

/*
Author:
David Mark
*/

var getOuterSize;

if(html && typeof html.offsetWidth == 'number') {
	getOuterSize = function(el) {
		return [el.offsetHeight, el.offsetWidth];
	};
}



/*
Description:
Relies on `el.clientWidth/Height`
*/

/*
Degrades:
IE3
*/

/*
Author:
David Mark
*/

var getInnerSize;

if(html && typeof html.clientWidth == 'number') {
	getInnerSize = function(el) {
		return [el.clientHeight, el.clientWidth];
	};
}



/*
Description:
Relies on `el.innerHTML`
*/

// See: https://groups.google.com/forum/#!search/david$20mark$20innerHTML/comp.lang.javascript/QQ9ClOT6igQ/LIZ5QXmmuw0J

/*
Degrades:
IE3
*/

/*
Author:
David Mark
*/

var getHtml;

if(html && "string" == typeof html.innerHTML) {
	getHtml = function(el) {
		return el.innerHTML;
	};
}


/*
Description:
Relies on 'document.getElementsByTagName'
*/

var getDescendantsByTagName;

if(globalDocument && isHostMethod(globalDocument, "getElementsByTagName") && toArray) {
	getDescendantsByTagName = function(el, tagName) {
		return toArray((el || document).getElementsByTagName(tagName));
	};
}



/*
Description:
Relies on 'document.getElementsByClassName'
*/

var getDescendantsByClassName;

if (globalDocument && isHostMethod(globalDocument, "getElementsByClassName") && toArray) {
	getDescendantsByClassName = function(el, className) {
		return toArray((el || document).getElementsByClassName(className));
	};
}



/*
Description:
Relies on `jessie.getElementParentElement` and `jessie.getElementTagName`
*/

var getAncestorByTagName;

if(getElementParentElement && getElementTagName){
	getAncestorByTagName = function(el, tagName) {
		el = getElementParentElement(el);
		while (el && tagName && getElementTagName(el) != tagName) {
			el = getElementParentElement(el);
		}
		return el;
	};
}



/*
Description:
Relies on `el.className` property, `jessie.getElementParentElement` and `jessie.hasClass`
*/

var getAncestorByClassName;

if(html && 'string' == typeof html.className && getElementParentElement && hasClass) {
	getAncestorByClassName = function(el, className) {
		el = getElementParentElement(el);
		while (el && !hasClass(el, className)) {
			el = getElementParentElement(el);
		}
		return el;
	};
}



var findProprietaryStyle;

if(html && isHostObjectProperty(html, "style")){
	findProprietaryStyle = function (style, el) {
		if ('string' != typeof el.style[style]) {
			var prefixes = ['Moz', 'O', 'Khtml', 'Webkit', 'Ms'],
			i = prefixes.length;
			style = style.charAt(0).toUpperCase() + style.substring(1);
			while ( i-- ) {
				if ('undefined' != typeof el.style[prefixes[i] + style]) {
					return prefixes[i] + style;
				}
			}
			return null;
		}
		return style;
	};
}




/*
Description:
Relies on `document.createElement`
*/

/*
Author:
David Mark
*/

var createElement;

if(globalDocument && isHostMethod(globalDocument, "createElement")) {
	createElement = function(tagName, doc) {
		return (doc || document).createElement(tagName);
	};
}


/* */

var htmlToNodes;

/*
 * htmlToNodes
 *
 * Relies on 'jessie.setHtml' and 'jessie.createElement'
 *
 */

if (setHtml && createElement) {
    htmlToNodes = function(html, docNode) {
        var c;

        elTemp = createElement('div', docNode);

        if (elTemp) {
            setHtml(html);
            c = elTemp.childNodes;
            elTemp = null;
        }

        return c;
    };
}





/*
 Description:
 Relies on `el.insertAdjacentHTML
 IE6 `el.insertAdjacentHtml` does not work on table, tbody, thead, tr elements
 */

/*
 Degrades:
 IE3, Firefox 7, Safari 3, Opera 7
 */

/*
 Author:
 Ben Chidgey
 */

var appendHtml;

if (html && isHostMethod(html, 'insertAdjacentHTML')) {
	appendHtml = function (el, html) {
		el.insertAdjacentHTML('beforeEnd', html);
	};
}



/*
Description:
Relies on `el.appendChild`
*/

/*
Author:
Adam Silver
*/

var appendChild;

if(html && isHostMethod(html, 'appendChild')) {
	appendChild = function(el, appendEl) {
		return el.appendChild(appendEl);
	};
}




/*
Description:
Relies on the `el.classList.add`
*/

/*
Degrades:
IE9, IE8, IE7, IE6, IE5.5, IE5, IE4, IE3 Chrome 7, FF3.5, Safari 5.0, Opera 11.1, IOS Safari 4.3, Opera Mini 6.0, Opera Mobile 11.0, Android Safari 2.3
*/

/*
See:
This is the see also section
*/

/*
Author:
Adam Silver
*/

var addClass;

if (html && isHostObjectProperty(html, "classList") && isHostMethod(html.classList, "add") ) {
	addClass = function(el, className) {
		return el.classList.add(className);
	};
}


KD.dom.isHostMethod = isHostMethod;
KD.dom.isHostObjectProperty = isHostObjectProperty;
KD.dom.areFeatures = areFeatures;
KD.dom.toArray = toArray;
KD.dom.detachListener = detachListener;
KD.dom.getEventTarget = getEventTarget;
KD.dom.attachListener = attachListener;
KD.dom.query = query;
KD.dom.queryOne = queryOne;
KD.dom.isNodeInNodeList = isNodeInNodeList;
KD.dom.bind = bind;
KD.dom.undelegateListener = undelegateListener;
KD.dom.delegateListener = delegateListener;
KD.dom.getElementTagName = getElementTagName;
KD.dom.getElementParentElement = getElementParentElement;
KD.dom.isInQuery = isInQuery;
KD.dom.isDescendant = isDescendant;
KD.dom.delegateBoundListener = delegateBoundListener;
KD.dom.hasClass = hasClass;
KD.dom.attachWindowListener = attachWindowListener;
KD.dom.getViewportScrollPosition = getViewportScrollPosition;
KD.dom.getPositionRelativeToViewport = getPositionRelativeToViewport;
KD.dom.getElement = getElement;
KD.dom.undelegateQueryListener = undelegateQueryListener;
KD.dom.setViewportScrollPosition = setViewportScrollPosition;
KD.dom.setInputValue = setInputValue;
KD.dom.getViewportSize = getViewportSize;
KD.dom.getEventTargetRelated = getEventTargetRelated;
KD.dom.detachWindowListener = detachWindowListener;
KD.dom.detachBoundListener = detachBoundListener;
KD.dom.delegateTagNameListener = delegateTagNameListener;
KD.dom.delegateQueryListener = delegateQueryListener;
KD.dom.delegateBoundQueryListener = delegateBoundQueryListener;
KD.dom.delegateBoundClassNameListener = delegateBoundClassNameListener;
KD.dom.cancelPropagation = cancelPropagation;
KD.dom.cancelDefault = cancelDefault;
KD.dom.attachDocumentListener = attachDocumentListener;
KD.dom.attachBoundWindowListener = attachBoundWindowListener;
KD.dom.attachBoundListener = attachBoundListener;
KD.dom.setText = setText;
KD.dom.setSize = setSize;
KD.dom.setPosition = setPosition;
KD.dom.setHtml = setHtml;
KD.dom.removeClass = removeClass;
KD.dom.removeChild = removeChild;
KD.dom.prependHtml = prependHtml;
KD.dom.getText = getText;
KD.dom.getStyleComputed = getStyleComputed;
KD.dom.getPositionRelativeToDocument = getPositionRelativeToDocument;
KD.dom.getOuterSize = getOuterSize;
KD.dom.getInnerSize = getInnerSize;
KD.dom.getHtml = getHtml;
KD.dom.getDescendantsByTagName = getDescendantsByTagName;
KD.dom.getDescendantsByClassName = getDescendantsByClassName;
KD.dom.getAncestorByTagName = getAncestorByTagName;
KD.dom.getAncestorByClassName = getAncestorByClassName;
KD.dom.findProprietaryStyle = findProprietaryStyle;
KD.dom.createElement = createElement;
KD.dom.htmlToNodes = htmlToNodes;
KD.dom.appendHtml = appendHtml;
KD.dom.appendChild = appendChild;
KD.dom.addClass = addClass;

	globalDocument = html = null;

}(window));

module.exports = KD.dom;
},{}],102:[function(require,module,exports){
var KD, KDEventEmitter, KDObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

KD = require('./kd.coffee');

KDEventEmitter = require('./eventemitter.coffee');

module.exports = KDObject = (function(_super) {
  var NOTREADY, READY, _ref;

  __extends(KDObject, _super);

  _ref = [0, 1], NOTREADY = _ref[0], READY = _ref[1];

  KDObject.prototype.utils = KD.utils;

  function KDObject(options, data) {
    if (options == null) {
      options = {};
    }
    this.id || (this.id = options.id || KD.utils.getUniqueId());
    this.setOptions(options);
    if (data) {
      this.setData(data);
    }
    if (options.delegate) {
      this.setDelegate(options.delegate);
    }
    this.registerKDObjectInstance();
    KDObject.__super__.constructor.apply(this, arguments);
    if (options.testPath) {
      KD.registerInstanceForTesting(this);
    }
    this.on('error', error);
    this.once('ready', (function(_this) {
      return function() {
        return _this.readyState = READY;
      };
    })(this));
  }

  KDObject.prototype.bound = function(method) {
    var boundMethod;
    if ('function' !== typeof this[method]) {
      throw new Error("bound: unknown method! " + method);
    }
    boundMethod = "__bound__" + method;
    boundMethod in this || Object.defineProperty(this, boundMethod, {
      value: this[method].bind(this)
    });
    return this[boundMethod];
  };

  KDObject.prototype.lazyBound = function() {
    var method, rest, _ref1;
    method = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return (_ref1 = this[method]).bind.apply(_ref1, [this].concat(__slice.call(rest)));
  };

  KDObject.prototype.forwardEvent = function(target, eventName, prefix) {
    if (prefix == null) {
      prefix = "";
    }
    return target.on(eventName, this.lazyBound('emit', prefix + eventName));
  };

  KDObject.prototype.forwardEvents = function(target, eventNames, prefix) {
    var eventName, _i, _len, _results;
    if (prefix == null) {
      prefix = "";
    }
    _results = [];
    for (_i = 0, _len = eventNames.length; _i < _len; _i++) {
      eventName = eventNames[_i];
      _results.push(this.forwardEvent(target, eventName, prefix));
    }
    return _results;
  };

  KDObject.prototype.ready = function(listener) {
    if (typeof Promise !== "undefined" && Promise !== null ? Promise.prototype.nodeify : void 0) {
      return new Promise((function(_this) {
        return function(resolve) {
          if (_this.readyState === READY) {
            resolve();
          }
          return _this.once('ready', resolve);
        };
      })(this)).nodeify(listener);
    } else if (this.readyState === READY) {
      return this.utils.defer(listener);
    } else {
      return this.once('ready', listener);
    }
  };

  KDObject.prototype.registerSingleton = KD.registerSingleton;

  KDObject.prototype.getSingleton = KD.getSingleton;

  KDObject.prototype.getInstance = function(instanceId) {
    var _ref1;
    return (_ref1 = KD.getAllKDInstances()[instanceId]) != null ? _ref1 : null;
  };

  KDObject.prototype.registerKDObjectInstance = function() {
    return KD.registerInstance(this);
  };

  KDObject.prototype.setData = function(data) {
    this.data = data;
  };

  KDObject.prototype.getData = function() {
    return this.data;
  };

  KDObject.prototype.setOptions = function(options) {
    this.options = options != null ? options : {};
  };

  KDObject.prototype.setOption = function(option, value) {
    return this.options[option] = value;
  };

  KDObject.prototype.unsetOption = function(option) {
    if (this.options[option]) {
      return delete this.options[option];
    }
  };

  KDObject.prototype.getOptions = function() {
    return this.options;
  };

  KDObject.prototype.getOption = function(key) {
    var _ref1;
    return (_ref1 = this.options[key]) != null ? _ref1 : null;
  };

  KDObject.prototype.changeId = function(id) {
    KD.deleteInstance(id);
    this.id = id;
    return KD.registerInstance(this);
  };

  KDObject.prototype.getId = function() {
    return this.id;
  };

  KDObject.prototype.setDelegate = function(delegate) {
    this.delegate = delegate;
  };

  KDObject.prototype.getDelegate = function() {
    return this.delegate;
  };

  KDObject.prototype.destroy = function() {
    this.isDestroyed = true;
    this.emit('KDObjectWillBeDestroyed');
    return KD.deleteInstance(this.id);
  };

  KDObject.prototype.chainNames = function(options) {
    options.chain;
    options.newLink;
    return "" + options.chain + "." + options.newLink;
  };

  return KDObject;

})(KDEventEmitter);


},{"./eventemitter.coffee":98,"./kd.coffee":100}],103:[function(require,module,exports){
var KDNotificationView, KDObject, KDRouter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

KDObject = require('./object.coffee');

KDNotificationView = require('./../components/notifications/notificationview.coffee');

module.exports = KDRouter = (function(_super) {
  var createObjectRef, history, listenerKey, revive, routeWithoutEdgeAtIndex;

  __extends(KDRouter, _super);

  history = window.history;

  listenerKey = 'ಠ_ಠ';

  KDRouter.registerStaticEmitter();

  createObjectRef = function(obj) {
    var _ref;
    if (!(((obj != null ? obj.bongo_ : void 0) != null) && (obj.getId != null))) {
      return;
    }
    return {
      constructorName: (_ref = obj.bongo_) != null ? _ref.constructorName : void 0,
      id: obj.getId()
    };
  };

  revive = function(objRef, callback) {
    if (!(((objRef != null ? objRef.constructorName : void 0) != null) && (objRef.id != null))) {
      return callback(null);
    } else {
      return KD.remote.cacheable(objRef.constructorName, objRef.id, callback);
    }
  };

  function KDRouter(routes) {
    KDRouter.__super__.constructor.call(this);
    this.tree = {};
    this.routes = {};
    this.visitedRoutes = [];
    if (routes) {
      this.addRoutes(routes);
    }
    KD.utils.defer((function(_this) {
      return function() {
        return KDRouter.emit('RouterIsReady', _this);
      };
    })(this));
  }

  KDRouter.prototype.listen = function() {
    var hashFragment;
    if (location.hash.length) {
      hashFragment = location.hash.substr(1);
      this.userRoute = hashFragment;
      this.utils.defer((function(_this) {
        return function() {
          return _this.handleRoute(hashFragment, {
            shouldPushState: true,
            replaceState: true
          });
        };
      })(this));
    }
    return this.startListening();
  };

  KDRouter.prototype.popState = function(event) {
    return revive(event.state, (function(_this) {
      return function(err, state) {
        if (err) {
          return KD.showError(err);
        }
        return _this.handleRoute("" + location.pathname + location.search, {
          shouldPushState: false,
          state: state
        });
      };
    })(this));
  };

  KDRouter.prototype.clear = function(route, replaceState) {
    if (route == null) {
      route = '/';
    }
    if (replaceState == null) {
      replaceState = true;
    }
    delete this.userRoute;
    return this.handleRoute(route, {
      replaceState: replaceState
    });
  };

  KDRouter.prototype.back = function() {
    if (this.visitedRoutes.length <= 1) {
      return this.clear();
    } else {
      return history.back();
    }
  };

  KDRouter.prototype.startListening = function() {
    if (this.isListening) {
      return false;
    }
    this.isListening = true;
    window.addEventListener('popstate', this.bound("popState"));
    return true;
  };

  KDRouter.prototype.stopListening = function() {
    if (!this.isListening) {
      return false;
    }
    this.isListening = false;
    window.removeEventListener('popstate', this.bound("popState"));
    return true;
  };

  KDRouter.handleNotFound = function(route) {
    console.trace();
    return log("The route " + (Encoder.XSSEncode(route)) + " was not found!");
  };

  KDRouter.prototype.getCurrentPath = function() {
    return this.currentPath;
  };

  KDRouter.prototype.handleNotFound = function(route) {
    var message;
    message = /<|>/.test(route) ? "Invalid route!" : "404 Not found! " + (Encoder.XSSEncode(route));
    delete this.userRoute;
    this.clear();
    log("The route " + route + " was not found!");
    return new KDNotificationView({
      title: message
    });
  };

  routeWithoutEdgeAtIndex = function(route, i) {
    return "/" + (route.slice(0, i).concat(route.slice(i + 1)).join('/'));
  };

  KDRouter.prototype.addRoute = function(route, listener) {
    var edge, i, last, node, _i, _len;
    this.routes[route] = listener;
    node = this.tree;
    route = route.split('/');
    route.shift();
    for (i = _i = 0, _len = route.length; _i < _len; i = ++_i) {
      edge = route[i];
      last = edge.length - 1;
      if ('?' === edge.charAt(last)) {
        this.addRoute(routeWithoutEdgeAtIndex(route, i), listener);
        edge = edge.substr(0, last);
      }
      if (/^:/.test(edge)) {
        node[':'] || (node[':'] = {
          name: edge.substr(1)
        });
        node = node[':'];
      } else {
        node[edge] || (node[edge] = {});
        node = node[edge];
      }
    }
    node[listenerKey] || (node[listenerKey] = []);
    if (__indexOf.call(node[listenerKey], listener) < 0) {
      return node[listenerKey].push(listener);
    }
  };

  KDRouter.prototype.addRoutes = function(routes) {
    var listener, route, _results;
    _results = [];
    for (route in routes) {
      if (!__hasProp.call(routes, route)) continue;
      listener = routes[route];
      _results.push(this.addRoute(route, listener));
    }
    return _results;
  };

  KDRouter.prototype.handleRoute = function(userRoute, options) {
    var edge, frag, listener, listeners, method, node, objRef, param, params, path, qs, query, replaceState, routeInfo, shouldPushState, state, suppressListeners, _i, _j, _len, _len1, _ref, _ref1;
    if (options == null) {
      options = {};
    }
    if (/<|>/.test(userRoute)) {
      return this.handleRoute('/Activity');
    }
    if ((userRoute.indexOf('!')) === 0) {
      userRoute = userRoute.slice(1);
    }
    if (this.visitedRoutes.last !== userRoute) {
      this.visitedRoutes.push(userRoute);
    }
    _ref1 = ((_ref = userRoute != null ? userRoute : typeof this.getDefaultRoute === "function" ? this.getDefaultRoute() : void 0) != null ? _ref : '/').split('?'), frag = _ref1[0], query = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
    query = this.utils.parseQuery(query.join('&'));
    shouldPushState = options.shouldPushState, replaceState = options.replaceState, state = options.state, suppressListeners = options.suppressListeners;
    if (shouldPushState == null) {
      shouldPushState = true;
    }
    objRef = createObjectRef(state);
    node = this.tree;
    params = {};
    frag = frag.split('/');
    frag.shift();
    frag = frag.filter(Boolean);
    path = "/" + (frag.join('/'));
    qs = this.utils.stringifyQuery(query);
    if (qs.length) {
      path += "?" + qs;
    }
    if (!suppressListeners && shouldPushState && !replaceState && path === this.currentPath) {
      this.emit('AlreadyHere', path);
      return;
    }
    this.currentPath = path;
    if (shouldPushState) {
      method = replaceState ? 'replaceState' : 'pushState';
      history[method](objRef, path, path);
    }
    for (_i = 0, _len = frag.length; _i < _len; _i++) {
      edge = frag[_i];
      if (node[edge]) {
        node = node[edge];
      } else {
        param = node[':'];
        if (param != null) {
          params[param.name] = edge;
          node = param;
        } else {
          this.handleNotFound(frag.join('/'));
        }
      }
    }
    routeInfo = {
      params: params,
      query: query
    };
    this.emit('RouteInfoHandled', {
      params: params,
      query: query,
      path: path
    });
    if (!suppressListeners) {
      listeners = node[listenerKey];
      if (listeners != null ? listeners.length : void 0) {
        for (_j = 0, _len1 = listeners.length; _j < _len1; _j++) {
          listener = listeners[_j];
          listener.call(this, routeInfo, state, path);
        }
      }
    }
    return this;
  };

  KDRouter.prototype.handleQuery = function(query) {
    var nextRoute;
    if ('string' !== typeof query) {
      query = this.utils.stringifyQuery(query);
    }
    if (!query.length) {
      return;
    }
    nextRoute = "" + this.currentPath + "?" + query;
    return this.handleRoute(nextRoute);
  };

  return KDRouter;

})(KDObject);


},{"./../components/notifications/notificationview.coffee":61,"./object.coffee":102}],104:[function(require,module,exports){
var _base, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;

(_base = Function.prototype).bind || (_base.bind = function(context) {
  var args;
  if (1 < arguments.length) {
    args = [].slice.call(arguments, 1);
    return (function(_this) {
      return function() {
        return _this.apply(context, arguments.length ? args.concat([].slice.call(arguments)) : args);
      };
    })(this);
  }
  return (function(_this) {
    return function() {
      if (arguments.length) {
        return _this.apply(context, arguments);
      } else {
        return _this.call(context);
      }
    };
  })(this);
});

if (window.URL == null) {
  window.URL = (_ref = window.webkitURL) != null ? _ref : null;
}

if (window.BlobBuilder == null) {
  window.BlobBuilder = (_ref1 = (_ref2 = window.WebKitBlobBuilder) != null ? _ref2 : window.MozBlobBuilder) != null ? _ref1 : null;
}

if (window.requestFileSystem == null) {
  window.requestFileSystem = (_ref3 = window.webkitRequestFileSystem) != null ? _ref3 : null;
}

if (window.requestAnimationFrame == null) {
  window.requestAnimationFrame = (_ref4 = (_ref5 = window.webkitRequestAnimationFrame) != null ? _ref5 : window.mozRequestAnimationFrame) != null ? _ref4 : null;
}

String.prototype.capitalize = function() {
  return this.charAt(0).toUpperCase() + this.slice(1);
};

String.prototype.trim = function() {
  return this.replace(/^\s+|\s+$/g, "");
};

(function(arrayProto, _arg) {
  var defineProperty;
  defineProperty = _arg.defineProperty;
  "last" in arrayProto || defineProperty(arrayProto, "last", {
    get: function() {
      return this[this.length - 1];
    }
  });
  return "first" in arrayProto || defineProperty(arrayProto, "first", {
    get: function() {
      return this[0];
    }
  });
})(Array.prototype, Object);


},{}],105:[function(require,module,exports){
var createCounter,
  __slice = [].slice;

module.exports = {
  idCounter: 0,
  extend: function() {
    var key, source, sources, target, val, _i, _len;
    target = arguments[0], sources = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      for (key in source) {
        val = source[key];
        target[key] = val;
      }
    }
    return target;
  },
  dict: Object.create.bind(null, null, Object.create(null)),
  getNearestElementByTagName: function(el, tagName) {
    while (!((el == null) || this.elementHasTag(el, tagName))) {
      el = el.parentNode;
    }
    return el;
  },
  elementShow: function(el) {
    return el != null ? el.classList.remove("hidden") : void 0;
  },
  elementHide: function(el) {
    return el != null ? el.classList.add("hidden") : void 0;
  },
  elementHasTag: function(el, tagName) {
    var _ref;
    return Boolean(((_ref = el.tagName) != null ? _ref.toLowerCase() : void 0) === tagName.toLowerCase());
  },
  elementIsVisible: function(el) {
    var height, i, inViewport, l, onTop, r, rects;
    if (el.offsetWidth <= 0 || el.offsetHeight <= 0) {
      return false;
    }
    height = document.documentElement.clientHeight;
    rects = el.getClientRects();
    onTop = function(r) {
      var x, y;
      x = (r.left + r.right) / 2;
      y = (r.top + r.bottom) / 2;
      return document.elementFromPoint(x, y) === el;
    };
    i = 0;
    l = rects.length;
    while (i < l) {
      r = rects[i];
      inViewport = (r.top > 0 ? r.top <= height : r.bottom > 0 && r.bottom <= height);
      if (inViewport && onTop(r)) {
        return true;
      }
      i++;
    }
    return false;
  },
  formatPlural: function(count, noun, showCount) {
    if (showCount == null) {
      showCount = true;
    }
    return "" + (showCount ? "" + (count || 0) + " " : '') + (count === 1 ? noun : Inflector.pluralize(noun));
  },
  formatIndefiniteArticle: function(noun) {
    var _ref;
    if ((_ref = noun[0].toLowerCase()) === 'a' || _ref === 'e' || _ref === 'i' || _ref === 'o' || _ref === 'u') {
      return "an " + noun;
    }
    return "a " + noun;
  },
  getSelection: function() {
    return window.getSelection();
  },
  getSelectionRange: function() {
    var selection;
    selection = this.getSelection();
    if (selection.type !== "None") {
      return selection.getRangeAt(0);
    }
  },
  getCursorNode: function() {
    return this.getSelectionRange().commonAncestorContainer;
  },
  addRange: function(range) {
    var selection;
    selection = window.getSelection();
    selection.removeAllRanges();
    return selection.addRange(range);
  },
  selectText: function(element, start, end) {
    var range, selection;
    if (end == null) {
      end = start;
    }
    if (document.body.createTextRange) {
      range = document.body.createTextRange();
      range.moveToElementText(element);
      return range.select();
    } else if (window.getSelection) {
      selection = window.getSelection();
      range = document.createRange();
      range.selectNodeContents(element);
      if (start != null) {
        range.setStart(element, start);
      }
      if (end != null) {
        range.setEnd(element, end);
      }
      selection.removeAllRanges();
      return selection.addRange(range);
    }
  },
  selectEnd: function(element, range) {
    range || (range = document.createRange());
    element || (element = this.getSelection().focusNode);
    if (!element) {
      return;
    }
    range.setStartAfter(element);
    range.collapse(false);
    return this.addRange(range);
  },
  replaceRange: function(node, replacement, start, end, appendTrailingSpace) {
    var range, trailingSpace;
    if (end == null) {
      end = start;
    }
    if (appendTrailingSpace == null) {
      appendTrailingSpace = true;
    }
    trailingSpace = document.createTextNode("\u00a0");
    range = new Range();
    if (start != null) {
      range.setStart(node, start);
      range.setEnd(node, end);
    } else {
      range.selectNode(node);
    }
    range.deleteContents();
    range.insertNode(replacement);
    this.selectEnd(replacement, range);
    if (appendTrailingSpace) {
      range.insertNode(trailingSpace);
      return this.selectEnd(trailingSpace, range);
    }
  },
  getCallerChain: function(args, depth) {
    var caller, chain;
    caller = args.callee.caller;
    chain = [caller];
    while (depth-- && (caller = caller != null ? caller.caller : void 0)) {
      chain.push(caller);
    }
    return chain;
  },
  createCounter: createCounter = function(i) {
    if (i == null) {
      i = 0;
    }
    return function() {
      return i++;
    };
  },
  getUniqueId: (function(inc) {
    return function() {
      return "kd-" + (inc());
    };
  })(createCounter()),
  getRandomNumber: function(range, min) {
    var res;
    if (range == null) {
      range = 1e6;
    }
    if (min == null) {
      min = 0;
    }
    res = Math.floor(Math.random() * range + 1);
    if (res > min) {
      return res;
    } else {
      return res + min;
    }
  },
  uniqueId: function(prefix) {
    var id;
    id = this.idCounter++;
    if (prefix != null) {
      return "" + prefix + id;
    } else {
      return id;
    }
  },
  getRandomRGB: function() {
    var getRandomNumber;
    getRandomNumber = this.getRandomNumber;
    return "rgb(" + (getRandomNumber(255)) + "," + (getRandomNumber(255)) + "," + (getRandomNumber(255)) + ")";
  },
  getRandomHex: function() {
    var hex;
    hex = (Math.random() * 0x999999 << 0).toString(16);
    while (hex.length < 6) {
      hex += "0";
    }
    return "#" + hex;
  },
  curry: function(obligatory, optional) {
    return obligatory + (optional ? ' ' + optional : '');
  },
  parseQuery: (function() {
    var decode, params, parseQuery, plusses;
    params = /([^&=]+)=?([^&]*)/g;
    plusses = /\+/g;
    decode = function(str) {
      return decodeURIComponent(str.replace(plusses, " "));
    };
    return parseQuery = function(queryString) {
      var m, result;
      if (queryString == null) {
        queryString = location.search.substring(1);
      }
      result = {};
      while (m = params.exec(queryString)) {
        result[decode(m[1])] = decode(m[2]);
      }
      return result;
    };
  })(),
  stringifyQuery: (function() {
    var encode, spaces, stringifyQuery;
    spaces = /\s/g;
    encode = function(str) {
      return encodeURIComponent(str.replace(spaces, "+"));
    };
    return stringifyQuery = function(obj) {
      return Object.keys(obj).map(function(key) {
        return "" + (encode(key)) + "=" + (encode(obj[key]));
      }).join('&').trim();
    };
  })(),
  capAndRemovePeriods: function(path) {
    var arg, newPath;
    newPath = (function() {
      var _i, _len, _ref, _results;
      _ref = path.split(".");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        _results.push(arg.capitalize());
      }
      return _results;
    })();
    return newPath.join("");
  },
  slugify: function(title) {
    var url;
    if (title == null) {
      title = "";
    }
    return url = String(title).toLowerCase().replace(/^\s+|\s+$/g, "").replace(/[_|\s]+/g, "-").replace(/[^a-z0-9-]+/g, "").replace(/[-]+/g, "-").replace(/^-+|-+$/g, "");
  },
  stripTags: function(value) {
    return value.replace(/<(?:.|\n)*?>/gm, '');
  },
  decimalToAnother: function(n, radix) {
    var a, b, hex, i, s, t, _i, _j;
    hex = [];
    for (i = _i = 0; _i <= 10; i = ++_i) {
      hex[i + 1] = i;
    }
    s = '';
    a = n;
    while (a >= radix) {
      b = a % radix;
      a = Math.floor(a / radix);
      s += hex[b + 1];
    }
    s += hex[a + 1];
    n = s.length;
    t = '';
    for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
      t = t + s.substring(n - i - 1, n - i);
    }
    s = t;
    return s;
  },
  applyMarkdown: function(text, options) {
    if (options == null) {
      options = {};
    }
    if (!text) {
      return null;
    }
    if (options.gfm == null) {
      options.gfm = true;
    }
    if (options.pedantic == null) {
      options.pedantic = false;
    }
    if (options.sanitize == null) {
      options.sanitize = true;
    }
    if (options.highlight == null) {
      options.highlight = function(text, lang) {
        if (hljs.getLanguage(lang)) {
          return hljs.highlight(lang, text).value;
        } else {
          return text;
        }
      };
    }
    return marked(Encoder.htmlDecode(text), options);
  },
  enterFullscreen: (function() {
    var launchFullscreen;
    launchFullscreen = function(element) {
      if (element.requestFullscreen) {
        return element.requestFullscreen();
      } else if (element.mozRequestFullScreen) {
        return element.mozRequestFullScreen();
      } else if (element.webkitRequestFullscreen) {
        return element.webkitRequestFullscreen();
      } else if (element.msRequestFullscreen) {
        return element.msRequestFullscreen();
      }
    };
    return function(element) {
      if (element == null) {
        element = document.documentElement;
      }
      return launchFullscreen(element);
    };
  })(),
  exitFullscreen: function() {
    if (document.exitFullscreen) {
      return document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      return document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      return document.webkitExitFullscreen();
    }
  },
  isFullscreen: function() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitIsFullScreen;
  },
  createExternalLink: function(href) {
    var tag;
    tag = document.createElement("a");
    tag.href = href.indexOf("http") > -1 ? href : "http://" + href;
    tag.target = "_blank";
    document.body.appendChild(tag);
    tag.click();
    return document.body.removeChild(tag);
  },
  wait: function(duration, fn) {
    if ("function" === typeof duration) {
      fn = duration;
      duration = 0;
    }
    return setTimeout(fn, duration);
  },
  killWait: function(id) {
    if (id) {
      clearTimeout(id);
    }
    return null;
  },
  repeat: function(duration, fn) {
    if ("function" === typeof duration) {
      fn = duration;
      duration = 500;
    }
    return setInterval(fn, duration);
  },
  killRepeat: function(id) {
    return clearInterval(id);
  },
  defer: (function(queue) {
    if ((typeof window !== "undefined" && window !== null ? window.postMessage : void 0) && window.addEventListener) {
      window.addEventListener("message", (function(ev) {
        if (ev.source === window && ev.data === "kd-tick") {
          ev.stopPropagation();
          if (queue.length > 0) {
            return queue.shift()();
          }
        }
      }), true);
      return function(fn) {
        queue.push(fn);
        return window.postMessage("kd-tick", "*");
      };
    } else {
      return function(fn) {
        return setTimeout(fn, 1);
      };
    }
  })([]),
  getCancellableCallback: function(callback) {
    var cancelled, kallback;
    cancelled = false;
    kallback = function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!cancelled) {
        return callback.apply(null, rest);
      }
    };
    kallback.cancel = function() {
      return cancelled = true;
    };
    return kallback;
  },
  getTimedOutCallback: function(callback, failcallback, timeout) {
    var cancelled, fallback, fallbackTimer, kallback;
    if (timeout == null) {
      timeout = 5000;
    }
    cancelled = false;
    kallback = function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      clearTimeout(fallbackTimer);
      if (!cancelled) {
        return callback.apply(null, rest);
      }
    };
    fallback = function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (!cancelled) {
        failcallback.apply(null, rest);
      }
      return cancelled = true;
    };
    fallbackTimer = setTimeout(fallback, timeout);
    return kallback;
  },
  getTimedOutCallbackOne: function(options) {
    var fallback, fallbackTimer, kallback, onResult, onSuccess, onTimeout, timedOut, timeout, timerName;
    if (options == null) {
      options = {};
    }
    timerName = options.name || "undefined";
    timeout = options.timeout || 10000;
    onSuccess = options.onSuccess || function() {};
    onTimeout = options.onTimeout || function() {};
    onResult = options.onResult || function() {};
    timedOut = false;
    kallback = (function(_this) {
      return function() {
        var rest;
        rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        clearTimeout(fallbackTimer);
        _this.updateLogTimer(timerName, fallbackTimer, Date.now());
        if (timedOut) {
          return onResult.apply(null, rest);
        } else {
          return onSuccess.apply(null, rest);
        }
      };
    })(this);
    fallback = (function(_this) {
      return function() {
        var rest;
        rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        timedOut = true;
        _this.updateLogTimer(timerName, fallbackTimer);
        return onTimeout.apply(null, rest);
      };
    })(this);
    fallbackTimer = setTimeout(fallback, timeout);
    this.logTimer(timerName, fallbackTimer, Date.now());
    kallback.cancel = function() {
      return clearTimeout(fallbackTimer);
    };
    return kallback;
  },
  logTimer: function(timerName, timerNumber, startTime) {
    var _base;
    log("logTimer name:" + timerName);
    (_base = this.timers)[timerName] || (_base[timerName] = {});
    return this.timers[timerName][timerNumber] = {
      start: startTime,
      status: "started"
    };
  },
  updateLogTimer: function(timerName, timerNumber, endTime) {
    var elapsed, startTime, status, timer;
    timer = this.timers[timerName][timerNumber];
    status = endTime ? "ended" : "failed";
    startTime = timer.start;
    elapsed = endTime - startTime;
    timer = {
      start: startTime,
      end: endTime,
      status: status,
      elapsed: elapsed
    };
    this.timers[timerName][timerNumber] = timer;
    return log("updateLogTimer name:" + timerName + ", status:" + status + " elapsed:" + elapsed);
  },
  timers: {},
  stopDOMEvent: function(event) {
    if (!event) {
      return false;
    }
    event.preventDefault();
    event.stopPropagation();
    return false;
  },
  utf8Encode: function(string) {
    var c, n, utftext;
    string = string.replace(/\r\n/g, "\n");
    utftext = "";
    n = 0;
    while (n < string.length) {
      c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }
      n++;
    }
    return utftext;
  },
  utf8Decode: function(utftext) {
    var c, c1, c2, c3, i, string;
    string = "";
    i = 0;
    c = c1 = c2 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if ((c > 191) && (c < 224)) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        i += 3;
      }
    }
    return string;
  },
  runXpercent: function(percent) {
    var chance;
    chance = Math.floor(Math.random() * 100);
    return chance <= percent;
  },
  shortenUrl: function(url, callback) {
    var request;
    request = $.ajax("https://www.googleapis.com/urlshortener/v1/url", {
      type: "POST",
      contentType: "application/json",
      data: JSON.stringify({
        longUrl: url
      }),
      timeout: 4000,
      dataType: "json"
    });
    request.done((function(_this) {
      return function(data) {
        return callback((data != null ? data.id : void 0) || url, data);
      };
    })(this));
    return request.error(function(_arg) {
      var responseText, status, statusText;
      status = _arg.status, statusText = _arg.statusText, responseText = _arg.responseText;
      error("URL shorten error, returning self as fallback.", status, statusText, responseText);
      return callback(url);
    });
  },
  formatBytesToHumanReadable: function(bytes, fixedAmout) {
    var minus, thresh, unitIndex, units;
    if (fixedAmout == null) {
      fixedAmout = 2;
    }
    minus = '';
    if (bytes < 0) {
      minus = '-';
      bytes *= -1;
    }
    thresh = 1024;
    units = ["kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    unitIndex = -1;
    if (bytes < thresh) {
      return "" + bytes + " B";
    }
    while (true) {
      bytes /= thresh;
      ++unitIndex;
      if (!(bytes >= thresh)) {
        break;
      }
    }
    return "" + minus + (bytes.toFixed(fixedAmout)) + " " + units[unitIndex];
  },
  splitTrim: function(str, delim, filterEmpty) {
    var arr, _ref;
    if (delim == null) {
      delim = ',';
    }
    if (filterEmpty == null) {
      filterEmpty = true;
    }
    arr = (_ref = str != null ? str.split(delim).map(function(part) {
      return part.trim();
    }) : void 0) != null ? _ref : [];
    if (filterEmpty) {
      arr = arr.filter(Boolean);
    }
    return arr;
  },
  arrayToObject: function(list, key) {
    var dict, obj, _i, _len;
    dict = {};
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      obj = list[_i];
      if (obj[key] != null) {
        dict[obj[key]] = obj;
      }
    }
    return dict;
  },
  partition: function(list, fn) {
    var item, result, _i, _len;
    result = [[], []];
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      item = list[_i];
      result[+(!fn(item))].push(item);
    }
    return result;
  },

  /*
  //     Underscore.js 1.3.1
  //     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
  //     Underscore is freely distributable under the MIT license.
  //     Portions of Underscore are inspired or borrowed from Prototype,
  //     Oliver Steele's Functional, and John Resig's Micro-Templating.
  //     For all details and documentation:
  //     http://documentcloud.github.com/underscore
   */
  throttle: function(wait, func) {
    var args, context, more, throttling, timeout, whenDone, _ref;
    if ((typeof func) === "number") {
      _ref = [func, wait], wait = _ref[0], func = _ref[1];
    }
    context = args = timeout = throttling = more = null;
    whenDone = KD.utils.debounce(wait, function() {
      return more = throttling = false;
    });
    return function() {
      var later;
      context = this;
      args = arguments;
      later = function() {
        timeout = null;
        if (more) {
          func.apply(context, args);
        }
        return whenDone();
      };
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (throttling) {
        more = true;
      } else {
        func.apply(context, args);
      }
      whenDone();
      return throttling = true;
    };
  },
  debounce: function(wait, func) {
    var timeout, _ref;
    if ((typeof func) === "number") {
      _ref = [func, wait], wait = _ref[0], func = _ref[1];
    }
    timeout = null;
    return function() {
      var args, context, later;
      context = this;
      args = arguments;
      later = function() {
        timeout = null;
        return func.apply(context, args);
      };
      clearTimeout(timeout);
      return timeout = setTimeout(later, wait);
    };
  }
};


},{}],106:[function(require,module,exports){
var KDObject, KDView,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

KDObject = require('./object.coffee');

module.exports = KDView = (function(_super) {
  var defineProperty, deprecated, eventNames, eventToMethodMap, overrideAndMergeObjects;

  __extends(KDView, _super);

  defineProperty = Object.defineProperty;

  deprecated = function(methodName) {
    return warn("" + methodName + " is deprecated from KDView if you need it override in your subclass");
  };

  eventNames = /^((dbl)?click|key(up|down|press)|mouse(up|down|over|enter|leave|move)|drag(start|end|enter|leave|over)|blur|change|focus|drop|contextmenu|scroll|paste|error|load)$/;

  eventToMethodMap = function() {
    return {
      dblclick: "dblClick",
      keyup: "keyUp",
      keydown: "keyDown",
      keypress: "keyPress",
      mouseup: "mouseUp",
      mousedown: "mouseDown",
      mouseenter: "mouseEnter",
      mouseleave: "mouseLeave",
      mousemove: "mouseMove",
      mousewheel: "mouseWheel",
      wheel: "mouseWheel",
      mouseover: "mouseOver",
      contextmenu: "contextMenu",
      dragstart: "dragStart",
      dragenter: "dragEnter",
      dragleave: "dragLeave",
      dragover: "dragOver",
      paste: "paste",
      transitionend: "transitionEnd"
    };
  };

  overrideAndMergeObjects = function(objects) {
    var item, title, _ref;
    _ref = objects.overridden;
    for (title in _ref) {
      if (!__hasProp.call(_ref, title)) continue;
      item = _ref[title];
      if (objects.overrider[title]) {
        continue;
      }
      objects.overrider[title] = item;
    }
    return objects.overrider;
  };

  KDView.prototype.appendToDomBody = function() {
    this.parentIsInDom = true;
    if (!this.lazy) {
      $("body").append(this.$());
      return this.utils.defer((function(_this) {
        return function() {
          return _this.emit("viewAppended");
        };
      })(this));
    }
  };

  KDView.appendToDOMBody = function(view) {
    console.warn("KDView.appendToDOMBody is deprecated; use #appendToDomBody instead");
    return view.appendToDomBody();
  };

  function KDView(options, data) {
    var o;
    if (options == null) {
      options = {};
    }
    o = options;
    o.tagName || (o.tagName = "div");
    o.domId || (o.domId = null);
    o.cssClass || (o.cssClass = "");
    o.parent || (o.parent = null);
    o.partial || (o.partial = null);
    o.delegate || (o.delegate = null);
    o.bind || (o.bind = "");
    o.draggable || (o.draggable = null);
    o.droppable || (o.droppable = null);
    o.size || (o.size = null);
    o.position || (o.position = null);
    o.attributes || (o.attributes = null);
    o.prefix || (o.prefix = "");
    o.suffix || (o.suffix = "");
    o.tooltip || (o.tooltip = null);
    o.resizable || (o.resizable = null);
    KDView.__super__.constructor.call(this, o, data);
    if (data != null) {
      if (typeof data.on === "function") {
        data.on('update', this.bound('render'));
      }
    }
    this.domId = options.domId, this.parent = options.parent;
    this.subViews = [];
    this.defaultInit(options, data);
    this.devHacks();
  }

  KDView.prototype.defaultInit = function(options, data) {
    this.setDomElement(options.cssClass);
    this.setDataId();
    if (options.domId) {
      this.setDomId(options.domId);
    }
    if (options.attributes) {
      this.setAttributes(options.attributes);
    }
    if (options.size) {
      this.setSize(options.size);
    }
    if (options.position) {
      this.setPosition(options.position);
    }
    if (options.partial) {
      this.updatePartial(options.partial);
    }
    if (options.draggable) {
      this.setClass('kddraggable');
    }
    this.addEventHandlers(options);
    if (options.lazyLoadThreshold) {
      this.setLazyLoader(options.lazyLoadThreshold);
    }
    if (options.tooltip) {
      this.setTooltip(options.tooltip);
    }
    if (options.draggable) {
      this.setDraggable(options.draggable);
    }
    this.bindEvents();
    this.on('childAppended', this.childAppended.bind(this));
    return this.on('viewAppended', (function(_this) {
      return function() {
        var child, fireViewAppended, key, subViews, _i, _len, _results, _results1;
        _this.setViewReady();
        _this.viewAppended();
        _this.childAppended(_this);
        _this.parentIsInDom = true;
        fireViewAppended = function(child) {
          if (!child.parentIsInDom) {
            child.parentIsInDom = true;
            if (!child.lazy) {
              return child.emit('viewAppended');
            }
          }
        };
        subViews = _this.getSubViews();
        if (Array.isArray(subViews)) {
          _results = [];
          for (_i = 0, _len = subViews.length; _i < _len; _i++) {
            child = subViews[_i];
            _results.push(fireViewAppended(child));
          }
          return _results;
        } else if ((subViews != null) && 'object' === typeof subViews) {
          _results1 = [];
          for (key in subViews) {
            if (!__hasProp.call(subViews, key)) continue;
            child = subViews[key];
            _results1.push(fireViewAppended(child));
          }
          return _results1;
        }
      };
    })(this));
  };

  KDView.prototype.getDomId = function() {
    return this.domElement.attr("id");
  };

  KDView.prototype.setDomElement = function(cssClass) {
    var domId, el, klass, tagName, _i, _len, _ref, _ref1;
    if (cssClass == null) {
      cssClass = '';
    }
    _ref = this.getOptions(), domId = _ref.domId, tagName = _ref.tagName;
    if (domId) {
      el = document.getElementById(domId);
    }
    this.lazy = el == null ? (el = document.createElement(tagName), domId ? el.id = domId : void 0, false) : true;
    _ref1 = ("kdview " + cssClass).split(' ');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      klass = _ref1[_i];
      if (klass.length) {
        el.classList.add(klass);
      }
    }
    this.domElement = $(el);
    if (this.lazy) {
      return this.utils.defer((function(_this) {
        return function() {
          return _this.emit('viewAppended');
        };
      })(this));
    }
  };

  KDView.prototype.setDomId = function(id) {
    return this.domElement.attr("id", id);
  };

  KDView.prototype.setData = function(data) {
    var _ref, _ref1;
    if ((_ref = this.data) != null) {
      if (typeof _ref.off === "function") {
        _ref.off('update', this.bound('render'));
      }
    }
    KDView.__super__.setData.call(this, data);
    if ((_ref1 = this.data) != null) {
      if (typeof _ref1.on === "function") {
        _ref1.on('update', this.bound('render'));
      }
    }
    if (this.parentIsInDom) {
      return this.render();
    }
  };

  KDView.prototype.setDataId = function() {
    return this.domElement.data("data-id", this.getId());
  };

  KDView.prototype.getAttribute = function(attr) {
    return this.getElement().getAttribute(attr);
  };

  KDView.prototype.setAttribute = function(attr, val) {
    return this.getElement().setAttribute(attr, val);
  };

  KDView.prototype.setAttributes = function(attributes) {
    var attr, val, _results;
    _results = [];
    for (attr in attributes) {
      if (!__hasProp.call(attributes, attr)) continue;
      val = attributes[attr];
      _results.push(this.setAttribute(attr, val));
    }
    return _results;
  };

  KDView.prototype.isInDom = (function() {
    var findUltimateAncestor;
    findUltimateAncestor = function(el) {
      var ancestor;
      ancestor = el;
      while (ancestor.parentNode) {
        ancestor = ancestor.parentNode;
      }
      return ancestor;
    };
    return function() {
      return findUltimateAncestor(this.$()[0]).body != null;
    };
  })();

  Object.defineProperty(KDView.prototype, "$$", {
    get: KDView.prototype.$
  });

  Object.defineProperty(KDView.prototype, "el", {
    get: KDView.prototype.getElement
  });

  KDView.prototype.getDomElement = function() {
    return this.domElement;
  };

  KDView.prototype.getElement = function() {
    return this.getDomElement()[0];
  };

  KDView.prototype.getTagName = function() {
    return this.options.tagName || 'div';
  };

  KDView.prototype.$ = function(selector) {
    if (selector) {
      return this.getDomElement().find(selector);
    } else {
      return this.getDomElement();
    }
  };

  KDView.prototype.append = function(child, selector) {
    this.$(selector).append(child.$());
    if (this.parentIsInDom) {
      child.emit('viewAppended');
    }
    return this;
  };

  KDView.prototype.appendTo = function(parent, selector) {
    this.$().appendTo(parent.$(selector));
    if (this.parentIsInDom) {
      this.emit('viewAppended');
    }
    return this;
  };

  KDView.prototype.appendToSelector = function(selector) {
    $(selector).append(this.$());
    return this.emit('viewAppended');
  };

  KDView.prototype.prepend = function(child, selector) {
    this.$(selector).prepend(child.$());
    if (this.parentIsInDom) {
      child.emit('viewAppended');
    }
    return this;
  };

  KDView.prototype.prependTo = function(parent, selector) {
    this.$().prependTo(parent.$(selector));
    if (this.parentIsInDom) {
      this.emit('viewAppended');
    }
    return this;
  };

  KDView.prototype.prependToSelector = function(selector) {
    $(selector).prepend(this.$());
    return this.emit('viewAppended');
  };

  KDView.prototype.setPartial = function(partial, selector) {
    this.$(selector).append(partial);
    return this;
  };

  KDView.prototype.updatePartial = function(partial, selector) {
    return this.$(selector).html(partial);
  };

  KDView.prototype.clear = function() {
    return this.getElement().innerHTML = '';
  };

  KDView.setElementClass = function(el, addOrRemove, cssClass) {
    var cl, _i, _len, _ref, _results;
    _ref = cssClass.split(' ');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      cl = _ref[_i];
      if (cl !== '') {
        _results.push(el.classList[addOrRemove](cl));
      }
    }
    return _results;
  };

  KDView.prototype.setCss = function(property, value) {
    return this.$().css(property, value);
  };

  KDView.prototype.setStyle = function(properties) {
    var property, value, _results;
    _results = [];
    for (property in properties) {
      if (!__hasProp.call(properties, property)) continue;
      value = properties[property];
      _results.push(this.$().css(property, value));
    }
    return _results;
  };

  KDView.prototype.setClass = function(cssClass) {
    if (!cssClass) {
      return;
    }
    KDView.setElementClass(this.getElement(), "add", cssClass);
    return this;
  };

  KDView.prototype.unsetClass = function(cssClass) {
    if (!cssClass) {
      return;
    }
    KDView.setElementClass(this.getElement(), "remove", cssClass);
    return this;
  };

  KDView.prototype.toggleClass = function(cssClass) {
    this.$().toggleClass(cssClass);
    return this;
  };

  KDView.prototype.hasClass = function(cssClass) {
    return this.getElement().classList.contains(cssClass);
  };

  KDView.prototype.getBounds = function() {
    var bounds;
    return bounds = {
      x: this.getX(),
      y: this.getY(),
      w: this.getWidth(),
      h: this.getHeight(),
      n: this.constructor.name
    };
  };

  KDView.prototype.setRandomBG = function() {
    return this.getDomElement().css("background-color", KD.utils.getRandomRGB());
  };

  KDView.prototype.hide = function(duration) {
    return this.setClass('hidden');
  };

  KDView.prototype.show = function(duration) {
    return this.unsetClass('hidden');
  };

  KDView.prototype.setSize = function(sizes) {
    if (sizes.width != null) {
      this.setWidth(sizes.width);
    }
    if (sizes.height != null) {
      return this.setHeight(sizes.height);
    }
  };

  KDView.prototype.setPosition = function() {
    var positionOptions;
    positionOptions = this.getOptions().position;
    positionOptions.position = "absolute";
    return this.$().css(positionOptions);
  };

  KDView.prototype.getWidth = function() {
    return this.$().outerWidth(false);
  };

  KDView.prototype.setWidth = function(w, unit) {
    if (unit == null) {
      unit = "px";
    }
    this.getElement().style.width = "" + w + unit;
    return this.emit("ViewResized", {
      newWidth: w,
      unit: unit
    });
  };

  KDView.prototype.getHeight = function() {
    return this.getDomElement().outerHeight(false);
  };

  KDView.prototype.setHeight = function(h, unit) {
    if (unit == null) {
      unit = "px";
    }
    this.getElement().style.height = "" + h + unit;
    return this.emit("ViewResized", {
      newHeight: h,
      unit: unit
    });
  };

  KDView.prototype.setX = function(x) {
    return this.$().css({
      left: x
    });
  };

  KDView.prototype.setY = function(y) {
    return this.$().css({
      top: y
    });
  };

  KDView.prototype.getX = function() {
    return this.$().offset().left;
  };

  KDView.prototype.getY = function() {
    return this.$().offset().top;
  };

  KDView.prototype.getRelativeX = function() {
    return this.$().position().left;
  };

  KDView.prototype.getRelativeY = function() {
    return this.$().position().top;
  };

  KDView.prototype.destroyChild = function(prop) {
    var _base;
    if (this[prop] != null) {
      if (typeof (_base = this[prop]).destroy === "function") {
        _base.destroy();
      }
      delete this[prop];
      return true;
    } else {
      return false;
    }
  };

  KDView.prototype.attach = function(view) {
    return this.getElement().appendChild(view.getElement());
  };

  KDView.prototype.detach = function() {
    var _ref;
    return (_ref = this.parent) != null ? _ref.getElement().removeChild(this.getElement()) : void 0;
  };

  KDView.prototype.destroy = function() {
    var index, _ref;
    if (this.getSubViews().length > 0) {
      this.destroySubViews();
    }
    if (((_ref = this.parent) != null ? _ref.subViews : void 0) && (index = this.parent.subViews.indexOf(this)) >= 0) {
      this.parent.subViews.splice(index, 1);
      this.unsetParent();
    }
    this.getDomElement().remove();
    if (this.$overlay != null) {
      this.removeOverlay();
    }
    return KDView.__super__.destroy.apply(this, arguments);
  };

  KDView.prototype.destroySubViews = function() {
    var view, _i, _len, _ref;
    _ref = this.getSubViews().slice();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      view = _ref[_i];
      if (typeof view.destroy === "function") {
        view.destroy();
      }
    }
  };

  KDView.prototype.addSubView = function(subView, selector, shouldPrepend) {
    if (subView == null) {
      throw new Error('no subview was specified');
    }
    this.subViews.push(subView);
    subView.setParent(this);
    subView.parentIsInDom = this.parentIsInDom;
    if (!subView.lazy) {
      if (shouldPrepend) {
        this.prepend(subView, selector);
      } else {
        this.append(subView, selector);
      }
    }
    subView.on("ViewResized", function() {
      return subView.parentDidResize();
    });
    if (this.template != null) {
      this.template.addSymbol(subView);
    }
    return subView;
  };

  KDView.prototype.removeSubView = function(subView) {
    return subView.destroy();
  };

  KDView.prototype.getSubViews = function() {

    /*
    FIX: NEEDS REFACTORING
    used in @destroy
    not always sub views stored in @subviews but in @items, @itemsOrdered etc
    see KDListView KDTreeView etc. and fix it.
     */
    var subViews;
    subViews = this.subViews;
    if (this.items != null) {
      subViews = subViews.concat([].slice.call(this.items));
    }
    return subViews;
  };

  KDView.prototype.setParent = function(parent) {
    if (this.parent != null) {
      return error('View already has a parent', this, this.parent);
    } else {
      if (defineProperty) {
        return defineProperty(this, 'parent', {
          value: parent,
          configurable: true
        });
      } else {
        return this.parent = parent;
      }
    }
  };

  KDView.prototype.unsetParent = function() {
    return delete this.parent;
  };

  KDView.prototype.embedChild = function(placeholderId, child, isCustom) {
    this.addSubView(child, '#' + placeholderId, false);
    if (!isCustom) {
      return this.$('#' + placeholderId).replaceWith(child.$());
    }
  };

  KDView.prototype.render = function(fields) {
    if (this.template != null) {
      return this.template.update(fields);
    }
  };

  KDView.prototype.addEventHandlers = function(options) {
    var cb, eventName, _results;
    _results = [];
    for (eventName in options) {
      if (!__hasProp.call(options, eventName)) continue;
      cb = options[eventName];
      if (eventNames.test(eventName) && "function" === typeof cb) {
        _results.push(this.on(eventName, cb));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  KDView.prototype.parentDidResize = function(parent, event) {
    var subView, _i, _len, _ref, _results;
    if (this.getSubViews()) {
      _ref = this.getSubViews();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subView = _ref[_i];
        _results.push(subView.parentDidResize(parent, event));
      }
      return _results;
    }
  };

  KDView.prototype.setLazyLoader = function(threshold) {
    var view;
    if (threshold == null) {
      threshold = .75;
    }
    if (!/\bscroll\b/.test(this.getOptions().bind)) {
      this.getOptions().bind += ' scroll';
    }
    view = this;
    return this.on('scroll', (function() {
      var lastRatio;
      lastRatio = 0;
      return function(event) {
        var dynamicThreshold, el, ratio, scrollHeight, scrollTop;
        el = view.$()[0];
        scrollHeight = el.scrollHeight, scrollTop = el.scrollTop;
        dynamicThreshold = threshold > 1 ? (scrollHeight - threshold) / scrollHeight : threshold;
        ratio = (scrollTop + view.getHeight()) / scrollHeight;
        if ((dynamicThreshold < ratio && ratio > lastRatio)) {
          this.emit('LazyLoadThresholdReached', {
            ratio: ratio
          });
        }
        return lastRatio = ratio;
      };
    })());
  };

  KDView.prototype.bindEvents = function($elm) {
    var defaultEvents, event, eventsToBeBound, instanceEvents;
    $elm || ($elm = this.getDomElement());
    defaultEvents = "mousedown mouseup click dblclick";
    instanceEvents = this.getOptions().bind;
    eventsToBeBound = (function() {
      var _i, _len;
      if (instanceEvents) {
        eventsToBeBound = defaultEvents.trim().split(" ");
        instanceEvents = instanceEvents.trim().split(" ");
        for (_i = 0, _len = instanceEvents.length; _i < _len; _i++) {
          event = instanceEvents[_i];
          if (__indexOf.call(eventsToBeBound, event) < 0) {
            eventsToBeBound.push(event);
          }
        }
        return eventsToBeBound.join(" ");
      } else {
        return defaultEvents;
      }
    })();
    $elm.bind(eventsToBeBound, (function(_this) {
      return function(event) {
        var willPropagateToDOM;
        willPropagateToDOM = _this.handleEvent(event);
        if (!willPropagateToDOM) {
          event.stopPropagation();
        }
        return true;
      };
    })(this));
    return eventsToBeBound;
  };

  KDView.prototype.bindTransitionEnd = function() {
    var el, key, transitionEvent, transitions, val;
    el = document.createElement('fakeelement');
    transitions = {
      'OTransition': 'oTransitionEnd',
      'MozTransition': 'transitionend',
      'webkitTransition': 'webkitTransitionEnd'
    };
    transitionEvent = 'transitionend';
    for (key in transitions) {
      if (!__hasProp.call(transitions, key)) continue;
      val = transitions[key];
      if (!(key in el.style)) {
        continue;
      }
      transitionEvent = val;
      break;
    }
    this.bindEvent(transitionEvent);
    if (transitionEvent !== "transitionend") {
      return this.on(transitionEvent, this.emit.bind(this, "transitionend"));
    }
  };

  KDView.prototype.bindEvent = function($elm, eventName) {
    var _ref;
    if (!eventName) {
      _ref = [$elm, this.$()], eventName = _ref[0], $elm = _ref[1];
    }
    return $elm.bind(eventName, (function(_this) {
      return function(event) {
        var shouldPropagate;
        shouldPropagate = _this.handleEvent(event);
        if (!shouldPropagate) {
          event.stopPropagation();
        }
        return true;
      };
    })(this));
  };

  KDView.prototype.handleEvent = function(event) {
    var methodName, shouldPropagate;
    methodName = eventToMethodMap()[event.type] || event.type;
    shouldPropagate = this[methodName] != null ? this[methodName](event) : true;
    if (shouldPropagate !== false) {
      this.emit(event.type, event);
    }
    return shouldPropagate;
  };

  KDView.prototype.scroll = function(event) {
    return true;
  };

  KDView.prototype.load = function(event) {
    return true;
  };

  KDView.prototype.error = function(event) {
    return true;
  };

  KDView.prototype.keyUp = function(event) {
    return true;
  };

  KDView.prototype.keyDown = function(event) {
    return true;
  };

  KDView.prototype.keyPress = function(event) {
    return true;
  };

  KDView.prototype.dblClick = function(event) {
    return true;
  };

  KDView.prototype.click = function(event) {
    return true;
  };

  KDView.prototype.contextMenu = function(event) {
    return true;
  };

  KDView.prototype.mouseMove = function(event) {
    return true;
  };

  KDView.prototype.mouseEnter = function(event) {
    return true;
  };

  KDView.prototype.mouseLeave = function(event) {
    return true;
  };

  KDView.prototype.mouseUp = function(event) {
    return true;
  };

  KDView.prototype.mouseOver = function(event) {
    return true;
  };

  KDView.prototype.mouseWheel = function(event) {
    return true;
  };

  KDView.prototype.mouseDown = function(event) {
    this.unsetKeyView();
    return true;
  };

  KDView.prototype.paste = function(event) {
    return true;
  };

  KDView.prototype.dragEnter = function(e) {
    e.preventDefault();
    return e.stopPropagation();
  };

  KDView.prototype.dragOver = function(e) {
    e.preventDefault();
    return e.stopPropagation();
  };

  KDView.prototype.dragLeave = function(e) {
    e.preventDefault();
    return e.stopPropagation();
  };

  KDView.prototype.drop = function(event) {
    event.preventDefault();
    return event.stopPropagation();
  };

  KDView.prototype.submit = function(event) {
    return false;
  };

  KDView.prototype.setEmptyDragState = function(moveBacktoInitialPosition) {
    var el;
    if (moveBacktoInitialPosition == null) {
      moveBacktoInitialPosition = false;
    }
    if (moveBacktoInitialPosition && this.dragState) {
      el = this.$();
      el.css('left', 0);
      el.css('top', 0);
    }
    return this.dragState = {
      containment: null,
      handle: null,
      axis: null,
      direction: {
        current: {
          x: null,
          y: null
        },
        global: {
          x: null,
          y: null
        }
      },
      position: {
        relative: {
          x: 0,
          y: 0
        },
        initial: {
          x: 0,
          y: 0
        },
        global: {
          x: 0,
          y: 0
        }
      },
      meta: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    };
  };

  KDView.prototype.setDraggable = function(options) {
    var handle;
    if (options == null) {
      options = {};
    }
    if (options === true) {
      options = {};
    }
    this.setEmptyDragState();
    handle = options.handle instanceof KDView ? options.handle : this;
    this.on("DragFinished", (function(_this) {
      return function(e) {
        return _this.beingDragged = false;
      };
    })(this));
    return handle.on("mousedown", (function(_this) {
      return function(event) {
        var bounds, dragEl, dragMeta, dragPos, dragState, oPad, p, padding, v, view;
        if ("string" === typeof options.handle) {
          if ($(event.target).closest(options.handle).length === 0) {
            return;
          }
        }
        _this.dragIsAllowed = true;
        _this.setEmptyDragState();
        dragState = _this.dragState;
        if (options.containment) {
          dragState.containment = {};
          dragState.containment.m = {
            w: _this.getWidth(),
            h: _this.getHeight()
          };
          view = options.containment.view;
          bounds = 'string' === typeof view ? _this[view].getBounds() : view instanceof KDView ? view.getBounds() : _this.parent.getBounds();
          dragState.containment.viewBounds = bounds;
          padding = {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          };
          oPad = options.containment.padding;
          if ('number' === typeof oPad) {
            for (p in padding) {
              if (!__hasProp.call(padding, p)) continue;
              v = padding[p];
              v = oPad;
            }
          } else if ('object' === typeof oPad) {
            KD.utils.extend(padding, oPad);
          }
          dragState.containment.padding = padding;
        }
        dragState.handle = options.handle;
        dragState.axis = options.axis;
        dragMeta = dragState.meta;
        dragEl = _this.getElement();
        dragMeta.top = parseInt(dragEl.style.top, 10) || 0;
        dragMeta.right = parseInt(dragEl.style.right, 10) || 0;
        dragMeta.bottom = parseInt(dragEl.style.bottom, 10) || 0;
        dragMeta.left = parseInt(dragEl.style.left, 10) || 0;
        dragPos = _this.dragState.position;
        dragPos.initial.x = event.pageX;
        dragPos.initial.y = event.pageY;
        KD.getSingleton('windowController').setDragView(_this);
        _this.emit("DragStarted", event, _this.dragState);
        event.stopPropagation();
        event.preventDefault();
        return false;
      };
    })(this));
  };

  KDView.prototype.drag = function(event, delta) {
    var axis, containment, cp, directionX, directionY, dragCurDir, dragDir, dragGlobDir, dragGlobPos, dragInitPos, dragMeta, dragPos, dragRelPos, draggedDistance, el, m, newX, newY, p, targetPosX, targetPosY, x, y, _ref;
    _ref = this.dragState, directionX = _ref.directionX, directionY = _ref.directionY, axis = _ref.axis, containment = _ref.containment;
    x = delta.x, y = delta.y;
    dragPos = this.dragState.position;
    dragRelPos = dragPos.relative;
    dragInitPos = dragPos.initial;
    dragGlobPos = dragPos.global;
    dragDir = this.dragState.direction;
    dragGlobDir = dragDir.global;
    dragCurDir = dragDir.current;
    axis = this.getOptions().draggable.axis;
    draggedDistance = axis ? axis === "x" ? Math.abs(x) : Math.abs(y) : Math.max(Math.abs(x), Math.abs(y));
    this.dragIsAllowed = this.beingDragged = !(draggedDistance < 20 && !this.beingDragged);
    if (x > dragRelPos.x) {
      dragCurDir.x = 'right';
    } else if (x < dragRelPos.x) {
      dragCurDir.x = 'left';
    }
    if (y > dragRelPos.y) {
      dragCurDir.y = 'bottom';
    } else if (y < dragRelPos.y) {
      dragCurDir.y = 'top';
    }
    dragGlobPos.x = dragInitPos.x + x;
    dragGlobPos.y = dragInitPos.y + y;
    dragGlobDir.x = x > 0 ? 'right' : 'left';
    dragGlobDir.y = y > 0 ? 'bottom' : 'top';
    if (this.dragIsAllowed) {
      el = this.$();
      dragMeta = this.dragState.meta;
      targetPosX = dragMeta.right && !dragMeta.left ? 'right' : 'left';
      targetPosY = dragMeta.bottom && !dragMeta.top ? 'bottom' : 'top';
      newX = targetPosX === 'left' ? dragMeta.left + dragRelPos.x : dragMeta.right - dragRelPos.x;
      newY = targetPosY === 'top' ? dragMeta.top + dragRelPos.y : dragMeta.bottom - dragRelPos.y;
      if (containment) {
        m = containment.m;
        p = containment.viewBounds;
        cp = containment.padding;
        if (newX <= cp.left) {
          newX = cp.left;
        }
        if (newY <= cp.top) {
          newY = cp.top;
        }
        if (newX + m.w >= p.w - cp.right) {
          newX = p.w - m.w - cp.right;
        }
        if (newY + m.h >= p.h - cp.bottom) {
          newY = p.h - m.h - cp.bottom;
        }
      }
      if (axis !== 'y') {
        el.css(targetPosX, newX);
      }
      if (axis !== 'x') {
        el.css(targetPosY, newY);
      }
    }
    dragRelPos.x = x;
    dragRelPos.y = y;
    return this.emit("DragInAction", x, y);
  };

  KDView.prototype.viewAppended = function() {};

  KDView.prototype.childAppended = function(child) {
    var _ref;
    return (_ref = this.parent) != null ? _ref.emit('childAppended', child) : void 0;
  };

  KDView.prototype.setViewReady = function() {
    return this.viewIsReady = true;
  };

  KDView.prototype.isViewReady = function() {
    return this.viewIsReady || false;
  };

  KDView.prototype.observeMutations = function() {
    var MutationObserver, MutationSummary, observerSummary;
    MutationSummary = require('./../../libs/mutation-summary.js');
    MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
    return observerSummary = new MutationSummary({
      callback: (function(_this) {
        return function(rest) {
          return _this.emit.apply(_this, ['MutationHappened'].concat(__slice.call(rest)));
        };
      })(this),
      rootNode: this.getElement(),
      queries: [
        {
          all: true
        }
      ]
    });
  };

  KDView.prototype.putOverlay = function(options) {
    var KDOverlayView;
    if (options == null) {
      options = {};
    }
    options.delegate = this;
    KDOverlayView = require('./../components/overlay/overlayview.coffee');
    return this.overlay = new KDOverlayView(options);
  };

  KDView.prototype.removeOverlay = function() {
    var _ref;
    return (_ref = this.overlay) != null ? _ref.destroy() : void 0;
  };

  KDView.prototype.unsetTooltip = function(o) {
    var _ref;
    if (o == null) {
      o = {};
    }
    if ((_ref = this.tooltip) != null) {
      _ref.destroy();
    }
    return delete this.tooltip;
  };

  KDView.prototype.setTooltip = function(o) {
    var KDTooltip, placementMap;
    if (o == null) {
      o = {};
    }
    placementMap = {
      above: "s",
      below: "n",
      left: "e",
      right: "w"
    };
    o.title || (o.title = "");
    o.cssClass || (o.cssClass = "");
    o.placement || (o.placement = "top");
    o.direction || (o.direction = "center");
    o.offset || (o.offset = {
      top: 0,
      left: 0
    });
    o.delayIn || (o.delayIn = 0);
    o.delayOut || (o.delayOut = 0);
    if (o.html == null) {
      o.html = true;
    }
    if (o.animate == null) {
      o.animate = false;
    }
    o.selector || (o.selector = null);
    o.gravity || (o.gravity = placementMap[o.placement]);
    o.fade || (o.fade = o.animate);
    o.fallback || (o.fallback = o.title);
    o.view || (o.view = null);
    if (o.sticky == null) {
      o.sticky = false;
    }
    o.delegate || (o.delegate = this);
    o.events || (o.events = ['mouseenter', 'mouseleave', 'mousemove']);
    this.unsetTooltip();
    KDTooltip = require('./../components/tooltip/tooltip.coffee');
    return this.tooltip = new KDTooltip(o, {});
  };

  KDView.prototype.getTooltip = function() {
    return this.tooltip;
  };

  KDView.prototype._windowDidResize = function() {};

  KDView.prototype.listenWindowResize = function(state) {
    if (state == null) {
      state = true;
    }
    if (state) {
      return KD.getSingleton('windowController').registerWindowResizeListener(this);
    } else {
      return KD.getSingleton('windowController').unregisterWindowResizeListener(this);
    }
  };

  KDView.prototype.notifyResizeListeners = function() {
    return KD.getSingleton('windowController').notifyWindowResizeListeners();
  };

  KDView.prototype.setKeyView = function() {
    return KD.getSingleton("windowController").setKeyView(this);
  };

  KDView.prototype.unsetKeyView = function() {
    return KD.getSingleton("windowController").setKeyView(null);
  };

  KDView.prototype.activateKeyView = function() {
    return typeof this.emit === "function" ? this.emit('KDViewBecameKeyView') : void 0;
  };

  KDView.prototype.devHacks = function() {
    return this.on("click", (function(_this) {
      return function(event) {
        if (!event) {
          return;
        }
        if (event.metaKey && event.altKey && event.ctrlKey) {
          log(_this.getData());
          if (typeof event.stopPropagation === "function") {
            event.stopPropagation();
          }
          if (typeof event.preventDefault === "function") {
            event.preventDefault();
          }
          return false;
        } else if (event.altKey && (event.metaKey || event.ctrlKey)) {
          log(_this);
          return false;
        }
      };
    })(this));
  };

  return KDView;

})(KDObject);


},{"./../../libs/mutation-summary.js":1,"./../components/overlay/overlayview.coffee":62,"./../components/tooltip/tooltip.coffee":85,"./object.coffee":102}],107:[function(require,module,exports){
var KDController, KDView, KDViewController,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

KDView = require('./view.coffee');

KDController = require('./controller.coffee');

module.exports = KDViewController = (function(_super) {
  __extends(KDViewController, _super);

  function KDViewController(options, data) {
    if (options == null) {
      options = {};
    }
    options.view || (options.view = new KDView);
    KDViewController.__super__.constructor.call(this, options, data);
    if (this.getOptions().view) {
      this.setView(this.getOptions().view);
    }
  }

  KDViewController.prototype.loadView = function(mainView) {};

  KDViewController.prototype.getView = function() {
    return this.mainView;
  };

  KDViewController.prototype.setView = function(aViewInstance) {
    var cb;
    this.mainView = aViewInstance;
    this.emit("ControllerHasSetItsView");
    cb = this.loadView.bind(this, aViewInstance);
    if (aViewInstance.isViewReady()) {
      return cb();
    } else {
      aViewInstance.once('viewAppended', cb);
      return aViewInstance.once('KDObjectWillBeDestroyed', (function(_this) {
        return function() {
          return KD.utils.defer(_this.bound("destroy"));
        };
      })(this));
    }
  };

  return KDViewController;

})(KDController);


},{"./controller.coffee":96,"./view.coffee":106}],108:[function(require,module,exports){

/*
todo:

  - make addLayer implementation more clear, by default adding a layer
    should set a listener for next ReceivedClickElsewhere and remove the layer automatically
    2012/5/21 Sinan
 */
var KDController, KDWindowController,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

KDController = require('./controller.coffee');

module.exports = KDWindowController = (function(_super) {
  var addListener, getVisibilityEventName, getVisibilityProperty, superKey, superizeCombos;

  __extends(KDWindowController, _super);

  KDWindowController.keyViewHistory = [];

  superKey = navigator.userAgent.indexOf("Mac OS X") === -1 ? "ctrl" : "command";

  addListener = function(eventName, listener, capturePhase) {
    if (capturePhase == null) {
      capturePhase = true;
    }
    return window.addEventListener(eventName, listener, capturePhase);
  };

  getVisibilityProperty = function() {
    var prefix, prefixes, _i, _len;
    prefixes = ["webkit", "moz", "o"];
    if ("hidden" in document) {
      return "hidden";
    }
    for (_i = 0, _len = prefixes.length; _i < _len; _i++) {
      prefix = prefixes[_i];
      if (prefix + "Hidden" in document) {
        return "" + prefix + "Hidden";
      }
    }
    return "";
  };

  getVisibilityEventName = function() {
    return "" + (getVisibilityProperty().replace(/[Hh]idden/, '')) + "visibilitychange";
  };

  function KDWindowController(options, data) {
    this.windowResizeListeners = {};
    this.keyEventsToBeListened = ['keydown', 'keyup', 'keypress'];
    this.currentCombos = {};
    this.keyView = null;
    this.dragView = null;
    this.scrollingEnabled = true;
    this.layers = [];
    this.unloadListeners = {};
    this.focusListeners = [];
    this.bindEvents();
    KDWindowController.__super__.constructor.call(this, options, data);
  }

  KDWindowController.prototype.addLayer = function(layer) {
    if (__indexOf.call(this.layers, layer) < 0) {
      this.layers.push(layer);
      return layer.on('KDObjectWillBeDestroyed', (function(_this) {
        return function() {
          return _this.removeLayer(layer);
        };
      })(this));
    }
  };

  KDWindowController.prototype.removeLayer = function(layer) {
    var index;
    if (__indexOf.call(this.layers, layer) >= 0) {
      index = this.layers.indexOf(layer);
      return this.layers.splice(index, 1);
    }
  };

  KDWindowController.prototype.bindEvents = function() {
    var eventName, layers, _i, _len, _ref;
    _ref = this.keyEventsToBeListened;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      eventName = _ref[_i];
      addEventListener(eventName, this.bound('key'));
    }
    addEventListener('resize', this.bound('notifyWindowResizeListeners'));
    document.addEventListener('scroll', (function(_this) {
      return function() {
        var body, timer;
        timer = null;
        body = document.body;
        return _.throttle(function(event) {
          return _this.emit("ScrollHappened", event);
        }, 50);
      };
    })(this)(), false);
    addListener("dragenter", (function(_this) {
      return function(event) {
        if (!_this.dragInAction) {
          _this.emit('DragEnterOnWindow', event);
          return _this.setDragInAction(true);
        }
      };
    })(this));
    addListener("dragleave", (function(_this) {
      return function(event) {
        var _ref1, _ref2;
        if (!((0 < (_ref1 = event.clientX) && _ref1 < _this.winWidth) && (0 < (_ref2 = event.clientY) && _ref2 < _this.winHeight))) {
          _this.emit('DragExitOnWindow', event);
          return _this.setDragInAction(false);
        }
      };
    })(this));
    addListener("drop", (function(_this) {
      return function(event) {
        _this.emit('DragExitOnWindow', event);
        _this.emit('DropOnWindow', event);
        return _this.setDragInAction(false);
      };
    })(this));
    layers = this.layers;
    addListener('mousedown', (function(_this) {
      return function(e) {
        var lastLayer;
        lastLayer = layers.last;
        if (lastLayer && $(e.target).closest(lastLayer != null ? lastLayer.$() : void 0).length === 0) {
          lastLayer.emit('ReceivedClickElsewhere', e);
          return _this.removeLayer(lastLayer);
        }
      };
    })(this));
    addListener('mouseup', (function(_this) {
      return function(e) {
        if (_this.dragView) {
          _this.unsetDragView(e);
        }
        return _this.emit('ReceivedMouseUpElsewhere', e);
      };
    })(this));
    addListener('mousemove', (function(_this) {
      return function(e) {
        if (_this.dragView) {
          return _this.redirectMouseMoveEvent(e);
        }
      };
    })(this));
    addListener('click', function(e) {
      var href, isHttp, nearestLink, _ref1;
      nearestLink = KD.utils.getNearestElementByTagName(e.target, 'a');
      if ((nearestLink != null ? (_ref1 = nearestLink.target) != null ? _ref1.length : void 0 : void 0) === 0) {
        href = nearestLink.getAttribute("href");
        isHttp = (href != null ? href.indexOf("http") : void 0) === 0;
        if (isHttp) {
          return nearestLink.target = "_blank";
        } else {
          e.preventDefault();
          if (href && !/^#/.test(href)) {
            return KD.getSingleton("router").handleRoute(href);
          }
        }
      }
    }, false);
    window.addEventListener('beforeunload', this.bound("beforeUnload"));
    return document.addEventListener(getVisibilityEventName(), (function(_this) {
      return function(event) {
        return _this.focusChange(event, _this.isFocused());
      };
    })(this));
  };

  KDWindowController.prototype.addUnloadListener = function(key, listener) {
    var _base;
    (_base = this.unloadListeners)[key] || (_base[key] = []);
    return this.unloadListeners[key].push(listener);
  };

  KDWindowController.prototype.clearUnloadListeners = function(key) {
    if (key) {
      return this.unloadListeners[key] = [];
    } else {
      return this.unloadListeners = {};
    }
  };

  KDWindowController.prototype.isFocused = function() {
    return !Boolean(document[getVisibilityProperty()]);
  };

  KDWindowController.prototype.addFocusListener = function(listener) {
    return this.focusListeners.push(listener);
  };

  KDWindowController.prototype.focusChange = function(event, state) {
    var listener, _i, _len, _ref, _results;
    if (!event) {
      return;
    }
    _ref = this.focusListeners;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      listener = _ref[_i];
      _results.push(listener(state, event));
    }
    return _results;
  };

  KDWindowController.prototype.beforeUnload = function(event) {
    var key, listener, listeners, message, _i, _len, _ref;
    if (!event) {
      return;
    }
    _ref = this.unloadListeners;
    for (key in _ref) {
      if (!__hasProp.call(_ref, key)) continue;
      listeners = _ref[key];
      for (_i = 0, _len = listeners.length; _i < _len; _i++) {
        listener = listeners[_i];
        if (listener() === false) {
          message = key !== "window" ? " on " + key : "";
          return "Please make sure that you saved all your work" + message + ".";
        }
      }
    }
  };

  KDWindowController.prototype.setDragInAction = function(dragInAction) {
    this.dragInAction = dragInAction != null ? dragInAction : false;
    return $('body')[this.dragInAction ? "addClass" : "removeClass"]("dragInAction");
  };

  KDWindowController.prototype.setMainView = function(mainView) {
    this.mainView = mainView;
  };

  KDWindowController.prototype.getMainView = function(view) {
    return this.mainView;
  };

  KDWindowController.prototype.revertKeyView = function(view) {
    if (!view) {
      warn("you must pass the view as a param, which doesn't want to be keyview anymore!");
      return;
    }
    if (view === this.keyView && this.keyView !== this.oldKeyView) {
      return this.setKeyView(this.oldKeyView);
    }
  };

  superizeCombos = function(combos) {
    var cb, combo, safeCombos;
    safeCombos = {};
    for (combo in combos) {
      if (!__hasProp.call(combos, combo)) continue;
      cb = combos[combo];
      if (/\bsuper(\+|\s)/.test(combo)) {
        combo = combo.replace(/super/g, superKey);
      }
      safeCombos[combo] = cb;
    }
    return safeCombos;
  };

  KDWindowController.prototype.viewHasKeyCombos = function(view) {
    var cb, combo, combos, e, o, _i, _len, _ref, _ref1;
    if (!view) {
      return;
    }
    o = view.getOptions();
    combos = {};
    _ref = this.keyEventsToBeListened;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if ("object" === typeof o[e]) {
        _ref1 = o[e];
        for (combo in _ref1) {
          if (!__hasProp.call(_ref1, combo)) continue;
          cb = _ref1[combo];
          combos[combo] = cb;
        }
      }
    }
    if (Object.keys(combos).length > 0) {
      return combos;
    } else {
      return false;
    }
  };

  KDWindowController.prototype.registerKeyCombos = function(view) {
    var cb, combo, combos, _ref, _results;
    if (combos = this.viewHasKeyCombos(view)) {
      view.setClass("mousetrap");
      this.currentCombos = superizeCombos(combos);
      _ref = this.currentCombos;
      _results = [];
      for (combo in _ref) {
        if (!__hasProp.call(_ref, combo)) continue;
        cb = _ref[combo];
        _results.push(Mousetrap.bind(combo, cb, 'keydown'));
      }
      return _results;
    }
  };

  KDWindowController.prototype.unregisterKeyCombos = function() {
    this.currentCombos = {};
    Mousetrap.reset();
    if (this.keyView) {
      return this.keyView.unsetClass("mousetrap");
    }
  };

  KDWindowController.prototype.setKeyView = function(keyView) {
    if (keyView != null) {
      if (typeof keyView.activateKeyView === "function") {
        keyView.activateKeyView();
      }
    }
    if (keyView === this.keyView) {
      return;
    }
    this.unregisterKeyCombos();
    this.oldKeyView = this.keyView;
    this.keyView = keyView;
    this.registerKeyCombos(keyView);
    this.constructor.keyViewHistory.push(keyView);
    if (keyView != null) {
      if (typeof keyView.activateKeyView === "function") {
        keyView.activateKeyView();
      }
    }
    return this.emit('WindowChangeKeyView', keyView);
  };

  KDWindowController.prototype.setDragView = function(dragView) {
    this.setDragInAction(true);
    return this.dragView = dragView;
  };

  KDWindowController.prototype.unsetDragView = function(e) {
    this.setDragInAction(false);
    this.dragView.emit("DragFinished", e);
    return this.dragView = null;
  };

  KDWindowController.prototype.redirectMouseMoveEvent = function(event) {
    var delta, initial, initialX, initialY, pageX, pageY, view;
    view = this.dragView;
    pageX = event.pageX, pageY = event.pageY;
    initial = view.dragState.position.initial;
    initialX = initial.x;
    initialY = initial.y;
    delta = {
      x: pageX - initialX,
      y: pageY - initialY
    };
    return view.drag(event, delta);
  };

  KDWindowController.prototype.getKeyView = function() {
    return this.keyView;
  };

  KDWindowController.prototype.key = function(event) {
    var _ref;
    this.emit(event.type, event);
    return (_ref = this.keyView) != null ? _ref.handleEvent(event) : void 0;
  };

  KDWindowController.prototype.enableScroll = function() {
    return this.scrollingEnabled = true;
  };

  KDWindowController.prototype.disableScroll = function() {
    return this.scrollingEnabled = false;
  };

  KDWindowController.prototype.registerWindowResizeListener = function(instance) {
    this.windowResizeListeners[instance.id] = instance;
    return instance.on("KDObjectWillBeDestroyed", (function(_this) {
      return function() {
        return delete _this.windowResizeListeners[instance.id];
      };
    })(this));
  };

  KDWindowController.prototype.unregisterWindowResizeListener = function(instance) {
    return delete this.windowResizeListeners[instance.id];
  };

  KDWindowController.prototype.setWindowProperties = function(event) {
    this.winWidth = window.innerWidth;
    return this.winHeight = window.innerHeight;
  };

  KDWindowController.prototype.notifyWindowResizeListeners = function(event, throttle, duration) {
    var fireResizeHandlers;
    if (throttle == null) {
      throttle = false;
    }
    if (duration == null) {
      duration = 17;
    }
    event || (event = {
      type: "resize"
    });
    fireResizeHandlers = (function(_this) {
      return function() {
        var instance, key, _ref, _results;
        _ref = _this.windowResizeListeners;
        _results = [];
        for (key in _ref) {
          if (!__hasProp.call(_ref, key)) continue;
          instance = _ref[key];
          if (instance._windowDidResize) {
            _results.push(instance._windowDidResize(event));
          }
        }
        return _results;
      };
    })(this);
    if (throttle) {
      KD.utils.killWait(this.resizeNotifiersTimer);
      return this.resizeNotifiersTimer = KD.utils.wait(duration, fireResizeHandlers);
    } else {
      return fireResizeHandlers();
    }
  };

  return KDWindowController;

})(KDController);

(function() {
  var KD;
  KD = require('./kd.coffee');
  return KD.registerSingleton("windowController", new KDWindowController);
})();


},{"./controller.coffee":96,"./kd.coffee":100}],109:[function(require,module,exports){
var KD, utils;

require('./lib.includes.coffee');

utils = require('./core/utils.coffee');

KD = require('./core/kd.coffee');

KD.dom = require('./core/kd.dom.js');

KD.classes = {};

KD.classes.KDAutoComplete = require("./components/autocomplete/autocomplete.coffee");

KD.classes.KDAutoCompleteController = require("./components/autocomplete/autocompletecontroller.coffee");

KD.classes.KDAutoCompletedItem = require("./components/autocomplete/autocompleteditems.coffee");

KD.classes.KDAutoCompleteFetchingItem = require("./components/autocomplete/autocompletefetchingitem.coffee");

KD.classes.KDAutoCompleteListView = require("./components/autocomplete/autocompletelist.coffee");

KD.classes.KDAutoCompleteListItemView = require("./components/autocomplete/autocompletelistitem.coffee");

KD.classes.KDAutoCompleteNothingFoundItem = require("./components/autocomplete/autocompletenothingfounditem.coffee");

KD.classes.KDAutocompleteUnselecteableItem = require("./components/autocomplete/autocompleteunselecteableitem.coffee");

KD.classes.MultipleInputListView = require("./components/autocomplete/multipleinputlistview.coffee");

KD.classes.KDMultipleInputView = require("./components/autocomplete/multipleinputview.coffee");

KD.classes.MultipleListItemView = require("./components/autocomplete/multiplelistitemview.coffee");

KD.classes.NoAutocompleteInputView = require("./components/autocomplete/noautocompleteinputview.coffee");

KD.classes.NoAutocompleteMultipleListView = require("./components/autocomplete/noautocompletemultiplelistview.coffee");

KD.classes.KDSimpleAutocomplete = require("./components/autocomplete/simpleautocomplete.coffee");

KD.classes.KDButtonBar = require("./components/buttons/buttonbar.coffee");

KD.classes.KDButtonGroupView = require("./components/buttons/buttongroupview.coffee");

KD.classes.JButtonMenu = require("./components/buttons/buttonmenu.coffee");

KD.classes.KDButtonView = require("./components/buttons/buttonview.coffee");

KD.classes.KDButtonViewWithMenu = require("./components/buttons/buttonviewwithmenu.coffee");

KD.classes.KDToggleButton = require("./components/buttons/togglebutton.coffee");

KD.classes.KDContextMenu = require("./components/contextmenu/contextmenu.coffee");

KD.classes.JContextMenuItem = require("./components/contextmenu/contextmenuitem.coffee");

KD.classes.JContextMenuTreeView = require("./components/contextmenu/contextmenutreeview.coffee");

KD.classes.JContextMenuTreeViewController = require("./components/contextmenu/contextmenutreeviewcontroller.coffee");

KD.classes.KDCounterDigitView = require("./components/counter/counterdigitview.coffee");

KD.classes.KDCounterView = require("./components/counter/counterview.coffee");

KD.classes.KDDiaContainer = require("./components/dia/diacontainer.coffee");

KD.classes.KDDiaJoint = require("./components/dia/diajoint.coffee");

KD.classes.KDDiaObject = require("./components/dia/diaobject.coffee");

KD.classes.KDDiaScene = require("./components/dia/diascene.coffee");

KD.classes.KDDialogView = require("./components/dialog/dialogview.coffee");

KD.classes.KDFormView = require("./components/forms/formview.coffee");

KD.classes.KDFormViewWithFields = require("./components/forms/formviewwithfields.coffee");

KD.classes.KDHeaderView = require("./components/header/headerview.coffee");

KD.classes.KDWebcamView = require("./components/image/webcamview.coffee");

KD.classes.KDCheckBox = require("./components/inputs/checkbox.coffee");

KD.classes.KDContentEditableView = require("./components/inputs/contenteditableview.coffee");

KD.classes.KDDelimitedInputView = require("./components/inputs/delimitedinputview.coffee");

KD.classes.KDHitEnterInputView = require("./components/inputs/hitenterinputview.coffee");

KD.classes.KDInputCheckboxGroup = require("./components/inputs/inputcheckboxgroup.coffee");

KD.classes.KDInputRadioGroup = require("./components/inputs/inputradiogroup.coffee");

KD.classes.KDInputSwitch = require("./components/inputs/inputswitch.coffee");

KD.classes.KDInputValidator = require("./components/inputs/inputvalidator.coffee");

KD.classes.KDInputView = require("./components/inputs/inputview.coffee");

KD.classes.KDLabelView = require("./components/inputs/labelview.coffee");

KD.classes.KDMultipleChoice = require("./components/inputs/multiplechoice.coffee");

KD.classes.KDOnOffSwitch = require("./components/inputs/onoffswitch.coffee");

KD.classes.KDSelectBox = require("./components/inputs/selectbox.coffee");

KD.classes.KDTokenizedInput = require("./components/inputs/tokenizedinputview.coffee");

KD.classes.KDWmdInput = require("./components/inputs/wmdinput.coffee");

KD.classes.KDListItemView = require("./components/list/listitemview.coffee");

KD.classes.KDListView = require("./components/list/listview.coffee");

KD.classes.KDListViewController = require("./components/list/listviewcontroller.coffee");

KD.classes.KDLoaderView = require("./components/loader/loaderview.coffee");

KD.classes.KDBlockingModalView = require("./components/modals/blockingmodalview.coffee");

KD.classes.KDModalView = require("./components/modals/modalview.coffee");

KD.classes.KDModalViewStack = require("./components/modals/modalviewstack.coffee");

KD.classes.KDModalViewWithForms = require("./components/modals/modalviewwithforms.coffee");

KD.classes.KDNotificationView = require("./components/notifications/notificationview.coffee");

KD.classes.KDOverlayView = require("./components/overlay/overlayview.coffee");

KD.classes.KDSpotlightView = require("./components/overlay/spotlightview.coffee");

KD.classes.KDProgressBarView = require("./components/progressbar/progressbarview.coffee");

KD.classes.KDCustomScrollView = require("./components/scrollview/customscrollview.coffee");

KD.classes.KDCustomScrollViewWrapper = require("./components/scrollview/customscrollviewinner.coffee");

KD.classes.KDScrollThumb = require("./components/scrollview/scrollthumb.coffee");

KD.classes.KDScrollTrack = require("./components/scrollview/scrolltrack.coffee");

KD.classes.KDScrollView = require("./components/scrollview/scrollview.coffee");

KD.classes.KDSliderBarHandleView = require("./components/sliderbar/sliderbarhandleview.coffee");

KD.classes.KDSliderBarView = require("./components/sliderbar/sliderbarview.coffee");

KD.classes.KDSlidePageView = require("./components/slideshow/slidepageview.coffee");

KD.classes.KDSlideShowView = require("./components/slideshow/slideshowview.coffee");

KD.classes.KDSplitComboView = require("./components/split/splitcomboview.coffee");

KD.classes.KDSplitViewPanel = require("./components/split/splitpanel.coffee");

KD.classes.KDSplitResizer = require("./components/split/splitresizer.coffee");

KD.classes.KDSplitView = require("./components/split/splitview.coffee");

KD.classes.KDTabHandleContainer = require("./components/tabs/tabhandlecontainer.coffee");

KD.classes.KDTabHandleMoveNav = require("./components/tabs/tabhandlemovenav.coffee");

KD.classes.KDTabHandleView = require("./components/tabs/tabhandleview.coffee");

KD.classes.KDTabPaneView = require("./components/tabs/tabpaneview.coffee");

KD.classes.KDTabView = require("./components/tabs/tabview.coffee");

KD.classes.KDTabViewWithForms = require("./components/tabs/tabviewwithforms.coffee");

KD.classes.KDTimeAgoView = require("./components/time/timeagoview.coffee");

KD.classes.KDTooltip = require("./components/tooltip/tooltip.coffee");

KD.classes.JTreeItemView = require("./components/tree/treeitemview.coffee");

KD.classes.JTreeView = require("./components/tree/treeview.coffee");

KD.classes.JTreeViewController = require("./components/tree/treeviewcontroller.coffee");

KD.classes.KDFileUploadArea = require("./components/upload/fileuploadarea.coffee");

KD.classes.KDFileUploadListItemView = require("./components/upload/fileuploadlistitemview.coffee");

KD.classes.KDFileUploadListView = require("./components/upload/fileuploadlistview.coffee");

KD.classes.KDFileUploadThumbItemView = require("./components/upload/fileuploadthumbitemview.coffee");

KD.classes.KDFileUploadThumbListView = require("./components/upload/fileuploadthumblistview.coffee");

KD.classes.KDFileUploadView = require("./components/upload/fileuploadview.coffee");

KD.classes.KDMultipartUploader = require("./components/upload/multipartuploader.coffee");

KD.classes.KDController = require("./core/controller.coffee");

KD.classes.KDCustomHTMLView = require("./core/customhtmlview.coffee");

KD.classes.KDEventEmitter = require("./core/eventemitter.coffee");

KD.classes.KDEventEmitter.Wildcard = require("./core/eventemitterwildcard.coffee");

KD.classes.KDObject = require("./core/object.coffee");

KD.classes.KDRouter = require("./core/router.coffee");

KD.classes.KDView = require("./core/view.coffee");

KD.classes.KDViewController = require("./core/viewcontroller.coffee");

KD.classes.KDWindowController = require("./core/windowcontroller.coffee");

KD = require('./core/kd.coffee');

KD.exportKDFramework();

console.timeEnd('Framework loaded');


},{"./components/autocomplete/autocomplete.coffee":3,"./components/autocomplete/autocompletecontroller.coffee":4,"./components/autocomplete/autocompleteditems.coffee":5,"./components/autocomplete/autocompletefetchingitem.coffee":6,"./components/autocomplete/autocompletelist.coffee":7,"./components/autocomplete/autocompletelistitem.coffee":8,"./components/autocomplete/autocompletenothingfounditem.coffee":9,"./components/autocomplete/autocompleteunselecteableitem.coffee":10,"./components/autocomplete/multipleinputlistview.coffee":11,"./components/autocomplete/multipleinputview.coffee":12,"./components/autocomplete/multiplelistitemview.coffee":13,"./components/autocomplete/noautocompleteinputview.coffee":14,"./components/autocomplete/noautocompletemultiplelistview.coffee":15,"./components/autocomplete/simpleautocomplete.coffee":16,"./components/buttons/buttonbar.coffee":17,"./components/buttons/buttongroupview.coffee":18,"./components/buttons/buttonmenu.coffee":19,"./components/buttons/buttonview.coffee":20,"./components/buttons/buttonviewwithmenu.coffee":21,"./components/buttons/togglebutton.coffee":22,"./components/contextmenu/contextmenu.coffee":23,"./components/contextmenu/contextmenuitem.coffee":24,"./components/contextmenu/contextmenutreeview.coffee":25,"./components/contextmenu/contextmenutreeviewcontroller.coffee":26,"./components/counter/counterdigitview.coffee":27,"./components/counter/counterview.coffee":28,"./components/dia/diacontainer.coffee":29,"./components/dia/diajoint.coffee":30,"./components/dia/diaobject.coffee":31,"./components/dia/diascene.coffee":32,"./components/dialog/dialogview.coffee":33,"./components/forms/formview.coffee":34,"./components/forms/formviewwithfields.coffee":35,"./components/header/headerview.coffee":36,"./components/image/webcamview.coffee":37,"./components/inputs/checkbox.coffee":38,"./components/inputs/contenteditableview.coffee":39,"./components/inputs/delimitedinputview.coffee":40,"./components/inputs/hitenterinputview.coffee":41,"./components/inputs/inputcheckboxgroup.coffee":42,"./components/inputs/inputradiogroup.coffee":43,"./components/inputs/inputswitch.coffee":44,"./components/inputs/inputvalidator.coffee":45,"./components/inputs/inputview.coffee":46,"./components/inputs/labelview.coffee":47,"./components/inputs/multiplechoice.coffee":48,"./components/inputs/onoffswitch.coffee":49,"./components/inputs/selectbox.coffee":50,"./components/inputs/tokenizedinputview.coffee":51,"./components/inputs/wmdinput.coffee":52,"./components/list/listitemview.coffee":53,"./components/list/listview.coffee":54,"./components/list/listviewcontroller.coffee":55,"./components/loader/loaderview.coffee":56,"./components/modals/blockingmodalview.coffee":57,"./components/modals/modalview.coffee":58,"./components/modals/modalviewstack.coffee":59,"./components/modals/modalviewwithforms.coffee":60,"./components/notifications/notificationview.coffee":61,"./components/overlay/overlayview.coffee":62,"./components/overlay/spotlightview.coffee":63,"./components/progressbar/progressbarview.coffee":64,"./components/scrollview/customscrollview.coffee":65,"./components/scrollview/customscrollviewinner.coffee":66,"./components/scrollview/scrollthumb.coffee":67,"./components/scrollview/scrolltrack.coffee":68,"./components/scrollview/scrollview.coffee":69,"./components/sliderbar/sliderbarhandleview.coffee":70,"./components/sliderbar/sliderbarview.coffee":71,"./components/slideshow/slidepageview.coffee":72,"./components/slideshow/slideshowview.coffee":73,"./components/split/splitcomboview.coffee":74,"./components/split/splitpanel.coffee":75,"./components/split/splitresizer.coffee":76,"./components/split/splitview.coffee":77,"./components/tabs/tabhandlecontainer.coffee":78,"./components/tabs/tabhandlemovenav.coffee":79,"./components/tabs/tabhandleview.coffee":80,"./components/tabs/tabpaneview.coffee":81,"./components/tabs/tabview.coffee":82,"./components/tabs/tabviewwithforms.coffee":83,"./components/time/timeagoview.coffee":84,"./components/tooltip/tooltip.coffee":85,"./components/tree/treeitemview.coffee":86,"./components/tree/treeview.coffee":87,"./components/tree/treeviewcontroller.coffee":88,"./components/upload/fileuploadarea.coffee":89,"./components/upload/fileuploadlistitemview.coffee":90,"./components/upload/fileuploadlistview.coffee":91,"./components/upload/fileuploadthumbitemview.coffee":92,"./components/upload/fileuploadthumblistview.coffee":93,"./components/upload/fileuploadview.coffee":94,"./components/upload/multipartuploader.coffee":95,"./core/controller.coffee":96,"./core/customhtmlview.coffee":97,"./core/eventemitter.coffee":98,"./core/eventemitterwildcard.coffee":99,"./core/kd.coffee":100,"./core/kd.dom.js":101,"./core/object.coffee":102,"./core/router.coffee":103,"./core/utils.coffee":105,"./core/view.coffee":106,"./core/viewcontroller.coffee":107,"./core/windowcontroller.coffee":108,"./lib.includes.coffee":110}],110:[function(require,module,exports){
module.exports = ["./libs/docwritenoop.js", "./libs/encode.js", "./libs/jquery-2.1.1.min.js", "./libs/underscore-min.1.3.js", "./libs/cookies.js", "./libs/jquery-timeago.js", "./libs/date.format.js", "./libs/highlight.pack.js", "./libs/inflector.js", "./libs/canvas-loader.js", "./libs/mousetrap.js", "./libs/mousetrap.js", "./libs/mousetrap-global-bind.js", "./libs/marked.js", "./libs/jspath.js", "./libs/hammer.js"];


},{}]},{},[109])